webpackJsonp([0],{

/***/ "./app/Resources/assets/js/pages/dayOff.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__("./node_modules/jquery/dist/jquery.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_bootstrap_sass__ = __webpack_require__("./node_modules/bootstrap-sass/assets/javascripts/bootstrap.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_bootstrap_sass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_bootstrap_sass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_bootstrap_datepicker__ = __webpack_require__("./node_modules/bootstrap-datepicker/dist/js/bootstrap-datepicker.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_bootstrap_datepicker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_bootstrap_datepicker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_daterangepicker__ = __webpack_require__("./node_modules/daterangepicker/daterangepicker.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_daterangepicker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_daterangepicker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_fullcalendar__ = __webpack_require__("./node_modules/fullcalendar/dist/fullcalendar.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_fullcalendar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_fullcalendar__);






var event = [];
__WEBPACK_IMPORTED_MODULE_0_jquery___default()(function () {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input[name="daterange"]').daterangepicker({
        datesDisabled: JSON.parse(array),
        locale: {
            format: 'MM/DD/YYYY',
            daysOfWeekDisabled: '06',
            todayHighlight: true,
            defaultDate: new Date()
        },
        isInvalidDate: function isInvalidDate(date) {
            if (date.day() === 0 || date.day() === 6 || __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.inArray(date.format('MM/DD/YYYY'), JSON.parse(array)) !== -1) {
                return true;
            }
        }

    });
});
__WEBPACK_IMPORTED_MODULE_0_jquery___default()(function () {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#calendar').fullCalendar({

        eventSources: [{
            events: JSON.parse(freeDays),
            color: '#a94442', // an option!
            textColor: 'white' // an option!

        }],

        eventClick: function eventClick(event, jsEvent, view) {
            var id = event.id;

            if (id === undefined) {
                return false;
            } else if (userId) {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#addModal').modal({
                    backdrop: 'static',
                    keyboard: false
                });
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#modalSaveBtn').attr('onclick', 'javascript:moveFreeDay(' + id + ')');
            }
        },
        weekends: false
    });

    __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(JSON.parse(daysOff), function (key, value) {
        var event1 = {
            events: value['daysOff'],
            allDay: true,
            nextDayThreshold: "00:00:00",
            color: value['color'], // an option!
            textColor: 'white' // an option!

        };

        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#calendar').fullCalendar('addEventSource', event1);
    });
});

__WEBPACK_IMPORTED_MODULE_0_jquery___default()(function () {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#datetime').datepicker({
        autoclose: true, // It is false, by default
        format: 'mm/dd/yyyy',
        datesDisabled: JSON.parse(array),
        daysOfWeekDisabled: '06',
        todayHighlight: true,
        minDate: 0

    }).on('changeDate', function (e) {});
});

/***/ }),

/***/ "./node_modules/bootstrap-datepicker/dist/js/bootstrap-datepicker.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Datepicker for Bootstrap v1.7.1 (https://github.com/uxsolutions/bootstrap-datepicker)
 *
 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */

(function(factory){
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(jQuery);
    }
}(function($, undefined){
	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function isUTCEquals(date1, date2) {
		return (
			date1.getUTCFullYear() === date2.getUTCFullYear() &&
			date1.getUTCMonth() === date2.getUTCMonth() &&
			date1.getUTCDate() === date2.getUTCDate()
		);
	}
	function alias(method, deprecationMsg){
		return function(){
			if (deprecationMsg !== undefined) {
				$.fn.datepicker.deprecated(deprecationMsg);
			}

			return this[method].apply(this, arguments);
		};
	}
	function isValidDate(d) {
		return d && !isNaN(d.getTime());
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i < l; i++)
          // Use date arithmetic to allow dates with different times to match
          if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.length = 0;
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		};
	})();


	// Picker object

	var Datepicker = function(element, options){
		$.data(element, 'datepicker', this);
		this._process_options(options);

		this.dates = new DateArray();
		this.viewDate = this.o.defaultViewDate;
		this.focusDate = null;

		this.element = $(element);
		this.isInput = this.element.is('input');
		this.inputField = this.isInput ? this.element : this.element.find('input');
		this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
		if (this.component && this.component.length === 0)
			this.component = false;
		this.isInline = !this.component && this.element.is('div');

		this.picker = $(DPGlobal.template);

		// Checking templates and inserting
		if (this._check_template(this.o.templates.leftArrow)) {
			this.picker.find('.prev').html(this.o.templates.leftArrow);
		}

		if (this._check_template(this.o.templates.rightArrow)) {
			this.picker.find('.next').html(this.o.templates.rightArrow);
		}

		this._buildEvents();
		this._attachEvents();

		if (this.isInline){
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		}
		else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
		}

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		if (this.o.calendarWeeks) {
			this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
				.attr('colspan', function(i, val){
					return Number(val) + 1;
				});
		}

		this._process_options({
			startDate: this._o.startDate,
			endDate: this._o.endDate,
			daysOfWeekDisabled: this.o.daysOfWeekDisabled,
			daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
			datesDisabled: this.o.datesDisabled
		});

		this._allow_update = false;
		this.setViewMode(this.o.startView);
		this._allow_update = true;

		this.fillDow();
		this.fillMonths();

		this.update();

		if (this.isInline){
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_resolveViewName: function(view){
			$.each(DPGlobal.viewModes, function(i, viewMode){
				if (view === i || $.inArray(view, viewMode.names) !== -1){
					view = i;
					return false;
				}
			});

			return view;
		},

		_resolveDaysOfWeek: function(daysOfWeek){
			if (!$.isArray(daysOfWeek))
				daysOfWeek = daysOfWeek.split(/[,\s]*/);
			return $.map(daysOfWeek, Number);
		},

		_check_template: function(tmp){
			try {
				// If empty
				if (tmp === undefined || tmp === "") {
					return false;
				}
				// If no html, everything ok
				if ((tmp.match(/[<>]/g) || []).length <= 0) {
					return true;
				}
				// Checking if html is fine
				var jDom = $(tmp);
				return jDom.length > 0;
			}
			catch (ex) {
				return false;
			}
		},

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			// Retrieve view index from any aliases
			o.startView = this._resolveViewName(o.startView);
			o.minViewMode = this._resolveViewName(o.minViewMode);
			o.maxViewMode = this._resolveViewName(o.maxViewMode);

			// Check view is between min and max
			o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = (o.weekStart + 6) % 7;

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity){
				if (!!o.startDate){
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity){
				if (!!o.endDate){
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
			o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

			o.datesDisabled = o.datesDisabled||[];
			if (!$.isArray(o.datesDisabled)) {
				o.datesDisabled = o.datesDisabled.split(',');
			}
			o.datesDisabled = $.map(o.datesDisabled, function(d){
				return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return /^auto|left|right|top|bottom$/.test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch (plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return /^left|right$/.test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return /^top|bottom$/.test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
			if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
				o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
			} else if (o.defaultViewDate) {
				var year = o.defaultViewDate.year || new Date().getFullYear();
				var month = o.defaultViewDate.month || 0;
				var day = o.defaultViewDate.day || 1;
				o.defaultViewDate = UTCDate(year, month, day);
			} else {
				o.defaultViewDate = UTCToday();
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev, ch; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
            var events = {
                keyup: $.proxy(function(e){
                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
                        this.update();
                }, this),
                keydown: $.proxy(this.keydown, this),
                paste: $.proxy(this.paste, this)
            };

            if (this.o.showOnFocus === true) {
                events.focus = $.proxy(this.show, this);
            }

            if (this.isInput) { // single input
                this._events = [
                    [this.element, events]
                ];
            }
            // component: input + button
            else if (this.component && this.inputField.length) {
                this._events = [
                    // For components that are not readonly, allow keyboard nav
                    [this.inputField, events],
                    [this.component, {
                        click: $.proxy(this.show, this)
                    }]
                ];
            }
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			if (this.o.immediateUpdates) {
				// Trigger input updates immediately on changed year/month
				this._events.push([this.element, {
					'changeYear changeMonth': $.proxy(function(e){
						this.update(e.date);
					}, this)
				}]);
			}

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[this.picker, '.prev, .next', {
					click: $.proxy(this.navArrowsClick, this)
				}],
				[this.picker, '.day:not(.disabled)', {
					click: $.proxy(this.dayCellClick, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function(e){
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length ||
							this.isInline
						)){
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				viewMode: this.viewMode,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					} else if (typeof ix === 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(){
			if (this.inputField.prop('disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
				return;
			if (!this.isInline)
				this.picker.appendTo(this.o.container);
			this.place();
			this.picker.show();
			this._attachSecondaryEvents();
			this._trigger('show');
			if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
				$(this.element).blur();
			}
			return this;
		},

		hide: function(){
			if (this.isInline || !this.picker.is(':visible'))
				return this;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.setViewMode(this.o.startView);

			if (this.o.forceParse && this.inputField.val())
				this.setValue();
			this._trigger('hide');
			return this;
		},

		destroy: function(){
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput){
				delete this.element.data().date;
			}
			return this;
		},

		paste: function(e){
			var dateString;
			if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
				&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
				dateString = e.originalEvent.clipboardData.getData('text/plain');
			} else if (window.clipboardData) {
				dateString = window.clipboardData.getData('Text');
			} else {
				return;
			}
			this.setDate(dateString);
			this.update();
			e.preventDefault();
		},

		_utc_to_local: function(utc){
			if (!utc) {
				return utc;
			}

			var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

			if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
				local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
			}

			return local;
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){
				return new Date(d);
			});
		},

		getDate: function(){
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function(){
			var selected_date = this.dates.get(-1);
			if (selected_date !== undefined) {
				return new Date(selected_date);
			} else {
				return null;
			}
		},

		clearDates: function(){
			this.inputField.val('');
			this.update();
			this._trigger('changeDate');

			if (this.o.autoclose) {
				this.hide();
			}
		},

		setDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, args);
			this._trigger('changeDate');
			this.setValue();
			return this;
		},

		setUTCDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.setDates.apply(this, $.map(args, this._utc_to_local));
			return this;
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

		setValue: function(){
			var formatted = this.getFormattedDate();
			this.inputField.val(formatted);
			return this;
		},

		getFormattedDate: function(format){
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		getStartDate: function(){
			return this.o.startDate;
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		getEndDate: function(){
			return this.o.endDate;
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			return this;
		},

		setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
			this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
			this.update();
			return this;
		},

		setDatesDisabled: function(datesDisabled){
			this._process_options({datesDisabled: datesDisabled});
			this.update();
			return this;
		},

		place: function(){
			if (this.isInline)
				return this;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				container = $(this.o.container),
				windowWidth = container.width(),
				scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
				appendOffset = container.offset();

			var parentsZindex = [0];
			this.element.parents().each(function(){
				var itemZIndex = $(this).css('z-index');
				if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
			});
			var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left - appendOffset.left;
			var top = offset.top - appendOffset.top;

			if (this.o.container !== 'body') {
				top += scrollTop;
			}

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto'){
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				if (offset.left < 0) {
					// component is outside the window on the left side. Move it into visible range
					this.picker.addClass('datepicker-orient-left');
					left -= offset.left - visualPadding;
				} else if (left + calendarWidth > windowWidth) {
					// the calendar passes the widow right edge. Align it to component right side
					this.picker.addClass('datepicker-orient-right');
					left += width - calendarWidth;
				} else {
					if (this.o.rtl) {
						// Default to right
						this.picker.addClass('datepicker-orient-right');
					} else {
						// Default to left
						this.picker.addClass('datepicker-orient-left');
					}
				}
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow;
			if (yorient === 'auto'){
				top_overflow = -scrollTop + top - calendarHeight;
				yorient = top_overflow < 0 ? 'bottom' : 'top';
			}

			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));
			else
				top += height;

			if (this.o.rtl) {
				var right = windowWidth - (left + width);
				this.picker.css({
					top: top,
					right: right,
					zIndex: zIndex
				});
			} else {
				this.picker.css({
					top: top,
					left: left,
					zIndex: zIndex
				});
			}
			return this;
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update)
				return this;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if (arguments.length){
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			} else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.inputField.val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					!this.dateWithinRange(date) ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.o.updateViewDate) {
				if (this.dates.length)
					this.viewDate = new Date(this.dates.get(-1));
				else if (this.viewDate < this.o.startDate)
					this.viewDate = new Date(this.o.startDate);
				else if (this.viewDate > this.o.endDate)
					this.viewDate = new Date(this.o.endDate);
				else
					this.viewDate = this.o.defaultViewDate;
			}

			if (fromArgs){
				// setting date by clicking
				this.setValue();
				this.element.change();
			}
			else if (this.dates.length){
				// setting date by typing
				if (String(oldDates) !== String(this.dates) && fromArgs) {
					this._trigger('changeDate');
					this.element.change();
				}
			}
			if (!this.dates.length && oldDates.length) {
				this._trigger('clearDate');
				this.element.change();
			}

			this.fill();
			return this;
		},

		fillDow: function(){
      if (this.o.showWeekDays) {
			var dowCnt = this.o.weekStart,
				html = '<tr>';
			if (this.o.calendarWeeks){
				html += '<th class="cw">&#160;</th>';
			}
			while (dowCnt < this.o.weekStart + 7){
				html += '<th class="dow';
        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
          html += ' disabled';
        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
      }
		},

		fillMonths: function(){
      var localDate = this._utc_to_local(this.viewDate);
			var html = '';
			var focused;
			for (var i = 0; i < 12; i++){
				focused = localDate && localDate.getMonth() === i ? ' focused' : '';
				html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){
					return d.valueOf();
				});
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = UTCToday();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
				cls.push('old');
			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with UTC today, not local today
			if (this.o.todayHighlight && isUTCEquals(date, today)) {
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (!this.dateWithinRange(date)){
				cls.push('disabled');
			}
			if (this.dateIsDisabled(date)){
				cls.push('disabled', 'disabled-date');
			}
			if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
				cls.push('highlighted');
			}

			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) !== -1){
					cls.push('selected');
				}
				if (date.valueOf() === this.range[0]){
          cls.push('range-start');
        }
        if (date.valueOf() === this.range[this.range.length-1]){
          cls.push('range-end');
        }
			}
			return cls;
		},

		_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
			var html = '';
			var step = factor / 10;
			var view = this.picker.find(selector);
			var startVal = Math.floor(year / factor) * factor;
			var endVal = startVal + step * 9;
			var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
			var selected = $.map(this.dates, function(d){
				return Math.floor(d.getUTCFullYear() / step) * step;
			});

			var classes, tooltip, before;
			for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
				classes = [cssClass];
				tooltip = null;

				if (currVal === startVal - step) {
					classes.push('old');
				} else if (currVal === endVal + step) {
					classes.push('new');
				}
				if ($.inArray(currVal, selected) !== -1) {
					classes.push('active');
				}
				if (currVal < startYear || currVal > endYear) {
					classes.push('disabled');
				}
				if (currVal === focusedVal) {
				  classes.push('focused');
        }

				if (beforeFn !== $.noop) {
					before = beforeFn(new Date(currVal, 0, 1));
					if (before === undefined) {
						before = {};
					} else if (typeof before === 'boolean') {
						before = {enabled: before};
					} else if (typeof before === 'string') {
						before = {classes: before};
					}
					if (before.enabled === false) {
						classes.push('disabled');
					}
					if (before.classes) {
						classes = classes.concat(before.classes.split(/\s+/));
					}
					if (before.tooltip) {
						tooltip = before.tooltip;
					}
				}

				html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
			}

			view.find('.datepicker-switch').text(startVal + '-' + endVal);
			view.find('td').html(html);
		},

		fill: function(){
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				todaytxt = dates[this.o.language].today || dates['en'].today || '',
				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
				titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
				tooltip,
				before;
			if (isNaN(year) || isNaN(month))
				return;
			this.picker.find('.datepicker-days .datepicker-switch')
						.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
			this.picker.find('tfoot .today')
						.text(todaytxt)
						.css('display', this.o.todayBtn === true || this.o.todayBtn === 'linked' ? 'table-cell' : 'none');
			this.picker.find('tfoot .clear')
						.text(cleartxt)
						.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
			this.picker.find('thead .datepicker-title')
						.text(this.o.title)
						.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month, 0),
				day = prevMonth.getUTCDate();
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			if (prevMonth.getUTCFullYear() < 100){
        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
      }
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var weekDay, clsName;
			while (prevMonth.valueOf() < nextMonth){
				weekDay = prevMonth.getUTCDay();
				if (weekDay === this.o.weekStart){
					html.push('<tr>');
					if (this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek = (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');
					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				var content = prevMonth.getUTCDate();

				if (this.o.beforeShowDay !== $.noop){
					before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
					if (before.content)
						content = before.content;
				}

				//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
				//Fallback to unique function for older jquery versions
				if ($.isFunction($.uniqueSort)) {
					clsName = $.uniqueSort(clsName);
				} else {
					clsName = $.unique(clsName);
				}

				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
				tooltip = null;
				if (weekDay === this.o.weekEnd){
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
			}
			this.picker.find('.datepicker-days tbody').html(html.join(''));

			var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
			var months = this.picker.find('.datepicker-months')
						.find('.datepicker-switch')
							.text(this.o.maxViewMode < 2 ? monthsTitle : year)
							.end()
						.find('tbody span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() === year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear){
				months.addClass('disabled');
			}
			if (year === startYear){
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year === endYear){
				months.slice(endMonth+1).addClass('disabled');
			}

			if (this.o.beforeShowMonth !== $.noop){
				var that = this;
				$.each(months, function(i, month){
          var moDate = new Date(year, i, 1);
          var before = that.o.beforeShowMonth(moDate);
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false && !$(month).hasClass('disabled'))
					    $(month).addClass('disabled');
					if (before.classes)
					    $(month).addClass(before.classes);
					if (before.tooltip)
					    $(month).prop('title', before.tooltip);
				});
			}

			// Generating decade/years picker
			this._fill_yearsView(
				'.datepicker-years',
				'year',
				10,
				year,
				startYear,
				endYear,
				this.o.beforeShowYear
			);

			// Generating century/decades picker
			this._fill_yearsView(
				'.datepicker-decades',
				'decade',
				100,
				year,
				startYear,
				endYear,
				this.o.beforeShowDecade
			);

			// Generating millennium/centuries picker
			this._fill_yearsView(
				'.datepicker-centuries',
				'century',
				1000,
				year,
				startYear,
				endYear,
				this.o.beforeShowCentury
			);
		},

		updateNavArrows: function(){
			if (!this._allow_update)
				return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				prevIsDisabled,
				nextIsDisabled,
				factor = 1;
			switch (this.viewMode){
				case 0:
					prevIsDisabled = year <= startYear && month <= startMonth;
					nextIsDisabled = year >= endYear && month >= endMonth;
					break;
				case 4:
					factor *= 10;
					/* falls through */
				case 3:
					factor *= 10;
					/* falls through */
				case 2:
					factor *= 10;
					/* falls through */
				case 1:
					prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
					nextIsDisabled = Math.floor(year / factor) * factor + factor >= endYear;
					break;
			}

			this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
			this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
		},

		click: function(e){
			e.preventDefault();
			e.stopPropagation();

			var target, dir, day, year, month;
			target = $(e.target);

			// Clicked on the switch
			if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
				this.setViewMode(this.viewMode + 1);
			}

			// Clicked on today button
			if (target.hasClass('today') && !target.hasClass('day')){
				this.setViewMode(0);
				this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
			}

			// Clicked on clear button
			if (target.hasClass('clear')){
				this.clearDates();
			}

			if (!target.hasClass('disabled')){
				// Clicked on a month, year, decade, century
				if (target.hasClass('month')
						|| target.hasClass('year')
						|| target.hasClass('decade')
						|| target.hasClass('century')) {
					this.viewDate.setUTCDate(1);

					day = 1;
					if (this.viewMode === 1){
						month = target.parent().find('span').index(target);
						year = this.viewDate.getUTCFullYear();
						this.viewDate.setUTCMonth(month);
					} else {
						month = 0;
						year = Number(target.text());
						this.viewDate.setUTCFullYear(year);
					}

					this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

					if (this.viewMode === this.o.minViewMode){
						this._setDate(UTCDate(year, month, day));
					} else {
						this.setViewMode(this.viewMode - 1);
						this.fill();
					}
				}
			}

			if (this.picker.is(':visible') && this._focused_from){
				this._focused_from.focus();
			}
			delete this._focused_from;
		},

		dayCellClick: function(e){
			var $target = $(e.currentTarget);
			var timestamp = $target.data('date');
			var date = new Date(timestamp);

			if (this.o.updateViewDate) {
				if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
					this._trigger('changeYear', this.viewDate);
				}

				if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
					this._trigger('changeMonth', this.viewDate);
				}
			}
			this._setDate(date);
		},

		// Clicked on prev or next
		navArrowsClick: function(e){
			var $target = $(e.currentTarget);
			var dir = $target.hasClass('prev') ? -1 : 1;
			if (this.viewMode !== 0){
				dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
			}
			this.viewDate = this.moveMonth(this.viewDate, dir);
			this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
			this.fill();
		},

		_toggle_multidate: function(date){
			var ix = this.dates.contains(date);
			if (!date){
				this.dates.clear();
			}

			if (ix !== -1){
				if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
					this.dates.remove(ix);
				}
			} else if (this.o.multidate === false) {
				this.dates.clear();
				this.dates.push(date);
			}
			else {
				this.dates.push(date);
			}

			if (typeof this.o.multidate === 'number')
				while (this.dates.length > this.o.multidate)
					this.dates.remove(0);
		},

		_setDate: function(date, which){
			if (!which || which === 'date')
				this._toggle_multidate(date && new Date(date));
			if ((!which && this.o.updateViewDate) || which === 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			if (!which || which !== 'view') {
				this._trigger('changeDate');
			}
			this.inputField.trigger('change');
			if (this.o.autoclose && (!which || which === 'date')){
				this.hide();
			}
		},

		moveDay: function(date, dir){
			var newDate = new Date(date);
			newDate.setUTCDate(date.getUTCDate() + dir);

			return newDate;
		},

		moveWeek: function(date, dir){
			return this.moveDay(date, dir * 7);
		},

		moveMonth: function(date, dir){
			if (!isValidDate(date))
				return this.o.defaultViewDate;
			if (!dir)
				return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag === 1){
				test = dir === -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){
						return new_date.getUTCMonth() === month;
					}
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){
						return new_date.getUTCMonth() !== new_month;
					};
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				new_month = (new_month + 12) % 12;
			}
			else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){
					return new_month !== new_date.getUTCMonth();
				};
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		moveAvailableDate: function(date, dir, fn){
			do {
				date = this[fn](date, dir);

				if (!this.dateWithinRange(date))
					return false;

				fn = 'moveDay';
			}
			while (this.dateIsDisabled(date));

			return date;
		},

		weekOfDateIsDisabled: function(date){
			return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
		},

		dateIsDisabled: function(date){
			return (
				this.weekOfDateIsDisabled(date) ||
				$.grep(this.o.datesDisabled, function(d){
					return isUTCEquals(date, d);
				}).length > 0
			);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (!this.picker.is(':visible')){
				if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
					this.show();
					e.stopPropagation();
        }
				return;
			}
			var dateChanged = false,
				dir, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch (e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					e.stopPropagation();
					break;
				case 37: // left
				case 38: // up
				case 39: // right
				case 40: // down
					if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
						break;
					dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
          if (this.viewMode === 0) {
  					if (e.ctrlKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

  						if (newViewDate)
  							this._trigger('changeYear', this.viewDate);
  					} else if (e.shiftKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

  						if (newViewDate)
  							this._trigger('changeMonth', this.viewDate);
  					} else if (e.keyCode === 37 || e.keyCode === 39){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
  					} else if (!this.weekOfDateIsDisabled(focusDate)){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
  					}
          } else if (this.viewMode === 1) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
          } else if (this.viewMode === 2) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
          }
					if (newViewDate){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 13: // enter
					if (!this.o.forceParse)
						break;
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					if (this.o.keyboardNavigation) {
						this._toggle_multidate(focusDate);
						dateChanged = true;
					}
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					if (this.picker.is(':visible')){
						e.preventDefault();
						e.stopPropagation();
						if (this.o.autoclose)
							this.hide();
					}
					break;
				case 9: // tab
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				this.inputField.trigger('change');
			}
		},

		setViewMode: function(viewMode){
			this.viewMode = viewMode;
			this.picker
				.children('div')
				.hide()
				.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
					.show();
			this.updateNavArrows();
      this._trigger('changeViewMode', new Date(this.viewDate));
		}
	};

	var DateRangePicker = function(element, options){
		$.data(element, 'datepicker', this);
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){
			return i.jquery ? i[0] : i;
		});
		delete options.inputs;

		this.keepEmptyValues = options.keepEmptyValues;
		delete options.keepEmptyValues;

		datepickerPlugin.call($(this.inputs), options)
			.on('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){
			return $.data(i, 'datepicker');
		});
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){
				return i.getUTCDate();
			});
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){
				return d.valueOf();
			});
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $.data(e.target, 'datepicker');

			if (dp === undefined) {
				return;
			}

			var new_date = dp.getUTCDate(),
				keep_empty_values = this.keepEmptyValues,
				i = $.inArray(e.target, this.inputs),
				j = i - 1,
				k = i + 1,
				l = this.inputs.length;
			if (i === -1)
				return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate() && (p === dp || !keep_empty_values))
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[j]){
				// Date being moved earlier/left
				while (j >= 0 && new_date < this.dates[j]){
					this.pickers[j--].setUTCDate(new_date);
				}
			} else if (new_date > this.dates[k]){
				// Date being moved later/right
				while (k < l && new_date > this.dates[k]){
					this.pickers[k++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		destroy: function(){
			$.map(this.pickers, function(p){ p.destroy(); });
			$(this.inputs).off('changeDate', this.dateUpdated);
			delete this.element.data().datepicker;
		},
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
		prefix = new RegExp('^' + prefix.toLowerCase());
		function re_lower(_,a){
			return a.toLowerCase();
		}
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, re_lower);
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]){
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	var datepickerPlugin = function(option){
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function(){
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data){
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.hasClass('input-daterange') || opts.inputs){
					$.extend(opts, {
						inputs: opts.inputs || $this.find('input').toArray()
					});
					data = new DateRangePicker(this, opts);
				}
				else {
					data = new Datepicker(this, opts);
				}
				$this.data('datepicker', data);
			}
			if (typeof option === 'string' && typeof data[option] === 'function'){
				internal_return = data[option].apply(data, args);
			}
		});

		if (
			internal_return === undefined ||
			internal_return instanceof Datepicker ||
			internal_return instanceof DateRangePicker
		)
			return this;

		if (this.length > 1)
			throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
		else
			return internal_return;
	};
	$.fn.datepicker = datepickerPlugin;

	var defaults = $.fn.datepicker.defaults = {
		assumeNearbyYear: false,
		autoclose: false,
		beforeShowDay: $.noop,
		beforeShowMonth: $.noop,
		beforeShowYear: $.noop,
		beforeShowDecade: $.noop,
		beforeShowCentury: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		toggleActive: false,
		daysOfWeekDisabled: [],
		daysOfWeekHighlighted: [],
		datesDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keepEmptyValues: false,
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		maxViewMode: 4,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		updateViewDate: true,
		weekStart: 0,
		disableTouchKeyboard: false,
		enableOnReadonly: true,
		showOnFocus: true,
		zIndexOffset: 10,
		container: 'body',
		immediateUpdates: false,
		title: '',
		templates: {
			leftArrow: '&#x00AB;',
			rightArrow: '&#x00BB;'
		},
    showWeekDays: true
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear",
			titleFormat: "MM yyyy"
		}
	};

	var DPGlobal = {
		viewModes: [
			{
				names: ['days', 'month'],
				clsName: 'days',
				e: 'changeMonth'
			},
			{
				names: ['months', 'year'],
				clsName: 'months',
				e: 'changeYear',
				navStep: 1
			},
			{
				names: ['years', 'decade'],
				clsName: 'years',
				e: 'changeDecade',
				navStep: 10
			},
			{
				names: ['decades', 'century'],
				clsName: 'decades',
				e: 'changeCentury',
				navStep: 100
			},
			{
				names: ['centuries', 'millennium'],
				clsName: 'centuries',
				e: 'changeMillennium',
				navStep: 1000
			}
		],
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
                return format;
            // IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language, assumeNearby){
			if (!date)
				return undefined;
			if (date instanceof Date)
				return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toValue)
				return format.toValue(date, format, language);
			var fn_map = {
					d: 'moveDay',
					m: 'moveMonth',
					w: 'moveWeek',
					y: 'moveYear'
				},
				dateAliases = {
					yesterday: '-1d',
					today: '+0d',
					tomorrow: '+1d'
				},
				parts, part, dir, i, fn;
			if (date in dateAliases){
				date = dateAliases[date];
			}
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
				parts = date.match(/([\-+]\d+)([dmwy])/gi);
				date = new Date();
				for (i=0; i < parts.length; i++){
					part = parts[i].match(/([\-+]\d+)([dmwy])/i);
					dir = Number(part[1]);
					fn = fn_map[part[2].toLowerCase()];
					date = Datepicker.prototype[fn](date, dir);
				}
				return Datepicker.prototype._zero_utc_time(date);
			}

			parts = date && date.match(this.nonpunctuation) || [];

			function applyNearbyYear(year, threshold){
				if (threshold === true)
					threshold = 10;

				// if year is 2 digits or less, than the user most likely is trying to get a recent century
				if (year < 100){
					year += 2000;
					// if the new year is more than threshold years in advance, use last century
					if (year > ((new Date()).getFullYear()+threshold)){
						year -= 100;
					}
				}

				return year;
			}

			var parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){
						return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
					},
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() !== v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){
						return d.setUTCDate(v);
					}
				},
				val, filtered;
			setters_map['yy'] = setters_map['yyyy'];
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCToday();
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length !== fparts.length){
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			function match_part(){
				var m = this.slice(0, parts[i].length),
					p = parts[i].slice(0, m.length);
				return m.toLowerCase() === p.toLowerCase();
			}
			if (parts.length === fparts.length){
				var cnt;
				for (i=0, cnt = fparts.length; i < cnt; i++){
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)){
						switch (part){
							case 'MM':
								filtered = $(dates[language].months).filter(match_part);
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(match_part);
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				var _date, s;
				for (i=0; i < setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toDisplay)
                return format.toDisplay(date, format, language);
            var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			date = [];
			var seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
			              '<tr>'+
			                '<th colspan="7" class="datepicker-title"></th>'+
			              '</tr>'+
							'<tr>'+
								'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">'+defaults.templates.rightArrow+'</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot>'+
							'<tr>'+
								'<th colspan="7" class="today"></th>'+
							'</tr>'+
							'<tr>'+
								'<th colspan="7" class="clear"></th>'+
							'</tr>'+
						'</tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-decades">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-centuries">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};

	/* DATEPICKER VERSION
	 * =================== */
	$.fn.datepicker.version = '1.7.1';

	$.fn.datepicker.deprecated = function(msg){
		var console = window.console;
		if (console && console.warn) {
			console.warn('DEPRECATED: ' + msg);
		}
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker'))
				return;
			e.preventDefault();
			// component click requires us to explicitly show it
			datepickerPlugin.call($this, 'show');
		}
	);
	$(function(){
		datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
	});

}));


/***/ }),

/***/ "./node_modules/daterangepicker/daterangepicker.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
* @version: 2.1.25
* @author: Dan Grossman http://www.dangrossman.info/
* @copyright: Copyright (c) 2012-2017 Dan Grossman. All rights reserved.
* @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
* @website: http://www.daterangepicker.com/
*/
// Follow the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
(function (root, factory) {
    if (true) {
        // AMD. Make globaly available as well
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/moment/moment.js"), __webpack_require__("./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment, jquery) {
            return (root.daterangepicker = factory(moment, jquery));
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        // Node / Browserify
        //isomorphic issue
        var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
        if (!jQuery) {
            jQuery = require('jquery');
            if (!jQuery.fn) jQuery.fn = {};
        }
        var moment = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : require('moment');
        module.exports = factory(moment, jQuery);
    } else {
        // Browser globals
        root.daterangepicker = factory(root.moment, root.jQuery);
    }
}(this, function(moment, $) {
    var DateRangePicker = function(element, options, cb) {

        //default settings for options
        this.parentEl = 'body';
        this.element = $(element);
        this.startDate = moment().startOf('day');
        this.endDate = moment().endOf('day');
        this.minDate = false;
        this.maxDate = false;
        this.dateLimit = false;
        this.autoApply = false;
        this.singleDatePicker = false;
        this.showDropdowns = false;
        this.showWeekNumbers = false;
        this.showISOWeekNumbers = false;
        this.showCustomRangeLabel = true;
        this.timePicker = false;
        this.timePicker24Hour = false;
        this.timePickerIncrement = 1;
        this.timePickerSeconds = false;
        this.linkedCalendars = true;
        this.autoUpdateInput = true;
        this.alwaysShowCalendars = false;
        this.ranges = {};

        this.opens = 'right';
        if (this.element.hasClass('pull-right'))
            this.opens = 'left';

        this.drops = 'down';
        if (this.element.hasClass('dropup'))
            this.drops = 'up';

        this.buttonClasses = 'btn btn-sm';
        this.applyClass = 'btn-success';
        this.cancelClass = 'btn-default';

        this.locale = {
            direction: 'ltr',
            format: moment.localeData().longDateFormat('L'),
            separator: ' - ',
            applyLabel: 'Apply',
            cancelLabel: 'Cancel',
            weekLabel: 'W',
            customRangeLabel: 'Custom Range',
            daysOfWeek: moment.weekdaysMin(),
            monthNames: moment.monthsShort(),
            firstDay: moment.localeData().firstDayOfWeek()
        };

        this.callback = function() { };

        //some state information
        this.isShowing = false;
        this.leftCalendar = {};
        this.rightCalendar = {};

        //custom options from user
        if (typeof options !== 'object' || options === null)
            options = {};

        //allow setting options with data attributes
        //data-api options will be overwritten with custom javascript options
        options = $.extend(this.element.data(), options);

        //html template for the picker UI
        if (typeof options.template !== 'string' && !(options.template instanceof $))
            options.template = '<div class="daterangepicker dropdown-menu">' +
                '<div class="calendar left">' +
                    '<div class="daterangepicker_input">' +
                      '<input class="input-mini form-control" type="text" name="daterangepicker_start" value="" />' +
                      '<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
                      '<div class="calendar-time">' +
                        '<div></div>' +
                        '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                      '</div>' +
                    '</div>' +
                    '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="calendar right">' +
                    '<div class="daterangepicker_input">' +
                      '<input class="input-mini form-control" type="text" name="daterangepicker_end" value="" />' +
                      '<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
                      '<div class="calendar-time">' +
                        '<div></div>' +
                        '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                      '</div>' +
                    '</div>' +
                    '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="ranges">' +
                    '<div class="range_inputs">' +
                        '<button class="applyBtn" disabled="disabled" type="button"></button> ' +
                        '<button class="cancelBtn" type="button"></button>' +
                    '</div>' +
                '</div>' +
            '</div>';

        this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
        this.container = $(options.template).appendTo(this.parentEl);

        //
        // handle all the possible options overriding defaults
        //

        if (typeof options.locale === 'object') {

            if (typeof options.locale.direction === 'string')
                this.locale.direction = options.locale.direction;

            if (typeof options.locale.format === 'string')
                this.locale.format = options.locale.format;

            if (typeof options.locale.separator === 'string')
                this.locale.separator = options.locale.separator;

            if (typeof options.locale.daysOfWeek === 'object')
                this.locale.daysOfWeek = options.locale.daysOfWeek.slice();

            if (typeof options.locale.monthNames === 'object')
              this.locale.monthNames = options.locale.monthNames.slice();

            if (typeof options.locale.firstDay === 'number')
              this.locale.firstDay = options.locale.firstDay;

            if (typeof options.locale.applyLabel === 'string')
              this.locale.applyLabel = options.locale.applyLabel;

            if (typeof options.locale.cancelLabel === 'string')
              this.locale.cancelLabel = options.locale.cancelLabel;

            if (typeof options.locale.weekLabel === 'string')
              this.locale.weekLabel = options.locale.weekLabel;

            if (typeof options.locale.customRangeLabel === 'string'){
                //Support unicode chars in the custom range name.
                var elem = document.createElement('textarea');
                elem.innerHTML = options.locale.customRangeLabel;
                var rangeHtml = elem.value;
                this.locale.customRangeLabel = rangeHtml;
            }
        }
        this.container.addClass(this.locale.direction);

        if (typeof options.startDate === 'string')
            this.startDate = moment(options.startDate, this.locale.format);

        if (typeof options.endDate === 'string')
            this.endDate = moment(options.endDate, this.locale.format);

        if (typeof options.minDate === 'string')
            this.minDate = moment(options.minDate, this.locale.format);

        if (typeof options.maxDate === 'string')
            this.maxDate = moment(options.maxDate, this.locale.format);

        if (typeof options.startDate === 'object')
            this.startDate = moment(options.startDate);

        if (typeof options.endDate === 'object')
            this.endDate = moment(options.endDate);

        if (typeof options.minDate === 'object')
            this.minDate = moment(options.minDate);

        if (typeof options.maxDate === 'object')
            this.maxDate = moment(options.maxDate);

        // sanity check for bad options
        if (this.minDate && this.startDate.isBefore(this.minDate))
            this.startDate = this.minDate.clone();

        // sanity check for bad options
        if (this.maxDate && this.endDate.isAfter(this.maxDate))
            this.endDate = this.maxDate.clone();

        if (typeof options.applyClass === 'string')
            this.applyClass = options.applyClass;

        if (typeof options.cancelClass === 'string')
            this.cancelClass = options.cancelClass;

        if (typeof options.dateLimit === 'object')
            this.dateLimit = options.dateLimit;

        if (typeof options.opens === 'string')
            this.opens = options.opens;

        if (typeof options.drops === 'string')
            this.drops = options.drops;

        if (typeof options.showWeekNumbers === 'boolean')
            this.showWeekNumbers = options.showWeekNumbers;

        if (typeof options.showISOWeekNumbers === 'boolean')
            this.showISOWeekNumbers = options.showISOWeekNumbers;

        if (typeof options.buttonClasses === 'string')
            this.buttonClasses = options.buttonClasses;

        if (typeof options.buttonClasses === 'object')
            this.buttonClasses = options.buttonClasses.join(' ');

        if (typeof options.showDropdowns === 'boolean')
            this.showDropdowns = options.showDropdowns;

        if (typeof options.showCustomRangeLabel === 'boolean')
            this.showCustomRangeLabel = options.showCustomRangeLabel;

        if (typeof options.singleDatePicker === 'boolean') {
            this.singleDatePicker = options.singleDatePicker;
            if (this.singleDatePicker)
                this.endDate = this.startDate.clone();
        }

        if (typeof options.timePicker === 'boolean')
            this.timePicker = options.timePicker;

        if (typeof options.timePickerSeconds === 'boolean')
            this.timePickerSeconds = options.timePickerSeconds;

        if (typeof options.timePickerIncrement === 'number')
            this.timePickerIncrement = options.timePickerIncrement;

        if (typeof options.timePicker24Hour === 'boolean')
            this.timePicker24Hour = options.timePicker24Hour;

        if (typeof options.autoApply === 'boolean')
            this.autoApply = options.autoApply;

        if (typeof options.autoUpdateInput === 'boolean')
            this.autoUpdateInput = options.autoUpdateInput;

        if (typeof options.linkedCalendars === 'boolean')
            this.linkedCalendars = options.linkedCalendars;

        if (typeof options.isInvalidDate === 'function')
            this.isInvalidDate = options.isInvalidDate;

        if (typeof options.isCustomDate === 'function')
            this.isCustomDate = options.isCustomDate;

        if (typeof options.alwaysShowCalendars === 'boolean')
            this.alwaysShowCalendars = options.alwaysShowCalendars;

        // update day names order to firstDay
        if (this.locale.firstDay != 0) {
            var iterator = this.locale.firstDay;
            while (iterator > 0) {
                this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                iterator--;
            }
        }

        var start, end, range;

        //if no start/end dates set, check if an input element contains initial values
        if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
            if ($(this.element).is('input[type=text]')) {
                var val = $(this.element).val(),
                    split = val.split(this.locale.separator);

                start = end = null;

                if (split.length == 2) {
                    start = moment(split[0], this.locale.format);
                    end = moment(split[1], this.locale.format);
                } else if (this.singleDatePicker && val !== "") {
                    start = moment(val, this.locale.format);
                    end = moment(val, this.locale.format);
                }
                if (start !== null && end !== null) {
                    this.setStartDate(start);
                    this.setEndDate(end);
                }
            }
        }

        if (typeof options.ranges === 'object') {
            for (range in options.ranges) {

                if (typeof options.ranges[range][0] === 'string')
                    start = moment(options.ranges[range][0], this.locale.format);
                else
                    start = moment(options.ranges[range][0]);

                if (typeof options.ranges[range][1] === 'string')
                    end = moment(options.ranges[range][1], this.locale.format);
                else
                    end = moment(options.ranges[range][1]);

                // If the start or end date exceed those allowed by the minDate or dateLimit
                // options, shorten the range to the allowable period.
                if (this.minDate && start.isBefore(this.minDate))
                    start = this.minDate.clone();

                var maxDate = this.maxDate;
                if (this.dateLimit && maxDate && start.clone().add(this.dateLimit).isAfter(maxDate))
                    maxDate = start.clone().add(this.dateLimit);
                if (maxDate && end.isAfter(maxDate))
                    end = maxDate.clone();

                // If the end of the range is before the minimum or the start of the range is
                // after the maximum, don't display this range option at all.
                if ((this.minDate && end.isBefore(this.minDate, this.timepicker ? 'minute' : 'day')) 
                  || (maxDate && start.isAfter(maxDate, this.timepicker ? 'minute' : 'day')))
                    continue;

                //Support unicode chars in the range names.
                var elem = document.createElement('textarea');
                elem.innerHTML = range;
                var rangeHtml = elem.value;

                this.ranges[rangeHtml] = [start, end];
            }

            var list = '<ul>';
            for (range in this.ranges) {
                list += '<li data-range-key="' + range + '">' + range + '</li>';
            }
            if (this.showCustomRangeLabel) {
                list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
            }
            list += '</ul>';
            this.container.find('.ranges').prepend(list);
        }

        if (typeof cb === 'function') {
            this.callback = cb;
        }

        if (!this.timePicker) {
            this.startDate = this.startDate.startOf('day');
            this.endDate = this.endDate.endOf('day');
            this.container.find('.calendar-time').hide();
        }

        //can't be used together for now
        if (this.timePicker && this.autoApply)
            this.autoApply = false;

        if (this.autoApply && typeof options.ranges !== 'object') {
            this.container.find('.ranges').hide();
        } else if (this.autoApply) {
            this.container.find('.applyBtn, .cancelBtn').addClass('hide');
        }

        if (this.singleDatePicker) {
            this.container.addClass('single');
            this.container.find('.calendar.left').addClass('single');
            this.container.find('.calendar.left').show();
            this.container.find('.calendar.right').hide();
            this.container.find('.daterangepicker_input input, .daterangepicker_input > i').hide();
            if (this.timePicker) {
                this.container.find('.ranges ul').hide();
            } else {
                this.container.find('.ranges').hide();
            }
        }

        if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
            this.container.addClass('show-calendar');
        }

        this.container.addClass('opens' + this.opens);

        //swap the position of the predefined ranges if opens right
        if (typeof options.ranges !== 'undefined' && this.opens == 'right') {
            this.container.find('.ranges').prependTo( this.container.find('.calendar.left').parent() );
        }

        //apply CSS classes and labels to buttons
        this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
        if (this.applyClass.length)
            this.container.find('.applyBtn').addClass(this.applyClass);
        if (this.cancelClass.length)
            this.container.find('.cancelBtn').addClass(this.cancelClass);
        this.container.find('.applyBtn').html(this.locale.applyLabel);
        this.container.find('.cancelBtn').html(this.locale.cancelLabel);

        //
        // event listeners
        //

        this.container.find('.calendar')
            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
            .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
            .on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
            .on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs, this))
            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this))
            .on('click.daterangepicker', '.daterangepicker_input input', $.proxy(this.showCalendars, this))
            .on('focus.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsFocused, this))
            .on('blur.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsBlurred, this))
            .on('change.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this));

        this.container.find('.ranges')
            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this))
            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))
            .on('mouseenter.daterangepicker', 'li', $.proxy(this.hoverRange, this))
            .on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs, this));

        if (this.element.is('input') || this.element.is('button')) {
            this.element.on({
                'click.daterangepicker': $.proxy(this.show, this),
                'focus.daterangepicker': $.proxy(this.show, this),
                'keyup.daterangepicker': $.proxy(this.elementChanged, this),
                'keydown.daterangepicker': $.proxy(this.keydown, this)
            });
        } else {
            this.element.on('click.daterangepicker', $.proxy(this.toggle, this));
        }

        //
        // if attached to a text input, set the initial value
        //

        if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
            this.element.trigger('change');
        } else if (this.element.is('input') && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format));
            this.element.trigger('change');
        }

    };

    DateRangePicker.prototype = {

        constructor: DateRangePicker,

        setStartDate: function(startDate) {
            if (typeof startDate === 'string')
                this.startDate = moment(startDate, this.locale.format);

            if (typeof startDate === 'object')
                this.startDate = moment(startDate);

            if (!this.timePicker)
                this.startDate = this.startDate.startOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.minDate && this.startDate.isBefore(this.minDate)) {
                this.startDate = this.minDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
                this.startDate = this.maxDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        setEndDate: function(endDate) {
            if (typeof endDate === 'string')
                this.endDate = moment(endDate, this.locale.format);

            if (typeof endDate === 'object')
                this.endDate = moment(endDate);

            if (!this.timePicker)
                this.endDate = this.endDate.endOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.endDate.isBefore(this.startDate))
                this.endDate = this.startDate.clone();

            if (this.maxDate && this.endDate.isAfter(this.maxDate))
                this.endDate = this.maxDate.clone();

            if (this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate))
                this.endDate = this.startDate.clone().add(this.dateLimit);

            this.previousRightTime = this.endDate.clone();

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        isInvalidDate: function() {
            return false;
        },

        isCustomDate: function() {
            return false;
        },

        updateView: function() {
            if (this.timePicker) {
                this.renderTimePicker('left');
                this.renderTimePicker('right');
                if (!this.endDate) {
                    this.container.find('.right .calendar-time select').attr('disabled', 'disabled').addClass('disabled');
                } else {
                    this.container.find('.right .calendar-time select').removeAttr('disabled').removeClass('disabled');
                }
            }
            if (this.endDate) {
                this.container.find('input[name="daterangepicker_end"]').removeClass('active');
                this.container.find('input[name="daterangepicker_start"]').addClass('active');
            } else {
                this.container.find('input[name="daterangepicker_end"]').addClass('active');
                this.container.find('input[name="daterangepicker_start"]').removeClass('active');
            }
            this.updateMonthsInView();
            this.updateCalendars();
            this.updateFormInputs();
        },

        updateMonthsInView: function() {
            if (this.endDate) {

                //if both dates are visible already, do nothing
                if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
                    (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                    &&
                    (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                    ) {
                    return;
                }

                this.leftCalendar.month = this.startDate.clone().date(2);
                if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
                    this.rightCalendar.month = this.endDate.clone().date(2);
                } else {
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }

            } else {
                if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
                    this.leftCalendar.month = this.startDate.clone().date(2);
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }
            }
            if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
              this.rightCalendar.month = this.maxDate.clone().date(2);
              this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
            }
        },

        updateCalendars: function() {

            if (this.timePicker) {
                var hour, minute, second;
                if (this.endDate) {
                    hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                } else {
                    hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                }
                this.leftCalendar.month.hour(hour).minute(minute).second(second);
                this.rightCalendar.month.hour(hour).minute(minute).second(second);
            }

            this.renderCalendar('left');
            this.renderCalendar('right');

            //highlight any predefined range matching the current start and end dates
            this.container.find('.ranges li').removeClass('active');
            if (this.endDate == null) return;

            this.calculateChosenLabel();
        },

        renderCalendar: function(side) {

            //
            // Build the matrix of dates that will populate the calendar
            //

            var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
            var month = calendar.month.month();
            var year = calendar.month.year();
            var hour = calendar.month.hour();
            var minute = calendar.month.minute();
            var second = calendar.month.second();
            var daysInMonth = moment([year, month]).daysInMonth();
            var firstDay = moment([year, month, 1]);
            var lastDay = moment([year, month, daysInMonth]);
            var lastMonth = moment(firstDay).subtract(1, 'month').month();
            var lastYear = moment(firstDay).subtract(1, 'month').year();
            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
            var dayOfWeek = firstDay.day();

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = [];
            calendar.firstDay = firstDay;
            calendar.lastDay = lastDay;

            for (var i = 0; i < 6; i++) {
                calendar[i] = [];
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
            if (startDay > daysInLastMonth)
                startDay -= 7;

            if (dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

            var col, row;
            for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {
                if (i > 0 && col % 7 === 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
                curDate.hour(12);

                if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
                    calendar[row][col] = this.minDate.clone();
                }

                if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
                    calendar[row][col] = this.maxDate.clone();
                }

            }

            //make the calendar object available to hoverDate/clickDate
            if (side == 'left') {
                this.leftCalendar.calendar = calendar;
            } else {
                this.rightCalendar.calendar = calendar;
            }

            //
            // Display the calendar
            //

            var minDate = side == 'left' ? this.minDate : this.startDate;
            var maxDate = this.maxDate;
            var selected = side == 'left' ? this.startDate : this.endDate;
            var arrow = this.locale.direction == 'ltr' ? {left: 'chevron-left', right: 'chevron-right'} : {left: 'chevron-right', right: 'chevron-left'};

            var html = '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th></th>';

            if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
                html += '<th class="prev available"><i class="fa fa-' + arrow.left + ' glyphicon glyphicon-' + arrow.left + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(" YYYY");

            if (this.showDropdowns) {
                var currentMonth = calendar[1][1].month();
                var currentYear = calendar[1][1].year();
                var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);
                var minYear = (minDate && minDate.year()) || (currentYear - 50);
                var inMinYear = currentYear == minYear;
                var inMaxYear = currentYear == maxYear;

                var monthHtml = '<select class="monthselect">';
                for (var m = 0; m < 12; m++) {
                    if ((!inMinYear || m >= minDate.month()) && (!inMaxYear || m <= maxDate.month())) {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            ">" + this.locale.monthNames[m] + "</option>";
                    } else {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            " disabled='disabled'>" + this.locale.monthNames[m] + "</option>";
                    }
                }
                monthHtml += "</select>";

                var yearHtml = '<select class="yearselect">';
                for (var y = minYear; y <= maxYear; y++) {
                    yearHtml += '<option value="' + y + '"' +
                        (y === currentYear ? ' selected="selected"' : '') +
                        '>' + y + '</option>';
                }
                yearHtml += '</select>';

                dateHtml = monthHtml + yearHtml;
            }

            html += '<th colspan="5" class="month">' + dateHtml + '</th>';
            if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
                html += '<th class="next available"><i class="fa fa-' + arrow.right + ' glyphicon glyphicon-' + arrow.right + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel + '</th>';

            $.each(this.locale.daysOfWeek, function(index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            //adjust maxDate to reflect the dateLimit setting in order to
            //grey out end dates beyond the dateLimit
            if (this.endDate == null && this.dateLimit) {
                var maxLimit = this.startDate.clone().add(this.dateLimit).endOf('day');
                if (!maxDate || maxLimit.isBefore(maxDate)) {
                    maxDate = maxLimit;
                }
            }

            for (var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if (this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() + '</td>';
                else if (this.showISOWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';

                for (var col = 0; col < 7; col++) {

                    var classes = [];

                    //highlight today's date
                    if (calendar[row][col].isSame(new Date(), "day"))
                        classes.push('today');

                    //highlight weekends
                    if (calendar[row][col].isoWeekday() > 5)
                        classes.push('weekend');

                    //grey out the dates in other months displayed at beginning and end of this calendar
                    if (calendar[row][col].month() != calendar[1][1].month())
                        classes.push('off');

                    //don't allow selection of dates before the minimum date
                    if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of dates after the maximum date
                    if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of date if a custom function decides it's invalid
                    if (this.isInvalidDate(calendar[row][col]))
                        classes.push('off', 'disabled');

                    //highlight the currently selected start date
                    if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
                        classes.push('active', 'start-date');

                    //highlight the currently selected end date
                    if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
                        classes.push('active', 'end-date');

                    //highlight dates in-between the selected dates
                    if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
                        classes.push('in-range');

                    //apply custom classes for this date
                    var isCustom = this.isCustomDate(calendar[row][col]);
                    if (isCustom !== false) {
                        if (typeof isCustom === 'string')
                            classes.push(isCustom);
                        else
                            Array.prototype.push.apply(classes, isCustom);
                    }

                    var cname = '', disabled = false;
                    for (var i = 0; i < classes.length; i++) {
                        cname += classes[i] + ' ';
                        if (classes[i] == 'disabled')
                            disabled = true;
                    }
                    if (!disabled)
                        cname += 'available';

                    html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';

                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';

            this.container.find('.calendar.' + side + ' .calendar-table').html(html);

        },

        renderTimePicker: function(side) {

            // Don't bother updating the time picker if it's currently disabled
            // because an end date hasn't been clicked yet
            if (side == 'right' && !this.endDate) return;

            var html, selected, minDate, maxDate = this.maxDate;

            if (this.dateLimit && (!this.maxDate || this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate)))
                maxDate = this.startDate.clone().add(this.dateLimit);

            if (side == 'left') {
                selected = this.startDate.clone();
                minDate = this.minDate;
            } else if (side == 'right') {
                selected = this.endDate.clone();
                minDate = this.startDate;

                //Preserve the time already selected
                var timeSelector = this.container.find('.calendar.right .calendar-time div');
                if (timeSelector.html() != '') {

                    selected.hour(timeSelector.find('.hourselect option:selected').val() || selected.hour());
                    selected.minute(timeSelector.find('.minuteselect option:selected').val() || selected.minute());
                    selected.second(timeSelector.find('.secondselect option:selected').val() || selected.second());

                    if (!this.timePicker24Hour) {
                        var ampm = timeSelector.find('.ampmselect option:selected').val();
                        if (ampm === 'PM' && selected.hour() < 12)
                            selected.hour(selected.hour() + 12);
                        if (ampm === 'AM' && selected.hour() === 12)
                            selected.hour(0);
                    }

                }

                if (selected.isBefore(this.startDate))
                    selected = this.startDate.clone();

                if (maxDate && selected.isAfter(maxDate))
                    selected = maxDate.clone();

            }

            //
            // hours
            //

            html = '<select class="hourselect">';

            var start = this.timePicker24Hour ? 0 : 1;
            var end = this.timePicker24Hour ? 23 : 12;

            for (var i = start; i <= end; i++) {
                var i_in_24 = i;
                if (!this.timePicker24Hour)
                    i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);

                var time = selected.clone().hour(i_in_24);
                var disabled = false;
                if (minDate && time.minute(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.minute(0).isAfter(maxDate))
                    disabled = true;

                if (i_in_24 == selected.hour() && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + i + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + i + '</option>';
                } else {
                    html += '<option value="' + i + '">' + i + '</option>';
                }
            }

            html += '</select> ';

            //
            // minutes
            //

            html += ': <select class="minuteselect">';

            for (var i = 0; i < 60; i += this.timePickerIncrement) {
                var padded = i < 10 ? '0' + i : i;
                var time = selected.clone().minute(i);

                var disabled = false;
                if (minDate && time.second(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.second(0).isAfter(maxDate))
                    disabled = true;

                if (selected.minute() == i && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                } else {
                    html += '<option value="' + i + '">' + padded + '</option>';
                }
            }

            html += '</select> ';

            //
            // seconds
            //

            if (this.timePickerSeconds) {
                html += ': <select class="secondselect">';

                for (var i = 0; i < 60; i++) {
                    var padded = i < 10 ? '0' + i : i;
                    var time = selected.clone().second(i);

                    var disabled = false;
                    if (minDate && time.isBefore(minDate))
                        disabled = true;
                    if (maxDate && time.isAfter(maxDate))
                        disabled = true;

                    if (selected.second() == i && !disabled) {
                        html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                    } else if (disabled) {
                        html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                    } else {
                        html += '<option value="' + i + '">' + padded + '</option>';
                    }
                }

                html += '</select> ';
            }

            //
            // AM/PM
            //

            if (!this.timePicker24Hour) {
                html += '<select class="ampmselect">';

                var am_html = '';
                var pm_html = '';

                if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))
                    am_html = ' disabled="disabled" class="disabled"';

                if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))
                    pm_html = ' disabled="disabled" class="disabled"';

                if (selected.hour() >= 12) {
                    html += '<option value="AM"' + am_html + '>AM</option><option value="PM" selected="selected"' + pm_html + '>PM</option>';
                } else {
                    html += '<option value="AM" selected="selected"' + am_html + '>AM</option><option value="PM"' + pm_html + '>PM</option>';
                }

                html += '</select>';
            }

            this.container.find('.calendar.' + side + ' .calendar-time div').html(html);

        },

        updateFormInputs: function() {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            this.container.find('input[name=daterangepicker_start]').val(this.startDate.format(this.locale.format));
            if (this.endDate)
                this.container.find('input[name=daterangepicker_end]').val(this.endDate.format(this.locale.format));

            if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
                this.container.find('button.applyBtn').removeAttr('disabled');
            } else {
                this.container.find('button.applyBtn').attr('disabled', 'disabled');
            }

        },

        move: function() {
            var parentOffset = { top: 0, left: 0 },
                containerTop;
            var parentRightEdge = $(window).width();
            if (!this.parentEl.is('body')) {
                parentOffset = {
                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()
                };
                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
            }

            if (this.drops == 'up')
                containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
            else
                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
            this.container[this.drops == 'up' ? 'addClass' : 'removeClass']('dropup');

            if (this.opens == 'left') {
                this.container.css({
                    top: containerTop,
                    right: parentRightEdge - this.element.offset().left - this.element.outerWidth(),
                    left: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else if (this.opens == 'center') {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
                            - this.container.outerWidth() / 2,
                    right: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left,
                    right: 'auto'
                });
                if (this.container.offset().left + this.container.outerWidth() > $(window).width()) {
                    this.container.css({
                        left: 'auto',
                        right: 0
                    });
                }
            }
        },

        show: function(e) {
            if (this.isShowing) return;

            // Create a click proxy that is private to this instance of datepicker, for unbinding
            this._outsideClickProxy = $.proxy(function(e) { this.outsideClick(e); }, this);

            // Bind global datepicker mousedown for hiding and
            $(document)
              .on('mousedown.daterangepicker', this._outsideClickProxy)
              // also support mobile devices
              .on('touchend.daterangepicker', this._outsideClickProxy)
              // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them
              .on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)
              // and also close when focus changes to outside the picker (eg. tabbing between controls)
              .on('focusin.daterangepicker', this._outsideClickProxy);

            // Reposition the picker if the window is resized while it's open
            $(window).on('resize.daterangepicker', $.proxy(function(e) { this.move(e); }, this));

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();
            this.previousRightTime = this.endDate.clone();

            this.updateView();
            this.container.show();
            this.move();
            this.element.trigger('show.daterangepicker', this);
            this.isShowing = true;
        },

        hide: function(e) {
            if (!this.isShowing) return;

            //incomplete date selection, revert to last values
            if (!this.endDate) {
                this.startDate = this.oldStartDate.clone();
                this.endDate = this.oldEndDate.clone();
            }

            //if a new date range was selected, invoke the user callback function
            if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
                this.callback(this.startDate, this.endDate, this.chosenLabel);

            //if picker is attached to a text input, update it
            this.updateElement();

            $(document).off('.daterangepicker');
            $(window).off('.daterangepicker');
            this.container.hide();
            this.element.trigger('hide.daterangepicker', this);
            this.isShowing = false;
        },

        toggle: function(e) {
            if (this.isShowing) {
                this.hide();
            } else {
                this.show();
            }
        },

        outsideClick: function(e) {
            var target = $(e.target);
            // if the page is clicked anywhere except within the daterangerpicker/button
            // itself then call this.hide()
            if (
                // ie modal dialog fix
                e.type == "focusin" ||
                target.closest(this.element).length ||
                target.closest(this.container).length ||
                target.closest('.calendar-table').length
                ) return;
            this.hide();
            this.element.trigger('outsideClick.daterangepicker', this);
        },

        showCalendars: function() {
            this.container.addClass('show-calendar');
            this.move();
            this.element.trigger('showCalendar.daterangepicker', this);
        },

        hideCalendars: function() {
            this.container.removeClass('show-calendar');
            this.element.trigger('hideCalendar.daterangepicker', this);
        },

        hoverRange: function(e) {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            var label = e.target.getAttribute('data-range-key');

            if (label == this.locale.customRangeLabel) {
                this.updateView();
            } else {
                var dates = this.ranges[label];
                this.container.find('input[name=daterangepicker_start]').val(dates[0].format(this.locale.format));
                this.container.find('input[name=daterangepicker_end]').val(dates[1].format(this.locale.format));
            }

        },

        clickRange: function(e) {
            var label = e.target.getAttribute('data-range-key');
            this.chosenLabel = label;
            if (label == this.locale.customRangeLabel) {
                this.showCalendars();
            } else {
                var dates = this.ranges[label];
                this.startDate = dates[0];
                this.endDate = dates[1];

                if (!this.timePicker) {
                    this.startDate.startOf('day');
                    this.endDate.endOf('day');
                }

                if (!this.alwaysShowCalendars)
                    this.hideCalendars();
                this.clickApply();
            }
        },

        clickPrev: function(e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.subtract(1, 'month');
                if (this.linkedCalendars)
                    this.rightCalendar.month.subtract(1, 'month');
            } else {
                this.rightCalendar.month.subtract(1, 'month');
            }
            this.updateCalendars();
        },

        clickNext: function(e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.add(1, 'month');
            } else {
                this.rightCalendar.month.add(1, 'month');
                if (this.linkedCalendars)
                    this.leftCalendar.month.add(1, 'month');
            }
            this.updateCalendars();
        },

        hoverDate: function(e) {

            //ignore mouse movements while an above-calendar text input has focus
            //if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
            //    return;

            //ignore dates that can't be selected
            if (!$(e.target).hasClass('available')) return;

            //have the text inputs above calendars reflect the date being hovered over
            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            if (this.endDate && !this.container.find('input[name=daterangepicker_start]').is(":focus")) {
                this.container.find('input[name=daterangepicker_start]').val(date.format(this.locale.format));
            } else if (!this.endDate && !this.container.find('input[name=daterangepicker_end]').is(":focus")) {
                this.container.find('input[name=daterangepicker_end]').val(date.format(this.locale.format));
            }

            //highlight the dates between the start date and the date being hovered as a potential end date
            var leftCalendar = this.leftCalendar;
            var rightCalendar = this.rightCalendar;
            var startDate = this.startDate;
            if (!this.endDate) {
                this.container.find('.calendar tbody td').each(function(index, el) {

                    //skip week numbers, only look at dates
                    if ($(el).hasClass('week')) return;

                    var title = $(el).attr('data-title');
                    var row = title.substr(1, 1);
                    var col = title.substr(3, 1);
                    var cal = $(el).parents('.calendar');
                    var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

                    if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
                        $(el).addClass('in-range');
                    } else {
                        $(el).removeClass('in-range');
                    }

                });
            }

        },

        clickDate: function(e) {

            if (!$(e.target).hasClass('available')) return;

            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            //
            // this function needs to do a few things:
            // * alternate between selecting a start and end date for the range,
            // * if the time picker is enabled, apply the hour/minute/second from the select boxes to the clicked date
            // * if autoapply is enabled, and an end date was chosen, apply the selection
            // * if single date picker mode, and time picker isn't enabled, apply the selection immediately
            // * if one of the inputs above the calendars was focused, cancel that manual input
            //

            if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.endDate = null;
                this.setStartDate(date.clone());
            } else if (!this.endDate && date.isBefore(this.startDate)) {
                //special case: clicking the same date for start/end,
                //but the time of the end date is before the start date
                this.setEndDate(this.startDate.clone());
            } else { // picking end
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.setEndDate(date.clone());
                if (this.autoApply) {
                  this.calculateChosenLabel();
                  this.clickApply();
                }
            }

            if (this.singleDatePicker) {
                this.setEndDate(this.startDate);
                if (!this.timePicker)
                    this.clickApply();
            }

            this.updateView();

            //This is to cancel the blur event handler if the mouse was in one of the inputs
            e.stopPropagation();

        },

        calculateChosenLabel: function () {
            var customRange = true;
            var i = 0;
            for (var range in this.ranges) {
                if (this.timePicker) {
                    if (this.startDate.isSame(this.ranges[range][0]) && this.endDate.isSame(this.ranges[range][1])) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                } else {
                    //ignore times when comparing dates if time picker is not enabled
                    if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                }
                i++;
            }
            if (customRange) {
                if (this.showCustomRangeLabel) {
                    this.chosenLabel = this.container.find('.ranges li:last').addClass('active').html();
                } else {
                    this.chosenLabel = null;
                }
                this.showCalendars();
            }
        },

        clickApply: function(e) {
            this.hide();
            this.element.trigger('apply.daterangepicker', this);
        },

        clickCancel: function(e) {
            this.startDate = this.oldStartDate;
            this.endDate = this.oldEndDate;
            this.hide();
            this.element.trigger('cancel.daterangepicker', this);
        },

        monthOrYearChanged: function(e) {
            var isLeft = $(e.target).closest('.calendar').hasClass('left'),
                leftOrRight = isLeft ? 'left' : 'right',
                cal = this.container.find('.calendar.'+leftOrRight);

            // Month must be Number for new moment versions
            var month = parseInt(cal.find('.monthselect').val(), 10);
            var year = cal.find('.yearselect').val();

            if (!isLeft) {
                if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
                    month = this.startDate.month();
                    year = this.startDate.year();
                }
            }

            if (this.minDate) {
                if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
                    month = this.minDate.month();
                    year = this.minDate.year();
                }
            }

            if (this.maxDate) {
                if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
                    month = this.maxDate.month();
                    year = this.maxDate.year();
                }
            }

            if (isLeft) {
                this.leftCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
            } else {
                this.rightCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
            }
            this.updateCalendars();
        },

        timeChanged: function(e) {

            var cal = $(e.target).closest('.calendar'),
                isLeft = cal.hasClass('left');

            var hour = parseInt(cal.find('.hourselect').val(), 10);
            var minute = parseInt(cal.find('.minuteselect').val(), 10);
            var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;

            if (!this.timePicker24Hour) {
                var ampm = cal.find('.ampmselect').val();
                if (ampm === 'PM' && hour < 12)
                    hour += 12;
                if (ampm === 'AM' && hour === 12)
                    hour = 0;
            }

            if (isLeft) {
                var start = this.startDate.clone();
                start.hour(hour);
                start.minute(minute);
                start.second(second);
                this.setStartDate(start);
                if (this.singleDatePicker) {
                    this.endDate = this.startDate.clone();
                } else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
                    this.setEndDate(start.clone());
                }
            } else if (this.endDate) {
                var end = this.endDate.clone();
                end.hour(hour);
                end.minute(minute);
                end.second(second);
                this.setEndDate(end);
            }

            //update the calendars so all clickable dates reflect the new time component
            this.updateCalendars();

            //update the form inputs above the calendars with the new time
            this.updateFormInputs();

            //re-render the time pickers because changing one selection can affect what's enabled in another
            this.renderTimePicker('left');
            this.renderTimePicker('right');

        },

        formInputsChanged: function(e) {
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            var start = moment(this.container.find('input[name="daterangepicker_start"]').val(), this.locale.format);
            var end = moment(this.container.find('input[name="daterangepicker_end"]').val(), this.locale.format);

            if (start.isValid() && end.isValid()) {

                if (isRight && end.isBefore(start))
                    start = end.clone();

                this.setStartDate(start);
                this.setEndDate(end);

                if (isRight) {
                    this.container.find('input[name="daterangepicker_start"]').val(this.startDate.format(this.locale.format));
                } else {
                    this.container.find('input[name="daterangepicker_end"]').val(this.endDate.format(this.locale.format));
                }

            }

            this.updateView();
        },

        formInputsFocused: function(e) {

            // Highlight the focused input
            this.container.find('input[name="daterangepicker_start"], input[name="daterangepicker_end"]').removeClass('active');
            $(e.target).addClass('active');

            // Set the state such that if the user goes back to using a mouse, 
            // the calendars are aware we're selecting the end of the range, not
            // the start. This allows someone to edit the end of a date range without
            // re-selecting the beginning, by clicking on the end date input then
            // using the calendar.
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            if (isRight) {
                this.endDate = null;
                this.setStartDate(this.startDate.clone());
                this.updateView();
            }

        },

        formInputsBlurred: function(e) {

            // this function has one purpose right now: if you tab from the first
            // text input to the second in the UI, the endDate is nulled so that
            // you can click another, but if you tab out without clicking anything
            // or changing the input value, the old endDate should be retained

            if (!this.endDate) {
                var val = this.container.find('input[name="daterangepicker_end"]').val();
                var end = moment(val, this.locale.format);
                if (end.isValid()) {
                    this.setEndDate(end);
                    this.updateView();
                }
            }

        },

        elementChanged: function() {
            if (!this.element.is('input')) return;
            if (!this.element.val().length) return;
            if (this.element.val().length < this.locale.format.length) return;

            var dateString = this.element.val().split(this.locale.separator),
                start = null,
                end = null;

            if (dateString.length === 2) {
                start = moment(dateString[0], this.locale.format);
                end = moment(dateString[1], this.locale.format);
            }

            if (this.singleDatePicker || start === null || end === null) {
                start = moment(this.element.val(), this.locale.format);
                end = start;
            }

            if (!start.isValid() || !end.isValid()) return;

            this.setStartDate(start);
            this.setEndDate(end);
            this.updateView();
        },

        keydown: function(e) {
            //hide on tab or enter
            if ((e.keyCode === 9) || (e.keyCode === 13)) {
                this.hide();
            }
        },

        updateElement: function() {
            if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
                this.element.trigger('change');
            } else if (this.element.is('input') && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format));
                this.element.trigger('change');
            }
        },

        remove: function() {
            this.container.remove();
            this.element.off('.daterangepicker');
            this.element.removeData();
        }

    };

    $.fn.daterangepicker = function(options, callback) {
        this.each(function() {
            var el = $(this);
            if (el.data('daterangepicker'))
                el.data('daterangepicker').remove();
            el.data('daterangepicker', new DateRangePicker(el, options, callback));
        });
        return this;
    };

    return DateRangePicker;

}));


/***/ }),

/***/ "./node_modules/fullcalendar/dist/fullcalendar.js":
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__("./node_modules/jquery/dist/jquery.js"), __webpack_require__("./node_modules/moment/moment.js"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery", "moment"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jquery"), require("moment")) : factory(root["jQuery"], root["moment"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 72);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {


/*
derived from:
https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js

only include the helpers we need, to keep down filesize
*/

var extendStatics =
	/* NOTE: tslib's as-is method is not compatible with how CoffeeScript does subclasses.
	 * When CoffeeScript is stripped out, can revert.
	 *
	 * Object.setPrototypeOf ||
	 * ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	 */
	function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

exports.__extends = function (d, b) {
	extendStatics(d, b);
	function __() { this.constructor = d; }
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
    if (scrollbarWidths.left) {
        rowEls.css({
            'border-left-width': 1,
            'margin-left': scrollbarWidths.left - 1
        });
    }
    if (scrollbarWidths.right) {
        rowEls.css({
            'border-right-width': 1,
            'margin-right': scrollbarWidths.right - 1
        });
    }
}
exports.compensateScroll = compensateScroll;
// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
    rowEls.css({
        'margin-left': '',
        'margin-right': '',
        'border-left-width': '',
        'border-right-width': ''
    });
}
exports.uncompensateScroll = uncompensateScroll;
// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
    $('body').addClass('fc-not-allowed');
}
exports.disableCursor = disableCursor;
// Returns the mouse cursor to its original look
function enableCursor() {
    $('body').removeClass('fc-not-allowed');
}
exports.enableCursor = enableCursor;
// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {
    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
    var flexEls = []; // elements that are allowed to expand. array of DOM nodes
    var flexOffsets = []; // amount of vertical space it takes up
    var flexHeights = []; // actual css height
    var usedHeight = 0;
    undistributeHeight(els); // give all elements their natural height
    // find elements that are below the recommended height (expandable).
    // important to query for heights in a single first pass (to avoid reflow oscillation).
    els.each(function (i, el) {
        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = $(el).outerHeight(true);
        if (naturalOffset < minOffset) {
            flexEls.push(el);
            flexOffsets.push(naturalOffset);
            flexHeights.push($(el).height());
        }
        else {
            // this element stretches past recommended height (non-expandable). mark the space as occupied.
            usedHeight += naturalOffset;
        }
    });
    // readjust the recommended height to only consider the height available to non-maxed-out rows.
    if (shouldRedistribute) {
        availableHeight -= usedHeight;
        minOffset1 = Math.floor(availableHeight / flexEls.length);
        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
    }
    // assign heights to all expandable elements
    $(flexEls).each(function (i, el) {
        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = flexOffsets[i];
        var naturalHeight = flexHeights[i];
        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
        if (naturalOffset < minOffset) {
            $(el).height(newHeight);
        }
    });
}
exports.distributeHeight = distributeHeight;
// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
    els.height('');
}
exports.undistributeHeight = undistributeHeight;
// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
    var maxInnerWidth = 0;
    els.find('> *').each(function (i, innerEl) {
        var innerWidth = $(innerEl).outerWidth();
        if (innerWidth > maxInnerWidth) {
            maxInnerWidth = innerWidth;
        }
    });
    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
    els.width(maxInnerWidth);
    return maxInnerWidth;
}
exports.matchCellWidths = matchCellWidths;
// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
    var both = outerEl.add(innerEl);
    var diff;
    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
    both.css({
        position: 'relative',
        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
    });
    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
    both.css({ position: '', left: '' }); // undo hack
    return diff;
}
exports.subtractInnerElHeight = subtractInnerElHeight;
/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/
// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
    var position = el.css('position'), scrollParent = el.parents().filter(function () {
        var parent = $(this);
        return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
    }).eq(0);
    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}
exports.getScrollParent = getScrollParent;
// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
    var offset = el.offset();
    var left = offset.left - (origin ? origin.left : 0);
    var top = offset.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.outerWidth(),
        top: top,
        bottom: top + el.outerHeight()
    };
}
exports.getOuterRect = getOuterRect;
// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
    var offset = el.offset();
    var scrollbarWidths = getScrollbarWidths(el);
    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el[0].clientWidth,
        top: top,
        bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
    };
}
exports.getClientRect = getClientRect;
// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
    var offset = el.offset(); // just outside of border, margin not included
    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
        (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
        (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.width(),
        top: top,
        bottom: top + el.height()
    };
}
exports.getContentRect = getContentRect;
// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
    var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
    var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
    var widths;
    leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
    bottomWidth = sanitizeScrollbarWidth(bottomWidth);
    widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };
    if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') {
        widths.left = leftRightWidth;
    }
    else {
        widths.right = leftRightWidth;
    }
    return widths;
}
exports.getScrollbarWidths = getScrollbarWidths;
// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
    width = Math.max(0, width); // no negatives
    width = Math.round(width);
    return width;
}
// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
var _isLeftRtlScrollbars = null;
function getIsLeftRtlScrollbars() {
    if (_isLeftRtlScrollbars === null) {
        _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
    }
    return _isLeftRtlScrollbars;
}
function computeIsLeftRtlScrollbars() {
    var el = $('<div><div/></div>')
        .css({
        position: 'absolute',
        top: -1000,
        left: 0,
        border: 0,
        padding: 0,
        overflow: 'scroll',
        direction: 'rtl'
    })
        .appendTo('body');
    var innerEl = el.children();
    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
    el.remove();
    return res;
}
// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
    return parseFloat(el.css(prop)) || 0;
}
/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
    return ev.which == 1 && !ev.ctrlKey;
}
exports.isPrimaryMouseButton = isPrimaryMouseButton;
function getEvX(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageX;
    }
    return ev.pageX;
}
exports.getEvX = getEvX;
function getEvY(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageY;
    }
    return ev.pageY;
}
exports.getEvY = getEvY;
function getEvIsTouch(ev) {
    return /^touch/.test(ev.type);
}
exports.getEvIsTouch = getEvIsTouch;
function preventSelection(el) {
    el.addClass('fc-unselectable')
        .on('selectstart', preventDefault);
}
exports.preventSelection = preventSelection;
function allowSelection(el) {
    el.removeClass('fc-unselectable')
        .off('selectstart', preventDefault);
}
exports.allowSelection = allowSelection;
// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
    ev.preventDefault();
}
exports.preventDefault = preventDefault;
/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/
// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
    var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
    };
    if (res.left < res.right && res.top < res.bottom) {
        return res;
    }
    return false;
}
exports.intersectRects = intersectRects;
// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
    return {
        left: Math.min(Math.max(point.left, rect.left), rect.right),
        top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
}
exports.constrainPoint = constrainPoint;
// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
    return {
        left: (rect.left + rect.right) / 2,
        top: (rect.top + rect.bottom) / 2
    };
}
exports.getRectCenter = getRectCenter;
// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
    return {
        left: point1.left - point2.left,
        top: point1.top - point2.top
    };
}
exports.diffPoints = diffPoints;
/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/
function parseFieldSpecs(input) {
    var specs = [];
    var tokens = [];
    var i, token;
    if (typeof input === 'string') {
        tokens = input.split(/\s*,\s*/);
    }
    else if (typeof input === 'function') {
        tokens = [input];
    }
    else if ($.isArray(input)) {
        tokens = input;
    }
    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (typeof token === 'string') {
            specs.push(token.charAt(0) == '-' ?
                { field: token.substring(1), order: -1 } :
                { field: token, order: 1 });
        }
        else if (typeof token === 'function') {
            specs.push({ func: token });
        }
    }
    return specs;
}
exports.parseFieldSpecs = parseFieldSpecs;
function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
    var i;
    var cmp;
    for (i = 0; i < fieldSpecs.length; i++) {
        cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
        if (cmp) {
            return cmp;
        }
    }
    return 0;
}
exports.compareByFieldSpecs = compareByFieldSpecs;
function compareByFieldSpec(obj1, obj2, fieldSpec) {
    if (fieldSpec.func) {
        return fieldSpec.func(obj1, obj2);
    }
    return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
        (fieldSpec.order || 1);
}
exports.compareByFieldSpec = compareByFieldSpec;
function flexibleCompare(a, b) {
    if (!a && !b) {
        return 0;
    }
    if (b == null) {
        return -1;
    }
    if (a == null) {
        return 1;
    }
    if ($.type(a) === 'string' || $.type(b) === 'string') {
        return String(a).localeCompare(String(b));
    }
    return a - b;
}
exports.flexibleCompare = flexibleCompare;
/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/
exports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
exports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending
// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
        ms: a.time() - b.time() // time-of-day from day start. disregards timezone
    });
}
exports.diffDayTime = diffDayTime;
// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
    });
}
exports.diffDay = diffDay;
// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true
    unit);
}
exports.diffByUnit = diffByUnit;
// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
    var i, unit;
    var val;
    for (i = 0; i < exports.unitsDesc.length; i++) {
        unit = exports.unitsDesc[i];
        val = computeRangeAs(unit, start, end);
        if (val >= 1 && isInt(val)) {
            break;
        }
    }
    return unit; // will be "milliseconds" if nothing else matches
}
exports.computeGreatestUnit = computeGreatestUnit;
// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
    var unit = computeGreatestUnit(duration);
    // prevent days:7 from being interpreted as a week
    if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
        unit = 'day';
    }
    return unit;
}
exports.computeDurationGreatestUnit = computeDurationGreatestUnit;
// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {
    if (end != null) {
        return end.diff(start, unit, true);
    }
    else if (moment.isDuration(start)) {
        return start.as(unit);
    }
    else {
        return start.end.diff(start.start, unit, true);
    }
}
// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
    var months;
    if (durationHasTime(dur)) {
        return (end - start) / dur;
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return end.diff(start, 'months', true) / months;
    }
    return end.diff(start, 'days', true) / dur.asDays();
}
exports.divideRangeByDuration = divideRangeByDuration;
// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
    var months1, months2;
    if (durationHasTime(dur1) || durationHasTime(dur2)) {
        return dur1 / dur2;
    }
    months1 = dur1.asMonths();
    months2 = dur2.asMonths();
    if (Math.abs(months1) >= 1 && isInt(months1) &&
        Math.abs(months2) >= 1 && isInt(months2)) {
        return months1 / months2;
    }
    return dur1.asDays() / dur2.asDays();
}
exports.divideDurationByDuration = divideDurationByDuration;
// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
    var months;
    if (durationHasTime(dur)) {
        return moment.duration(dur * n);
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return moment.duration({ months: months * n });
    }
    return moment.duration({ days: dur.asDays() * n });
}
exports.multiplyDuration = multiplyDuration;
// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}
exports.durationHasTime = durationHasTime;
function isNativeDate(input) {
    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}
exports.isNativeDate = isNativeDate;
// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
    return typeof str === 'string' &&
        /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}
exports.isTimeString = isTimeString;
/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.log) {
        return console.log.apply(console, args);
    }
}
exports.log = log;
function warn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.warn) {
        return console.warn.apply(console, args);
    }
    else {
        return log.apply(null, args);
    }
}
exports.warn = warn;
/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/
var hasOwnPropMethod = {}.hasOwnProperty;
// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
    var dest = {};
    var i, name;
    var complexObjs;
    var j, val;
    var props;
    if (complexProps) {
        for (i = 0; i < complexProps.length; i++) {
            name = complexProps[i];
            complexObjs = [];
            // collect the trailing object values, stopping when a non-object is discovered
            for (j = propObjs.length - 1; j >= 0; j--) {
                val = propObjs[j][name];
                if (typeof val === 'object') {
                    complexObjs.unshift(val);
                }
                else if (val !== undefined) {
                    dest[name] = val; // if there were no objects, this value will be used
                    break;
                }
            }
            // if the trailing values were objects, use the merged value
            if (complexObjs.length) {
                dest[name] = mergeProps(complexObjs);
            }
        }
    }
    // copy values into the destination, going from last to first
    for (i = propObjs.length - 1; i >= 0; i--) {
        props = propObjs[i];
        for (name in props) {
            if (!(name in dest)) {
                dest[name] = props[name];
            }
        }
    }
    return dest;
}
exports.mergeProps = mergeProps;
function copyOwnProps(src, dest) {
    for (var name in src) {
        if (hasOwnProp(src, name)) {
            dest[name] = src[name];
        }
    }
}
exports.copyOwnProps = copyOwnProps;
function hasOwnProp(obj, name) {
    return hasOwnPropMethod.call(obj, name);
}
exports.hasOwnProp = hasOwnProp;
function applyAll(functions, thisObj, args) {
    if ($.isFunction(functions)) {
        functions = [functions];
    }
    if (functions) {
        var i;
        var ret;
        for (i = 0; i < functions.length; i++) {
            ret = functions[i].apply(thisObj, args) || ret;
        }
        return ret;
    }
}
exports.applyAll = applyAll;
function removeMatching(array, testFunc) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (testFunc(array[i])) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeMatching = removeMatching;
function removeExact(array, exactVal) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (array[i] === exactVal) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeExact = removeExact;
function isArraysEqual(a0, a1) {
    var len = a0.length;
    var i;
    if (len == null || len !== a1.length) {
        return false;
    }
    for (i = 0; i < len; i++) {
        if (a0[i] !== a1[i]) {
            return false;
        }
    }
    return true;
}
exports.isArraysEqual = isArraysEqual;
function firstDefined() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        if (args[i] !== undefined) {
            return args[i];
        }
    }
}
exports.firstDefined = firstDefined;
function htmlEscape(s) {
    return (s + '').replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/'/g, '&#039;')
        .replace(/"/g, '&quot;')
        .replace(/\n/g, '<br />');
}
exports.htmlEscape = htmlEscape;
function stripHtmlEntities(text) {
    return text.replace(/&.*?;/g, '');
}
exports.stripHtmlEntities = stripHtmlEntities;
// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
    var statements = [];
    $.each(cssProps, function (name, val) {
        if (val != null) {
            statements.push(name + ':' + val);
        }
    });
    return statements.join(';');
}
exports.cssToStr = cssToStr;
// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
    var parts = [];
    $.each(attrs, function (name, val) {
        if (val != null) {
            parts.push(name + '="' + htmlEscape(val) + '"');
        }
    });
    return parts.join(' ');
}
exports.attrsToStr = attrsToStr;
function capitaliseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.capitaliseFirstLetter = capitaliseFirstLetter;
function compareNumbers(a, b) {
    return a - b;
}
exports.compareNumbers = compareNumbers;
function isInt(n) {
    return n % 1 === 0;
}
exports.isInt = isInt;
// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
    var method = obj[methodName];
    return function () {
        return method.apply(obj, arguments);
    };
}
exports.proxy = proxy;
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
    if (immediate === void 0) { immediate = false; }
    var timeout, args, context, timestamp, result;
    var later = function () {
        var last = +new Date() - timestamp;
        if (last < wait) {
            timeout = setTimeout(later, wait - last);
        }
        else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    };
    return function () {
        context = this;
        args = arguments;
        timestamp = +new Date();
        var callNow = immediate && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
}
exports.debounce = debounce;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var moment_ext_1 = __webpack_require__(9);
var UnzonedRange = /** @class */ (function () {
    function UnzonedRange(startInput, endInput) {
        // TODO: move these into footprint.
        // Especially, doesn't make sense for null startMs/endMs.
        this.isStart = true;
        this.isEnd = true;
        if (moment.isMoment(startInput)) {
            startInput = startInput.clone().stripZone();
        }
        if (moment.isMoment(endInput)) {
            endInput = endInput.clone().stripZone();
        }
        if (startInput) {
            this.startMs = startInput.valueOf();
        }
        if (endInput) {
            this.endMs = endInput.valueOf();
        }
    }
    UnzonedRange.prototype.intersect = function (otherRange) {
        var startMs = this.startMs;
        var endMs = this.endMs;
        var newRange = null;
        if (otherRange.startMs != null) {
            if (startMs == null) {
                startMs = otherRange.startMs;
            }
            else {
                startMs = Math.max(startMs, otherRange.startMs);
            }
        }
        if (otherRange.endMs != null) {
            if (endMs == null) {
                endMs = otherRange.endMs;
            }
            else {
                endMs = Math.min(endMs, otherRange.endMs);
            }
        }
        if (startMs == null || endMs == null || startMs < endMs) {
            newRange = new UnzonedRange(startMs, endMs);
            newRange.isStart = this.isStart && startMs === this.startMs;
            newRange.isEnd = this.isEnd && endMs === this.endMs;
        }
        return newRange;
    };
    UnzonedRange.prototype.intersectsWith = function (otherRange) {
        return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&
            (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);
    };
    UnzonedRange.prototype.containsRange = function (innerRange) {
        return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&
            (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));
    };
    // `date` can be a moment, a Date, or a millisecond time.
    UnzonedRange.prototype.containsDate = function (date) {
        var ms = date.valueOf();
        return (this.startMs == null || ms >= this.startMs) &&
            (this.endMs == null || ms < this.endMs);
    };
    // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).
    // `date` can be a moment, a Date, or a millisecond time.
    // Returns a MS-time.
    UnzonedRange.prototype.constrainDate = function (date) {
        var ms = date.valueOf();
        if (this.startMs != null && ms < this.startMs) {
            ms = this.startMs;
        }
        if (this.endMs != null && ms >= this.endMs) {
            ms = this.endMs - 1;
        }
        return ms;
    };
    UnzonedRange.prototype.equals = function (otherRange) {
        return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;
    };
    UnzonedRange.prototype.clone = function () {
        var range = new UnzonedRange(this.startMs, this.endMs);
        range.isStart = this.isStart;
        range.isEnd = this.isEnd;
        return range;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getStart = function () {
        if (this.startMs != null) {
            return moment_ext_1.default.utc(this.startMs).stripZone();
        }
        return null;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getEnd = function () {
        if (this.endMs != null) {
            return moment_ext_1.default.utc(this.endMs).stripZone();
        }
        return null;
    };
    UnzonedRange.prototype.as = function (unit) {
        return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);
    };
    /*
    SIDEEFFECT: will mutate eventRanges.
    Will return a new array result.
    Only works for non-open-ended ranges.
    */
    UnzonedRange.invertRanges = function (ranges, constraintRange) {
        var invertedRanges = [];
        var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range
        var i;
        var dateRange;
        // ranges need to be in order. required for our date-walking algorithm
        ranges.sort(compareUnzonedRanges);
        for (i = 0; i < ranges.length; i++) {
            dateRange = ranges[i];
            // add the span of time before the event (if there is any)
            if (dateRange.startMs > startMs) {
                invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));
            }
            if (dateRange.endMs > startMs) {
                startMs = dateRange.endMs;
            }
        }
        // add the span of time after the last event (if there is any)
        if (startMs < constraintRange.endMs) {
            invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));
        }
        return invertedRanges;
    };
    return UnzonedRange;
}());
exports.default = UnzonedRange;
/*
Only works for non-open-ended ranges.
*/
function compareUnzonedRanges(range1, range2) {
    return range1.startMs - range2.startMs; // earlier ranges go first
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var ParsableModelMixin_1 = __webpack_require__(50);
var Class_1 = __webpack_require__(21);
var EventDefParser_1 = __webpack_require__(33);
var EventSource = /** @class */ (function (_super) {
    tslib_1.__extends(EventSource, _super);
    // can we do away with calendar? at least for the abstract?
    // useful for buildEventDef
    function EventSource(calendar) {
        var _this = _super.call(this) || this;
        _this.calendar = calendar;
        _this.className = [];
        _this.uid = String(EventSource.uuid++);
        return _this;
    }
    EventSource.prototype.fetch = function (start, end, timezone) {
        // subclasses must implement. must return a promise.
    };
    EventSource.prototype.removeEventDefsById = function (eventDefId) {
        // optional for subclasses to implement
    };
    EventSource.prototype.removeAllEventDefs = function () {
        // optional for subclasses to implement
    };
    /*
    For compairing/matching
    */
    EventSource.prototype.getPrimitive = function (otherSource) {
        // subclasses must implement
    };
    EventSource.prototype.parseEventDefs = function (rawEventDefs) {
        var i;
        var eventDef;
        var eventDefs = [];
        for (i = 0; i < rawEventDefs.length; i++) {
            eventDef = this.parseEventDef(rawEventDefs[i]);
            if (eventDef) {
                eventDefs.push(eventDef);
            }
        }
        return eventDefs;
    };
    EventSource.prototype.parseEventDef = function (rawInput) {
        var calendarTransform = this.calendar.opt('eventDataTransform');
        var sourceTransform = this.eventDataTransform;
        if (calendarTransform) {
            rawInput = calendarTransform(rawInput);
        }
        if (sourceTransform) {
            rawInput = sourceTransform(rawInput);
        }
        return EventDefParser_1.default.parse(rawInput, this);
    };
    EventSource.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventSource.normalizeId(rawProps.id);
        }
        // TODO: converge with EventDef
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        else if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    /*
    rawInput can be any data type!
    */
    EventSource.parse = function (rawInput, calendar) {
        var source = new this(calendar);
        if (typeof rawInput === 'object') {
            if (source.applyProps(rawInput)) {
                return source;
            }
        }
        return false;
    };
    EventSource.normalizeId = function (id) {
        if (id) {
            return String(id);
        }
        return null;
    };
    EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    // IDs
    // -----------------------------------------------------------------------------------------------------------------
    // TODO: converge with EventDef
    EventSource.uuid = 0;
    return EventSource;
}(Class_1.default));
exports.default = EventSource;
ParsableModelMixin_1.default.mixInto(EventSource);
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
EventSource.defineStandardProps({
    // manually process...
    id: false,
    className: false,
    // automatically transfer...
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    rendering: true,
    overlap: true,
    constraint: true,
    allDayDefault: true,
    eventDataTransform: true
});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.

USAGE:
    import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'
in class:
    listenTo: ListenerInterface['listenTo']
    stopListeningTo: ListenerInterface['stopListeningTo']
after class:
    ListenerMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var Mixin_1 = __webpack_require__(12);
var guid = 0;
var ListenerMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ListenerMixin, _super);
    function ListenerMixin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listenerId = null;
        return _this;
    }
    /*
    Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
    The `callback` will be called with the `this` context of the object that .listenTo is being called on.
    Can be called:
        .listenTo(other, eventName, callback)
    OR
        .listenTo(other, {
            eventName1: callback1,
            eventName2: callback2
        })
    */
    ListenerMixin.prototype.listenTo = function (other, arg, callback) {
        if (typeof arg === 'object') {
            for (var eventName in arg) {
                if (arg.hasOwnProperty(eventName)) {
                    this.listenTo(other, eventName, arg[eventName]);
                }
            }
        }
        else if (typeof arg === 'string') {
            other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
            $.proxy(callback, this) // always use `this` context
            // the usually-undesired jQuery guid behavior doesn't matter,
            // because we always unbind via namespace
            );
        }
    };
    /*
    Causes the current object to stop listening to events on the `other` object.
    `eventName` is optional. If omitted, will stop listening to ALL events on `other`.
    */
    ListenerMixin.prototype.stopListeningTo = function (other, eventName) {
        other.off((eventName || '') + '.' + this.getListenerNamespace());
    };
    /*
    Returns a string, unique to this object, to be used for event namespacing
    */
    ListenerMixin.prototype.getListenerNamespace = function () {
        if (this.listenerId == null) {
            this.listenerId = guid++;
        }
        return '_listener' + this.listenerId;
    };
    return ListenerMixin;
}(Mixin_1.default));
exports.default = ListenerMixin;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    version: "<%= version %>",
    // When introducing internal API incompatibilities (where fullcalendar plugins would break),
    // the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
    // and the below integer should be incremented.
    internalApiVersion: 12,
    // for GlobalEmitter
    touchMouseIgnoreWait: 500,
    // for ExternalDropping
    // Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
    // A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
    dataAttrPrefix: '',
    views: {},
    locales: {}
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
    import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
in class:
    on: EmitterInterface['on']
    one: EmitterInterface['one']
    off: EmitterInterface['off']
    trigger: EmitterInterface['trigger']
    triggerWith: EmitterInterface['triggerWith']
    hasHandlers: EmitterInterface['hasHandlers']
after class:
    EmitterMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var Mixin_1 = __webpack_require__(12);
var EmitterMixin = /** @class */ (function (_super) {
    tslib_1.__extends(EmitterMixin, _super);
    function EmitterMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // jQuery-ification via $(this) allows a non-DOM object to have
    // the same event handling capabilities (including namespaces).
    EmitterMixin.prototype.on = function (types, handler) {
        $(this).on(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype.one = function (types, handler) {
        $(this).one(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype._prepareIntercept = function (handler) {
        // handlers are always called with an "event" object as their first param.
        // sneak the `this` context and arguments into the extra parameter object
        // and forward them on to the original handler.
        var intercept = function (ev, extra) {
            return handler.apply(extra.context || this, extra.args || []);
        };
        // mimick jQuery's internal "proxy" system (risky, I know)
        // causing all functions with the same .guid to appear to be the same.
        // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
        // this is needed for calling .off with the original non-intercept handler.
        if (!handler.guid) {
            handler.guid = $.guid++;
        }
        intercept.guid = handler.guid;
        return intercept;
    };
    EmitterMixin.prototype.off = function (types, handler) {
        $(this).off(types, handler);
        return this; // for chaining
    };
    EmitterMixin.prototype.trigger = function (types) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // pass in "extra" info to the intercept
        $(this).triggerHandler(types, { args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.triggerWith = function (types, context, args) {
        // `triggerHandler` is less reliant on the DOM compared to `trigger`.
        // pass in "extra" info to the intercept.
        $(this).triggerHandler(types, { context: context, args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.hasHandlers = function (type) {
        var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/
        return hash && hash[type] && hash[type].length > 0;
    };
    return EmitterMixin;
}(Mixin_1.default));
exports.default = EmitterMixin;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
/*
GENERAL NOTE on moments throughout the *entire rest* of the codebase:
All moments are assumed to be ambiguously-zoned unless otherwise noted,
with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
*/
var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
exports.newMomentProto = newMomentProto;
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
exports.oldMomentProto = oldMomentProto;
// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');
/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}
exports.oldMomentFormat = oldMomentFormat;
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
var momentExt = function () {
    return makeMoment(arguments);
};
exports.default = momentExt;
// Sames as momentExt, but forces the resulting moment to be in the UTC timezone.
momentExt.utc = function () {
    var mom = makeMoment(arguments, true);
    // Force it into UTC because makeMoment doesn't guarantee it
    // (if given a pre-existing moment for example)
    if (mom.hasTime()) {
        mom.utc();
    }
    return mom;
};
// Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
momentExt.parseZone = function () {
    return makeMoment(arguments, true, true);
};
// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
    if (parseAsUTC === void 0) { parseAsUTC = false; }
    if (parseZone === void 0) { parseZone = false; }
    var input = args[0];
    var isSingleString = args.length == 1 && typeof input === 'string';
    var isAmbigTime;
    var isAmbigZone;
    var ambigMatch;
    var mom;
    if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {
        mom = moment.apply(null, args);
    }
    else {
        isAmbigTime = false;
        isAmbigZone = false;
        if (isSingleString) {
            if (ambigDateOfMonthRegex.test(input)) {
                // accept strings like '2014-05', but convert to the first of the month
                input += '-01';
                args = [input]; // for when we pass it on to moment's constructor
                isAmbigTime = true;
                isAmbigZone = true;
            }
            else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
                isAmbigTime = !ambigMatch[5]; // no time part?
                isAmbigZone = true;
            }
        }
        else if ($.isArray(input)) {
            // arrays have no timezone information, so assume ambiguous zone
            isAmbigZone = true;
        }
        // otherwise, probably a string with a format
        if (parseAsUTC || isAmbigTime) {
            mom = moment.utc.apply(moment, args);
        }
        else {
            mom = moment.apply(null, args);
        }
        if (isAmbigTime) {
            mom._ambigTime = true;
            mom._ambigZone = true; // ambiguous time always means ambiguous zone
        }
        else if (parseZone) {
            if (isAmbigZone) {
                mom._ambigZone = true;
            }
            else if (isSingleString) {
                mom.utcOffset(input); // if not a valid zone, will assign UTC
            }
        }
    }
    mom._fullCalendar = true; // flag for extended functionality
    return mom;
}
// Week Number
// -------------------------------------------------------------------------------------------------
// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function (input) {
    var weekCalc = this._locale._fullCalendar_weekCalc;
    if (input == null && typeof weekCalc === 'function') {
        return weekCalc(this);
    }
    else if (weekCalc === 'ISO') {
        return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
    }
    return oldMomentProto.week.apply(this, arguments); // local getter/setter
};
// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function (time) {
    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
    if (!this._fullCalendar) {
        return oldMomentProto.time.apply(this, arguments);
    }
    if (time == null) {
        return moment.duration({
            hours: this.hours(),
            minutes: this.minutes(),
            seconds: this.seconds(),
            milliseconds: this.milliseconds()
        });
    }
    else {
        this._ambigTime = false; // mark that the moment now has a time
        if (!moment.isDuration(time) && !moment.isMoment(time)) {
            time = moment.duration(time);
        }
        // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
        // Only for Duration times, not Moment times.
        var dayHours = 0;
        if (moment.isDuration(time)) {
            dayHours = Math.floor(time.asDays()) * 24;
        }
        // We need to set the individual fields.
        // Can't use startOf('day') then add duration. In case of DST at start of day.
        return this.hours(dayHours + time.hours())
            .minutes(time.minutes())
            .seconds(time.seconds())
            .milliseconds(time.milliseconds());
    }
};
// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function () {
    if (!this._ambigTime) {
        this.utc(true); // keepLocalTime=true (for keeping *date* value)
        // set time to zero
        this.set({
            hours: 0,
            minutes: 0,
            seconds: 0,
            ms: 0
        });
        // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears all ambig flags.
        this._ambigTime = true;
        this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
    }
    return this; // for chaining
};
// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function () {
    return !this._ambigTime;
};
// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function () {
    var wasAmbigTime;
    if (!this._ambigZone) {
        wasAmbigTime = this._ambigTime;
        this.utc(true); // keepLocalTime=true (for keeping date and time values)
        // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
        this._ambigTime = wasAmbigTime || false;
        // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears the ambig flags.
        this._ambigZone = true;
    }
    return this; // for chaining
};
// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function () {
    return !this._ambigZone;
};
// implicitly marks a zone
newMomentProto.local = function (keepLocalTime) {
    // for when converting from ambiguously-zoned to local,
    // keep the time values when converting from UTC -> local
    oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this; // for chaining
};
// implicitly marks a zone
newMomentProto.utc = function (keepLocalTime) {
    oldMomentProto.utc.call(this, keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this;
};
// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function (tzo) {
    if (tzo != null) {
        // these assignments needs to happen before the original zone method is called.
        // I forget why, something to do with a browser crash.
        this._ambigTime = false;
        this._ambigZone = false;
    }
    return oldMomentProto.utcOffset.apply(this, arguments);
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
/*
Meant to be immutable
*/
var ComponentFootprint = /** @class */ (function () {
    function ComponentFootprint(unzonedRange, isAllDay) {
        this.isAllDay = false; // component can choose to ignore this
        this.unzonedRange = unzonedRange;
        this.isAllDay = isAllDay;
    }
    /*
    Only works for non-open-ended ranges.
    */
    ComponentFootprint.prototype.toLegacy = function (calendar) {
        return {
            start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),
            end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)
        };
    };
    return ComponentFootprint;
}());
exports.default = ComponentFootprint;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var EventDef_1 = __webpack_require__(22);
var EventInstance_1 = __webpack_require__(51);
var EventDateProfile_1 = __webpack_require__(15);
var SingleEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(SingleEventDef, _super);
    function SingleEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Will receive start/end params, but will be ignored.
    */
    SingleEventDef.prototype.buildInstances = function () {
        return [this.buildInstance()];
    };
    SingleEventDef.prototype.buildInstance = function () {
        return new EventInstance_1.default(this, // definition
        this.dateProfile);
    };
    SingleEventDef.prototype.isAllDay = function () {
        return this.dateProfile.isAllDay();
    };
    SingleEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        def.dateProfile = this.dateProfile;
        return def;
    };
    SingleEventDef.prototype.rezone = function () {
        var calendar = this.source.calendar;
        var dateProfile = this.dateProfile;
        this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);
    };
    /*
    NOTE: if super-method fails, should still attempt to apply
    */
    SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure
        if (dateProfile) {
            this.dateProfile = dateProfile;
            // make sure `date` shows up in the legacy event objects as-is
            if (rawProps.date != null) {
                this.miscProps.date = rawProps.date;
            }
            return superSuccess;
        }
        else {
            return false;
        }
    };
    return SingleEventDef;
}(EventDef_1.default));
exports.default = SingleEventDef;
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
SingleEventDef.defineStandardProps({
    start: false,
    date: false,
    end: false,
    allDay: false
});


/***/ }),
/* 12 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Mixin = /** @class */ (function () {
    function Mixin() {
    }
    Mixin.mixInto = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            if (!destClass.prototype[name]) {
                destClass.prototype[name] = _this.prototype[name];
            }
        });
    };
    /*
    will override existing methods
    */
    Mixin.mixOver = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            destClass.prototype[name] = _this.prototype[name];
        });
    };
    return Mixin;
}());
exports.default = Mixin;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Interaction = /** @class */ (function () {
    function Interaction(component) {
        this.view = component._getView();
        this.component = component;
    }
    Interaction.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    Interaction.prototype.end = function () {
        // subclasses can implement
    };
    return Interaction;
}());
exports.default = Interaction;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var namespace_hooks_1 = __webpack_require__(7);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var globalEmitter = null;
var neededCount = 0;
/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/
var GlobalEmitter = /** @class */ (function () {
    function GlobalEmitter() {
        this.isTouching = false;
        this.mouseIgnoreDepth = 0;
    }
    GlobalEmitter.prototype.bind = function () {
        var _this = this;
        this.listenTo($(document), {
            touchstart: this.handleTouchStart,
            touchcancel: this.handleTouchCancel,
            touchend: this.handleTouchEnd,
            mousedown: this.handleMouseDown,
            mousemove: this.handleMouseMove,
            mouseup: this.handleMouseUp,
            click: this.handleClick,
            selectstart: this.handleSelectStart,
            contextmenu: this.handleContextMenu
        });
        // because we need to call preventDefault
        // because https://www.chromestatus.com/features/5093566007214080
        // TODO: investigate performance because this is a global handler
        window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {
            _this.handleTouchMove($.Event(ev));
        }, { passive: false } // allows preventDefault()
        );
        // attach a handler to get called when ANY scroll action happens on the page.
        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
        // http://stackoverflow.com/a/32954565/96342
        window.addEventListener('scroll', this.handleScrollProxy = function (ev) {
            _this.handleScroll($.Event(ev));
        }, true // useCapture
        );
    };
    GlobalEmitter.prototype.unbind = function () {
        this.stopListeningTo($(document));
        window.removeEventListener('touchmove', this.handleTouchMoveProxy);
        window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture
        );
    };
    // Touch Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleTouchStart = function (ev) {
        // if a previous touch interaction never ended with a touchend, then implicitly end it,
        // but since a new touch interaction is about to begin, don't start the mouse ignore period.
        this.stopTouch(ev, true); // skipMouseIgnore=true
        this.isTouching = true;
        this.trigger('touchstart', ev);
    };
    GlobalEmitter.prototype.handleTouchMove = function (ev) {
        if (this.isTouching) {
            this.trigger('touchmove', ev);
        }
    };
    GlobalEmitter.prototype.handleTouchCancel = function (ev) {
        if (this.isTouching) {
            this.trigger('touchcancel', ev);
            // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
            // If touchend fires later, it won't have any effect b/c isTouching will be false.
            this.stopTouch(ev);
        }
    };
    GlobalEmitter.prototype.handleTouchEnd = function (ev) {
        this.stopTouch(ev);
    };
    // Mouse Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleMouseDown = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousedown', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseMove = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousemove', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseUp = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mouseup', ev);
        }
    };
    GlobalEmitter.prototype.handleClick = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('click', ev);
        }
    };
    // Misc Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleSelectStart = function (ev) {
        this.trigger('selectstart', ev);
    };
    GlobalEmitter.prototype.handleContextMenu = function (ev) {
        this.trigger('contextmenu', ev);
    };
    GlobalEmitter.prototype.handleScroll = function (ev) {
        this.trigger('scroll', ev);
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {
        if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }
        if (this.isTouching) {
            this.isTouching = false;
            this.trigger('touchend', ev);
            if (!skipMouseIgnore) {
                this.startTouchMouseIgnore();
            }
        }
    };
    GlobalEmitter.prototype.startTouchMouseIgnore = function () {
        var _this = this;
        var wait = namespace_hooks_1.default.touchMouseIgnoreWait;
        if (wait) {
            this.mouseIgnoreDepth++;
            setTimeout(function () {
                _this.mouseIgnoreDepth--;
            }, wait);
        }
    };
    GlobalEmitter.prototype.shouldIgnoreMouse = function () {
        return this.isTouching || Boolean(this.mouseIgnoreDepth);
    };
    // Singleton
    // -----------------------------------------------------------------------------------------------------------------
    // gets the singleton
    GlobalEmitter.get = function () {
        if (!globalEmitter) {
            globalEmitter = new GlobalEmitter();
            globalEmitter.bind();
        }
        return globalEmitter;
    };
    // called when an object knows it will need a GlobalEmitter in the near future.
    GlobalEmitter.needed = function () {
        GlobalEmitter.get(); // ensures globalEmitter
        neededCount++;
    };
    // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
    GlobalEmitter.unneeded = function () {
        neededCount--;
        if (!neededCount) {
            globalEmitter.unbind();
            globalEmitter = null;
        }
    };
    return GlobalEmitter;
}());
exports.default = GlobalEmitter;
ListenerMixin_1.default.mixInto(GlobalEmitter);
EmitterMixin_1.default.mixInto(GlobalEmitter);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(4);
/*
Meant to be immutable
*/
var EventDateProfile = /** @class */ (function () {
    function EventDateProfile(start, end, calendar) {
        this.start = start;
        this.end = end || null;
        this.unzonedRange = this.buildUnzonedRange(calendar);
    }
    EventDateProfile.prototype.isAllDay = function () {
        return !(this.start.hasTime() || (this.end && this.end.hasTime()));
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.buildUnzonedRange = function (calendar) {
        var startMs = this.start.clone().stripZone().valueOf();
        var endMs = this.getEnd(calendar).stripZone().valueOf();
        return new UnzonedRange_1.default(startMs, endMs);
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.getEnd = function (calendar) {
        return this.end ?
            this.end.clone() :
            // derive the end from the start and allDay. compute allDay if necessary
            calendar.getDefaultEventEnd(this.isAllDay(), this.start);
    };
    EventDateProfile.isStandardProp = function (propName) {
        return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';
    };
    /*
    Needs an EventSource object
    */
    EventDateProfile.parse = function (rawProps, source) {
        var startInput = rawProps.start || rawProps.date;
        var endInput = rawProps.end;
        if (!startInput) {
            return false;
        }
        var calendar = source.calendar;
        var start = calendar.moment(startInput);
        var end = endInput ? calendar.moment(endInput) : null;
        var forcedAllDay = rawProps.allDay;
        var forceEventDuration = calendar.opt('forceEventDuration');
        if (!start.isValid()) {
            return false;
        }
        if (end && (!end.isValid() || !end.isAfter(start))) {
            end = null;
        }
        if (forcedAllDay == null) {
            forcedAllDay = source.allDayDefault;
            if (forcedAllDay == null) {
                forcedAllDay = calendar.opt('allDayDefault');
            }
        }
        if (forcedAllDay === true) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else if (forcedAllDay === false) {
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        if (!end && forceEventDuration) {
            end = calendar.getDefaultEventEnd(!start.hasTime(), start);
        }
        return new EventDateProfile(start, end, calendar);
    };
    return EventDateProfile;
}());
exports.default = EventDateProfile;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var PromiseStub = {
    construct: function (executor) {
        var deferred = $.Deferred();
        var promise = deferred.promise();
        if (typeof executor === 'function') {
            executor(function (val) {
                deferred.resolve(val);
                attachImmediatelyResolvingThen(promise, val);
            }, function () {
                deferred.reject();
                attachImmediatelyRejectingThen(promise);
            });
        }
        return promise;
    },
    resolve: function (val) {
        var deferred = $.Deferred().resolve(val);
        var promise = deferred.promise();
        attachImmediatelyResolvingThen(promise, val);
        return promise;
    },
    reject: function () {
        var deferred = $.Deferred().reject();
        var promise = deferred.promise();
        attachImmediatelyRejectingThen(promise);
        return promise;
    }
};
exports.default = PromiseStub;
function attachImmediatelyResolvingThen(promise, val) {
    promise.then = function (onResolve) {
        if (typeof onResolve === 'function') {
            return PromiseStub.resolve(onResolve(val));
        }
        return promise;
    };
}
function attachImmediatelyRejectingThen(promise) {
    promise.then = function (onResolve, onReject) {
        if (typeof onReject === 'function') {
            onReject();
        }
        return promise;
    };
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(4);
var util_1 = __webpack_require__(23);
var EventRange_1 = __webpack_require__(53);
/*
It's expected that there will be at least one EventInstance,
OR that an explicitEventDef is assigned.
*/
var EventInstanceGroup = /** @class */ (function () {
    function EventInstanceGroup(eventInstances) {
        this.eventInstances = eventInstances || [];
    }
    EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {
        if (constraintRange) {
            return this.sliceNormalRenderRanges(constraintRange);
        }
        else {
            return this.eventInstances.map(util_1.eventInstanceToEventRange);
        }
    };
    EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {
        if (this.isInverse()) {
            return this.sliceInverseRenderRanges(constraintRange);
        }
        else {
            return this.sliceNormalRenderRanges(constraintRange);
        }
    };
    EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {
        var eventInstances = this.eventInstances;
        var i, eventInstance;
        var slicedRange;
        var slicedEventRanges = [];
        for (i = 0; i < eventInstances.length; i++) {
            eventInstance = eventInstances[i];
            slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);
            if (slicedRange) {
                slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));
            }
        }
        return slicedEventRanges;
    };
    EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {
        var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);
        var ownerDef = this.getEventDef();
        unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);
        return unzonedRanges.map(function (unzonedRange) {
            return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance
        });
    };
    EventInstanceGroup.prototype.isInverse = function () {
        return this.getEventDef().hasInverseRendering();
    };
    EventInstanceGroup.prototype.getEventDef = function () {
        return this.explicitEventDef || this.eventInstances[0].def;
    };
    return EventInstanceGroup;
}());
exports.default = EventInstanceGroup;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var DragListener_1 = __webpack_require__(39);
/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/
var HitDragListener = /** @class */ (function (_super) {
    tslib_1.__extends(HitDragListener, _super);
    function HitDragListener(component, options) {
        var _this = _super.call(this, options) || this;
        _this.component = component;
        return _this;
    }
    // Called when drag listening starts (but a real drag has not necessarily began).
    // ev might be undefined if dragging was started manually.
    HitDragListener.prototype.handleInteractionStart = function (ev) {
        var subjectEl = this.subjectEl;
        var subjectRect;
        var origPoint;
        var point;
        this.component.hitsNeeded();
        this.computeScrollBounds(); // for autoscroll
        if (ev) {
            origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };
            point = origPoint;
            // constrain the point to bounds of the element being dragged
            if (subjectEl) {
                subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well
                point = util_1.constrainPoint(point, subjectRect);
            }
            this.origHit = this.queryHit(point.left, point.top);
            // treat the center of the subject as the collision point?
            if (subjectEl && this.options.subjectCenter) {
                // only consider the area the subject overlaps the hit. best for large subjects.
                // TODO: skip this if hit didn't supply left/right/top/bottom
                if (this.origHit) {
                    subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||
                        subjectRect; // in case there is no intersection
                }
                point = util_1.getRectCenter(subjectRect);
            }
            this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint
        }
        else {
            this.origHit = null;
            this.coordAdjust = null;
        }
        // call the super-method. do it after origHit has been computed
        _super.prototype.handleInteractionStart.call(this, ev);
    };
    // Called when the actual drag has started
    HitDragListener.prototype.handleDragStart = function (ev) {
        var hit;
        _super.prototype.handleDragStart.call(this, ev);
        // might be different from this.origHit if the min-distance is large
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        // report the initial hit the mouse is over
        // especially important if no min-distance and drag starts immediately
        if (hit) {
            this.handleHitOver(hit);
        }
    };
    // Called when the drag moves
    HitDragListener.prototype.handleDrag = function (dx, dy, ev) {
        var hit;
        _super.prototype.handleDrag.call(this, dx, dy, ev);
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        if (!isHitsEqual(hit, this.hit)) {
            if (this.hit) {
                this.handleHitOut();
            }
            if (hit) {
                this.handleHitOver(hit);
            }
        }
    };
    // Called when dragging has been stopped
    HitDragListener.prototype.handleDragEnd = function (ev) {
        this.handleHitDone();
        _super.prototype.handleDragEnd.call(this, ev);
    };
    // Called when a the mouse has just moved over a new hit
    HitDragListener.prototype.handleHitOver = function (hit) {
        var isOrig = isHitsEqual(hit, this.origHit);
        this.hit = hit;
        this.trigger('hitOver', this.hit, isOrig, this.origHit);
    };
    // Called when the mouse has just moved out of a hit
    HitDragListener.prototype.handleHitOut = function () {
        if (this.hit) {
            this.trigger('hitOut', this.hit);
            this.handleHitDone();
            this.hit = null;
        }
    };
    // Called after a hitOut. Also called before a dragStop
    HitDragListener.prototype.handleHitDone = function () {
        if (this.hit) {
            this.trigger('hitDone', this.hit);
        }
    };
    // Called when the interaction ends, whether there was a real drag or not
    HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);
        this.origHit = null;
        this.hit = null;
        this.component.hitsNotNeeded();
    };
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    HitDragListener.prototype.handleScrollEnd = function () {
        _super.prototype.handleScrollEnd.call(this);
        // hits' absolute positions will be in new places after a user's scroll.
        // HACK for recomputing.
        if (this.isDragging) {
            this.component.releaseHits();
            this.component.prepareHits();
        }
    };
    // Gets the hit underneath the coordinates for the given mouse event
    HitDragListener.prototype.queryHit = function (left, top) {
        if (this.coordAdjust) {
            left += this.coordAdjust.left;
            top += this.coordAdjust.top;
        }
        return this.component.queryHit(left, top);
    };
    return HitDragListener;
}(DragListener_1.default));
exports.default = HitDragListener;
// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) {
        return true;
    }
    if (hit0 && hit1) {
        return hit0.component === hit1.component &&
            isHitPropsWithin(hit0, hit1) &&
            isHitPropsWithin(hit1, hit0); // ensures all props are identical
    }
    return false;
}
// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
    for (var propName in subHit) {
        if (!/^(component|left|right|top|bottom)$/.test(propName)) {
            if (subHit[propName] !== superHit[propName]) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(2);
exports.globalDefaults = {
    titleRangeSeparator: ' \u2013 ',
    monthYearFormat: 'MMMM YYYY',
    defaultTimedEventDuration: '02:00:00',
    defaultAllDayEventDuration: { days: 1 },
    forceEventDuration: false,
    nextDayThreshold: '09:00:00',
    // display
    columnHeader: true,
    defaultView: 'month',
    aspectRatio: 1.35,
    header: {
        left: 'title',
        center: '',
        right: 'today prev,next'
    },
    weekends: true,
    weekNumbers: false,
    weekNumberTitle: 'W',
    weekNumberCalculation: 'local',
    //editable: false,
    //nowIndicator: false,
    scrollTime: '06:00:00',
    minTime: '00:00:00',
    maxTime: '24:00:00',
    showNonCurrentDates: true,
    // event ajax
    lazyFetching: true,
    startParam: 'start',
    endParam: 'end',
    timezoneParam: 'timezone',
    timezone: false,
    //allDayDefault: undefined,
    // locale
    locale: null,
    isRTL: false,
    buttonText: {
        prev: "prev",
        next: "next",
        prevYear: "prev year",
        nextYear: "next year",
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day'
    },
    //buttonIcons: null,
    allDayText: 'all-day',
    // allows setting a min-height to the event segment to prevent short events overlapping each other
    agendaEventMinHeight: 0,
    // jquery-ui theming
    theme: false,
    //themeButtonIcons: null,
    //eventResizableFromStart: false,
    dragOpacity: .75,
    dragRevertDuration: 500,
    dragScroll: true,
    //selectable: false,
    unselectAuto: true,
    //selectMinDistance: 0,
    dropAccept: '*',
    eventOrder: 'title',
    //eventRenderWait: null,
    eventLimit: false,
    eventLimitText: 'more',
    eventLimitClick: 'popover',
    dayPopoverFormat: 'LL',
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1000
};
exports.englishDefaults = {
    dayPopoverFormat: 'dddd, MMMM D'
};
exports.rtlDefaults = {
    header: {
        left: 'next,prev today',
        center: '',
        right: 'title'
    },
    buttonIcons: {
        prev: 'right-single-arrow',
        next: 'left-single-arrow',
        prevYear: 'right-double-arrow',
        nextYear: 'left-double-arrow'
    },
    themeButtonIcons: {
        prev: 'circle-triangle-e',
        next: 'circle-triangle-w',
        nextYear: 'seek-prev',
        prevYear: 'seek-next'
    }
};
var complexOptions = [
    'header',
    'footer',
    'buttonText',
    'buttonIcons',
    'themeButtonIcons'
];
// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
    return util_1.mergeProps(optionObjs, complexOptions);
}
exports.mergeOptions = mergeOptions;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var namespace_hooks_1 = __webpack_require__(7);
var options_1 = __webpack_require__(19);
var util_1 = __webpack_require__(2);
var localeOptionHash = namespace_hooks_1.default.locales;
exports.localeOptionHash = localeOptionHash;
// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
function datepickerLocale(localeCode, dpLocaleCode, dpOptions) {
    // get the FullCalendar internal option hash for this locale. create if necessary
    var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});
    // transfer some simple options from datepicker to fc
    fcOptions.isRTL = dpOptions.isRTL;
    fcOptions.weekNumberTitle = dpOptions.weekHeader;
    // compute some more complex options from datepicker
    $.each(dpComputableOptions, function (name, func) {
        fcOptions[name] = func(dpOptions);
    });
    var jqDatePicker = $.datepicker;
    // is jQuery UI Datepicker is on the page?
    if (jqDatePicker) {
        // Register the locale data.
        // FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
        // does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
        // Make an alias so the locale can be referenced either way.
        jqDatePicker.regional[dpLocaleCode] =
            jqDatePicker.regional[localeCode] = // alias
                dpOptions;
        // Alias 'en' to the default locale data. Do this every time.
        jqDatePicker.regional.en = jqDatePicker.regional[''];
        // Set as Datepicker's global defaults.
        jqDatePicker.setDefaults(dpOptions);
    }
}
exports.datepickerLocale = datepickerLocale;
// Sets FullCalendar-specific translations. Will set the locales as the global default.
function locale(localeCode, newFcOptions) {
    var fcOptions;
    var momOptions;
    // get the FullCalendar internal option hash for this locale. create if necessary
    fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});
    // provided new options for this locales? merge them in
    if (newFcOptions) {
        fcOptions = localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);
    }
    // compute locale options that weren't defined.
    // always do this. newFcOptions can be undefined when initializing from i18n file,
    // so no way to tell if this is an initialization or a default-setting.
    momOptions = getMomentLocaleData(localeCode); // will fall back to en
    $.each(momComputableOptions, function (name, func) {
        if (fcOptions[name] == null) {
            fcOptions[name] = func(momOptions, fcOptions);
        }
    });
    // set it as the default locale for FullCalendar
    options_1.globalDefaults.locale = localeCode;
}
exports.locale = locale;
;
// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {
    buttonText: function (dpOptions) {
        return {
            // the translations sometimes wrongly contain HTML entities
            prev: util_1.stripHtmlEntities(dpOptions.prevText),
            next: util_1.stripHtmlEntities(dpOptions.nextText),
            today: util_1.stripHtmlEntities(dpOptions.currentText)
        };
    },
    // Produces format strings like "MMMM YYYY" -> "September 2014"
    monthYearFormat: function (dpOptions) {
        return dpOptions.showMonthAfterYear ?
            'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
            'MMMM YYYY[' + dpOptions.yearSuffix + ']';
    }
};
var momComputableOptions = {
    // Produces format strings like "ddd M/D" -> "Fri 9/15"
    dayOfMonthFormat: function (momOptions, fcOptions) {
        var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"
        // strip the year off the edge, as well as other misc non-whitespace chars
        format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');
        if (fcOptions.isRTL) {
            format += ' ddd'; // for RTL, add day-of-week to end
        }
        else {
            format = 'ddd ' + format; // for LTR, add day-of-week to beginning
        }
        return format;
    },
    // Produces format strings like "h:mma" -> "6:00pm"
    mediumTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
    smallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
    extraSmallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
    },
    // Produces format strings like "ha" / "H" -> "6pm" / "18"
    hourFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '')
            .replace(/(\Wmm)$/, '') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
    noMeridiemTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, ''); // remove trailing AM/PM
    }
};
// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {
    // Produces format strings for results like "Mo 16"
    smallDayDateFormat: function (options) {
        return options.isRTL ?
            'D dd' :
            'dd D';
    },
    // Produces format strings for results like "Wk 5"
    weekFormat: function (options) {
        return options.isRTL ?
            'w[ ' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ' ]w';
    },
    // Produces format strings for results like "Wk5"
    smallWeekFormat: function (options) {
        return options.isRTL ?
            'w[' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ']w';
    }
};
// TODO: make these computable properties in optionsManager
function populateInstanceComputableOptions(options) {
    $.each(instanceComputableOptions, function (name, func) {
        if (options[name] == null) {
            options[name] = func(options);
        }
    });
}
exports.populateInstanceComputableOptions = populateInstanceComputableOptions;
// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
    return moment.localeData(localeCode) || moment.localeData('en');
}
exports.getMomentLocaleData = getMomentLocaleData;
// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
locale('en', options_1.englishDefaults);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
// Class that all other classes will inherit from
var Class = /** @class */ (function () {
    function Class() {
    }
    // Called on a class to create a subclass.
    // LIMITATION: cannot provide a constructor!
    Class.extend = function (members) {
        var SubClass = /** @class */ (function (_super) {
            tslib_1.__extends(SubClass, _super);
            function SubClass() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return SubClass;
        }(this));
        ;
        util_1.copyOwnProps(members, SubClass.prototype);
        return SubClass;
    };
    // Adds new member variables/methods to the class's prototype.
    // Can be called with another class, or a plain object hash containing new members.
    Class.mixin = function (members) {
        util_1.copyOwnProps(members, this.prototype);
    };
    return Class;
}());
exports.default = Class;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var ParsableModelMixin_1 = __webpack_require__(50);
var EventDef = /** @class */ (function () {
    function EventDef(source) {
        this.source = source;
        this.className = [];
        this.miscProps = {};
    }
    EventDef.prototype.clone = function () {
        var copy = new this.constructor(this.source);
        copy.id = this.id;
        copy.rawId = this.rawId;
        copy.uid = this.uid; // not really unique anymore :(
        EventDef.copyVerbatimStandardProps(this, copy);
        copy.className = this.className.slice(); // copy
        copy.miscProps = $.extend({}, this.miscProps);
        return copy;
    };
    EventDef.prototype.hasInverseRendering = function () {
        return this.getRendering() === 'inverse-background';
    };
    EventDef.prototype.hasBgRendering = function () {
        var rendering = this.getRendering();
        return rendering === 'inverse-background' || rendering === 'background';
    };
    EventDef.prototype.getRendering = function () {
        if (this.rendering != null) {
            return this.rendering;
        }
        return this.source.rendering;
    };
    EventDef.prototype.getConstraint = function () {
        if (this.constraint != null) {
            return this.constraint;
        }
        if (this.source.constraint != null) {
            return this.source.constraint;
        }
        return this.source.calendar.opt('eventConstraint'); // what about View option?
    };
    EventDef.prototype.getOverlap = function () {
        if (this.overlap != null) {
            return this.overlap;
        }
        if (this.source.overlap != null) {
            return this.source.overlap;
        }
        return this.source.calendar.opt('eventOverlap'); // what about View option?
    };
    EventDef.prototype.isStartExplicitlyEditable = function () {
        if (this.startEditable != null) {
            return this.startEditable;
        }
        return this.source.startEditable;
    };
    EventDef.prototype.isDurationExplicitlyEditable = function () {
        if (this.durationEditable != null) {
            return this.durationEditable;
        }
        return this.source.durationEditable;
    };
    EventDef.prototype.isExplicitlyEditable = function () {
        if (this.editable != null) {
            return this.editable;
        }
        return this.source.editable;
    };
    EventDef.prototype.toLegacy = function () {
        var obj = $.extend({}, this.miscProps);
        obj._id = this.uid;
        obj.source = this.source;
        obj.className = this.className.slice(); // copy
        obj.allDay = this.isAllDay();
        if (this.rawId != null) {
            obj.id = this.rawId;
        }
        EventDef.copyVerbatimStandardProps(this, obj);
        return obj;
    };
    EventDef.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventDef.normalizeId((this.rawId = rawProps.id));
        }
        else {
            this.id = EventDef.generateId();
        }
        if (rawProps._id != null) {
            this.uid = String(rawProps._id);
        }
        else {
            this.uid = EventDef.generateId();
        }
        // TODO: converge with EventSource
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    EventDef.prototype.applyMiscProps = function (rawProps) {
        $.extend(this.miscProps, rawProps);
    };
    EventDef.parse = function (rawInput, source) {
        var def = new this(source);
        if (def.applyProps(rawInput)) {
            return def;
        }
        return false;
    };
    EventDef.normalizeId = function (id) {
        return String(id);
    };
    EventDef.generateId = function () {
        return '_fc' + (EventDef.uuid++);
    };
    EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    // IDs
    // ---------------------------------------------------------------------------------------------------------------------
    // TODO: converge with EventSource
    EventDef.uuid = 0;
    return EventDef;
}());
exports.default = EventDef;
ParsableModelMixin_1.default.mixInto(EventDef);
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
EventDef.defineStandardProps({
    // not automatically assigned (`false`)
    _id: false,
    id: false,
    className: false,
    source: false,
    // automatically assigned (`true`)
    title: true,
    url: true,
    rendering: true,
    constraint: true,
    overlap: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true
});


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange_1 = __webpack_require__(53);
var EventFootprint_1 = __webpack_require__(24);
var ComponentFootprint_1 = __webpack_require__(10);
function eventDefsToEventInstances(eventDefs, unzonedRange) {
    var eventInstances = [];
    var i;
    for (i = 0; i < eventDefs.length; i++) {
        eventInstances.push.apply(eventInstances, // append
        eventDefs[i].buildInstances(unzonedRange));
    }
    return eventInstances;
}
exports.eventDefsToEventInstances = eventDefsToEventInstances;
function eventInstanceToEventRange(eventInstance) {
    return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);
}
exports.eventInstanceToEventRange = eventInstanceToEventRange;
function eventRangeToEventFootprint(eventRange) {
    return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist
    );
}
exports.eventRangeToEventFootprint = eventRangeToEventFootprint;
function eventInstanceToUnzonedRange(eventInstance) {
    return eventInstance.dateProfile.unzonedRange;
}
exports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;
function eventFootprintToComponentFootprint(eventFootprint) {
    return eventFootprint.componentFootprint;
}
exports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventFootprint = /** @class */ (function () {
    function EventFootprint(componentFootprint, eventDef, eventInstance) {
        this.componentFootprint = componentFootprint;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    EventFootprint.prototype.getEventLegacy = function () {
        return (this.eventInstance || this.eventDef).toLegacy();
    };
    return EventFootprint;
}());
exports.default = EventFootprint;


/***/ }),
/* 25 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    sourceClasses: [],
    registerClass: function (EventSourceClass) {
        this.sourceClasses.unshift(EventSourceClass); // give highest priority
    },
    parse: function (rawInput, calendar) {
        var sourceClasses = this.sourceClasses;
        var i;
        var eventSource;
        for (i = 0; i < sourceClasses.length; i++) {
            eventSource = sourceClasses[i].parse(rawInput, calendar);
            if (eventSource) {
                return eventSource;
            }
        }
    }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(2);
var EventDateProfile_1 = __webpack_require__(15);
var EventDef_1 = __webpack_require__(22);
var EventDefDateMutation_1 = __webpack_require__(35);
var SingleEventDef_1 = __webpack_require__(11);
var EventDefMutation = /** @class */ (function () {
    function EventDefMutation() {
    }
    /*
    eventDef assumed to be a SingleEventDef.
    returns an undo function.
    */
    EventDefMutation.prototype.mutateSingle = function (eventDef) {
        var origDateProfile;
        if (this.dateMutation) {
            origDateProfile = eventDef.dateProfile;
            eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.eventDefId != null) {
            eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.className) {
            eventDef.className = this.className;
        }
        // can't undo
        if (this.verbatimStandardProps) {
            SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src
            eventDef // dest
            );
        }
        // can't undo
        if (this.miscProps) {
            eventDef.applyMiscProps(this.miscProps);
        }
        if (origDateProfile) {
            return function () {
                eventDef.dateProfile = origDateProfile;
            };
        }
        else {
            return function () { };
        }
    };
    EventDefMutation.prototype.setDateMutation = function (dateMutation) {
        if (dateMutation && !dateMutation.isEmpty()) {
            this.dateMutation = dateMutation;
        }
        else {
            this.dateMutation = null;
        }
    };
    EventDefMutation.prototype.isEmpty = function () {
        return !this.dateMutation;
    };
    EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {
        var eventDef = eventInstance.def;
        var dateProps = {};
        var standardProps = {};
        var miscProps = {};
        var verbatimStandardProps = {};
        var eventDefId = null;
        var className = null;
        var propName;
        var dateProfile;
        var dateMutation;
        var defMutation;
        for (propName in rawProps) {
            if (EventDateProfile_1.default.isStandardProp(propName)) {
                dateProps[propName] = rawProps[propName];
            }
            else if (eventDef.isStandardProp(propName)) {
                standardProps[propName] = rawProps[propName];
            }
            else if (eventDef.miscProps[propName] !== rawProps[propName]) {
                miscProps[propName] = rawProps[propName];
            }
        }
        dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);
        if (dateProfile) {
            dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);
        }
        if (standardProps.id !== eventDef.id) {
            eventDefId = standardProps.id; // only apply if there's a change
        }
        if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {
            className = standardProps.className; // only apply if there's a change
        }
        EventDef_1.default.copyVerbatimStandardProps(standardProps, // src
        verbatimStandardProps // dest
        );
        defMutation = new EventDefMutation();
        defMutation.eventDefId = eventDefId;
        defMutation.className = className;
        defMutation.verbatimStandardProps = verbatimStandardProps;
        defMutation.miscProps = miscProps;
        if (dateMutation) {
            defMutation.dateMutation = dateMutation;
        }
        return defMutation;
    };
    return EventDefMutation;
}());
exports.default = EventDefMutation;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var Theme = /** @class */ (function () {
    function Theme(optionsManager) {
        this.optionsManager = optionsManager;
        this.processIconOverride();
    }
    Theme.prototype.processIconOverride = function () {
        if (this.iconOverrideOption) {
            this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));
        }
    };
    Theme.prototype.setIconOverride = function (iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;
        if ($.isPlainObject(iconOverrideHash)) {
            iconClassesCopy = $.extend({}, this.iconClasses);
            for (buttonName in iconOverrideHash) {
                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
            }
            this.iconClasses = iconClassesCopy;
        }
        else if (iconOverrideHash === false) {
            this.iconClasses = {};
        }
    };
    Theme.prototype.applyIconOverridePrefix = function (className) {
        var prefix = this.iconOverridePrefix;
        if (prefix && className.indexOf(prefix) !== 0) {
            className = prefix + className;
        }
        return className;
    };
    Theme.prototype.getClass = function (key) {
        return this.classes[key] || '';
    };
    Theme.prototype.getIconClass = function (buttonName) {
        var className = this.iconClasses[buttonName];
        if (className) {
            return this.baseIconClass + ' ' + className;
        }
        return '';
    };
    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
        var className;
        if (this.iconOverrideCustomButtonOption) {
            className = customButtonProps[this.iconOverrideCustomButtonOption];
            if (className) {
                return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
            }
        }
        return '';
    };
    return Theme;
}());
exports.default = Theme;
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = '';
Theme.prototype.iconOverridePrefix = '';


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Class_1 = __webpack_require__(21);
/*
Embodies a div that has potential scrollbars
*/
var Scroller = /** @class */ (function (_super) {
    tslib_1.__extends(Scroller, _super);
    function Scroller(options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.overflowX = options.overflowX || options.overflow || 'auto';
        _this.overflowY = options.overflowY || options.overflow || 'auto';
        return _this;
    }
    Scroller.prototype.render = function () {
        this.el = this.renderEl();
        this.applyOverflow();
    };
    Scroller.prototype.renderEl = function () {
        return (this.scrollEl = $('<div class="fc-scroller"></div>'));
    };
    // sets to natural height, unlocks overflow
    Scroller.prototype.clear = function () {
        this.setHeight('auto');
        this.applyOverflow();
    };
    Scroller.prototype.destroy = function () {
        this.el.remove();
    };
    // Overflow
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.applyOverflow = function () {
        this.scrollEl.css({
            'overflow-x': this.overflowX,
            'overflow-y': this.overflowY
        });
    };
    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
    // Useful for preserving scrollbar widths regardless of future resizes.
    // Can pass in scrollbarWidths for optimization.
    Scroller.prototype.lockOverflow = function (scrollbarWidths) {
        var overflowX = this.overflowX;
        var overflowY = this.overflowY;
        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
        if (overflowX === 'auto') {
            overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth) ? 'scroll' : 'hidden';
        }
        if (overflowY === 'auto') {
            overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight) ? 'scroll' : 'hidden';
        }
        this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
    };
    // Getters / Setters
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.setHeight = function (height) {
        this.scrollEl.height(height);
    };
    Scroller.prototype.getScrollTop = function () {
        return this.scrollEl.scrollTop();
    };
    Scroller.prototype.setScrollTop = function (top) {
        this.scrollEl.scrollTop(top);
    };
    Scroller.prototype.getClientWidth = function () {
        return this.scrollEl[0].clientWidth;
    };
    Scroller.prototype.getClientHeight = function () {
        return this.scrollEl[0].clientHeight;
    };
    Scroller.prototype.getScrollbarWidths = function () {
        return util_1.getScrollbarWidths(this.scrollEl);
    };
    return Scroller;
}(Class_1.default));
exports.default = Scroller;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var DateComponent_1 = __webpack_require__(61);
var GlobalEmitter_1 = __webpack_require__(14);
var InteractiveDateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InteractiveDateComponent, _super);
    function InteractiveDateComponent(_view, _options) {
        var _this = _super.call(this, _view, _options) || this;
        // self-config, overridable by subclasses
        _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?
        if (_this.dateSelectingClass) {
            _this.dateClicking = new _this.dateClickingClass(_this);
        }
        if (_this.dateSelectingClass) {
            _this.dateSelecting = new _this.dateSelectingClass(_this);
        }
        if (_this.eventPointingClass) {
            _this.eventPointing = new _this.eventPointingClass(_this);
        }
        if (_this.eventDraggingClass && _this.eventPointing) {
            _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);
        }
        if (_this.eventResizingClass && _this.eventPointing) {
            _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);
        }
        if (_this.externalDroppingClass) {
            _this.externalDropping = new _this.externalDroppingClass(_this);
        }
        return _this;
    }
    // Sets the container element that the view should render inside of, does global DOM-related initializations,
    // and renders all the non-date-related content inside.
    InteractiveDateComponent.prototype.setElement = function (el) {
        _super.prototype.setElement.call(this, el);
        if (this.dateClicking) {
            this.dateClicking.bindToEl(el);
        }
        if (this.dateSelecting) {
            this.dateSelecting.bindToEl(el);
        }
        this.bindAllSegHandlersToEl(el);
    };
    InteractiveDateComponent.prototype.removeElement = function () {
        this.endInteractions();
        _super.prototype.removeElement.call(this);
    };
    InteractiveDateComponent.prototype.executeEventUnrender = function () {
        this.endInteractions();
        _super.prototype.executeEventUnrender.call(this);
    };
    InteractiveDateComponent.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.bindToDocument();
        }
    };
    InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.unbindFromDocument();
        }
    };
    InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {
        var _this = this;
        // attach a handler to the grid's root element.
        // jQuery will take care of unregistering them when removeElement gets called.
        this.el.on(name, function (ev) {
            if (!$(ev.target).is(_this.segSelector + ',' + // directly on an event element
                _this.segSelector + ' *,' + // within an event element
                '.fc-more,' + // a "more.." link
                'a[data-goto]' // a clickable nav link
            )) {
                return handler.call(_this, ev);
            }
        });
    };
    InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {
        [
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (eventInteraction) {
            if (eventInteraction) {
                eventInteraction.bindToEl(el);
            }
        });
    };
    InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {
        var _this = this;
        el.on(name, this.segSelector, function (ev) {
            var seg = $(ev.currentTarget).data('fc-seg'); // grab segment data. put there by View::renderEventsPayload
            if (seg && !_this.shouldIgnoreEventPointing()) {
                return handler.call(_this, seg, ev); // context will be the Grid
            }
        });
    };
    InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {
        // HACK
        // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.
        return GlobalEmitter_1.default.get().shouldIgnoreMouse();
    };
    InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {
        var view = this._getView();
        // On iOS (and Android?) when a new selection is initiated overtop another selection,
        // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
        // HACK: simply don't allow this to happen.
        // ALSO: prevent selection when an *event* is already raised.
        return view.isSelected || view.selectedEvent;
    };
    InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {
        // only call the handlers if there is not a drag/resize in progress
        return (this.eventDragging && this.eventDragging.isDragging) ||
            (this.eventResizing && this.eventResizing.isResizing);
    };
    InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {
        return util_1.getEvIsTouch(ev) &&
            !this.canStartResize(seg, ev) &&
            (this.isEventDefDraggable(seg.footprint.eventDef) ||
                this.isEventDefResizable(seg.footprint.eventDef));
    };
    InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {
        return !this.canStartResize(seg, ev) &&
            this.isEventDefDraggable(seg.footprint.eventDef);
    };
    InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {
        var view = this._getView();
        var eventDef = seg.footprint.eventDef;
        return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&
            this.isEventDefResizable(eventDef) &&
            $(ev.target).is('.fc-resizer');
    };
    // Kills all in-progress dragging.
    // Useful for when public API methods that result in re-rendering are invoked during a drag.
    // Also useful for when touch devices misbehave and don't fire their touchend.
    InteractiveDateComponent.prototype.endInteractions = function () {
        [
            this.dateClicking,
            this.dateSelecting,
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (interaction) {
            if (interaction) {
                interaction.end();
            }
        });
    };
    // Event Drag-n-Drop
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be dragged by the user
    InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {
        return this.isEventDefStartEditable(eventDef);
    };
    InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {
        var isEditable = eventDef.isStartExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('eventStartEditable');
            if (isEditable == null) {
                isEditable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isEditable;
    };
    InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {
        var isEditable = eventDef.isExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('editable');
        }
        return isEditable;
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be resized from its starting edge
    InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {
        return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized from its ending edge
    InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {
        return this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized by the user at all
    InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {
        var isResizable = eventDef.isDurationExplicitlyEditable();
        if (isResizable == null) {
            isResizable = this.opt('eventDurationEditable');
            if (isResizable == null) {
                isResizable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isResizable;
    };
    // Event Mutation / Constraints
    // ---------------------------------------------------------------------------------------------------------------
    // Diffs the two dates, returning a duration, based on granularity of the grid
    // TODO: port isTimeScale into this system?
    InteractiveDateComponent.prototype.diffDates = function (a, b) {
        if (this.largeUnit) {
            return util_1.diffByUnit(a, b, this.largeUnit);
        }
        else {
            return util_1.diffDayTime(a, b);
        }
    };
    // is it allowed, in relation to the view's validRange?
    // NOTE: very similar to isExternalInstanceGroupAllowed
    InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            // TODO: just use getAllEventRanges directly
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);
    };
    // NOTE: very similar to isEventInstanceGroupAllowed
    // when it's a completely anonymous external drag, no event.
    InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        for (i = 0; i < eventFootprints.length; i++) {
            // treat it as a selection
            // TODO: pass in eventInstanceGroup instead
            //  because we don't want calendar's constraint system to depend on a component's
            //  determination of footprints.
            if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {
                return false;
            }
        }
        return true;
    };
    return InteractiveDateComponent;
}(DateComponent_1.default));
exports.default = InteractiveDateComponent;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var RenderQueue_1 = __webpack_require__(60);
var DateProfileGenerator_1 = __webpack_require__(62);
var InteractiveDateComponent_1 = __webpack_require__(29);
var GlobalEmitter_1 = __webpack_require__(14);
var UnzonedRange_1 = __webpack_require__(4);
/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/
var View = /** @class */ (function (_super) {
    tslib_1.__extends(View, _super);
    function View(calendar, viewSpec) {
        var _this = _super.call(this, null, viewSpec.options) || this;
        _this.batchRenderDepth = 0;
        _this.isSelected = false; // boolean whether a range of time is user-selected or not
        _this.calendar = calendar;
        _this.viewSpec = viewSpec;
        // shortcuts
        _this.type = viewSpec.type;
        // .name is deprecated
        _this.name = _this.type;
        _this.initRenderQueue();
        _this.initHiddenDays();
        _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);
        _this.bindBaseRenderHandlers();
        _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));
        // legacy
        if (_this['initialize']) {
            _this['initialize']();
        }
        return _this;
    }
    View.prototype._getView = function () {
        return this;
    };
    // Retrieves an option with the given name
    View.prototype.opt = function (name) {
        return this.options[name];
    };
    /* Render Queue
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.initRenderQueue = function () {
        this.renderQueue = new RenderQueue_1.default({
            event: this.opt('eventRenderWait')
        });
        this.renderQueue.on('start', this.onRenderQueueStart.bind(this));
        this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));
        this.on('before:change', this.startBatchRender);
        this.on('change', this.stopBatchRender);
    };
    View.prototype.onRenderQueueStart = function () {
        this.calendar.freezeContentHeight();
        this.addScroll(this.queryScroll());
    };
    View.prototype.onRenderQueueStop = function () {
        if (this.calendar.updateViewSize()) {
            this.popScroll();
        }
        this.calendar.thawContentHeight();
    };
    View.prototype.startBatchRender = function () {
        if (!(this.batchRenderDepth++)) {
            this.renderQueue.pause();
        }
    };
    View.prototype.stopBatchRender = function () {
        if (!(--this.batchRenderDepth)) {
            this.renderQueue.resume();
        }
    };
    View.prototype.requestRender = function (func, namespace, actionType) {
        this.renderQueue.queue(func, namespace, actionType);
    };
    // given func will auto-bind to `this`
    View.prototype.whenSizeUpdated = function (func) {
        if (this.renderQueue.isRunning) {
            this.renderQueue.one('stop', func.bind(this));
        }
        else {
            func.call(this);
        }
    };
    /* Title and Date Formatting
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes what the title at the top of the calendar should be for this view
    View.prototype.computeTitle = function (dateProfile) {
        var unzonedRange;
        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
            unzonedRange = dateProfile.currentUnzonedRange;
        }
        else {
            unzonedRange = dateProfile.activeUnzonedRange;
        }
        return this.formatRange({
            start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),
            end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)
        }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));
    };
    // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
    View.prototype.computeTitleFormat = function (dateProfile) {
        var currentRangeUnit = dateProfile.currentRangeUnit;
        if (currentRangeUnit == 'year') {
            return 'YYYY';
        }
        else if (currentRangeUnit == 'month') {
            return this.opt('monthYearFormat'); // like "September 2014"
        }
        else if (dateProfile.currentUnzonedRange.as('days') > 1) {
            return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
        }
        else {
            return 'LL'; // one day. longer, like "September 9 2014"
        }
    };
    // Date Setting/Unsetting
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.setDate = function (date) {
        var currentDateProfile = this.get('dateProfile');
        var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true
        if (!currentDateProfile ||
            !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {
            this.set('dateProfile', newDateProfile);
        }
    };
    View.prototype.unsetDate = function () {
        this.unset('dateProfile');
    };
    // Event Data
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.fetchInitialEvents = function (dateProfile) {
        var calendar = this.calendar;
        var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;
        return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));
    };
    View.prototype.bindEventChanges = function () {
        this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event
    };
    View.prototype.unbindEventChanges = function () {
        this.stopListeningTo(this.calendar, 'eventsReset');
    };
    View.prototype.setEvents = function (eventsPayload) {
        this.set('currentEvents', eventsPayload);
        this.set('hasEvents', true);
    };
    View.prototype.unsetEvents = function () {
        this.unset('currentEvents');
        this.unset('hasEvents');
    };
    View.prototype.resetEvents = function (eventsPayload) {
        this.startBatchRender();
        this.unsetEvents();
        this.setEvents(eventsPayload);
        this.stopBatchRender();
    };
    // Date High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestDateRender = function (dateProfile) {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateRender(dateProfile);
        }, 'date', 'init');
    };
    View.prototype.requestDateUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateUnrender();
        }, 'date', 'destroy');
    };
    // if dateProfile not specified, uses current
    View.prototype.executeDateRender = function (dateProfile) {
        _super.prototype.executeDateRender.call(this, dateProfile);
        if (this['render']) {
            this['render'](); // TODO: deprecate
        }
        this.trigger('datesRendered');
        this.addScroll({ isDateInit: true });
        this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon
    };
    View.prototype.executeDateUnrender = function () {
        this.unselect();
        this.stopNowIndicator();
        this.trigger('before:datesUnrendered');
        if (this['destroy']) {
            this['destroy'](); // TODO: deprecate
        }
        _super.prototype.executeDateUnrender.call(this);
    };
    // "Base" rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.bindBaseRenderHandlers = function () {
        var _this = this;
        this.on('datesRendered', function () {
            _this.whenSizeUpdated(_this.triggerViewRender);
        });
        this.on('before:datesUnrendered', function () {
            _this.triggerViewDestroy();
        });
    };
    View.prototype.triggerViewRender = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerViewDestroy = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Event High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestEventsRender = function (eventsPayload) {
        var _this = this;
        this.requestRender(function () {
            _this.executeEventRender(eventsPayload);
            _this.whenSizeUpdated(_this.triggerAfterEventsRendered);
        }, 'event', 'init');
    };
    View.prototype.requestEventsUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.triggerBeforeEventsDestroyed();
            _this.executeEventUnrender();
        }, 'event', 'destroy');
    };
    // Business Hour High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {
        var _this = this;
        this.requestRender(function () {
            _this.renderBusinessHours(businessHourGenerator);
        }, 'businessHours', 'init');
    };
    View.prototype.requestBusinessHoursUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.unrenderBusinessHours();
        }, 'businessHours', 'destroy');
    };
    // Misc view rendering utils
    // -----------------------------------------------------------------------------------------------------------------
    // Binds DOM handlers to elements that reside outside the view container, such as the document
    View.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        this.listenTo(GlobalEmitter_1.default.get(), {
            touchstart: this.processUnselect,
            mousedown: this.handleDocumentMousedown
        });
    };
    // Unbinds DOM handlers from elements that reside outside the view container
    View.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        this.stopListeningTo(GlobalEmitter_1.default.get());
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    // Immediately render the current time indicator and begins re-rendering it at an interval,
    // which is defined by this.getNowIndicatorUnit().
    // TODO: somehow do this for the current whole day's background too
    View.prototype.startNowIndicator = function () {
        var _this = this;
        var unit;
        var update;
        var delay; // ms wait value
        if (this.opt('nowIndicator')) {
            unit = this.getNowIndicatorUnit();
            if (unit) {
                update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`
                this.initialNowDate = this.calendar.getNow();
                this.initialNowQueriedMs = +new Date();
                // wait until the beginning of the next interval
                delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
                this.nowIndicatorTimeoutID = setTimeout(function () {
                    _this.nowIndicatorTimeoutID = null;
                    update();
                    delay = +moment.duration(1, unit);
                    delay = Math.max(100, delay); // prevent too frequent
                    _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
                }, delay);
            }
            // rendering will be initiated in updateSize
        }
    };
    // rerenders the now indicator, computing the new current time from the amount of time that has passed
    // since the initial getNow call.
    View.prototype.updateNowIndicator = function () {
        if (this.isDatesRendered &&
            this.initialNowDate // activated before?
        ) {
            this.unrenderNowIndicator(); // won't unrender if unnecessary
            this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms
            );
            this.isNowIndicatorRendered = true;
        }
    };
    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
    // Won't cause side effects if indicator isn't rendered.
    View.prototype.stopNowIndicator = function () {
        if (this.isNowIndicatorRendered) {
            if (this.nowIndicatorTimeoutID) {
                clearTimeout(this.nowIndicatorTimeoutID);
                this.nowIndicatorTimeoutID = null;
            }
            if (this.nowIndicatorIntervalID) {
                clearInterval(this.nowIndicatorIntervalID);
                this.nowIndicatorIntervalID = null;
            }
            this.unrenderNowIndicator();
            this.isNowIndicatorRendered = false;
        }
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        if (this['setHeight']) {
            this['setHeight'](totalHeight, isAuto);
        }
        else {
            _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        }
        this.updateNowIndicator();
    };
    /* Scroller
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.addScroll = function (scroll) {
        var queuedScroll = this.queuedScroll || (this.queuedScroll = {});
        $.extend(queuedScroll, scroll);
    };
    View.prototype.popScroll = function () {
        this.applyQueuedScroll();
        this.queuedScroll = null;
    };
    View.prototype.applyQueuedScroll = function () {
        if (this.queuedScroll) {
            this.applyScroll(this.queuedScroll);
        }
    };
    View.prototype.queryScroll = function () {
        var scroll = {};
        if (this.isDatesRendered) {
            $.extend(scroll, this.queryDateScroll());
        }
        return scroll;
    };
    View.prototype.applyScroll = function (scroll) {
        if (scroll.isDateInit && this.isDatesRendered) {
            $.extend(scroll, this.computeInitialDateScroll());
        }
        if (this.isDatesRendered) {
            this.applyDateScroll(scroll);
        }
    };
    View.prototype.computeInitialDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.queryDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.applyDateScroll = function (scroll) {
        ; // subclasses must implement
    };
    /* Event Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation, this.calendar);
        var dateMutation = eventMutation.dateMutation;
        // update the EventInstance, for handlers
        if (dateMutation) {
            eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        }
        this.triggerEventDrop(eventInstance, 
        // a drop doesn't necessarily mean a date mutation (ex: resource change)
        (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);
    };
    // Triggers event-drop handlers that have subscribed via the API
    View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventDrop', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                dateDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* External Element Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
    // `meta` is the parsed data that has been embedded into the dragging event.
    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
    View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {
        if (isEvent) {
            this.calendar.eventManager.addEventDef(singleEventDef, isSticky);
        }
        this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);
    };
    // Triggers external-drop handlers that have subscribed via the API
    View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {
        // trigger 'drop' regardless of whether element represents an event
        this.publiclyTrigger('drop', {
            context: el[0],
            args: [
                singleEventDef.dateProfile.start.clone(),
                ev,
                ui,
                this
            ]
        });
        if (isEvent) {
            // signal an external event landed
            this.publiclyTrigger('eventReceive', {
                context: this,
                args: [
                    singleEventDef.buildInstance().toLegacy(),
                    this
                ]
            });
        }
    };
    /* Event Resizing
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an event in the view has been resized to a new length
    View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation, this.calendar);
        // update the EventInstance, for handlers
        eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);
    };
    // Triggers event-resize handlers that have subscribed via the API
    View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventResize', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                durationDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* Selection (time range)
    ------------------------------------------------------------------------------------------------------------------*/
    // Selects a date span on the view. `start` and `end` are both Moments.
    // `ev` is the native mouse event that begin the interaction.
    View.prototype.select = function (footprint, ev) {
        this.unselect(ev);
        this.renderSelectionFootprint(footprint);
        this.reportSelection(footprint, ev);
    };
    View.prototype.renderSelectionFootprint = function (footprint) {
        if (this['renderSelection']) {
            this['renderSelection'](footprint.toLegacy(this.calendar));
        }
        else {
            _super.prototype.renderSelectionFootprint.call(this, footprint);
        }
    };
    // Called when a new selection is made. Updates internal state and triggers handlers.
    View.prototype.reportSelection = function (footprint, ev) {
        this.isSelected = true;
        this.triggerSelect(footprint, ev);
    };
    // Triggers handlers to 'select'
    View.prototype.triggerSelect = function (footprint, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('select', {
            context: this,
            args: [
                dateProfile.start,
                dateProfile.end,
                ev,
                this
            ]
        });
    };
    // Undoes a selection. updates in the internal state and triggers handlers.
    // `ev` is the native mouse event that began the interaction.
    View.prototype.unselect = function (ev) {
        if (ev === void 0) { ev = null; }
        if (this.isSelected) {
            this.isSelected = false;
            if (this['destroySelection']) {
                this['destroySelection'](); // TODO: deprecate
            }
            this.unrenderSelection();
            this.publiclyTrigger('unselect', {
                context: this,
                args: [ev, this]
            });
        }
    };
    /* Event Selection
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.selectEventInstance = function (eventInstance) {
        if (!this.selectedEventInstance ||
            this.selectedEventInstance !== eventInstance) {
            this.unselectEventInstance();
            this.getEventSegs().forEach(function (seg) {
                if (seg.footprint.eventInstance === eventInstance &&
                    seg.el // necessary?
                ) {
                    seg.el.addClass('fc-selected');
                }
            });
            this.selectedEventInstance = eventInstance;
        }
    };
    View.prototype.unselectEventInstance = function () {
        if (this.selectedEventInstance) {
            this.getEventSegs().forEach(function (seg) {
                if (seg.el) {
                    seg.el.removeClass('fc-selected');
                }
            });
            this.selectedEventInstance = null;
        }
    };
    View.prototype.isEventDefSelected = function (eventDef) {
        // event references might change on refetchEvents(), while selectedEventInstance doesn't,
        // so compare IDs
        return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;
    };
    /* Mouse / Touch Unselecting (time range & event unselection)
    ------------------------------------------------------------------------------------------------------------------*/
    // TODO: move consistently to down/start or up/end?
    // TODO: don't kill previous selection if touch scrolling
    View.prototype.handleDocumentMousedown = function (ev) {
        if (util_1.isPrimaryMouseButton(ev)) {
            this.processUnselect(ev);
        }
    };
    View.prototype.processUnselect = function (ev) {
        this.processRangeUnselect(ev);
        this.processEventUnselect(ev);
    };
    View.prototype.processRangeUnselect = function (ev) {
        var ignore;
        // is there a time-range selection?
        if (this.isSelected && this.opt('unselectAuto')) {
            // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
            ignore = this.opt('unselectCancel');
            if (!ignore || !$(ev.target).closest(ignore).length) {
                this.unselect(ev);
            }
        }
    };
    View.prototype.processEventUnselect = function (ev) {
        if (this.selectedEventInstance) {
            if (!$(ev.target).closest('.fc-selected').length) {
                this.unselectEventInstance();
            }
        }
    };
    /* Triggers
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.triggerBaseRendered = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerBaseUnrendered = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Triggers handlers to 'dayClick'
    // Span has start/end of the clicked area. Only the start is useful.
    View.prototype.triggerDayClick = function (footprint, dayEl, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('dayClick', {
            context: dayEl,
            args: [dateProfile.start, ev, this]
        });
    };
    /* Date Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // For DateComponent::getDayClasses
    View.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return false;
    };
    // Arguments after name will be forwarded to a hypothetical function value
    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
    // Always clone your objects if you fear mutation.
    View.prototype.getUnzonedRangeOption = function (name) {
        var val = this.opt(name);
        if (typeof val === 'function') {
            val = val.apply(null, Array.prototype.slice.call(arguments, 1));
        }
        if (val) {
            return this.calendar.parseUnzonedRange(val);
        }
    };
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/
    // Initializes internal variables related to calculating hidden days-of-week
    View.prototype.initHiddenDays = function () {
        var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
        var dayCnt = 0;
        var i;
        if (this.opt('weekends') === false) {
            hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        }
        for (i = 0; i < 7; i++) {
            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
                dayCnt++;
            }
        }
        if (!dayCnt) {
            throw 'invalid hiddenDays'; // all days were hidden? bad.
        }
        this.isHiddenDayHash = isHiddenDayHash;
    };
    // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null
    View.prototype.trimHiddenDays = function (inputUnzonedRange) {
        var start = inputUnzonedRange.getStart();
        var end = inputUnzonedRange.getEnd();
        if (start) {
            start = this.skipHiddenDays(start);
        }
        if (end) {
            end = this.skipHiddenDays(end, -1, true);
        }
        if (start === null || end === null || start < end) {
            return new UnzonedRange_1.default(start, end);
        }
        return null;
    };
    // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Moment
    View.prototype.isHiddenDay = function (day) {
        if (moment.isMoment(day)) {
            day = day.day();
        }
        return this.isHiddenDayHash[day];
    };
    // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validUnzonedRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)
    View.prototype.skipHiddenDays = function (date, inc, isExclusive) {
        if (inc === void 0) { inc = 1; }
        if (isExclusive === void 0) { isExclusive = false; }
        var out = date.clone();
        while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
            out.add(inc, 'days');
        }
        return out;
    };
    return View;
}(InteractiveDateComponent_1.default));
exports.default = View;
View.prototype.usesMinMaxTime = false;
View.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;
View.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {
    this.requestDateRender(deps.dateProfile);
}, function () {
    this.requestDateUnrender();
});
View.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {
    this.requestBusinessHoursRender(deps.businessHourGenerator);
}, function () {
    this.requestBusinessHoursUnrender();
});
View.watch('initialEvents', ['dateProfile'], function (deps) {
    return this.fetchInitialEvents(deps.dateProfile);
});
View.watch('bindingEvents', ['initialEvents'], function (deps) {
    this.setEvents(deps.initialEvents);
    this.bindEventChanges();
}, function () {
    this.unbindEventChanges();
    this.unsetEvents();
});
View.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {
    this.requestEventsRender(this.get('currentEvents'));
}, function () {
    this.requestEventsUnrender();
});
View.watch('title', ['dateProfile'], function (deps) {
    return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons
});
View.watch('legacyDateProps', ['dateProfile'], function (deps) {
    var calendar = this.calendar;
    var dateProfile = deps.dateProfile;
    // DEPRECATED, but we need to keep it updated...
    this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);
    this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);
});


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventRenderer = /** @class */ (function () {
    function EventRenderer(component, fillRenderer) {
        this.view = component._getView();
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    EventRenderer.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    // Updates values that rely on options and also relate to range
    EventRenderer.prototype.rangeUpdated = function () {
        var displayEventTime;
        var displayEventEnd;
        this.eventTimeFormat =
            this.opt('eventTimeFormat') ||
                this.opt('timeFormat') || // deprecated
                this.computeEventTimeFormat();
        displayEventTime = this.opt('displayEventTime');
        if (displayEventTime == null) {
            displayEventTime = this.computeDisplayEventTime(); // might be based off of range
        }
        displayEventEnd = this.opt('displayEventEnd');
        if (displayEventEnd == null) {
            displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
        }
        this.displayEventTime = displayEventTime;
        this.displayEventEnd = displayEventEnd;
    };
    EventRenderer.prototype.render = function (eventsPayload) {
        var dateProfile = this.component._getDateProfile();
        var eventDefId;
        var instanceGroup;
        var eventRanges;
        var bgRanges = [];
        var fgRanges = [];
        for (eventDefId in eventsPayload) {
            instanceGroup = eventsPayload[eventDefId];
            eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);
            if (instanceGroup.getEventDef().hasBgRendering()) {
                bgRanges.push.apply(bgRanges, eventRanges);
            }
            else {
                fgRanges.push.apply(fgRanges, eventRanges);
            }
        }
        this.renderBgRanges(bgRanges);
        this.renderFgRanges(fgRanges);
    };
    EventRenderer.prototype.unrender = function () {
        this.unrenderBgRanges();
        this.unrenderFgRanges();
    };
    EventRenderer.prototype.renderFgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        // render an `.el` on each seg
        // returns a subset of the segs. segs that were actually rendered
        segs = this.renderFgSegEls(segs);
        if (this.renderFgSegs(segs) !== false) {
            this.fgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderFgRanges = function () {
        this.unrenderFgSegs(this.fgSegs || []);
        this.fgSegs = null;
    };
    EventRenderer.prototype.renderBgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        if (this.renderBgSegs(segs) !== false) {
            this.bgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderBgRanges = function () {
        this.unrenderBgSegs();
        this.bgSegs = null;
    };
    EventRenderer.prototype.getSegs = function () {
        return (this.bgSegs || []).concat(this.fgSegs || []);
    };
    // Renders foreground event segments onto the grid
    EventRenderer.prototype.renderFgSegs = function (segs) {
        // subclasses must implement
        // segs already has rendered els, and has been filtered.
        return false; // signal failure if not implemented
    };
    // Unrenders all currently rendered foreground segments
    EventRenderer.prototype.unrenderFgSegs = function (segs) {
        // subclasses must implement
    };
    EventRenderer.prototype.renderBgSegs = function (segs) {
        var _this = this;
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('bgEvent', segs, {
                getClasses: function (seg) {
                    return _this.getBgClasses(seg.footprint.eventDef);
                },
                getCss: function (seg) {
                    return {
                        'background-color': _this.getBgColor(seg.footprint.eventDef)
                    };
                },
                filterEl: function (seg, el) {
                    return _this.filterEventRenderEl(seg.footprint, el);
                }
            });
        }
        else {
            return false; // signal failure if no fillRenderer
        }
    };
    EventRenderer.prototype.unrenderBgSegs = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('bgEvent');
        }
    };
    // Renders and assigns an `el` property for each foreground event segment.
    // Only returns segments that successfully rendered.
    EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {
        var _this = this;
        if (disableResizing === void 0) { disableResizing = false; }
        var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of event segment HTML
            for (i = 0; i < segs.length; i++) {
                this.beforeFgSegHtml(segs[i]);
                html += this.fgSegHtml(segs[i], disableResizing);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                if (hasEventRenderHandlers) {
                    el = _this.filterEventRenderEl(seg.footprint, el);
                }
                if (el) {
                    el.data('fc-seg', seg); // used by handlers
                    seg.el = el;
                    renderedSegs.push(seg);
                }
            });
        }
        return renderedSegs;
    };
    EventRenderer.prototype.beforeFgSegHtml = function (seg) {
    };
    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
    EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        // subclasses should implement
    };
    // Generic utility for generating the HTML classNames for an event segment's element
    EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {
        var classes = [
            'fc-event',
            seg.isStart ? 'fc-start' : 'fc-not-start',
            seg.isEnd ? 'fc-end' : 'fc-not-end'
        ].concat(this.getClasses(seg.footprint.eventDef));
        if (isDraggable) {
            classes.push('fc-draggable');
        }
        if (isResizable) {
            classes.push('fc-resizable');
        }
        // event is currently selected? attach a className.
        if (this.view.isEventDefSelected(seg.footprint.eventDef)) {
            classes.push('fc-selected');
        }
        return classes;
    };
    // Given an event and the default element used for rendering, returns the element that should actually be used.
    // Basically runs events and elements through the eventRender hook.
    EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {
        var legacy = eventFootprint.getEventLegacy();
        var custom = this.view.publiclyTrigger('eventRender', {
            context: legacy,
            args: [legacy, el, this.view]
        });
        if (custom === false) {
            el = null;
        }
        else if (custom && custom !== true) {
            el = $(custom);
        }
        return el;
    };
    // Compute the text that should be displayed on an event's element.
    // `range` can be the Event object itself, or something range-like, with at least a `start`.
    // If event times are disabled, or the event has no time, will return a blank string.
    // If not specified, formatStr will default to the eventTimeFormat setting,
    // and displayEnd will default to the displayEventEnd setting.
    EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {
        return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);
    };
    EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {
        if (formatStr == null) {
            formatStr = this.eventTimeFormat;
        }
        if (displayEnd == null) {
            displayEnd = this.displayEventEnd;
        }
        if (this.displayEventTime && !isAllDay) {
            if (displayEnd && end) {
                return this.view.formatRange({ start: start, end: end }, false, // allDay
                formatStr);
            }
            else {
                return start.format(formatStr);
            }
        }
        return '';
    };
    EventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('smallTimeFormat');
    };
    EventRenderer.prototype.computeDisplayEventTime = function () {
        return true;
    };
    EventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    EventRenderer.prototype.getBgClasses = function (eventDef) {
        var classNames = this.getClasses(eventDef);
        classNames.push('fc-bgevent');
        return classNames;
    };
    EventRenderer.prototype.getClasses = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var classNames = [];
        for (i = 0; i < objs.length; i++) {
            classNames.push.apply(// append
            classNames, objs[i].eventClassName || objs[i].className || []);
        }
        return classNames;
    };
    // Utility for generating event skin-related CSS properties
    EventRenderer.prototype.getSkinCss = function (eventDef) {
        return {
            'background-color': this.getBgColor(eventDef),
            'border-color': this.getBorderColor(eventDef),
            color: this.getTextColor(eventDef)
        };
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBgColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBackgroundColor || objs[i].eventColor ||
                objs[i].backgroundColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBackgroundColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBorderColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBorderColor || objs[i].eventColor ||
                objs[i].borderColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBorderColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getTextColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventTextColor ||
                objs[i].textColor;
        }
        if (!val) {
            val = this.opt('eventTextColor');
        }
        return val;
    };
    EventRenderer.prototype.getStylingObjs = function (eventDef) {
        var objs = this.getFallbackStylingObjs(eventDef);
        objs.unshift(eventDef);
        return objs;
    };
    EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {
        return [eventDef.source];
    };
    EventRenderer.prototype.sortEventSegs = function (segs) {
        segs.sort(util_1.proxy(this, 'compareEventSegs'));
    };
    // A cmp function for determining which segments should take visual priority
    EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {
        var f1 = seg1.footprint.componentFootprint;
        var r1 = f1.unzonedRange;
        var f2 = seg2.footprint.componentFootprint;
        var r2 = f2.unzonedRange;
        return r1.startMs - r2.startMs || // earlier events go first
            (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first
            f2.isAllDay - f1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)
            util_1.compareByFieldSpecs(seg1.footprint.eventDef, seg2.footprint.eventDef, this.view.eventOrderSpecs);
    };
    return EventRenderer;
}());
exports.default = EventRenderer;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Class_1 = __webpack_require__(21);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var Model = /** @class */ (function (_super) {
    tslib_1.__extends(Model, _super);
    function Model() {
        var _this = _super.call(this) || this;
        _this._watchers = {};
        _this._props = {};
        _this.applyGlobalWatchers();
        _this.constructed();
        return _this;
    }
    // useful for monkeypatching. TODO: BaseClass?
    Model.prototype.constructed = function () {
    };
    Model.prototype.applyGlobalWatchers = function () {
        var map = this._globalWatchArgs;
        var name;
        for (name in map) {
            this.watch.apply(this, [name].concat(map[name]));
        }
    };
    Model.prototype.has = function (name) {
        return name in this._props;
    };
    Model.prototype.get = function (name) {
        if (name === undefined) {
            return this._props;
        }
        return this._props[name];
    };
    Model.prototype.set = function (name, val) {
        var newProps;
        if (typeof name === 'string') {
            newProps = {};
            newProps[name] = val === undefined ? null : val;
        }
        else {
            newProps = name;
        }
        this.setProps(newProps);
    };
    Model.prototype.reset = function (newProps) {
        var oldProps = this._props;
        var changeset = {}; // will have undefined's to signal unsets
        var name;
        for (name in oldProps) {
            changeset[name] = undefined;
        }
        for (name in newProps) {
            changeset[name] = newProps[name];
        }
        this.setProps(changeset);
    };
    Model.prototype.unset = function (name) {
        var newProps = {};
        var names;
        var i;
        if (typeof name === 'string') {
            names = [name];
        }
        else {
            names = name;
        }
        for (i = 0; i < names.length; i++) {
            newProps[names[i]] = undefined;
        }
        this.setProps(newProps);
    };
    Model.prototype.setProps = function (newProps) {
        var changedProps = {};
        var changedCnt = 0;
        var name, val;
        for (name in newProps) {
            val = newProps[name];
            // a change in value?
            // if an object, don't check equality, because might have been mutated internally.
            // TODO: eventually enforce immutability.
            if (typeof val === 'object' ||
                val !== this._props[name]) {
                changedProps[name] = val;
                changedCnt++;
            }
        }
        if (changedCnt) {
            this.trigger('before:batchChange', changedProps);
            for (name in changedProps) {
                val = changedProps[name];
                this.trigger('before:change', name, val);
                this.trigger('before:change:' + name, val);
            }
            for (name in changedProps) {
                val = changedProps[name];
                if (val === undefined) {
                    delete this._props[name];
                }
                else {
                    this._props[name] = val;
                }
                this.trigger('change:' + name, val);
                this.trigger('change', name, val);
            }
            this.trigger('batchChange', changedProps);
        }
    };
    Model.prototype.watch = function (name, depList, startFunc, stopFunc) {
        var _this = this;
        this.unwatch(name);
        this._watchers[name] = this._watchDeps(depList, function (deps) {
            var res = startFunc.call(_this, deps);
            if (res && res.then) {
                _this.unset(name); // put in an unset state while resolving
                res.then(function (val) {
                    _this.set(name, val);
                });
            }
            else {
                _this.set(name, res);
            }
        }, function (deps) {
            _this.unset(name);
            if (stopFunc) {
                stopFunc.call(_this, deps);
            }
        });
    };
    Model.prototype.unwatch = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            delete this._watchers[name];
            watcher.teardown();
        }
    };
    Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {
        var _this = this;
        var queuedChangeCnt = 0;
        var depCnt = depList.length;
        var satisfyCnt = 0;
        var values = {}; // what's passed as the `deps` arguments
        var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
        var isCallingStop = false;
        var onBeforeDepChange = function (depName, val, isOptional) {
            queuedChangeCnt++;
            if (queuedChangeCnt === 1) {
                if (satisfyCnt === depCnt) {
                    isCallingStop = true;
                    stopFunc(values);
                    isCallingStop = false;
                }
            }
        };
        var onDepChange = function (depName, val, isOptional) {
            if (val === undefined) {
                // required dependency that was previously set?
                if (!isOptional && values[depName] !== undefined) {
                    satisfyCnt--;
                }
                delete values[depName];
            }
            else {
                // required dependency that was previously unset?
                if (!isOptional && values[depName] === undefined) {
                    satisfyCnt++;
                }
                values[depName] = val;
            }
            queuedChangeCnt--;
            if (!queuedChangeCnt) {
                // now finally satisfied or satisfied all along?
                if (satisfyCnt === depCnt) {
                    // if the stopFunc initiated another value change, ignore it.
                    // it will be processed by another change event anyway.
                    if (!isCallingStop) {
                        startFunc(values);
                    }
                }
            }
        };
        // intercept for .on() that remembers handlers
        var bind = function (eventName, handler) {
            _this.on(eventName, handler);
            bindTuples.push([eventName, handler]);
        };
        // listen to dependency changes
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') {
                depName = depName.substring(1);
                isOptional = true;
            }
            bind('before:change:' + depName, function (val) {
                onBeforeDepChange(depName, val, isOptional);
            });
            bind('change:' + depName, function (val) {
                onDepChange(depName, val, isOptional);
            });
        });
        // process current dependency values
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') {
                depName = depName.substring(1);
                isOptional = true;
            }
            if (_this.has(depName)) {
                values[depName] = _this.get(depName);
                satisfyCnt++;
            }
            else if (isOptional) {
                satisfyCnt++;
            }
        });
        // initially satisfied
        if (satisfyCnt === depCnt) {
            startFunc(values);
        }
        return {
            teardown: function () {
                // remove all handlers
                for (var i = 0; i < bindTuples.length; i++) {
                    _this.off(bindTuples[i][0], bindTuples[i][1]);
                }
                bindTuples = null;
                // was satisfied, so call stopFunc
                if (satisfyCnt === depCnt) {
                    stopFunc();
                }
            },
            flash: function () {
                if (satisfyCnt === depCnt) {
                    stopFunc();
                    startFunc(values);
                }
            }
        };
    };
    Model.prototype.flash = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            watcher.flash();
        }
    };
    Model.watch = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // subclasses should make a masked-copy of the superclass's map
        // TODO: write test
        if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {
            this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);
        }
        this.prototype._globalWatchArgs[name] = args;
    };
    return Model;
}(Class_1.default));
exports.default = Model;
Model.prototype._globalWatchArgs = {}; // mutation protection in Model.watch
EmitterMixin_1.default.mixInto(Model);
ListenerMixin_1.default.mixInto(Model);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var SingleEventDef_1 = __webpack_require__(11);
var RecurringEventDef_1 = __webpack_require__(52);
exports.default = {
    parse: function (eventInput, source) {
        if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||
            util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {
            return RecurringEventDef_1.default.parse(eventInput, source);
        }
        else {
            return SingleEventDef_1.default.parse(eventInput, source);
        }
    }
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Promise_1 = __webpack_require__(16);
var EventSource_1 = __webpack_require__(5);
var SingleEventDef_1 = __webpack_require__(11);
var ArrayEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(ArrayEventSource, _super);
    function ArrayEventSource(calendar) {
        var _this = _super.call(this, calendar) || this;
        _this.eventDefs = []; // for if setRawEventDefs is never called
        return _this;
    }
    ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {
        this.rawEventDefs = rawEventDefs;
        this.eventDefs = this.parseEventDefs(rawEventDefs);
    };
    ArrayEventSource.prototype.fetch = function (start, end, timezone) {
        var eventDefs = this.eventDefs;
        var i;
        if (this.currentTimezone != null &&
            this.currentTimezone !== timezone) {
            for (i = 0; i < eventDefs.length; i++) {
                if (eventDefs[i] instanceof SingleEventDef_1.default) {
                    eventDefs[i].rezone();
                }
            }
        }
        this.currentTimezone = timezone;
        return Promise_1.default.resolve(eventDefs);
    };
    ArrayEventSource.prototype.addEventDef = function (eventDef) {
        this.eventDefs.push(eventDef);
    };
    /*
    eventDefId already normalized to a string
    */
    ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {
        return util_1.removeMatching(this.eventDefs, function (eventDef) {
            return eventDef.id === eventDefId;
        });
    };
    ArrayEventSource.prototype.removeAllEventDefs = function () {
        this.eventDefs = [];
    };
    ArrayEventSource.prototype.getPrimitive = function () {
        return this.rawEventDefs;
    };
    ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.setRawEventDefs(rawProps.events);
        return superSuccess;
    };
    ArrayEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isArray(rawInput.events)) {
            rawProps = rawInput;
        }
        else if ($.isArray(rawInput)) {
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    return ArrayEventSource;
}(EventSource_1.default));
exports.default = ArrayEventSource;
ArrayEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(2);
var EventDateProfile_1 = __webpack_require__(15);
var EventDefDateMutation = /** @class */ (function () {
    function EventDefDateMutation() {
        this.clearEnd = false;
        this.forceTimed = false;
        this.forceAllDay = false;
    }
    /*
    returns an undo function.
    */
    EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {
        var start = eventDateProfile.start.clone();
        var end = null;
        var shouldRezone = false;
        if (eventDateProfile.end && !this.clearEnd) {
            end = eventDateProfile.end.clone();
        }
        else if (this.endDelta && !end) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        if (this.forceTimed) {
            shouldRezone = true;
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        else if (this.forceAllDay) {
            if (start.hasTime()) {
                start.stripTime();
            }
            if (end && end.hasTime()) {
                end.stripTime();
            }
        }
        if (this.dateDelta) {
            shouldRezone = true;
            start.add(this.dateDelta);
            if (end) {
                end.add(this.dateDelta);
            }
        }
        // do this before adding startDelta to start, so we can work off of start
        if (this.endDelta) {
            shouldRezone = true;
            end.add(this.endDelta);
        }
        if (this.startDelta) {
            shouldRezone = true;
            start.add(this.startDelta);
        }
        if (shouldRezone) {
            start = calendar.applyTimezone(start);
            if (end) {
                end = calendar.applyTimezone(end);
            }
        }
        // TODO: okay to access calendar option?
        if (!end && calendar.opt('forceEventDuration')) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        return new EventDateProfile_1.default(start, end, calendar);
    };
    EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {
        if (dateDelta && dateDelta.valueOf()) {
            this.dateDelta = dateDelta;
        }
        else {
            this.dateDelta = null;
        }
    };
    EventDefDateMutation.prototype.setStartDelta = function (startDelta) {
        if (startDelta && startDelta.valueOf()) {
            this.startDelta = startDelta;
        }
        else {
            this.startDelta = null;
        }
    };
    EventDefDateMutation.prototype.setEndDelta = function (endDelta) {
        if (endDelta && endDelta.valueOf()) {
            this.endDelta = endDelta;
        }
        else {
            this.endDelta = null;
        }
    };
    EventDefDateMutation.prototype.isEmpty = function () {
        return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&
            !this.dateDelta && !this.startDelta && !this.endDelta;
    };
    EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {
        var clearEnd = dateProfile0.end && !dateProfile1.end;
        var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();
        var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();
        var dateDelta;
        var endDiff;
        var endDelta;
        var mutation;
        // subtracts the dates in the appropriate way, returning a duration
        function subtractDates(date1, date0) {
            if (largeUnit) {
                return util_1.diffByUnit(date1, date0, largeUnit); // poorly named
            }
            else if (dateProfile1.isAllDay()) {
                return util_1.diffDay(date1, date0); // poorly named
            }
            else {
                return util_1.diffDayTime(date1, date0); // poorly named
            }
        }
        dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);
        if (dateProfile1.end) {
            // use unzonedRanges because dateProfile0.end might be null
            endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());
            endDelta = endDiff.subtract(dateDelta);
        }
        mutation = new EventDefDateMutation();
        mutation.clearEnd = clearEnd;
        mutation.forceTimed = forceTimed;
        mutation.forceAllDay = forceAllDay;
        mutation.setDateDelta(dateDelta);
        mutation.setEndDelta(endDelta);
        return mutation;
    };
    return EventDefDateMutation;
}());
exports.default = EventDefDateMutation;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var StandardTheme_1 = __webpack_require__(55);
var JqueryUiTheme_1 = __webpack_require__(56);
exports.default = {
    themeClassHash: {},
    register: function (themeName, themeClass) {
        this.themeClassHash[themeName] = themeClass;
    },
    getThemeClass: function (themeSetting) {
        if (!themeSetting) {
            return StandardTheme_1.default;
        }
        else if (themeSetting === true) {
            return JqueryUiTheme_1.default;
        }
        else {
            return this.themeClassHash[themeSetting];
        }
    }
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment_ext_1 = __webpack_require__(9);
// Plugin
// -------------------------------------------------------------------------------------------------
moment_ext_1.newMomentProto.format = function () {
    if (this._fullCalendar && arguments[0]) {
        return formatDate(this, arguments[0]); // our extended formatting
    }
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) {
        // moment.format() doesn't ensure english, but we want to.
        return moment_ext_1.oldMomentFormat(englishMoment(this));
    }
    return moment_ext_1.oldMomentProto.format.apply(this, arguments);
};
moment_ext_1.newMomentProto.toISOString = function () {
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) {
        // depending on browser, moment might not output english. ensure english.
        // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
        return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);
    }
    return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);
};
function englishMoment(mom) {
    if (mom.locale() !== 'en') {
        return mom.clone().locale('en');
    }
    return mom;
}
// Config
// ---------------------------------------------------------------------------------------------------------------------
/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab
/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1
/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global
/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
    t: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);
    },
    T: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);
    }
};
/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
    Y: { value: 1, unit: 'year' },
    M: { value: 2, unit: 'month' },
    W: { value: 3, unit: 'week' },
    w: { value: 3, unit: 'week' },
    D: { value: 4, unit: 'day' },
    d: { value: 4, unit: 'day' } // day of week
};
// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
    return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);
}
exports.formatDate = formatDate;
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
    var localeData;
    date1 = moment_ext_1.default.parseZone(date1);
    date2 = moment_ext_1.default.parseZone(date2);
    localeData = date1.localeData();
    // Expand localized format strings, like "LL" -> "MMMM D YYYY".
    // BTW, this is not important for `formatDate` because it is impossible to put custom tokens
    // or non-zero areas in Moment's localized format strings.
    formatStr = localeData.longDateFormat(formatStr) || formatStr;
    return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);
}
exports.formatRange = formatRange;
/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
    var sameUnits = parsedFormat.sameUnits;
    var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
    var unzonedDate2 = date2.clone().stripZone(); // "
    var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
    var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);
    var leftI;
    var leftStr = '';
    var rightI;
    var rightStr = '';
    var middleI;
    var middleStr1 = '';
    var middleStr2 = '';
    var middleStr = '';
    // Start at the leftmost side of the formatting string and continue until you hit a token
    // that is not the same between dates.
    for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {
        leftStr += renderedParts1[leftI];
    }
    // Similarly, start at the rightmost side of the formatting string and move left
    for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {
        // If current chunk is on the boundary of unique date-content, and is a special-case
        // date-formatting postfix character, then don't consume it. Consider it unique date-content.
        // TODO: make configurable
        if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
            break;
        }
        rightStr = renderedParts1[rightI] + rightStr;
    }
    // The area in the middle is different for both of the dates.
    // Collect them distinctly so we can jam them together later.
    for (middleI = leftI; middleI <= rightI; middleI++) {
        middleStr1 += renderedParts1[middleI];
        middleStr2 += renderedParts2[middleI];
    }
    if (middleStr1 || middleStr2) {
        if (isRTL) {
            middleStr = middleStr2 + separator + middleStr1;
        }
        else {
            middleStr = middleStr1 + separator + middleStr2;
        }
    }
    return processMaybeMarkers(leftStr + middleStr + rightStr);
}
// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------
var parsedFormatStrCache = {};
/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
    return parsedFormatStrCache[formatStr] ||
        (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}
/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
    var chunks = chunkFormatString(formatStr);
    return {
        fakeFormatString: buildFakeFormatString(chunks),
        sameUnits: buildSameUnits(chunks)
    };
}
/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
    var chunks = [];
    var match;
    // TODO: more descrimination
    // \4 is a backreference to the first character of a multi-character set.
    var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
    while ((match = chunker.exec(formatStr))) {
        if (match[1]) {
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[1]));
        }
        else if (match[2]) {
            chunks.push({ maybe: chunkFormatString(match[2]) });
        }
        else if (match[3]) {
            chunks.push({ token: match[3] });
        }
        else if (match[5]) {
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[5]));
        }
    }
    return chunks;
}
/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
    if (s === '. ') {
        return ['.', ' ']; // for locales with periods bound to the end of each year/month/date
    }
    else {
        return [s];
    }
}
/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
    var parts = [];
    var i, chunk;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (typeof chunk === 'string') {
            parts.push('[' + chunk + ']');
        }
        else if (chunk.token) {
            if (chunk.token in specialTokens) {
                parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing
                    '[' + chunk.token + ']' // preserve as literal text
                );
            }
            else {
                parts.push(chunk.token); // unprotected text implies a format string
            }
        }
        else if (chunk.maybe) {
            parts.push(MAYBE_MARKER + // useful during post-processing
                buildFakeFormatString(chunk.maybe) +
                MAYBE_MARKER);
        }
    }
    return parts.join(PART_SEPARATOR);
}
/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
    var units = [];
    var i, chunk;
    var tokenInfo;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            tokenInfo = largeTokenMap[chunk.token.charAt(0)];
            units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
        }
        else if (chunk.maybe) {
            units.push.apply(units, // append
            buildSameUnits(chunk.maybe));
        }
        else {
            units.push(null);
        }
    }
    return units;
}
// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
    return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));
}
/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
    var parts = [];
    var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);
    var fakeParts = fakeRender.split(PART_SEPARATOR);
    var i, fakePart;
    for (i = 0; i < fakeParts.length; i++) {
        fakePart = fakeParts[i];
        if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
            parts.push(
            // the literal string IS the token's name.
            // call special token's registered function.
            specialTokens[fakePart.substring(1)](date));
        }
        else {
            parts.push(fakePart);
        }
    }
    return parts;
}
/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
    return s.replace(MAYBE_REGEXP, function (m0, m1) {
        if (m1.match(/[1-9]/)) {
            return m1;
        }
        else {
            return '';
        }
    });
}
// Misc Utils
// -------------------------------------------------------------------------------------------------
/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
    var chunks = chunkFormatString(formatStr);
    var i, chunk;
    var candidate;
    var best;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            candidate = largeTokenMap[chunk.token.charAt(0)];
            if (candidate) {
                if (!best || candidate.value > best.value) {
                    best = candidate;
                }
            }
        }
    }
    if (best) {
        return best.unit;
    }
    return null;
}
exports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = /** @class */ (function () {
    function CoordCache(options) {
        this.isHorizontal = false; // whether to query for left/right/width
        this.isVertical = false; // whether to query for top/bottom/height
        this.els = $(options.els);
        this.isHorizontal = options.isHorizontal;
        this.isVertical = options.isVertical;
        this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
    }
    // Queries the els for coordinates and stores them.
    // Call this method before using and of the get* methods below.
    CoordCache.prototype.build = function () {
        var offsetParentEl = this.forcedOffsetParentEl;
        if (!offsetParentEl && this.els.length > 0) {
            offsetParentEl = this.els.eq(0).offsetParent();
        }
        this.origin = offsetParentEl ?
            offsetParentEl.offset() :
            null;
        this.boundingRect = this.queryBoundingRect();
        if (this.isHorizontal) {
            this.buildElHorizontals();
        }
        if (this.isVertical) {
            this.buildElVerticals();
        }
    };
    // Destroys all internal data about coordinates, freeing memory
    CoordCache.prototype.clear = function () {
        this.origin = null;
        this.boundingRect = null;
        this.lefts = null;
        this.rights = null;
        this.tops = null;
        this.bottoms = null;
    };
    // When called, if coord caches aren't built, builds them
    CoordCache.prototype.ensureBuilt = function () {
        if (!this.origin) {
            this.build();
        }
    };
    // Populates the left/right internal coordinate arrays
    CoordCache.prototype.buildElHorizontals = function () {
        var lefts = [];
        var rights = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var left = el.offset().left;
            var width = el.outerWidth();
            lefts.push(left);
            rights.push(left + width);
        });
        this.lefts = lefts;
        this.rights = rights;
    };
    // Populates the top/bottom internal coordinate arrays
    CoordCache.prototype.buildElVerticals = function () {
        var tops = [];
        var bottoms = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var top = el.offset().top;
            var height = el.outerHeight();
            tops.push(top);
            bottoms.push(top + height);
        });
        this.tops = tops;
        this.bottoms = bottoms;
    };
    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getHorizontalIndex = function (leftOffset) {
        this.ensureBuilt();
        var lefts = this.lefts;
        var rights = this.rights;
        var len = lefts.length;
        var i;
        for (i = 0; i < len; i++) {
            if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                return i;
            }
        }
    };
    // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getVerticalIndex = function (topOffset) {
        this.ensureBuilt();
        var tops = this.tops;
        var bottoms = this.bottoms;
        var len = tops.length;
        var i;
        for (i = 0; i < len; i++) {
            if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                return i;
            }
        }
    };
    // Gets the left offset (from document left) of the element at the given index
    CoordCache.prototype.getLeftOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex];
    };
    // Gets the left position (from offsetParent left) of the element at the given index
    CoordCache.prototype.getLeftPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex] - this.origin.left;
    };
    // Gets the right offset (from document left) of the element at the given index.
    // This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex];
    };
    // Gets the right position (from offsetParent left) of the element at the given index.
    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.origin.left;
    };
    // Gets the width of the element at the given index
    CoordCache.prototype.getWidth = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.lefts[leftIndex];
    };
    // Gets the top offset (from document top) of the element at the given index
    CoordCache.prototype.getTopOffset = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex];
    };
    // Gets the top position (from offsetParent top) of the element at the given position
    CoordCache.prototype.getTopPosition = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex] - this.origin.top;
    };
    // Gets the bottom offset (from the document top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomOffset = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex];
    };
    // Gets the bottom position (from the offsetParent top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomPosition = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.origin.top;
    };
    // Gets the height of the element at the given index
    CoordCache.prototype.getHeight = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.tops[topIndex];
    };
    // Bounding Rect
    // TODO: decouple this from CoordCache
    // Compute and return what the elements' bounding rectangle is, from the user's perspective.
    // Right now, only returns a rectangle if constrained by an overflow:scroll element.
    // Returns null if there are no elements
    CoordCache.prototype.queryBoundingRect = function () {
        var scrollParentEl;
        if (this.els.length > 0) {
            scrollParentEl = util_1.getScrollParent(this.els.eq(0));
            if (!scrollParentEl.is(document)) {
                return util_1.getClientRect(scrollParentEl);
            }
        }
        return null;
    };
    CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {
        return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
    };
    CoordCache.prototype.isLeftInBounds = function (leftOffset) {
        return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
    };
    CoordCache.prototype.isTopInBounds = function (topOffset) {
        return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
    };
    return CoordCache;
}());
exports.default = CoordCache;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var ListenerMixin_1 = __webpack_require__(6);
var GlobalEmitter_1 = __webpack_require__(14);
/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter
var DragListener = /** @class */ (function () {
    function DragListener(options) {
        this.isInteracting = false;
        this.isDistanceSurpassed = false;
        this.isDelayEnded = false;
        this.isDragging = false;
        this.isTouch = false;
        this.isGeneric = false; // initiated by 'dragstart' (jqui)
        this.shouldCancelTouchScroll = true;
        this.scrollAlwaysKills = false;
        this.isAutoScroll = false;
        // defaults
        this.scrollSensitivity = 30; // pixels from edge for scrolling to start
        this.scrollSpeed = 200; // pixels per second, at maximum speed
        this.scrollIntervalMs = 50; // millisecond wait between scroll increment
        this.options = options || {};
    }
    // Interaction (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startInteraction = function (ev, extraOptions) {
        if (extraOptions === void 0) { extraOptions = {}; }
        if (ev.type === 'mousedown') {
            if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {
                return;
            }
            else if (!util_1.isPrimaryMouseButton(ev)) {
                return;
            }
            else {
                ev.preventDefault(); // prevents native selection in most browsers
            }
        }
        if (!this.isInteracting) {
            // process options
            this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);
            this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);
            this.subjectEl = this.options.subjectEl;
            util_1.preventSelection($('body'));
            this.isInteracting = true;
            this.isTouch = util_1.getEvIsTouch(ev);
            this.isGeneric = ev.type === 'dragstart';
            this.isDelayEnded = false;
            this.isDistanceSurpassed = false;
            this.originX = util_1.getEvX(ev);
            this.originY = util_1.getEvY(ev);
            this.scrollEl = util_1.getScrollParent($(ev.target));
            this.bindHandlers();
            this.initAutoScroll();
            this.handleInteractionStart(ev);
            this.startDelay(ev);
            if (!this.minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
    };
    DragListener.prototype.handleInteractionStart = function (ev) {
        this.trigger('interactionStart', ev);
    };
    DragListener.prototype.endInteraction = function (ev, isCancelled) {
        if (this.isInteracting) {
            this.endDrag(ev);
            if (this.delayTimeoutId) {
                clearTimeout(this.delayTimeoutId);
                this.delayTimeoutId = null;
            }
            this.destroyAutoScroll();
            this.unbindHandlers();
            this.isInteracting = false;
            this.handleInteractionEnd(ev, isCancelled);
            util_1.allowSelection($('body'));
        }
    };
    DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        this.trigger('interactionEnd', ev, isCancelled || false);
    };
    // Binding To DOM
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.bindHandlers = function () {
        // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
        // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
        var globalEmitter = GlobalEmitter_1.default.get();
        if (this.isGeneric) {
            this.listenTo($(document), {
                drag: this.handleMove,
                dragstop: this.endInteraction
            });
        }
        else if (this.isTouch) {
            this.listenTo(globalEmitter, {
                touchmove: this.handleTouchMove,
                touchend: this.endInteraction,
                scroll: this.handleTouchScroll
            });
        }
        else {
            this.listenTo(globalEmitter, {
                mousemove: this.handleMouseMove,
                mouseup: this.endInteraction
            });
        }
        this.listenTo(globalEmitter, {
            selectstart: util_1.preventDefault,
            contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools
        });
    };
    DragListener.prototype.unbindHandlers = function () {
        this.stopListeningTo(GlobalEmitter_1.default.get());
        this.stopListeningTo($(document)); // for isGeneric
    };
    // Drag (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    // extraOptions ignored if drag already started
    DragListener.prototype.startDrag = function (ev, extraOptions) {
        this.startInteraction(ev, extraOptions); // ensure interaction began
        if (!this.isDragging) {
            this.isDragging = true;
            this.handleDragStart(ev);
        }
    };
    DragListener.prototype.handleDragStart = function (ev) {
        this.trigger('dragStart', ev);
    };
    DragListener.prototype.handleMove = function (ev) {
        var dx = util_1.getEvX(ev) - this.originX;
        var dy = util_1.getEvY(ev) - this.originY;
        var minDistance = this.minDistance;
        var distanceSq; // current distance from the origin, squared
        if (!this.isDistanceSurpassed) {
            distanceSq = dx * dx + dy * dy;
            if (distanceSq >= minDistance * minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
        if (this.isDragging) {
            this.handleDrag(dx, dy, ev);
        }
    };
    // Called while the mouse is being moved and when we know a legitimate drag is taking place
    DragListener.prototype.handleDrag = function (dx, dy, ev) {
        this.trigger('drag', dx, dy, ev);
        this.updateAutoScroll(ev); // will possibly cause scrolling
    };
    DragListener.prototype.endDrag = function (ev) {
        if (this.isDragging) {
            this.isDragging = false;
            this.handleDragEnd(ev);
        }
    };
    DragListener.prototype.handleDragEnd = function (ev) {
        this.trigger('dragEnd', ev);
    };
    // Delay
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startDelay = function (initialEv) {
        var _this = this;
        if (this.delay) {
            this.delayTimeoutId = setTimeout(function () {
                _this.handleDelayEnd(initialEv);
            }, this.delay);
        }
        else {
            this.handleDelayEnd(initialEv);
        }
    };
    DragListener.prototype.handleDelayEnd = function (initialEv) {
        this.isDelayEnded = true;
        if (this.isDistanceSurpassed) {
            this.startDrag(initialEv);
        }
    };
    // Distance
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleDistanceSurpassed = function (ev) {
        this.isDistanceSurpassed = true;
        if (this.isDelayEnded) {
            this.startDrag(ev);
        }
    };
    // Mouse / Touch
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchMove = function (ev) {
        // prevent inertia and touchmove-scrolling while dragging
        if (this.isDragging && this.shouldCancelTouchScroll) {
            ev.preventDefault();
        }
        this.handleMove(ev);
    };
    DragListener.prototype.handleMouseMove = function (ev) {
        this.handleMove(ev);
    };
    // Scrolling (unrelated to auto-scroll)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchScroll = function (ev) {
        // if the drag is being initiated by touch, but a scroll happens before
        // the drag-initiating delay is over, cancel the drag
        if (!this.isDragging || this.scrollAlwaysKills) {
            this.endInteraction(ev, true); // isCancelled=true
        }
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    DragListener.prototype.trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.options[name]) {
            this.options[name].apply(this, args);
        }
        // makes _methods callable by event name. TODO: kill this
        if (this['_' + name]) {
            this['_' + name].apply(this, args);
        }
    };
    // Auto-scroll
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.initAutoScroll = function () {
        var scrollEl = this.scrollEl;
        this.isAutoScroll =
            this.options.scroll &&
                scrollEl &&
                !scrollEl.is(window) &&
                !scrollEl.is(document);
        if (this.isAutoScroll) {
            // debounce makes sure rapid calls don't happen
            this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));
        }
    };
    DragListener.prototype.destroyAutoScroll = function () {
        this.endAutoScroll(); // kill any animation loop
        // remove the scroll handler if there is a scrollEl
        if (this.isAutoScroll) {
            this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
        }
    };
    // Computes and stores the bounding rectangle of scrollEl
    DragListener.prototype.computeScrollBounds = function () {
        if (this.isAutoScroll) {
            this.scrollBounds = util_1.getOuterRect(this.scrollEl);
            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
        }
    };
    // Called when the dragging is in progress and scrolling should be updated
    DragListener.prototype.updateAutoScroll = function (ev) {
        var sensitivity = this.scrollSensitivity;
        var bounds = this.scrollBounds;
        var topCloseness, bottomCloseness;
        var leftCloseness, rightCloseness;
        var topVel = 0;
        var leftVel = 0;
        if (bounds) {
            // compute closeness to edges. valid range is from 0.0 - 1.0
            topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;
            bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;
            leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;
            rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;
            // translate vertical closeness into velocity.
            // mouse must be completely in bounds for velocity to happen.
            if (topCloseness >= 0 && topCloseness <= 1) {
                topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
            }
            else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                topVel = bottomCloseness * this.scrollSpeed;
            }
            // translate horizontal closeness into velocity
            if (leftCloseness >= 0 && leftCloseness <= 1) {
                leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
            }
            else if (rightCloseness >= 0 && rightCloseness <= 1) {
                leftVel = rightCloseness * this.scrollSpeed;
            }
        }
        this.setScrollVel(topVel, leftVel);
    };
    // Sets the speed-of-scrolling for the scrollEl
    DragListener.prototype.setScrollVel = function (topVel, leftVel) {
        this.scrollTopVel = topVel;
        this.scrollLeftVel = leftVel;
        this.constrainScrollVel(); // massages into realistic values
        // if there is non-zero velocity, and an animation loop hasn't already started, then START
        if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
            this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`
            this.scrollIntervalMs);
        }
    };
    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
    DragListener.prototype.constrainScrollVel = function () {
        var el = this.scrollEl;
        if (this.scrollTopVel < 0) {
            if (el.scrollTop() <= 0) {
                this.scrollTopVel = 0;
            }
        }
        else if (this.scrollTopVel > 0) {
            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {
                this.scrollTopVel = 0;
            }
        }
        if (this.scrollLeftVel < 0) {
            if (el.scrollLeft() <= 0) {
                this.scrollLeftVel = 0;
            }
        }
        else if (this.scrollLeftVel > 0) {
            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {
                this.scrollLeftVel = 0;
            }
        }
    };
    // This function gets called during every iteration of the scrolling animation loop
    DragListener.prototype.scrollIntervalFunc = function () {
        var el = this.scrollEl;
        var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by
        // change the value of scrollEl's scroll
        if (this.scrollTopVel) {
            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
        }
        if (this.scrollLeftVel) {
            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
        }
        this.constrainScrollVel(); // since the scroll values changed, recompute the velocities
        // if scrolled all the way, which causes the vels to be zero, stop the animation loop
        if (!this.scrollTopVel && !this.scrollLeftVel) {
            this.endAutoScroll();
        }
    };
    // Kills any existing scrolling animation loop
    DragListener.prototype.endAutoScroll = function () {
        if (this.scrollIntervalId) {
            clearInterval(this.scrollIntervalId);
            this.scrollIntervalId = null;
            this.handleScrollEnd();
        }
    };
    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
    DragListener.prototype.handleDebouncedScroll = function () {
        // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
        if (!this.scrollIntervalId) {
            this.handleScrollEnd();
        }
    };
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    DragListener.prototype.handleScrollEnd = function () {
    };
    return DragListener;
}());
exports.default = DragListener;
ListenerMixin_1.default.mixInto(DragListener);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var Mixin_1 = __webpack_require__(12);
/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = /** @class */ (function (_super) {
    tslib_1.__extends(DayTableMixin, _super);
    function DayTableMixin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.breakOnWeeks = false; // should create a new row for each week?
        return _this;
    }
    // Populates internal variables used for date calculation and rendering
    DayTableMixin.prototype.updateDayTable = function () {
        var t = this;
        var view = t.view;
        var calendar = view.calendar;
        var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);
        var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);
        var dayIndex = -1;
        var dayIndices = [];
        var dayDates = [];
        var daysPerRow;
        var firstDay;
        var rowCnt;
        while (date.isBefore(end)) {
            if (view.isHiddenDay(date)) {
                dayIndices.push(dayIndex + 0.5); // mark that it's between indices
            }
            else {
                dayIndex++;
                dayIndices.push(dayIndex);
                dayDates.push(date.clone());
            }
            date.add(1, 'days');
        }
        if (this.breakOnWeeks) {
            // count columns until the day-of-week repeats
            firstDay = dayDates[0].day();
            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
                if (dayDates[daysPerRow].day() == firstDay) {
                    break;
                }
            }
            rowCnt = Math.ceil(dayDates.length / daysPerRow);
        }
        else {
            rowCnt = 1;
            daysPerRow = dayDates.length;
        }
        this.dayDates = dayDates;
        this.dayIndices = dayIndices;
        this.daysPerRow = daysPerRow;
        this.rowCnt = rowCnt;
        this.updateDayTableCols();
    };
    // Computes and assigned the colCnt property and updates any options that may be computed from it
    DayTableMixin.prototype.updateDayTableCols = function () {
        this.colCnt = this.computeColCnt();
        this.colHeadFormat = this.opt('columnFormat') || this.computeColHeadFormat();
    };
    // Determines how many columns there should be in the table
    DayTableMixin.prototype.computeColCnt = function () {
        return this.daysPerRow;
    };
    // Computes the ambiguously-timed moment for the given cell
    DayTableMixin.prototype.getCellDate = function (row, col) {
        return this.dayDates[this.getCellDayIndex(row, col)].clone();
    };
    // Computes the ambiguously-timed date range for the given cell
    DayTableMixin.prototype.getCellRange = function (row, col) {
        var start = this.getCellDate(row, col);
        var end = start.clone().add(1, 'days');
        return { start: start, end: end };
    };
    // Returns the number of day cells, chronologically, from the first of the grid (0-based)
    DayTableMixin.prototype.getCellDayIndex = function (row, col) {
        return row * this.daysPerRow + this.getColDayIndex(col);
    };
    // Returns the numner of day cells, chronologically, from the first cell in *any given row*
    DayTableMixin.prototype.getColDayIndex = function (col) {
        if (this.isRTL) {
            return this.colCnt - 1 - col;
        }
        else {
            return col;
        }
    };
    // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
    DayTableMixin.prototype.getDateDayIndex = function (date) {
        var dayIndices = this.dayIndices;
        var dayOffset = date.diff(this.dayDates[0], 'days');
        if (dayOffset < 0) {
            return dayIndices[0] - 1;
        }
        else if (dayOffset >= dayIndices.length) {
            return dayIndices[dayIndices.length - 1] + 1;
        }
        else {
            return dayIndices[dayOffset];
        }
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes a default column header formatting string if `colFormat` is not explicitly defined
    DayTableMixin.prototype.computeColHeadFormat = function () {
        // if more than one week row, or if there are a lot of columns with not much space,
        // put just the day numbers will be in each cell
        if (this.rowCnt > 1 || this.colCnt > 10) {
            return 'ddd'; // "Sat"
        }
        else if (this.colCnt > 1) {
            return this.opt('dayOfMonthFormat'); // "Sat 12/10"
        }
        else {
            return 'dddd'; // "Saturday"
        }
    };
    /* Slicing
    ------------------------------------------------------------------------------------------------------------------*/
    // Slices up a date range into a segment for every week-row it intersects with
    DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst, rowLast; // inclusive day-index range for current row
        var segFirst, segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            // intersect segment's offset range with the row's
            segFirst = Math.max(rangeFirst, rowFirst);
            segLast = Math.min(rangeLast, rowLast);
            // deal with in-between indices
            segFirst = Math.ceil(segFirst); // in-between starts round to next cell
            segLast = Math.floor(segLast); // in-between ends round to prev cell
            if (segFirst <= segLast) {
                segs.push({
                    row: row,
                    // normalize to start of row
                    firstRowDayIndex: segFirst - rowFirst,
                    lastRowDayIndex: segLast - rowFirst,
                    // must be matching integers to be the segment's start/end
                    isStart: segFirst === rangeFirst,
                    isEnd: segLast === rangeLast
                });
            }
        }
        return segs;
    };
    // Slices up a date range into a segment for every day-cell it intersects with.
    // TODO: make more DRY with sliceRangeByRow somehow.
    DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst, rowLast; // inclusive day-index range for current row
        var i;
        var segFirst, segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            for (i = rowFirst; i <= rowLast; i++) {
                // intersect segment's offset range with the row's
                segFirst = Math.max(rangeFirst, i);
                segLast = Math.min(rangeLast, i);
                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell
                if (segFirst <= segLast) {
                    segs.push({
                        row: row,
                        // normalize to start of row
                        firstRowDayIndex: segFirst - rowFirst,
                        lastRowDayIndex: segLast - rowFirst,
                        // must be matching integers to be the segment's start/end
                        isStart: segFirst === rangeFirst,
                        isEnd: segLast === rangeLast
                    });
                }
            }
        }
        return segs;
    };
    /* Header Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderHeadHtml = function () {
        var theme = this.view.calendar.theme;
        return '' +
            '<div class="fc-row ' + theme.getClass('headerRow') + '">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            '<thead>' +
            this.renderHeadTrHtml() +
            '</thead>' +
            '</table>' +
            '</div>';
    };
    DayTableMixin.prototype.renderHeadIntroHtml = function () {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderHeadTrHtml = function () {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderHeadIntroHtml()) +
            this.renderHeadDateCellsHtml() +
            (this.isRTL ? this.renderHeadIntroHtml() : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderHeadDateCellsHtml = function () {
        var htmls = [];
        var col, date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(0, col);
            htmls.push(this.renderHeadDateCellHtml(date));
        }
        return htmls.join('');
    };
    // TODO: when internalApiVersion, accept an object for HTML attributes
    // (colspan should be no different)
    DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classNames = [
            'fc-day-header',
            view.calendar.theme.getClass('widgetHeader')
        ];
        var innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));
        // if only one row of days, the classNames on the header can represent the specific days beneath
        if (t.rowCnt === 1) {
            classNames = classNames.concat(
            // includes the day-of-week class
            // noThemeHighlight=true (don't highlight the header)
            t.getDayClasses(date, true));
        }
        else {
            classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class
        }
        return '' +
            '<th class="' + classNames.join(' ') + '"' +
            ((isDateValid && t.rowCnt) === 1 ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' :
                '') +
            (colspan > 1 ?
                ' colspan="' + colspan + '"' :
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '>' +
            (isDateValid ?
                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
                view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :
                // if not valid, display text, but no link
                innerHtml) +
            '</th>';
    };
    /* Background Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderBgTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderBgIntroHtml(row)) +
            this.renderBgCellsHtml(row) +
            (this.isRTL ? this.renderBgIntroHtml(row) : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderBgIntroHtml = function (row) {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderBgCellsHtml = function (row) {
        var htmls = [];
        var col, date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderBgCellHtml(date));
        }
        return htmls.join('');
    };
    DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classes = t.getDayClasses(date);
        classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));
        return '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '></td>';
    };
    /* Generic
    ------------------------------------------------------------------------------------------------------------------*/
    // Generates the default HTML intro for any row. User classes should override
    DayTableMixin.prototype.renderIntroHtml = function () {
    };
    // TODO: a generic method for dealing with <tr>, RTL, intro
    // when increment internalApiVersion
    // wrapTr (scheduler)
    /* Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // Applies the generic "intro" and "outro" HTML to the given cells.
    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
    DayTableMixin.prototype.bookendCells = function (trEl) {
        var introHtml = this.renderIntroHtml();
        if (introHtml) {
            if (this.isRTL) {
                trEl.append(introHtml);
            }
            else {
                trEl.prepend(introHtml);
            }
        }
    };
    return DayTableMixin;
}(Mixin_1.default));
exports.default = DayTableMixin;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var BusinessHourRenderer = /** @class */ (function () {
    /*
    component implements:
        - eventRangesToEventFootprints
        - eventFootprintsToSegs
    */
    function BusinessHourRenderer(component, fillRenderer) {
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    BusinessHourRenderer.prototype.render = function (businessHourGenerator) {
        var component = this.component;
        var unzonedRange = component._getDateProfile().activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);
        var eventFootprints = eventInstanceGroup ?
            component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :
            [];
        this.renderEventFootprints(eventFootprints);
    };
    BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        this.renderSegs(segs);
        this.segs = segs;
    };
    BusinessHourRenderer.prototype.renderSegs = function (segs) {
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('businessHours', segs, {
                getClasses: function (seg) {
                    return ['fc-nonbusiness', 'fc-bgevent'];
                }
            });
        }
    };
    BusinessHourRenderer.prototype.unrender = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('businessHours');
        }
        this.segs = null;
    };
    BusinessHourRenderer.prototype.getSegs = function () {
        return this.segs || [];
    };
    return BusinessHourRenderer;
}());
exports.default = BusinessHourRenderer;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var FillRenderer = /** @class */ (function () {
    function FillRenderer(component) {
        this.fillSegTag = 'div';
        this.component = component;
        this.elsByFill = {};
    }
    FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {
        this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);
    };
    FillRenderer.prototype.renderSegs = function (type, segs, props) {
        var els;
        segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs
        els = this.attachSegEls(type, segs);
        if (els) {
            this.reportEls(type, els);
        }
        return segs;
    };
    // Unrenders a specific type of fill that is currently rendered on the grid
    FillRenderer.prototype.unrender = function (type) {
        var el = this.elsByFill[type];
        if (el) {
            el.remove();
            delete this.elsByFill[type];
        }
    };
    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
    // Only returns segments that successfully rendered.
    FillRenderer.prototype.buildSegEls = function (type, segs, props) {
        var _this = this;
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of segment HTML
            for (i = 0; i < segs.length; i++) {
                html += this.buildSegHtml(type, segs[i], props);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                // allow custom filter methods per-type
                if (props.filterEl) {
                    el = props.filterEl(seg, el);
                }
                if (el) {
                    el = $(el); // allow custom filter to return raw DOM node
                    // correct element type? (would be bad if a non-TD were inserted into a table for example)
                    if (el.is(_this.fillSegTag)) {
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                }
            });
        }
        return renderedSegs;
    };
    // Builds the HTML needed for one fill segment. Generic enough to work with different types.
    FillRenderer.prototype.buildSegHtml = function (type, seg, props) {
        // custom hooks per-type
        var classes = props.getClasses ? props.getClasses(seg) : [];
        var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});
        return '<' + this.fillSegTag +
            (classes.length ? ' class="' + classes.join(' ') + '"' : '') +
            (css ? ' style="' + css + '"' : '') +
            ' />';
    };
    // Should return wrapping DOM structure
    FillRenderer.prototype.attachSegEls = function (type, segs) {
        // subclasses must implement
    };
    FillRenderer.prototype.reportEls = function (type, nodes) {
        if (this.elsByFill[type]) {
            this.elsByFill[type] = this.elsByFill[type].add(nodes);
        }
        else {
            this.elsByFill[type] = $(nodes);
        }
    };
    return FillRenderer;
}());
exports.default = FillRenderer;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventDef_1 = __webpack_require__(11);
var EventFootprint_1 = __webpack_require__(24);
var EventSource_1 = __webpack_require__(5);
var HelperRenderer = /** @class */ (function () {
    function HelperRenderer(component, eventRenderer) {
        this.view = component._getView();
        this.component = component;
        this.eventRenderer = eventRenderer;
    }
    HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {
        this.renderEventFootprints([
            this.fabricateEventFootprint(componentFootprint)
        ]);
    };
    HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));
    };
    HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');
    };
    HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        var classNames = 'fc-helper ' + (extraClassNames || '');
        var i;
        // assigns each seg's el and returns a subset of segs that were rendered
        segs = this.eventRenderer.renderFgSegEls(segs);
        for (i = 0; i < segs.length; i++) {
            segs[i].el.addClass(classNames);
        }
        if (opacity != null) {
            for (i = 0; i < segs.length; i++) {
                segs[i].el.css('opacity', opacity);
            }
        }
        this.helperEls = this.renderSegs(segs, sourceSeg);
    };
    /*
    Must return all mock event elements
    */
    HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        // Subclasses must implement
    };
    HelperRenderer.prototype.unrender = function () {
        if (this.helperEls) {
            this.helperEls.remove();
            this.helperEls = null;
        }
    };
    HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {
        var calendar = this.view.calendar;
        var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);
        var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));
        var dummyInstance;
        dummyEvent.dateProfile = eventDateProfile;
        dummyInstance = dummyEvent.buildInstance();
        return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);
    };
    return HelperRenderer;
}());
exports.default = HelperRenderer;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var GlobalEmitter_1 = __webpack_require__(14);
var Interaction_1 = __webpack_require__(13);
var EventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(EventPointing, _super);
    function EventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    component must implement:
        - publiclyTrigger
    */
    EventPointing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));
        component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));
        component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));
    };
    EventPointing.prototype.handleClick = function (seg, ev) {
        var res = this.component.publiclyTrigger('eventClick', {
            context: seg.el[0],
            args: [seg.footprint.getEventLegacy(), ev, this.view]
        });
        if (res === false) {
            ev.preventDefault();
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused over
    EventPointing.prototype.handleMouseover = function (seg, ev) {
        if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&
            !this.mousedOverSeg) {
            this.mousedOverSeg = seg;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.addClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseover', {
                context: seg.el[0],
                args: [seg.footprint.getEventLegacy(), ev, this.view]
            });
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused out.
    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
    EventPointing.prototype.handleMouseout = function (seg, ev) {
        if (this.mousedOverSeg) {
            this.mousedOverSeg = null;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.removeClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseout', {
                context: seg.el[0],
                args: [
                    seg.footprint.getEventLegacy(),
                    ev || {},
                    this.view
                ]
            });
        }
    };
    EventPointing.prototype.end = function () {
        if (this.mousedOverSeg) {
            this.handleMouseout(this.mousedOverSeg);
        }
    };
    return EventPointing;
}(Interaction_1.default));
exports.default = EventPointing;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Mixin_1 = __webpack_require__(12);
var DateClicking_1 = __webpack_require__(82);
var DateSelecting_1 = __webpack_require__(66);
var EventPointing_1 = __webpack_require__(44);
var EventDragging_1 = __webpack_require__(65);
var EventResizing_1 = __webpack_require__(64);
var ExternalDropping_1 = __webpack_require__(63);
var StandardInteractionsMixin = /** @class */ (function (_super) {
    tslib_1.__extends(StandardInteractionsMixin, _super);
    function StandardInteractionsMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardInteractionsMixin;
}(Mixin_1.default));
exports.default = StandardInteractionsMixin;
StandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;
StandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;
StandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;
StandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;
StandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;
StandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var CoordCache_1 = __webpack_require__(38);
var Popover_1 = __webpack_require__(86);
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var EventFootprint_1 = __webpack_require__(24);
var BusinessHourRenderer_1 = __webpack_require__(41);
var StandardInteractionsMixin_1 = __webpack_require__(45);
var InteractiveDateComponent_1 = __webpack_require__(29);
var DayTableMixin_1 = __webpack_require__(40);
var DayGridEventRenderer_1 = __webpack_require__(87);
var DayGridHelperRenderer_1 = __webpack_require__(88);
var DayGridFillRenderer_1 = __webpack_require__(89);
/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/
var DayGrid = /** @class */ (function (_super) {
    tslib_1.__extends(DayGrid, _super);
    function DayGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.cellWeekNumbersVisible = false; // display week numbers in day cell?
        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid
        // isRigid determines whether the individual rows should ignore the contents and be a constant height.
        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
        _this.isRigid = false;
        _this.hasAllDayBusinessHours = true;
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (this.isRTL) {
                seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
                seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
            }
            else {
                seg.leftCol = seg.firstRowDayIndex;
                seg.rightCol = seg.lastRowDayIndex;
            }
        }
        return segs;
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderGrid();
    };
    DayGrid.prototype.unrenderDates = function () {
        this.removeSegPopover();
    };
    // Renders the rows and columns into the component's `this.el`, which should already be assigned.
    DayGrid.prototype.renderGrid = function () {
        var view = this.view;
        var rowCnt = this.rowCnt;
        var colCnt = this.colCnt;
        var html = '';
        var row;
        var col;
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        for (row = 0; row < rowCnt; row++) {
            html += this.renderDayRowHtml(row, this.isRigid);
        }
        this.el.html(html);
        this.rowEls = this.el.find('.fc-row');
        this.cellEls = this.el.find('.fc-day, .fc-disabled-day');
        this.rowCoordCache = new CoordCache_1.default({
            els: this.rowEls,
            isVertical: true
        });
        this.colCoordCache = new CoordCache_1.default({
            els: this.cellEls.slice(0, this.colCnt),
            isHorizontal: true
        });
        // trigger dayRender with each cell's element
        for (row = 0; row < rowCnt; row++) {
            for (col = 0; col < colCnt; col++) {
                this.publiclyTrigger('dayRender', {
                    context: view,
                    args: [
                        this.getCellDate(row, col),
                        this.getCellEl(row, col),
                        view
                    ]
                });
            }
        }
    };
    // Generates the HTML for a single row, which is a div that wraps a table.
    // `row` is the row number.
    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
        var theme = this.view.calendar.theme;
        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];
        if (isRigid) {
            classes.push('fc-rigid');
        }
        return '' +
            '<div class="' + classes.join(' ') + '">' +
            '<div class="fc-bg">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(row) +
            '</table>' +
            '</div>' +
            '<div class="fc-content-skeleton">' +
            '<table>' +
            (this.getIsNumbersVisible() ?
                '<thead>' +
                    this.renderNumberTrHtml(row) +
                    '</thead>' :
                '') +
            '</table>' +
            '</div>' +
            '</div>';
    };
    DayGrid.prototype.getIsNumbersVisible = function () {
        return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;
    };
    DayGrid.prototype.getIsDayNumbersVisible = function () {
        return this.rowCnt > 1;
    };
    /* Grid Number Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderNumberTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
            this.renderNumberCellsHtml(row) +
            (this.isRTL ? this.renderNumberIntroHtml(row) : '') +
            '</tr>';
    };
    DayGrid.prototype.renderNumberIntroHtml = function (row) {
        return this.renderIntroHtml();
    };
    DayGrid.prototype.renderNumberCellsHtml = function (row) {
        var htmls = [];
        var col, date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderNumberCellHtml(date));
        }
        return htmls.join('');
    };
    // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
    // The number row will only exist if either day numbers or week numbers are turned on.
    DayGrid.prototype.renderNumberCellHtml = function (date) {
        var view = this.view;
        var html = '';
        var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
        var classes;
        var weekCalcFirstDoW;
        if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {
            // no numbers in day cell (week number must be along the side)
            return '<td/>'; //  will create an empty space above events :(
        }
        classes = this.getDayClasses(date);
        classes.unshift('fc-day-top');
        if (this.cellWeekNumbersVisible) {
            // To determine the day of week number change under ISO, we cannot
            // rely on moment.js methods such as firstDayOfWeek() or weekday(),
            // because they rely on the locale's dow (possibly overridden by
            // our firstDay option), which may not be Monday. We cannot change
            // dow, because that would affect the calendar start day as well.
            if (date._locale._fullCalendar_weekCalc === 'ISO') {
                weekCalcFirstDoW = 1; // Monday by ISO 8601 definition
            }
            else {
                weekCalcFirstDoW = date._locale.firstDayOfWeek();
            }
        }
        html += '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format() + '"' :
                '') +
            '>';
        if (this.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
            html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML
            );
        }
        if (isDayNumberVisible) {
            html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.date() // inner HTML
            );
        }
        html += '</td>';
        return html;
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.rowCoordCache.build();
        this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
    };
    DayGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        this.rowCoordCache.clear();
    };
    DayGrid.prototype.queryHit = function (leftOffset, topOffset) {
        if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
            var col = this.colCoordCache.getHorizontalIndex(leftOffset);
            var row = this.rowCoordCache.getVerticalIndex(topOffset);
            if (row != null && col != null) {
                return this.getCellHit(row, col);
            }
        }
    };
    DayGrid.prototype.getHitFootprint = function (hit) {
        var range = this.getCellRange(hit.row, hit.col);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?
        );
    };
    DayGrid.prototype.getHitEl = function (hit) {
        return this.getCellEl(hit.row, hit.col);
    };
    /* Cell System
    ------------------------------------------------------------------------------------------------------------------*/
    // FYI: the first column is the leftmost column, regardless of date
    DayGrid.prototype.getCellHit = function (row, col) {
        return {
            row: row,
            col: col,
            component: this,
            left: this.colCoordCache.getLeftOffset(col),
            right: this.colCoordCache.getRightOffset(col),
            top: this.rowCoordCache.getTopOffset(row),
            bottom: this.rowCoordCache.getBottomOffset(row)
        };
    };
    DayGrid.prototype.getCellEl = function (row, col) {
        return this.cellEls.eq(row * this.colCnt + col);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    // Unrenders all events currently rendered on the grid
    DayGrid.prototype.executeEventUnrender = function () {
        this.removeSegPopover(); // removes the "more.." events popover
        _super.prototype.executeEventUnrender.call(this);
    };
    // Retrieves all rendered segment objects currently rendered on the grid
    DayGrid.prototype.getOwnEventSegs = function () {
        // append the segments from the "more..." popover
        return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event or external element being dragged.
    // `eventLocation` has zoned start and end (optional)
    DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        // render drags from OTHER components as helpers
        if (eventFootprints.length && seg && seg.component !== this) {
            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
            return true; // signal helpers rendered
        }
    };
    // Unrenders any visual indication of a hovering event
    DayGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders a visual indication of an event being resized
    DayGrid.prototype.unrenderEventResize = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* More+ Link Popover
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.removeSegPopover = function () {
        if (this.segPopover) {
            this.segPopover.hide(); // in handler, will call segPopover's removeElement
        }
    };
    // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
    // `levelLimit` can be false (don't limit), a number, or true (should be computed).
    DayGrid.prototype.limitRows = function (levelLimit) {
        var rowStructs = this.eventRenderer.rowStructs || [];
        var row; // row #
        var rowLevelLimit;
        for (row = 0; row < rowStructs.length; row++) {
            this.unlimitRow(row);
            if (!levelLimit) {
                rowLevelLimit = false;
            }
            else if (typeof levelLimit === 'number') {
                rowLevelLimit = levelLimit;
            }
            else {
                rowLevelLimit = this.computeRowLevelLimit(row);
            }
            if (rowLevelLimit !== false) {
                this.limitRow(row, rowLevelLimit);
            }
        }
    };
    // Computes the number of levels a row will accomodate without going outside its bounds.
    // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
    // `row` is the row number.
    DayGrid.prototype.computeRowLevelLimit = function (row) {
        var rowEl = this.rowEls.eq(row); // the containing "fake" row div
        var rowHeight = rowEl.height(); // TODO: cache somehow?
        var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();
        var i, trEl;
        var trHeight;
        function iterInnerHeights(i, childNode) {
            trHeight = Math.max(trHeight, $(childNode).outerHeight());
        }
        // Reveal one level <tr> at a time and stop when we find one out of bounds
        for (i = 0; i < trEls.length; i++) {
            trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)
            // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
            // so instead, find the tallest inner content element.
            trHeight = 0;
            trEl.find('> td > :first-child').each(iterInnerHeights);
            if (trEl.position().top + trHeight > rowHeight) {
                return i;
            }
        }
        return false; // should not limit at all
    };
    // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
    // `row` is the row number.
    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
    DayGrid.prototype.limitRow = function (row, levelLimit) {
        var _this = this;
        var rowStruct = this.eventRenderer.rowStructs[row];
        var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
        var col = 0; // col #, left-to-right (not chronologically)
        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
        var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
        var i, seg;
        var segsBelow; // array of segment objects below `seg` in the current `col`
        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
        var td, rowspan;
        var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
        var j;
        var moreTd, moreWrap, moreLink;
        // Iterates through empty level cells and places "more" links inside if need be
        var emptyCellsUntil = function (endCol) {
            while (col < endCol) {
                segsBelow = _this.getCellSegs(row, col, levelLimit);
                if (segsBelow.length) {
                    td = cellMatrix[levelLimit - 1][col];
                    moreLink = _this.renderMoreLink(row, col, segsBelow);
                    moreWrap = $('<div/>').append(moreLink);
                    td.append(moreWrap);
                    moreNodes.push(moreWrap[0]);
                }
                col++;
            }
        };
        if (levelLimit && levelLimit < rowStruct.segLevels.length) {
            levelSegs = rowStruct.segLevels[levelLimit - 1];
            cellMatrix = rowStruct.cellMatrix;
            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
                .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array
            // iterate though segments in the last allowable level
            for (i = 0; i < levelSegs.length; i++) {
                seg = levelSegs[i];
                emptyCellsUntil(seg.leftCol); // process empty cells before the segment
                // determine *all* segments below `seg` that occupy the same columns
                colSegsBelow = [];
                totalSegsBelow = 0;
                while (col <= seg.rightCol) {
                    segsBelow = this.getCellSegs(row, col, levelLimit);
                    colSegsBelow.push(segsBelow);
                    totalSegsBelow += segsBelow.length;
                    col++;
                }
                if (totalSegsBelow) {
                    td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
                    rowspan = td.attr('rowspan') || 1;
                    segMoreNodes = [];
                    // make a replacement <td> for each column the segment occupies. will be one for each colspan
                    for (j = 0; j < colSegsBelow.length; j++) {
                        moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
                        segsBelow = colSegsBelow[j];
                        moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                        );
                        moreWrap = $('<div/>').append(moreLink);
                        moreTd.append(moreWrap);
                        segMoreNodes.push(moreTd[0]);
                        moreNodes.push(moreTd[0]);
                    }
                    td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
                    limitedNodes.push(td[0]);
                }
            }
            emptyCellsUntil(this.colCnt); // finish off the level
            rowStruct.moreEls = $(moreNodes); // for easy undoing later
            rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
        }
    };
    // Reveals all levels and removes all "more"-related elements for a grid's row.
    // `row` is a row number.
    DayGrid.prototype.unlimitRow = function (row) {
        var rowStruct = this.eventRenderer.rowStructs[row];
        if (rowStruct.moreEls) {
            rowStruct.moreEls.remove();
            rowStruct.moreEls = null;
        }
        if (rowStruct.limitedEls) {
            rowStruct.limitedEls.removeClass('fc-limited');
            rowStruct.limitedEls = null;
        }
    };
    // Renders an <a> element that represents hidden event element for a cell.
    // Responsible for attaching click handler as well.
    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
        var _this = this;
        var view = this.view;
        return $('<a class="fc-more"/>')
            .text(this.getMoreLinkText(hiddenSegs.length))
            .on('click', function (ev) {
            var clickOption = _this.opt('eventLimitClick');
            var date = _this.getCellDate(row, col);
            var moreEl = $(ev.currentTarget);
            var dayEl = _this.getCellEl(row, col);
            var allSegs = _this.getCellSegs(row, col);
            // rescope the segments to be within the cell's date
            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
            if (typeof clickOption === 'function') {
                // the returned value can be an atomic option
                clickOption = _this.publiclyTrigger('eventLimitClick', {
                    context: view,
                    args: [
                        {
                            date: date.clone(),
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs
                        },
                        ev,
                        view
                    ]
                });
            }
            if (clickOption === 'popover') {
                _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
            }
            else if (typeof clickOption === 'string') {
                view.calendar.zoomTo(date, clickOption);
            }
        });
    };
    // Reveals the popover that displays all events within a cell
    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
        var _this = this;
        var view = this.view;
        var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
        var topEl; // the element we want to match the top coordinate of
        var options;
        if (this.rowCnt == 1) {
            topEl = view.el; // will cause the popover to cover any sort of header
        }
        else {
            topEl = this.rowEls.eq(row); // will align with top of row
        }
        options = {
            className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),
            content: this.renderSegPopoverContent(row, col, segs),
            parentEl: view.el,
            top: topEl.offset().top,
            autoHide: true,
            viewportConstrain: this.opt('popoverViewportConstrain'),
            hide: function () {
                // kill everything when the popover is hidden
                // notify events to be removed
                if (_this.popoverSegs) {
                    _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);
                }
                _this.segPopover.removeElement();
                _this.segPopover = null;
                _this.popoverSegs = null;
            }
        };
        // Determine horizontal coordinate.
        // We use the moreWrap instead of the <td> to avoid border confusion.
        if (this.isRTL) {
            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
        }
        else {
            options.left = moreWrap.offset().left - 1; // -1 to be over cell border
        }
        this.segPopover = new Popover_1.default(options);
        this.segPopover.show();
        // the popover doesn't live within the grid's container element, and thus won't get the event
        // delegated-handlers for free. attach event-related handlers to the popover.
        this.bindAllSegHandlersToEl(this.segPopover.el);
        this.triggerAfterEventSegsRendered(segs);
    };
    // Builds the inner DOM contents of the segment popover
    DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {
        var view = this.view;
        var theme = view.calendar.theme;
        var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));
        var content = $('<div class="fc-header ' + theme.getClass('popoverHeader') + '">' +
            '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' +
            '<span class="fc-title">' +
            util_1.htmlEscape(title) +
            '</span>' +
            '<div class="fc-clear"/>' +
            '</div>' +
            '<div class="fc-body ' + theme.getClass('popoverContent') + '">' +
            '<div class="fc-event-container"></div>' +
            '</div>');
        var segContainer = content.find('.fc-event-container');
        var i;
        // render each seg's `el` and only return the visible segs
        segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true
        this.popoverSegs = segs;
        for (i = 0; i < segs.length; i++) {
            // because segments in the popover are not part of a grid coordinate system, provide a hint to any
            // grids that want to do drag-n-drop about which cell it came from
            this.hitsNeeded();
            segs[i].hit = this.getCellHit(row, col);
            this.hitsNotNeeded();
            segContainer.append(segs[i].el);
        }
        return content;
    };
    // Given the events within an array of segment objects, reslice them to be in a single day
    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
        var dayStart = dayDate.clone();
        var dayEnd = dayStart.clone().add(1, 'days');
        var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);
        var newSegs = [];
        var i, seg;
        var slicedRange;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);
            if (slicedRange) {
                newSegs.push($.extend({}, seg, {
                    footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),
                    isStart: seg.isStart && slicedRange.isStart,
                    isEnd: seg.isEnd && slicedRange.isEnd
                }));
            }
        }
        // force an order because eventsToSegs doesn't guarantee one
        // TODO: research if still needed
        this.eventRenderer.sortEventSegs(newSegs);
        return newSegs;
    };
    // Generates the text that should be inside a "more" link, given the number of events it represents
    DayGrid.prototype.getMoreLinkText = function (num) {
        var opt = this.opt('eventLimitText');
        if (typeof opt === 'function') {
            return opt(num);
        }
        else {
            return '+' + num + ' ' + opt;
        }
    };
    // Returns segments within a given cell.
    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
        var level = startLevel || 0;
        var segs = [];
        var seg;
        while (level < segMatrix.length) {
            seg = segMatrix[level][col];
            if (seg) {
                segs.push(seg);
            }
            level++;
        }
        return segs;
    };
    return DayGrid;
}(InteractiveDateComponent_1.default));
exports.default = DayGrid;
DayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;
DayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
DayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;
DayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(DayGrid);
DayTableMixin_1.default.mixInto(DayGrid);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Scroller_1 = __webpack_require__(28);
var View_1 = __webpack_require__(30);
var BasicViewDateProfileGenerator_1 = __webpack_require__(69);
var DayGrid_1 = __webpack_require__(46);
/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
var BasicView = /** @class */ (function (_super) {
    tslib_1.__extends(BasicView, _super);
    function BasicView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.dayGrid = _this.instantiateDayGrid();
        _this.dayGrid.isRigid = _this.hasRigidRows();
        if (_this.opt('weekNumbers')) {
            if (_this.opt('weekNumbersWithinDays')) {
                _this.dayGrid.cellWeekNumbersVisible = true;
                _this.dayGrid.colWeekNumbersVisible = false;
            }
            else {
                _this.dayGrid.cellWeekNumbersVisible = false;
                _this.dayGrid.colWeekNumbersVisible = true;
            }
            ;
        }
        _this.addChild(_this.dayGrid);
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Generates the DayGrid object this view needs. Draws from this.dayGridClass
    BasicView.prototype.instantiateDayGrid = function () {
        // generate a subclass on the fly with BasicView-specific behavior
        // TODO: cache this subclass
        var subclass = makeDayGridSubclass(this.dayGridClass);
        return new subclass(this);
    };
    BasicView.prototype.executeDateRender = function (dateProfile) {
        this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);
        _super.prototype.executeDateRender.call(this, dateProfile);
    };
    BasicView.prototype.renderSkeleton = function () {
        var dayGridContainerEl;
        var dayGridEl;
        this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
        dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
        this.el.find('.fc-body > tr > td').append(dayGridContainerEl);
        this.dayGrid.headContainerEl = this.el.find('.fc-head-container');
        this.dayGrid.setElement(dayGridEl);
    };
    BasicView.prototype.unrenderSkeleton = function () {
        this.dayGrid.removeElement();
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid component will render inside of a container defined by this HTML.
    BasicView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '"></td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the week number column, if it is known
    BasicView.prototype.weekNumberStyleAttr = function () {
        if (this.weekNumberWidth != null) {
            return 'style="width:' + this.weekNumberWidth + 'px"';
        }
        return '';
    };
    // Determines whether each row should have a constant height
    BasicView.prototype.hasRigidRows = function () {
        var eventLimit = this.opt('eventLimit');
        return eventLimit && typeof eventLimit !== 'number';
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Refreshes the horizontal dimensions of the view
    BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit = this.opt('eventLimit');
        var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');
        var scrollerHeight;
        var scrollbarWidths;
        // hack to give the view some height prior to dayGrid's columns being rendered
        // TODO: separate setting height from scroller VS dayGrid.
        if (!this.dayGrid.rowEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        if (this.dayGrid.colWeekNumbersVisible) {
            // Make sure all week number cells running down the side have the same width.
            // Record the width for cells created later.
            this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));
        }
        // reset all heights to be natural
        this.scroller.clear();
        util_1.uncompensateScroll(headRowEl);
        this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
        // is the event limit a constant level number?
        if (eventLimit && typeof eventLimit === 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
        }
        // distribute the height to the rows
        // (totalHeight is a "recommended" value if isAuto)
        scrollerHeight = this.computeScrollerHeight(totalHeight);
        this.setGridHeight(scrollerHeight, isAuto);
        // is the event limit dynamically calculated?
        if (eventLimit && typeof eventLimit !== 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
        }
        if (!isAuto) {
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) {
                util_1.compensateScroll(headRowEl, scrollbarWidths);
                // doing the scrollbar compensation might have created text overflow which created more height. redo
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    BasicView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    // Sets the height of just the DayGrid component in this view
    BasicView.prototype.setGridHeight = function (height, isAuto) {
        if (isAuto) {
            util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
        }
        else {
            util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
        }
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    BasicView.prototype.computeInitialDateScroll = function () {
        return { top: 0 };
    };
    BasicView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    BasicView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    return BasicView;
}(View_1.default));
exports.default = BasicView;
BasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;
BasicView.prototype.dayGridClass = DayGrid_1.default;
// customize the rendering behavior of BasicView's dayGrid
function makeDayGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colWeekNumbersVisible = false; // display week numbers along the side?
            return _this;
        }
        // Generates the HTML that will go before the day-of week header cells
        SubClass.prototype.renderHeadIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<th class="fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '" ' + view.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    util_1.htmlEscape(this.opt('weekNumberTitle')) +
                    '</span>' +
                    '</th>';
            }
            return '';
        };
        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
        SubClass.prototype.renderNumberIntroHtml = function (row) {
            var view = this.view;
            var weekStart = this.getCellDate(row, 0);
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                    { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML
                    ) +
                    '</td>';
            }
            return '';
        };
        // Generates the HTML that goes before the day bg cells for each day-row
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '" ' +
                    view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        // Generates the HTML that goes before every other type of row generated by DayGrid.
        // Affects helper-skeleton and highlight-skeleton rows.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        SubClass.prototype.getIsNumbersVisible = function () {
            return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;
        };
        return SubClass;
    }(SuperClass));
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var Iterator_1 = __webpack_require__(74);
var GlobalEmitter_1 = __webpack_require__(14);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var Toolbar_1 = __webpack_require__(75);
var OptionsManager_1 = __webpack_require__(76);
var ViewSpecManager_1 = __webpack_require__(77);
var Constraints_1 = __webpack_require__(49);
var locale_1 = __webpack_require__(20);
var moment_ext_1 = __webpack_require__(9);
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var EventDateProfile_1 = __webpack_require__(15);
var EventManager_1 = __webpack_require__(78);
var BusinessHourGenerator_1 = __webpack_require__(54);
var EventSourceParser_1 = __webpack_require__(25);
var EventDefParser_1 = __webpack_require__(33);
var SingleEventDef_1 = __webpack_require__(11);
var EventDefMutation_1 = __webpack_require__(26);
var EventSource_1 = __webpack_require__(5);
var ThemeRegistry_1 = __webpack_require__(36);
var Calendar = /** @class */ (function () {
    function Calendar(el, overrides) {
        this.loadingLevel = 0; // number of simultaneous loading tasks
        this.ignoreUpdateViewSize = 0;
        this.freezeContentHeightDepth = 0;
        // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
        // unneeded() is called in destroy.
        GlobalEmitter_1.default.needed();
        this.el = el;
        this.viewsByType = {};
        this.optionsManager = new OptionsManager_1.default(this, overrides);
        this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);
        this.initMomentInternals(); // needs to happen after options hash initialized
        this.initCurrentDate();
        this.initEventManager();
        this.constraints = new Constraints_1.default(this.eventManager, this);
        this.constructed();
    }
    // useful for monkeypatching. used?
    Calendar.prototype.constructed = function () {
    };
    Calendar.prototype.getView = function () {
        return this.view;
    };
    Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {
        var optHandler = this.opt(name);
        var context;
        var args;
        if ($.isPlainObject(triggerInfo)) {
            context = triggerInfo.context;
            args = triggerInfo.args;
        }
        else if ($.isArray(triggerInfo)) {
            args = triggerInfo;
        }
        if (context == null) {
            context = this.el[0]; // fallback context
        }
        if (!args) {
            args = [];
        }
        this.triggerWith(name, context, args); // Emitter's method
        if (optHandler) {
            return optHandler.apply(context, args);
        }
    };
    Calendar.prototype.hasPublicHandlers = function (name) {
        return this.hasHandlers(name) ||
            this.opt(name); // handler specified in options
    };
    // Options Public API
    // -----------------------------------------------------------------------------------------------------------------
    // public getter/setter
    Calendar.prototype.option = function (name, value) {
        var newOptionHash;
        if (typeof name === 'string') {
            if (value === undefined) {
                return this.optionsManager.get(name);
            }
            else {
                newOptionHash = {};
                newOptionHash[name] = value;
                this.optionsManager.add(newOptionHash);
            }
        }
        else if (typeof name === 'object') {
            this.optionsManager.add(name);
        }
    };
    // private getter
    Calendar.prototype.opt = function (name) {
        return this.optionsManager.get(name);
    };
    // View
    // -----------------------------------------------------------------------------------------------------------------
    // Given a view name for a custom view or a standard view, creates a ready-to-go View object
    Calendar.prototype.instantiateView = function (viewType) {
        var spec = this.viewSpecManager.getViewSpec(viewType);
        return new spec['class'](this, spec);
    };
    // Returns a boolean about whether the view is okay to instantiate at some point
    Calendar.prototype.isValidViewType = function (viewType) {
        return Boolean(this.viewSpecManager.getViewSpec(viewType));
    };
    Calendar.prototype.changeView = function (viewName, dateOrRange) {
        if (dateOrRange) {
            if (dateOrRange.start && dateOrRange.end) {
                this.optionsManager.recordOverrides({
                    visibleRange: dateOrRange
                });
            }
            else {
                this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
            }
        }
        this.renderView(viewName);
    };
    // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    Calendar.prototype.zoomTo = function (newDate, viewType) {
        var spec;
        viewType = viewType || 'day'; // day is default zoom
        spec = this.viewSpecManager.getViewSpec(viewType) ||
            this.viewSpecManager.getUnitViewSpec(viewType);
        this.currentDate = newDate.clone();
        this.renderView(spec ? spec.type : null);
    };
    // Current Date
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initCurrentDate = function () {
        var defaultDateInput = this.opt('defaultDate');
        // compute the initial ambig-timezone date
        if (defaultDateInput != null) {
            this.currentDate = this.moment(defaultDateInput).stripZone();
        }
        else {
            this.currentDate = this.getNow(); // getNow already returns unzoned
        }
    };
    Calendar.prototype.prev = function () {
        var view = this.view;
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        if (prevInfo.isValid) {
            this.currentDate = prevInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.next = function () {
        var view = this.view;
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        if (nextInfo.isValid) {
            this.currentDate = nextInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.prevYear = function () {
        this.currentDate.add(-1, 'years');
        this.renderView();
    };
    Calendar.prototype.nextYear = function () {
        this.currentDate.add(1, 'years');
        this.renderView();
    };
    Calendar.prototype.today = function () {
        this.currentDate = this.getNow(); // should deny like prev/next?
        this.renderView();
    };
    Calendar.prototype.gotoDate = function (zonedDateInput) {
        this.currentDate = this.moment(zonedDateInput).stripZone();
        this.renderView();
    };
    Calendar.prototype.incrementDate = function (delta) {
        this.currentDate.add(moment.duration(delta));
        this.renderView();
    };
    // for external API
    Calendar.prototype.getDate = function () {
        return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
    };
    // Loading Triggering
    // -----------------------------------------------------------------------------------------------------------------
    // Should be called when any type of async data fetching begins
    Calendar.prototype.pushLoading = function () {
        if (!(this.loadingLevel++)) {
            this.publiclyTrigger('loading', [true, this.view]);
        }
    };
    // Should be called when any type of async data fetching completes
    Calendar.prototype.popLoading = function () {
        if (!(--this.loadingLevel)) {
            this.publiclyTrigger('loading', [false, this.view]);
        }
    };
    // High-level Rendering
    // -----------------------------------------------------------------------------------
    Calendar.prototype.render = function () {
        if (!this.contentEl) {
            this.initialRender();
        }
        else if (this.elementVisible()) {
            // mainly for the public API
            this.calcSize();
            this.updateViewSize();
        }
    };
    Calendar.prototype.initialRender = function () {
        var _this = this;
        var el = this.el;
        el.addClass('fc');
        // event delegation for nav links
        el.on('click.fc', 'a[data-goto]', function (ev) {
            var anchorEl = $(ev.currentTarget);
            var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
            var date = _this.moment(gotoOptions.date);
            var viewType = gotoOptions.type;
            // property like "navLinkDayClick". might be a string or a function
            var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');
            if (typeof customAction === 'function') {
                customAction(date, ev);
            }
            else {
                if (typeof customAction === 'string') {
                    viewType = customAction;
                }
                _this.zoomTo(date, viewType);
            }
        });
        // called immediately, and upon option change
        this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {
            var themeClass = ThemeRegistry_1.default.getThemeClass(opts.themeSystem || opts.theme);
            var theme = new themeClass(_this.optionsManager);
            var widgetClass = theme.getClass('widget');
            _this.theme = theme;
            if (widgetClass) {
                el.addClass(widgetClass);
            }
        }, function () {
            var widgetClass = _this.theme.getClass('widget');
            _this.theme = null;
            if (widgetClass) {
                el.removeClass(widgetClass);
            }
        });
        this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {
            _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);
            if (_this.view) {
                _this.view.set('businessHourGenerator', _this.businessHourGenerator);
            }
        }, function () {
            _this.businessHourGenerator = null;
        });
        // called immediately, and upon option change.
        // HACK: locale often affects isRTL, so we explicitly listen to that too.
        this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {
            el.toggleClass('fc-ltr', !opts.isRTL);
            el.toggleClass('fc-rtl', opts.isRTL);
        });
        this.contentEl = $("<div class='fc-view-container'/>").prependTo(el);
        this.initToolbars();
        this.renderHeader();
        this.renderFooter();
        this.renderView(this.opt('defaultView'));
        if (this.opt('handleWindowResize')) {
            $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls
            this.windowResize.bind(this), this.opt('windowResizeDelay')));
        }
    };
    Calendar.prototype.destroy = function () {
        if (this.view) {
            this.clearView();
        }
        this.toolbarsManager.proxyCall('removeElement');
        this.contentEl.remove();
        this.el.removeClass('fc fc-ltr fc-rtl');
        // removes theme-related root className
        this.optionsManager.unwatch('settingTheme');
        this.optionsManager.unwatch('settingBusinessHourGenerator');
        this.el.off('.fc'); // unbind nav link handlers
        if (this.windowResizeProxy) {
            $(window).unbind('resize', this.windowResizeProxy);
            this.windowResizeProxy = null;
        }
        GlobalEmitter_1.default.unneeded();
    };
    Calendar.prototype.elementVisible = function () {
        return this.el.is(':visible');
    };
    // Render Queue
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.bindViewHandlers = function (view) {
        var _this = this;
        view.watch('titleForCalendar', ['title'], function (deps) {
            if (view === _this.view) {
                _this.setToolbarsTitle(deps.title);
            }
        });
        view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {
            if (view === _this.view) {
                _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates
                _this.updateToolbarButtons(deps.dateProfile);
            }
        });
    };
    Calendar.prototype.unbindViewHandlers = function (view) {
        view.unwatch('titleForCalendar');
        view.unwatch('dateProfileForCalendar');
    };
    // View Rendering
    // -----------------------------------------------------------------------------------
    // Renders a view because of a date change, view-type change, or for the first time.
    // If not given a viewType, keep the current view but render different dates.
    // Accepts an optional scroll state to restore to.
    Calendar.prototype.renderView = function (viewType) {
        var oldView = this.view;
        var newView;
        this.freezeContentHeight();
        if (oldView && viewType && oldView.type !== viewType) {
            this.clearView();
        }
        // if viewType changed, or the view was never created, create a fresh view
        if (!this.view && viewType) {
            newView = this.view =
                this.viewsByType[viewType] ||
                    (this.viewsByType[viewType] = this.instantiateView(viewType));
            this.bindViewHandlers(newView);
            newView.startBatchRender(); // so that setElement+setDate rendering are joined
            newView.setElement($("<div class='fc-view fc-" + viewType + "-view' />").appendTo(this.contentEl));
            this.toolbarsManager.proxyCall('activateButton', viewType);
        }
        if (this.view) {
            // prevent unnecessary change firing
            if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {
                this.view.set('businessHourGenerator', this.businessHourGenerator);
            }
            this.view.setDate(this.currentDate);
            if (newView) {
                newView.stopBatchRender();
            }
        }
        this.thawContentHeight();
    };
    // Unrenders the current view and reflects this change in the Header.
    // Unregsiters the `view`, but does not remove from viewByType hash.
    Calendar.prototype.clearView = function () {
        var currentView = this.view;
        this.toolbarsManager.proxyCall('deactivateButton', currentView.type);
        this.unbindViewHandlers(currentView);
        currentView.removeElement();
        currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time
        this.view = null;
    };
    // Destroys the view, including the view object. Then, re-instantiates it and renders it.
    // Maintains the same scroll state.
    // TODO: maintain any other user-manipulated state.
    Calendar.prototype.reinitView = function () {
        var oldView = this.view;
        var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll
        this.freezeContentHeight();
        this.clearView();
        this.calcSize();
        this.renderView(oldView.type); // needs the type to freshly render
        this.view.applyScroll(scroll);
        this.thawContentHeight();
    };
    // Resizing
    // -----------------------------------------------------------------------------------
    Calendar.prototype.getSuggestedViewHeight = function () {
        if (this.suggestedViewHeight == null) {
            this.calcSize();
        }
        return this.suggestedViewHeight;
    };
    Calendar.prototype.isHeightAuto = function () {
        return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
    };
    Calendar.prototype.updateViewSize = function (isResize) {
        if (isResize === void 0) { isResize = false; }
        var view = this.view;
        var scroll;
        if (!this.ignoreUpdateViewSize && view) {
            if (isResize) {
                this.calcSize();
                scroll = view.queryScroll();
            }
            this.ignoreUpdateViewSize++;
            view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);
            this.ignoreUpdateViewSize--;
            if (isResize) {
                view.applyScroll(scroll);
            }
            return true; // signal success
        }
    };
    Calendar.prototype.calcSize = function () {
        if (this.elementVisible()) {
            this._calcSize();
        }
    };
    Calendar.prototype._calcSize = function () {
        var contentHeightInput = this.opt('contentHeight');
        var heightInput = this.opt('height');
        if (typeof contentHeightInput === 'number') {
            this.suggestedViewHeight = contentHeightInput;
        }
        else if (typeof contentHeightInput === 'function') {
            this.suggestedViewHeight = contentHeightInput();
        }
        else if (typeof heightInput === 'number') {
            this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
        }
        else if (typeof heightInput === 'function') {
            this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
        }
        else if (heightInput === 'parent') {
            this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
        }
        else {
            this.suggestedViewHeight = Math.round(this.contentEl.width() /
                Math.max(this.opt('aspectRatio'), .5));
        }
    };
    Calendar.prototype.windowResize = function (ev) {
        if (ev.target === window && // so we don't process jqui "resize" events that have bubbled up
            this.view &&
            this.view.isDatesRendered) {
            if (this.updateViewSize(true)) {
                this.publiclyTrigger('windowResize', [this.view]);
            }
        }
    };
    /* Height "Freezing"
    -----------------------------------------------------------------------------*/
    Calendar.prototype.freezeContentHeight = function () {
        if (!(this.freezeContentHeightDepth++)) {
            this.forceFreezeContentHeight();
        }
    };
    Calendar.prototype.forceFreezeContentHeight = function () {
        this.contentEl.css({
            width: '100%',
            height: this.contentEl.height(),
            overflow: 'hidden'
        });
    };
    Calendar.prototype.thawContentHeight = function () {
        this.freezeContentHeightDepth--;
        // always bring back to natural height
        this.contentEl.css({
            width: '',
            height: '',
            overflow: ''
        });
        // but if there are future thaws, re-freeze
        if (this.freezeContentHeightDepth) {
            this.forceFreezeContentHeight();
        }
    };
    // Toolbar
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initToolbars = function () {
        this.header = new Toolbar_1.default(this, this.computeHeaderOptions());
        this.footer = new Toolbar_1.default(this, this.computeFooterOptions());
        this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);
    };
    Calendar.prototype.computeHeaderOptions = function () {
        return {
            extraClasses: 'fc-header-toolbar',
            layout: this.opt('header')
        };
    };
    Calendar.prototype.computeFooterOptions = function () {
        return {
            extraClasses: 'fc-footer-toolbar',
            layout: this.opt('footer')
        };
    };
    // can be called repeatedly and Header will rerender
    Calendar.prototype.renderHeader = function () {
        var header = this.header;
        header.setToolbarOptions(this.computeHeaderOptions());
        header.render();
        if (header.el) {
            this.el.prepend(header.el);
        }
    };
    // can be called repeatedly and Footer will rerender
    Calendar.prototype.renderFooter = function () {
        var footer = this.footer;
        footer.setToolbarOptions(this.computeFooterOptions());
        footer.render();
        if (footer.el) {
            this.el.append(footer.el);
        }
    };
    Calendar.prototype.setToolbarsTitle = function (title) {
        this.toolbarsManager.proxyCall('updateTitle', title);
    };
    Calendar.prototype.updateToolbarButtons = function (dateProfile) {
        var now = this.getNow();
        var view = this.view;
        var todayInfo = view.dateProfileGenerator.build(now);
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?
            'enableButton' :
            'disableButton', 'today');
        this.toolbarsManager.proxyCall(prevInfo.isValid ?
            'enableButton' :
            'disableButton', 'prev');
        this.toolbarsManager.proxyCall(nextInfo.isValid ?
            'enableButton' :
            'disableButton', 'next');
    };
    Calendar.prototype.queryToolbarsHeight = function () {
        return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {
            var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
            return accumulator + toolbarHeight;
        }, 0);
    };
    // Selection
    // -----------------------------------------------------------------------------------------------------------------
    // this public method receives start/end dates in any format, with any timezone
    Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {
        this.view.select(this.buildSelectFootprint.apply(this, arguments));
    };
    Calendar.prototype.unselect = function () {
        if (this.view) {
            this.view.unselect();
        }
    };
    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
    Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {
        var start = this.moment(zonedStartInput).stripZone();
        var end;
        if (zonedEndInput) {
            end = this.moment(zonedEndInput).stripZone();
        }
        else if (start.hasTime()) {
            end = start.clone().add(this.defaultTimedEventDuration);
        }
        else {
            end = start.clone().add(this.defaultAllDayEventDuration);
        }
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());
    };
    // Date Utils
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initMomentInternals = function () {
        var _this = this;
        this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
        this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));
        // Called immediately, and when any of the options change.
        // Happens before any internal objects rebuild or rerender, because this is very core.
        this.optionsManager.watch('buildingMomentLocale', [
            '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
            '?firstDay', '?weekNumberCalculation'
        ], function (opts) {
            var weekNumberCalculation = opts.weekNumberCalculation;
            var firstDay = opts.firstDay;
            var _week;
            // normalize
            if (weekNumberCalculation === 'iso') {
                weekNumberCalculation = 'ISO'; // normalize
            }
            var localeData = Object.create(// make a cheap copy
            locale_1.getMomentLocaleData(opts.locale) // will fall back to en
            );
            if (opts.monthNames) {
                localeData._months = opts.monthNames;
            }
            if (opts.monthNamesShort) {
                localeData._monthsShort = opts.monthNamesShort;
            }
            if (opts.dayNames) {
                localeData._weekdays = opts.dayNames;
            }
            if (opts.dayNamesShort) {
                localeData._weekdaysShort = opts.dayNamesShort;
            }
            if (firstDay == null && weekNumberCalculation === 'ISO') {
                firstDay = 1;
            }
            if (firstDay != null) {
                _week = Object.create(localeData._week); // _week: { dow: # }
                _week.dow = firstDay;
                localeData._week = _week;
            }
            if (weekNumberCalculation === 'ISO' ||
                weekNumberCalculation === 'local' ||
                typeof weekNumberCalculation === 'function') {
                localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
            }
            _this.localeData = localeData;
            // If the internal current date object already exists, move to new locale.
            // We do NOT need to do this technique for event dates, because this happens when converting to "segments".
            if (_this.currentDate) {
                _this.localizeMoment(_this.currentDate); // sets to localeData
            }
        });
    };
    // Builds a moment using the settings of the current calendar: timezone and locale.
    // Accepts anything the vanilla moment() constructor accepts.
    Calendar.prototype.moment = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var mom;
        if (this.opt('timezone') === 'local') {
            mom = moment_ext_1.default.apply(null, args);
            // Force the moment to be local, because momentExt doesn't guarantee it.
            if (mom.hasTime()) {
                mom.local();
            }
        }
        else if (this.opt('timezone') === 'UTC') {
            mom = moment_ext_1.default.utc.apply(null, args); // process as UTC
        }
        else {
            mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone
        }
        this.localizeMoment(mom); // TODO
        return mom;
    };
    Calendar.prototype.msToMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        else {
            mom = this.applyTimezone(mom); // may or may not apply locale
        }
        this.localizeMoment(mom);
        return mom;
    };
    Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        this.localizeMoment(mom);
        return mom;
    };
    // Updates the given moment's locale settings to the current calendar locale settings.
    Calendar.prototype.localizeMoment = function (mom) {
        mom._locale = this.localeData;
    };
    // Returns a boolean about whether or not the calendar knows how to calculate
    // the timezone offset of arbitrary dates in the current timezone.
    Calendar.prototype.getIsAmbigTimezone = function () {
        return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
    };
    // Returns a copy of the given date in the current timezone. Has no effect on dates without times.
    Calendar.prototype.applyTimezone = function (date) {
        if (!date.hasTime()) {
            return date.clone();
        }
        var zonedDate = this.moment(date.toArray());
        var timeAdjust = date.time() - zonedDate.time();
        var adjustedZonedDate;
        // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
        if (timeAdjust) {
            adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
            if (date.time() - adjustedZonedDate.time() === 0) {
                zonedDate = adjustedZonedDate;
            }
        }
        return zonedDate;
    };
    /*
    Assumes the footprint is non-open-ended.
    */
    Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);
        var end;
        if (!ignoreEnd) {
            end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);
        }
        if (componentFootprint.isAllDay) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else {
            start = this.applyTimezone(start);
            if (end) {
                end = this.applyTimezone(end);
            }
        }
        return new EventDateProfile_1.default(start, end, this);
    };
    // Returns a moment for the current date, as defined by the client's computer or from the `now` option.
    // Will return an moment with an ambiguous timezone.
    Calendar.prototype.getNow = function () {
        var now = this.opt('now');
        if (typeof now === 'function') {
            now = now();
        }
        return this.moment(now).stripZone();
    };
    // Produces a human-readable string for the given duration.
    // Side-effect: changes the locale of the given duration.
    Calendar.prototype.humanizeDuration = function (duration) {
        return duration.locale(this.opt('locale')).humanize();
    };
    // will return `null` if invalid range
    Calendar.prototype.parseUnzonedRange = function (rangeInput) {
        var start = null;
        var end = null;
        if (rangeInput.start) {
            start = this.moment(rangeInput.start).stripZone();
        }
        if (rangeInput.end) {
            end = this.moment(rangeInput.end).stripZone();
        }
        if (!start && !end) {
            return null;
        }
        if (start && end && end.isBefore(start)) {
            return null;
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Event-Date Utilities
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initEventManager = function () {
        var _this = this;
        var eventManager = new EventManager_1.default(this);
        var rawSources = this.opt('eventSources') || [];
        var singleRawSource = this.opt('events');
        this.eventManager = eventManager;
        if (singleRawSource) {
            rawSources.unshift(singleRawSource);
        }
        eventManager.on('release', function (eventsPayload) {
            _this.trigger('eventsReset', eventsPayload);
        });
        eventManager.freeze();
        rawSources.forEach(function (rawSource) {
            var source = EventSourceParser_1.default.parse(rawSource, _this);
            if (source) {
                eventManager.addSource(source);
            }
        });
        eventManager.thaw();
    };
    Calendar.prototype.requestEvents = function (start, end) {
        return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));
    };
    // Get an event's normalized end date. If not present, calculate it from the defaults.
    Calendar.prototype.getEventEnd = function (event) {
        if (event.end) {
            return event.end.clone();
        }
        else {
            return this.getDefaultEventEnd(event.allDay, event.start);
        }
    };
    // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd
    Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {
        var end = zonedStart.clone();
        if (allDay) {
            end.stripTime().add(this.defaultAllDayEventDuration);
        }
        else {
            end.add(this.defaultTimedEventDuration);
        }
        if (this.getIsAmbigTimezone()) {
            end.stripZone(); // we don't know what the tzo should be
        }
        return end;
    };
    // Public Events API
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.rerenderEvents = function () {
        this.view.flash('displayingEvents');
    };
    Calendar.prototype.refetchEvents = function () {
        this.eventManager.refetchAllSources();
    };
    Calendar.prototype.renderEvents = function (eventInputs, isSticky) {
        this.eventManager.freeze();
        for (var i = 0; i < eventInputs.length; i++) {
            this.renderEvent(eventInputs[i], isSticky);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.renderEvent = function (eventInput, isSticky) {
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);
        if (eventDef) {
            eventManager.addEventDef(eventDef, isSticky);
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.removeEvents = function (legacyQuery) {
        var eventManager = this.eventManager;
        var legacyInstances = [];
        var idMap = {};
        var eventDef;
        var i;
        if (legacyQuery == null) {
            eventManager.removeAllEventDefs(true); // persist=true
        }
        else {
            eventManager.getEventInstances().forEach(function (eventInstance) {
                legacyInstances.push(eventInstance.toLegacy());
            });
            legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);
            // compute unique IDs
            for (i = 0; i < legacyInstances.length; i++) {
                eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);
                idMap[eventDef.id] = true;
            }
            eventManager.freeze();
            for (i in idMap) {
                eventManager.removeEventDefsById(i, true); // persist=true
            }
            eventManager.thaw();
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.clientEvents = function (legacyQuery) {
        var legacyEventInstances = [];
        this.eventManager.getEventInstances().forEach(function (eventInstance) {
            legacyEventInstances.push(eventInstance.toLegacy());
        });
        return filterLegacyEventInstances(legacyEventInstances, legacyQuery);
    };
    Calendar.prototype.updateEvents = function (eventPropsArray) {
        this.eventManager.freeze();
        for (var i = 0; i < eventPropsArray.length; i++) {
            this.updateEvent(eventPropsArray[i]);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.updateEvent = function (eventProps) {
        var eventDef = this.eventManager.getEventDefByUid(eventProps._id);
        var eventInstance;
        var eventDefMutation;
        if (eventDef instanceof SingleEventDef_1.default) {
            eventInstance = eventDef.buildInstance();
            eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props
            null // largeUnit -- who uses it?
            );
            this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release
        }
    };
    // Public Event Sources API
    // ------------------------------------------------------------------------------------
    Calendar.prototype.getEventSources = function () {
        return this.eventManager.otherSources.slice(); // clone
    };
    Calendar.prototype.getEventSourceById = function (id) {
        return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));
    };
    Calendar.prototype.addEventSource = function (sourceInput) {
        var source = EventSourceParser_1.default.parse(sourceInput, this);
        if (source) {
            this.eventManager.addSource(source);
        }
    };
    Calendar.prototype.removeEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources;
        var i;
        if (sourceMultiQuery == null) {
            this.eventManager.removeAllSources();
        }
        else {
            sources = eventManager.multiQuerySources(sourceMultiQuery);
            eventManager.freeze();
            for (i = 0; i < sources.length; i++) {
                eventManager.removeSource(sources[i]);
            }
            eventManager.thaw();
        }
    };
    Calendar.prototype.removeEventSource = function (sourceQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.querySources(sourceQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.removeSource(sources[i]);
        }
        eventManager.thaw();
    };
    Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.multiQuerySources(sourceMultiQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.refetchSource(sources[i]);
        }
        eventManager.thaw();
    };
    return Calendar;
}());
exports.default = Calendar;
EmitterMixin_1.default.mixInto(Calendar);
ListenerMixin_1.default.mixInto(Calendar);
function filterLegacyEventInstances(legacyEventInstances, legacyQuery) {
    if (legacyQuery == null) {
        return legacyEventInstances;
    }
    else if ($.isFunction(legacyQuery)) {
        return legacyEventInstances.filter(legacyQuery);
    }
    else {
        legacyQuery += ''; // normalize to string
        return legacyEventInstances.filter(function (legacyEventInstance) {
            // soft comparison because id not be normalized to string
            return legacyEventInstance.id == legacyQuery ||
                legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match
        });
    }
}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var EventDefParser_1 = __webpack_require__(33);
var EventSource_1 = __webpack_require__(5);
var util_1 = __webpack_require__(23);
var Constraints = /** @class */ (function () {
    function Constraints(eventManager, _calendar) {
        this.eventManager = eventManager;
        this._calendar = _calendar;
    }
    Constraints.prototype.opt = function (name) {
        return this._calendar.opt(name);
    };
    /*
    determines if eventInstanceGroup is allowed,
    in relation to other EVENTS and business hours.
    */
    Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var eventDef = eventInstanceGroup.getEventDef();
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        var peerEventInstances = this.getPeerEventInstances(eventDef);
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var constraintVal = eventDef.getConstraint();
        var overlapVal = eventDef.getOverlap();
        var eventAllowFunc = this.opt('eventAllow');
        for (i = 0; i < eventFootprints.length; i++) {
            if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {
                return false;
            }
        }
        if (eventAllowFunc) {
            for (i = 0; i < eventFootprints.length; i++) {
                if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {
                    return false;
                }
            }
        }
        return true;
    };
    Constraints.prototype.getPeerEventInstances = function (eventDef) {
        return this.eventManager.getEventInstancesWithoutId(eventDef.id);
    };
    Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        var peerEventInstances = this.eventManager.getEventInstances();
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var selectAllowFunc;
        if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {
            selectAllowFunc = this.opt('selectAllow');
            if (selectAllowFunc) {
                return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional
    ) {
        var constraintFootprints; // ComponentFootprint[]
        var overlapEventFootprints; // EventFootprint[]
        if (constraintVal != null) {
            constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);
            if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {
                return false;
            }
        }
        overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);
        if (overlapVal === false) {
            if (overlapEventFootprints.length) {
                return false;
            }
        }
        else if (typeof overlapVal === 'function') {
            if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {
                return false;
            }
        }
        if (subjectEventInstance) {
            if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {
                return false;
            }
        }
        return true;
    };
    // Constraint
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {
        var i;
        for (i = 0; i < constraintFootprints.length; i++) {
            if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {
        var eventInstances;
        if (constraintVal === 'businessHours') {
            return this.buildCurrentBusinessFootprints(isAllDay);
        }
        else if (typeof constraintVal === 'object') {
            eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events
            if (!eventInstances) {
                return this.parseFootprints(constraintVal);
            }
            else {
                return this.eventInstancesToFootprints(eventInstances);
            }
        }
        else if (constraintVal != null) {
            eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);
            return this.eventInstancesToFootprints(eventInstances);
        }
    };
    // returns ComponentFootprint[]
    // uses current view's range
    Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {
        var view = this._calendar.view;
        var businessHourGenerator = view.get('businessHourGenerator');
        var unzonedRange = view.dateProfile.activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);
        if (eventInstanceGroup) {
            return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);
        }
        else {
            return [];
        }
    };
    // conversion util
    Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {
        var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);
        var eventFootprints = this.eventRangesToEventFootprints(eventRanges);
        return eventFootprints.map(util_1.eventFootprintToComponentFootprint);
    };
    // Overlap
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {
        var overlapEventFootprints = [];
        var i;
        for (i = 0; i < peerEventFootprints.length; i++) {
            if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {
                overlapEventFootprints.push(peerEventFootprints[i]);
            }
        }
        return overlapEventFootprints;
    };
    // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints
    // ------------------------------------------------------------------------------------------------
    // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to
    // constraints whereas the Grid code is related to rendering. Each approach might want to convert
    // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make
    // this more DRY.
    /*
    Returns false on invalid input.
    */
    Constraints.prototype.parseEventDefToInstances = function (eventInput) {
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));
        if (!eventDef) {
            return false;
        }
        return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);
    };
    Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var i;
        var eventFootprints = [];
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// footprints
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_1.eventRangeToEventFootprint(eventRange)];
    };
    /*
    Parses footprints directly.
    Very similar to EventDateProfile::parse :(
    */
    Constraints.prototype.parseFootprints = function (rawInput) {
        var start, end;
        if (rawInput.start) {
            start = this._calendar.moment(rawInput.start);
            if (!start.isValid()) {
                start = null;
            }
        }
        if (rawInput.end) {
            end = this._calendar.moment(rawInput.end);
            if (!end.isValid()) {
                end = null;
            }
        }
        return [
            new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay
            )
        ];
    };
    // Footprint Utils
    // ----------------------------------------------------------------------------------------
    Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {
        return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);
    };
    Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {
        return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);
    };
    return Constraints;
}());
exports.default = Constraints;
// optional subjectEventInstance
function isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {
    var i;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {
            return false;
        }
    }
    return true;
}
function isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {
    var subjectLegacyInstance = subjectEventInstance.toLegacy();
    var i;
    var overlapEventInstance;
    var overlapEventDef;
    var overlapVal;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        overlapEventInstance = overlapEventFootprints[i].eventInstance;
        overlapEventDef = overlapEventInstance.def;
        // don't need to pass in calendar, because don't want to consider global eventOverlap property,
        // because we already considered that earlier in the process.
        overlapVal = overlapEventDef.getOverlap();
        if (overlapVal === false) {
            return false;
        }
        else if (typeof overlapVal === 'function') {
            if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
    import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'
in class:
    applyProps: ParsableModelInterface['applyProps']
    applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']
    applyMiscProps: ParsableModelInterface['applyMiscProps']
    isStandardProp: ParsableModelInterface['isStandardProp']
    static defineStandardProps = ParsableModelMixin.defineStandardProps
    static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps
after class:
    ParsableModelMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var Mixin_1 = __webpack_require__(12);
var ParsableModelMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ParsableModelMixin, _super);
    function ParsableModelMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Returns true/false for success.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyProps = function (rawProps) {
        var standardPropMap = this.standardPropMap;
        var manualProps = {};
        var miscProps = {};
        var propName;
        for (propName in rawProps) {
            if (standardPropMap[propName] === true) {
                this[propName] = rawProps[propName];
            }
            else if (standardPropMap[propName] === false) {
                manualProps[propName] = rawProps[propName];
            }
            else {
                miscProps[propName] = rawProps[propName];
            }
        }
        this.applyMiscProps(miscProps);
        return this.applyManualStandardProps(manualProps);
    };
    /*
    If subclasses override, they must call this supermethod and return the boolean response.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {
        return true;
    };
    /*
    Can be called even after initial object creation.
    */
    ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {
        // subclasses can implement
    };
    /*
    TODO: why is this a method when defineStandardProps is static
    */
    ParsableModelMixin.prototype.isStandardProp = function (propName) {
        return propName in this.standardPropMap;
    };
    ParsableModelMixin.defineStandardProps = function (propDefs) {
        var proto = this.prototype;
        if (!proto.hasOwnProperty('standardPropMap')) {
            proto.standardPropMap = Object.create(proto.standardPropMap);
        }
        util_1.copyOwnProps(propDefs, proto.standardPropMap);
    };
    ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {
        var map = this.prototype.standardPropMap;
        var propName;
        for (propName in map) {
            if (src[propName] != null && // in the src object?
                map[propName] === true // false means "copy verbatim"
            ) {
                dest[propName] = src[propName];
            }
        }
    };
    return ParsableModelMixin;
}(Mixin_1.default));
exports.default = ParsableModelMixin;
ParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps


/***/ }),
/* 51 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventInstance = /** @class */ (function () {
    function EventInstance(def, dateProfile) {
        this.def = def;
        this.dateProfile = dateProfile;
    }
    EventInstance.prototype.toLegacy = function () {
        var dateProfile = this.dateProfile;
        var obj = this.def.toLegacy();
        obj.start = dateProfile.start.clone();
        obj.end = dateProfile.end ? dateProfile.end.clone() : null;
        return obj;
    };
    return EventInstance;
}());
exports.default = EventInstance;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var EventDef_1 = __webpack_require__(22);
var EventInstance_1 = __webpack_require__(51);
var EventDateProfile_1 = __webpack_require__(15);
var RecurringEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(RecurringEventDef, _super);
    function RecurringEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RecurringEventDef.prototype.isAllDay = function () {
        return !this.startTime && !this.endTime;
    };
    RecurringEventDef.prototype.buildInstances = function (unzonedRange) {
        var calendar = this.source.calendar;
        var unzonedDate = unzonedRange.getStart();
        var unzonedEnd = unzonedRange.getEnd();
        var zonedDayStart;
        var instanceStart, instanceEnd;
        var instances = [];
        while (unzonedDate.isBefore(unzonedEnd)) {
            // if everyday, or this particular day-of-week
            if (!this.dowHash || this.dowHash[unzonedDate.day()]) {
                zonedDayStart = calendar.applyTimezone(unzonedDate);
                instanceStart = zonedDayStart.clone();
                instanceEnd = null;
                if (this.startTime) {
                    instanceStart.time(this.startTime);
                }
                else {
                    instanceStart.stripTime();
                }
                if (this.endTime) {
                    instanceEnd = zonedDayStart.clone().time(this.endTime);
                }
                instances.push(new EventInstance_1.default(this, // definition
                new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));
            }
            unzonedDate.add(1, 'days');
        }
        return instances;
    };
    RecurringEventDef.prototype.setDow = function (dowNumbers) {
        if (!this.dowHash) {
            this.dowHash = {};
        }
        for (var i = 0; i < dowNumbers.length; i++) {
            this.dowHash[dowNumbers[i]] = true;
        }
    };
    RecurringEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        if (def.startTime) {
            def.startTime = moment.duration(this.startTime);
        }
        if (def.endTime) {
            def.endTime = moment.duration(this.endTime);
        }
        if (this.dowHash) {
            def.dowHash = $.extend({}, this.dowHash);
        }
        return def;
    };
    return RecurringEventDef;
}(EventDef_1.default));
exports.default = RecurringEventDef;
/*
HACK to work with TypeScript mixins
NOTE: if super-method fails, should still attempt to apply
*/
RecurringEventDef.prototype.applyProps = function (rawProps) {
    var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);
    if (rawProps.start) {
        this.startTime = moment.duration(rawProps.start);
    }
    if (rawProps.end) {
        this.endTime = moment.duration(rawProps.end);
    }
    if (rawProps.dow) {
        this.setDow(rawProps.dow);
    }
    return superSuccess;
};
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
RecurringEventDef.defineStandardProps({
    start: false,
    end: false,
    dow: false
});


/***/ }),
/* 53 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange = /** @class */ (function () {
    function EventRange(unzonedRange, eventDef, eventInstance) {
        this.unzonedRange = unzonedRange;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    return EventRange;
}());
exports.default = EventRange;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(23);
var EventInstanceGroup_1 = __webpack_require__(17);
var RecurringEventDef_1 = __webpack_require__(52);
var EventSource_1 = __webpack_require__(5);
var BUSINESS_HOUR_EVENT_DEFAULTS = {
    start: '09:00',
    end: '17:00',
    dow: [1, 2, 3, 4, 5],
    rendering: 'inverse-background'
    // classNames are defined in businessHoursSegClasses
};
var BusinessHourGenerator = /** @class */ (function () {
    function BusinessHourGenerator(rawComplexDef, calendar) {
        this.rawComplexDef = rawComplexDef;
        this.calendar = calendar;
    }
    BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {
        var eventDefs = this.buildEventDefs(isAllDay);
        var eventInstanceGroup;
        if (eventDefs.length) {
            eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));
            // so that inverse-background rendering can happen even when no eventRanges in view
            eventInstanceGroup.explicitEventDef = eventDefs[0];
            return eventInstanceGroup;
        }
    };
    BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {
        var rawComplexDef = this.rawComplexDef;
        var rawDefs = [];
        var requireDow = false;
        var i;
        var defs = [];
        if (rawComplexDef === true) {
            rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim
        }
        else if ($.isPlainObject(rawComplexDef)) {
            rawDefs = [rawComplexDef];
        }
        else if ($.isArray(rawComplexDef)) {
            rawDefs = rawComplexDef;
            requireDow = true; // every sub-definition NEEDS a day-of-week
        }
        for (i = 0; i < rawDefs.length; i++) {
            if (!requireDow || rawDefs[i].dow) {
                defs.push(this.buildEventDef(isAllDay, rawDefs[i]));
            }
        }
        return defs;
    };
    BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {
        var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);
        if (isAllDay) {
            fullRawDef.start = null;
            fullRawDef.end = null;
        }
        return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source
        );
    };
    return BusinessHourGenerator;
}());
exports.default = BusinessHourGenerator;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Theme_1 = __webpack_require__(27);
var StandardTheme = /** @class */ (function (_super) {
    tslib_1.__extends(StandardTheme, _super);
    function StandardTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardTheme;
}(Theme_1.default));
exports.default = StandardTheme;
StandardTheme.prototype.classes = {
    widget: 'fc-unthemed',
    widgetHeader: 'fc-widget-header',
    widgetContent: 'fc-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'fc-button',
    cornerLeft: 'fc-corner-left',
    cornerRight: 'fc-corner-right',
    stateDefault: 'fc-state-default',
    stateActive: 'fc-state-active',
    stateDisabled: 'fc-state-disabled',
    stateHover: 'fc-state-hover',
    stateDown: 'fc-state-down',
    popoverHeader: 'fc-widget-header',
    popoverContent: 'fc-widget-content',
    // day grid
    headerRow: 'fc-widget-header',
    dayRow: 'fc-widget-content',
    // list view
    listView: 'fc-widget-content'
};
StandardTheme.prototype.baseIconClass = 'fc-icon';
StandardTheme.prototype.iconClasses = {
    close: 'fc-icon-x',
    prev: 'fc-icon-left-single-arrow',
    next: 'fc-icon-right-single-arrow',
    prevYear: 'fc-icon-left-double-arrow',
    nextYear: 'fc-icon-right-double-arrow'
};
StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Theme_1 = __webpack_require__(27);
var JqueryUiTheme = /** @class */ (function (_super) {
    tslib_1.__extends(JqueryUiTheme, _super);
    function JqueryUiTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JqueryUiTheme;
}(Theme_1.default));
exports.default = JqueryUiTheme;
JqueryUiTheme.prototype.classes = {
    widget: 'ui-widget',
    widgetHeader: 'ui-widget-header',
    widgetContent: 'ui-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'ui-button',
    cornerLeft: 'ui-corner-left',
    cornerRight: 'ui-corner-right',
    stateDefault: 'ui-state-default',
    stateActive: 'ui-state-active',
    stateDisabled: 'ui-state-disabled',
    stateHover: 'ui-state-hover',
    stateDown: 'ui-state-down',
    today: 'ui-state-highlight',
    popoverHeader: 'ui-widget-header',
    popoverContent: 'ui-widget-content',
    // day grid
    headerRow: 'ui-widget-header',
    dayRow: 'ui-widget-content',
    // list view
    listView: 'ui-widget-content'
};
JqueryUiTheme.prototype.baseIconClass = 'ui-icon';
JqueryUiTheme.prototype.iconClasses = {
    close: 'ui-icon-closethick',
    prev: 'ui-icon-circle-triangle-w',
    next: 'ui-icon-circle-triangle-e',
    prevYear: 'ui-icon-seek-prev',
    nextYear: 'ui-icon-seek-next'
};
JqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';
JqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';
JqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var Promise_1 = __webpack_require__(16);
var EventSource_1 = __webpack_require__(5);
var FuncEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(FuncEventSource, _super);
    function FuncEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FuncEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve) {
            _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {
                _this.calendar.popLoading();
                onResolve(_this.parseEventDefs(rawEventDefs));
            });
        });
    };
    FuncEventSource.prototype.getPrimitive = function () {
        return this.func;
    };
    FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.func = rawProps.events;
        return superSuccess;
    };
    FuncEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isFunction(rawInput.events)) {
            rawProps = rawInput;
        }
        else if ($.isFunction(rawInput)) {
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    return FuncEventSource;
}(EventSource_1.default));
exports.default = FuncEventSource;
FuncEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Promise_1 = __webpack_require__(16);
var EventSource_1 = __webpack_require__(5);
var JsonFeedEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(JsonFeedEventSource, _super);
    function JsonFeedEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        var ajaxSettings = this.ajaxSettings;
        var onSuccess = ajaxSettings.success;
        var onError = ajaxSettings.error;
        var requestParams = this.buildRequestParams(start, end, timezone);
        // todo: eventually handle the promise's then,
        // don't intercept success/error
        // tho will be a breaking API change
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve, onReject) {
            $.ajax($.extend({}, // destination
            JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {
                url: _this.url,
                data: requestParams,
                success: function (rawEventDefs, status, xhr) {
                    var callbackRes;
                    _this.calendar.popLoading();
                    if (rawEventDefs) {
                        callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`
                        if ($.isArray(callbackRes)) {
                            rawEventDefs = callbackRes;
                        }
                        onResolve(_this.parseEventDefs(rawEventDefs));
                    }
                    else {
                        onReject();
                    }
                },
                error: function (data, status, xhr) {
                    _this.calendar.popLoading();
                    util_1.applyAll(onError, _this, [data, status, xhr]); // redirect `this`
                    onReject();
                }
            }));
        });
    };
    JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {
        var calendar = this.calendar;
        var ajaxSettings = this.ajaxSettings;
        var startParam, endParam, timezoneParam;
        var customRequestParams;
        var params = {};
        startParam = this.startParam;
        if (startParam == null) {
            startParam = calendar.opt('startParam');
        }
        endParam = this.endParam;
        if (endParam == null) {
            endParam = calendar.opt('endParam');
        }
        timezoneParam = this.timezoneParam;
        if (timezoneParam == null) {
            timezoneParam = calendar.opt('timezoneParam');
        }
        // retrieve any outbound GET/POST $.ajax data from the options
        if ($.isFunction(ajaxSettings.data)) {
            // supplied as a function that returns a key/value object
            customRequestParams = ajaxSettings.data();
        }
        else {
            // probably supplied as a straight key/value object
            customRequestParams = ajaxSettings.data || {};
        }
        $.extend(params, customRequestParams);
        params[startParam] = start.format();
        params[endParam] = end.format();
        if (timezone && timezone !== 'local') {
            params[timezoneParam] = timezone;
        }
        return params;
    };
    JsonFeedEventSource.prototype.getPrimitive = function () {
        return this.url;
    };
    JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {
        this.ajaxSettings = rawProps;
    };
    JsonFeedEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if (typeof rawInput.url === 'string') {
            rawProps = rawInput;
        }
        else if (typeof rawInput === 'string') {
            rawProps = { url: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    JsonFeedEventSource.AJAX_DEFAULTS = {
        dataType: 'json',
        cache: false
    };
    return JsonFeedEventSource;
}(EventSource_1.default));
exports.default = JsonFeedEventSource;
JsonFeedEventSource.defineStandardProps({
    // automatically transfer (true)...
    url: true,
    startParam: true,
    endParam: true,
    timezoneParam: true
});


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EmitterMixin_1 = __webpack_require__(8);
var TaskQueue = /** @class */ (function () {
    function TaskQueue() {
        this.q = [];
        this.isPaused = false;
        this.isRunning = false;
    }
    TaskQueue.prototype.queue = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.q.push.apply(this.q, args); // append
        this.tryStart();
    };
    TaskQueue.prototype.pause = function () {
        this.isPaused = true;
    };
    TaskQueue.prototype.resume = function () {
        this.isPaused = false;
        this.tryStart();
    };
    TaskQueue.prototype.getIsIdle = function () {
        return !this.isRunning && !this.isPaused;
    };
    TaskQueue.prototype.tryStart = function () {
        if (!this.isRunning && this.canRunNext()) {
            this.isRunning = true;
            this.trigger('start');
            this.runRemaining();
        }
    };
    TaskQueue.prototype.canRunNext = function () {
        return !this.isPaused && this.q.length;
    };
    TaskQueue.prototype.runRemaining = function () {
        var _this = this;
        var task;
        var res;
        do {
            task = this.q.shift(); // always freshly reference q. might have been reassigned.
            res = this.runTask(task);
            if (res && res.then) {
                res.then(function () {
                    if (_this.canRunNext()) {
                        _this.runRemaining();
                    }
                });
                return; // prevent marking as stopped
            }
        } while (this.canRunNext());
        this.trigger('stop'); // not really a 'stop' ... more of a 'drained'
        this.isRunning = false;
        // if 'stop' handler added more tasks.... TODO: write test for this
        this.tryStart();
    };
    TaskQueue.prototype.runTask = function (task) {
        return task(); // task *is* the function, but subclasses can change the format of a task
    };
    return TaskQueue;
}());
exports.default = TaskQueue;
EmitterMixin_1.default.mixInto(TaskQueue);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TaskQueue_1 = __webpack_require__(59);
var RenderQueue = /** @class */ (function (_super) {
    tslib_1.__extends(RenderQueue, _super);
    function RenderQueue(waitsByNamespace) {
        var _this = _super.call(this) || this;
        _this.waitsByNamespace = waitsByNamespace || {};
        return _this;
    }
    RenderQueue.prototype.queue = function (taskFunc, namespace, type) {
        var task = {
            func: taskFunc,
            namespace: namespace,
            type: type
        };
        var waitMs;
        if (namespace) {
            waitMs = this.waitsByNamespace[namespace];
        }
        if (this.waitNamespace) {
            if (namespace === this.waitNamespace && waitMs != null) {
                this.delayWait(waitMs);
            }
            else {
                this.clearWait();
                this.tryStart();
            }
        }
        if (this.compoundTask(task)) {
            if (!this.waitNamespace && waitMs != null) {
                this.startWait(namespace, waitMs);
            }
            else {
                this.tryStart();
            }
        }
    };
    RenderQueue.prototype.startWait = function (namespace, waitMs) {
        this.waitNamespace = namespace;
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.delayWait = function (waitMs) {
        clearTimeout(this.waitId);
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.spawnWait = function (waitMs) {
        var _this = this;
        this.waitId = setTimeout(function () {
            _this.waitNamespace = null;
            _this.tryStart();
        }, waitMs);
    };
    RenderQueue.prototype.clearWait = function () {
        if (this.waitNamespace) {
            clearTimeout(this.waitId);
            this.waitId = null;
            this.waitNamespace = null;
        }
    };
    RenderQueue.prototype.canRunNext = function () {
        if (!_super.prototype.canRunNext.call(this)) {
            return false;
        }
        // waiting for a certain namespace to stop receiving tasks?
        if (this.waitNamespace) {
            // if there was a different namespace task in the meantime,
            // that forces all previously-waiting tasks to suddenly execute.
            // TODO: find a way to do this in constant time.
            for (var q = this.q, i = 0; i < q.length; i++) {
                if (q[i].namespace !== this.waitNamespace) {
                    return true; // allow execution
                }
            }
            return false;
        }
        return true;
    };
    RenderQueue.prototype.runTask = function (task) {
        task.func();
    };
    RenderQueue.prototype.compoundTask = function (newTask) {
        var q = this.q;
        var shouldAppend = true;
        var i, task;
        if (newTask.namespace && newTask.type === 'destroy') {
            // remove all init/add/remove ops with same namespace, regardless of order
            for (i = q.length - 1; i >= 0; i--) {
                task = q[i];
                switch (task.type) {
                    case 'init':
                        shouldAppend = false;
                    // the latest destroy is cancelled out by not doing the init
                    // and fallthrough....
                    case 'add':
                    case 'remove':
                        q.splice(i, 1); // remove task
                }
            }
        }
        if (shouldAppend) {
            q.push(newTask);
        }
        return shouldAppend;
    };
    return RenderQueue;
}(TaskQueue_1.default));
exports.default = RenderQueue;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var moment_ext_1 = __webpack_require__(9);
var date_formatting_1 = __webpack_require__(37);
var Component_1 = __webpack_require__(80);
var util_2 = __webpack_require__(23);
var DateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DateComponent, _super);
    function DateComponent(_view, _options) {
        var _this = _super.call(this) || this;
        _this.isRTL = false; // frequently accessed options
        _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits
        _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?
        _this.isDatesRendered = false;
        // hack to set options prior to the this.opt calls
        if (_view) {
            _this['view'] = _view;
        }
        if (_options) {
            _this['options'] = _options;
        }
        _this.uid = String(DateComponent.guid++);
        _this.childrenByUid = {};
        _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));
        _this.isRTL = _this.opt('isRTL');
        if (_this.fillRendererClass) {
            _this.fillRenderer = new _this.fillRendererClass(_this);
        }
        if (_this.eventRendererClass) {
            _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);
        }
        if (_this.helperRendererClass && _this.eventRenderer) {
            _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);
        }
        if (_this.businessHourRendererClass && _this.fillRenderer) {
            _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);
        }
        return _this;
    }
    DateComponent.prototype.addChild = function (child) {
        if (!this.childrenByUid[child.uid]) {
            this.childrenByUid[child.uid] = child;
            return true;
        }
        return false;
    };
    DateComponent.prototype.removeChild = function (child) {
        if (this.childrenByUid[child.uid]) {
            delete this.childrenByUid[child.uid];
            return true;
        }
        return false;
    };
    // TODO: only do if isInDom?
    // TODO: make part of Component, along with children/batch-render system?
    DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        this.callChildren('updateSize', arguments);
    };
    // Options
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.opt = function (name) {
        return this._getView().opt(name); // default implementation
    };
    DateComponent.prototype.publiclyTrigger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.publiclyTrigger.apply(calendar, args);
    };
    DateComponent.prototype.hasPublicHandlers = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.hasPublicHandlers.apply(calendar, args);
    };
    // Date
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeDateRender = function (dateProfile) {
        this.dateProfile = dateProfile; // for rendering
        this.renderDates(dateProfile);
        this.isDatesRendered = true;
        this.callChildren('executeDateRender', arguments);
    };
    DateComponent.prototype.executeDateUnrender = function () {
        this.callChildren('executeDateUnrender', arguments);
        this.dateProfile = null;
        this.unrenderDates();
        this.isDatesRendered = false;
    };
    // date-cell content only
    DateComponent.prototype.renderDates = function (dateProfile) {
        // subclasses should implement
    };
    // date-cell content only
    DateComponent.prototype.unrenderDates = function () {
        // subclasses should override
    };
    // Now-Indicator
    // -----------------------------------------------------------------------------------------------------------------
    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.
    DateComponent.prototype.getNowIndicatorUnit = function () {
        // subclasses should implement
    };
    // Renders a current time indicator at the given datetime
    DateComponent.prototype.renderNowIndicator = function (date) {
        this.callChildren('renderNowIndicator', arguments);
    };
    // Undoes the rendering actions from renderNowIndicator
    DateComponent.prototype.unrenderNowIndicator = function () {
        this.callChildren('unrenderNowIndicator', arguments);
    };
    // Business Hours
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {
        if (this.businessHourRenderer) {
            this.businessHourRenderer.render(businessHourGenerator);
        }
        this.callChildren('renderBusinessHours', arguments);
    };
    // Unrenders previously-rendered business-hours
    DateComponent.prototype.unrenderBusinessHours = function () {
        this.callChildren('unrenderBusinessHours', arguments);
        if (this.businessHourRenderer) {
            this.businessHourRenderer.unrender();
        }
    };
    // Event Displaying
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeEventRender = function (eventsPayload) {
        if (this.eventRenderer) {
            this.eventRenderer.rangeUpdated(); // poorly named now
            this.eventRenderer.render(eventsPayload);
        }
        else if (this['renderEvents']) {
            this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));
        }
        this.callChildren('executeEventRender', arguments);
    };
    DateComponent.prototype.executeEventUnrender = function () {
        this.callChildren('executeEventUnrender', arguments);
        if (this.eventRenderer) {
            this.eventRenderer.unrender();
        }
        else if (this['destroyEvents']) {
            this['destroyEvents']();
        }
    };
    DateComponent.prototype.getBusinessHourSegs = function () {
        var segs = this.getOwnBusinessHourSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getBusinessHourSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnBusinessHourSegs = function () {
        if (this.businessHourRenderer) {
            return this.businessHourRenderer.getSegs();
        }
        return [];
    };
    DateComponent.prototype.getEventSegs = function () {
        var segs = this.getOwnEventSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getEventSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnEventSegs = function () {
        if (this.eventRenderer) {
            return this.eventRenderer.getSegs();
        }
        return [];
    };
    // Event Rendering Triggering
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.triggerAfterEventsRendered = function () {
        this.triggerAfterEventSegsRendered(this.getEventSegs());
        this.publiclyTrigger('eventAfterAllRender', {
            context: this,
            args: [this]
        });
    };
    DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {
        var _this = this;
        // an optimization, because getEventLegacy is expensive
        if (this.hasPublicHandlers('eventAfterRender')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) {
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventAfterRender', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    DateComponent.prototype.triggerBeforeEventsDestroyed = function () {
        this.triggerBeforeEventSegsDestroyed(this.getEventSegs());
    };
    DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {
        var _this = this;
        if (this.hasPublicHandlers('eventDestroy')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) {
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventDestroy', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    // Event Rendering Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Hides all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.showEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', '');
            }
        });
        this.callChildren('showEventsWithId', arguments);
    };
    // Shows all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.hideEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', 'hidden');
            }
        });
        this.callChildren('hideEventsWithId', arguments);
    };
    // Drag-n-Drop Rendering (for both events and external elements)
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of a event or external-element drag over the given drop zone.
    // If an external-element, seg will be `null`.
    // Must return elements used for any mock events.
    DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var renderedHelper = false;
        this.iterChildren(function (child) {
            if (child.renderDrag(eventFootprints, seg, isTouch)) {
                renderedHelper = true;
            }
        });
        return renderedHelper;
    };
    // Unrenders a visual indication of an event or external-element being dragged.
    DateComponent.prototype.unrenderDrag = function () {
        this.callChildren('unrenderDrag', arguments);
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of an event being resized.
    DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.callChildren('renderEventResize', arguments);
    };
    // Unrenders a visual indication of an event being resized.
    DateComponent.prototype.unrenderEventResize = function () {
        this.callChildren('unrenderEventResize', arguments);
    };
    // Selection
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of the selection
    // TODO: rename to `renderSelection` after legacy is gone
    DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {
        this.renderHighlight(componentFootprint);
        this.callChildren('renderSelectionFootprint', arguments);
    };
    // Unrenders a visual indication of selection
    DateComponent.prototype.unrenderSelection = function () {
        this.unrenderHighlight();
        this.callChildren('unrenderSelection', arguments);
    };
    // Highlight
    // ---------------------------------------------------------------------------------------------------------------
    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
    DateComponent.prototype.renderHighlight = function (componentFootprint) {
        if (this.fillRenderer) {
            this.fillRenderer.renderFootprint('highlight', componentFootprint, {
                getClasses: function () {
                    return ['fc-highlight'];
                }
            });
        }
        this.callChildren('renderHighlight', arguments);
    };
    // Unrenders the emphasis on a date range
    DateComponent.prototype.unrenderHighlight = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('highlight');
        }
        this.callChildren('unrenderHighlight', arguments);
    };
    // Hit Areas
    // ---------------------------------------------------------------------------------------------------------------
    // just because all DateComponents support this interface
    // doesn't mean they need to have their own internal coord system. they can defer to sub-components.
    DateComponent.prototype.hitsNeeded = function () {
        if (!(this.hitsNeededDepth++)) {
            this.prepareHits();
        }
        this.callChildren('hitsNeeded', arguments);
    };
    DateComponent.prototype.hitsNotNeeded = function () {
        if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
            this.releaseHits();
        }
        this.callChildren('hitsNotNeeded', arguments);
    };
    DateComponent.prototype.prepareHits = function () {
        // subclasses can implement
    };
    DateComponent.prototype.releaseHits = function () {
        // subclasses can implement
    };
    // Given coordinates from the topleft of the document, return data about the date-related area underneath.
    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
    // Must have a `grid` property, a reference to this current grid. TODO: avoid this
    // The returned object will be processed by getHitFootprint and getHitEl.
    DateComponent.prototype.queryHit = function (leftOffset, topOffset) {
        var childrenByUid = this.childrenByUid;
        var uid;
        var hit;
        for (uid in childrenByUid) {
            hit = childrenByUid[uid].queryHit(leftOffset, topOffset);
            if (hit) {
                break;
            }
        }
        return hit;
    };
    DateComponent.prototype.getSafeHitFootprint = function (hit) {
        var footprint = this.getHitFootprint(hit);
        if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {
            return null;
        }
        return footprint;
    };
    DateComponent.prototype.getHitFootprint = function (hit) {
        // what about being abstract!?
    };
    // Given position-level information about a date-related area within the grid,
    // should return a jQuery element that best represents it. passed to dayClick callback.
    DateComponent.prototype.getHitEl = function (hit) {
        // what about being abstract!?
    };
    /* Converting eventRange -> eventFootprint
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var eventFootprints = [];
        var i;
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// append
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_2.eventRangeToEventFootprint(eventRange)];
    };
    /* Converting componentFootprint/eventFootprint -> segs
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {
        var segs = [];
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));
        }
        return segs;
    };
    // Given an event's span (unzoned start/end and other misc data), and the event itself,
    // slices into segments and attaches event-derived properties to them.
    // eventSpan - { start, end, isStart, isEnd, otherthings... }
    DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {
        var unzonedRange = eventFootprint.componentFootprint.unzonedRange;
        var segs;
        var i, seg;
        segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (!unzonedRange.isStart) {
                seg.isStart = false;
            }
            if (!unzonedRange.isEnd) {
                seg.isEnd = false;
            }
            seg.footprint = eventFootprint;
            // TODO: rename to seg.eventFootprint
        }
        return segs;
    };
    DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {
        return [];
    };
    // Utils
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.callChildren = function (methodName, args) {
        this.iterChildren(function (child) {
            child[methodName].apply(child, args);
        });
    };
    DateComponent.prototype.iterChildren = function (func) {
        var childrenByUid = this.childrenByUid;
        var uid;
        for (uid in childrenByUid) {
            func(childrenByUid[uid]);
        }
    };
    DateComponent.prototype._getCalendar = function () {
        var t = this;
        return t.calendar || t.view.calendar;
    };
    DateComponent.prototype._getView = function () {
        return this.view;
    };
    DateComponent.prototype._getDateProfile = function () {
        return this._getView().get('dateProfile');
    };
    // Generates HTML for an anchor to another view into the calendar.
    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
    // `gotoOptions` can either be a moment input, or an object with the form:
    // { date, type, forceOff }
    // `type` is a view-type like "day" or "week". default value is "day".
    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
    DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {
        var date, type, forceOff;
        var finalOptions;
        if ($.isPlainObject(gotoOptions)) {
            date = gotoOptions.date;
            type = gotoOptions.type;
            forceOff = gotoOptions.forceOff;
        }
        else {
            date = gotoOptions; // a single moment input
        }
        date = moment_ext_1.default(date); // if a string, parse it
        finalOptions = {
            date: date.format('YYYY-MM-DD'),
            type: type || 'day'
        };
        if (typeof attrs === 'string') {
            innerHtml = attrs;
            attrs = null;
        }
        attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space
        innerHtml = innerHtml || '';
        if (!forceOff && this.opt('navLinks')) {
            return '<a' + attrs +
                ' data-goto="' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '">' +
                innerHtml +
                '</a>';
        }
        else {
            return '<span' + attrs + '>' +
                innerHtml +
                '</span>';
        }
    };
    DateComponent.prototype.getAllDayHtml = function () {
        return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));
    };
    // Computes HTML classNames for a single-day element
    DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {
        var view = this._getView();
        var classes = [];
        var today;
        if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {
            classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
        }
        else {
            classes.push('fc-' + util_1.dayIDs[date.day()]);
            if (view.isDateInOtherMonth(date, this.dateProfile)) {
                classes.push('fc-other-month');
            }
            today = view.calendar.getNow();
            if (date.isSame(today, 'day')) {
                classes.push('fc-today');
                if (noThemeHighlight !== true) {
                    classes.push(view.calendar.theme.getClass('today'));
                }
            }
            else if (date < today) {
                classes.push('fc-past');
            }
            else {
                classes.push('fc-future');
            }
        }
        return classes;
    };
    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
    // The timezones of the dates within `range` will be respected.
    DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {
        var end = range.end;
        if (isAllDay) {
            end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
        }
        return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);
    };
    // Compute the number of the give units in the "current" range.
    // Will return a floating-point number. Won't round.
    DateComponent.prototype.currentRangeAs = function (unit) {
        return this._getDateProfile().currentUnzonedRange.as(unit);
    };
    // Returns the date range of the full days the given range visually appears to occupy.
    // Returns a plain object with start/end, NOT an UnzonedRange!
    DateComponent.prototype.computeDayRange = function (unzonedRange) {
        var calendar = this._getCalendar();
        var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts
        var end = calendar.msToUtcMoment(unzonedRange.endMs);
        var endTimeMS = +end.time(); // # of milliseconds into `endDay`
        var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
            endDay.add(1, 'days');
        }
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
        if (endDay <= startDay) {
            endDay = startDay.clone().add(1, 'days');
        }
        return { start: startDay, end: endDay };
    };
    // Does the given range visually appear to occupy more than one day?
    DateComponent.prototype.isMultiDayRange = function (unzonedRange) {
        var dayRange = this.computeDayRange(unzonedRange);
        return dayRange.end.diff(dayRange.start, 'days') > 1;
    };
    DateComponent.guid = 0; // TODO: better system for this?
    return DateComponent;
}(Component_1.default));
exports.default = DateComponent;
// legacy
function convertEventsPayloadToLegacyArray(eventsPayload) {
    var eventDefId;
    var eventInstances;
    var legacyEvents = [];
    var i;
    for (eventDefId in eventsPayload) {
        eventInstances = eventsPayload[eventDefId].eventInstances;
        for (i = 0; i < eventInstances.length; i++) {
            legacyEvents.push(eventInstances[i].toLegacy());
        }
    }
    return legacyEvents;
}


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(4);
var DateProfileGenerator = /** @class */ (function () {
    function DateProfileGenerator(_view) {
        this._view = _view;
    }
    DateProfileGenerator.prototype.opt = function (name) {
        return this._view.opt(name);
    };
    DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {
        return this._view.trimHiddenDays(unzonedRange);
    };
    DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {
        return this._view.calendar.msToUtcMoment(ms, forceAllDay);
    };
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds a structure with info about what the dates/ranges will be for the "prev" view.
    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {
        var prevDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .subtract(currentDateProfile.dateIncrement);
        return this.build(prevDate, -1);
    };
    // Builds a structure with info about what the dates/ranges will be for the "next" view.
    DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {
        var nextDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .add(currentDateProfile.dateIncrement);
        return this.build(nextDate, 1);
    };
    // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).
    DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {
        if (forceToValid === void 0) { forceToValid = false; }
        var isDateAllDay = !date.hasTime();
        var validUnzonedRange;
        var minTime = null;
        var maxTime = null;
        var currentInfo;
        var isRangeAllDay;
        var renderUnzonedRange;
        var activeUnzonedRange;
        var isValid;
        validUnzonedRange = this.buildValidRange();
        validUnzonedRange = this.trimHiddenDays(validUnzonedRange);
        if (forceToValid) {
            date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        currentInfo = this.buildCurrentRangeInfo(date, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);
        renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);
        activeUnzonedRange = renderUnzonedRange.clone();
        if (!this.opt('showNonCurrentDates')) {
            activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);
        }
        minTime = moment.duration(this.opt('minTime'));
        maxTime = moment.duration(this.opt('maxTime'));
        activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);
        activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null
        if (activeUnzonedRange) {
            date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.
        isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);
        return {
            // constraint for where prev/next operations can go and where events can be dragged/resized to.
            // an object with optional start and end properties.
            validUnzonedRange: validUnzonedRange,
            // range the view is formally responsible for.
            // for example, a month view might have 1st-31st, excluding padded dates
            currentUnzonedRange: currentInfo.unzonedRange,
            // name of largest unit being displayed, like "month" or "week"
            currentRangeUnit: currentInfo.unit,
            isRangeAllDay: isRangeAllDay,
            // dates that display events and accept drag-n-drop
            // will be `null` if no dates accept events
            activeUnzonedRange: activeUnzonedRange,
            // date range with a rendered skeleton
            // includes not-active days that need some sort of DOM
            renderUnzonedRange: renderUnzonedRange,
            // Duration object that denotes the first visible time of any given day
            minTime: minTime,
            // Duration object that denotes the exclusive visible end time of any given day
            maxTime: maxTime,
            isValid: isValid,
            date: date,
            // how far the current date will move for a prev/next operation
            dateIncrement: this.buildDateIncrement(currentInfo.duration)
            // pass a fallback (might be null) ^
        };
    };
    // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildValidRange = function () {
        return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||
            new UnzonedRange_1.default(); // completely open-ended
    };
    // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
        var viewSpec = this._view.viewSpec;
        var duration = null;
        var unit = null;
        var unzonedRange = null;
        var dayCount;
        if (viewSpec.duration) {
            duration = viewSpec.duration;
            unit = viewSpec.durationUnit;
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        else if ((dayCount = this.opt('dayCount'))) {
            unit = 'day';
            unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);
        }
        else if ((unzonedRange = this.buildCustomVisibleRange(date))) {
            unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());
        }
        else {
            duration = this.getFallbackDuration();
            unit = util_1.computeGreatestUnit(duration);
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        return { duration: duration, unit: unit, unzonedRange: unzonedRange };
    };
    DateProfileGenerator.prototype.getFallbackDuration = function () {
        return moment.duration({ days: 1 });
    };
    // Returns a new activeUnzonedRange to have time values (un-ambiguate)
    // minTime or maxTime causes the range to expand.
    DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {
        var start = unzonedRange.getStart();
        var end = unzonedRange.getEnd();
        if (this._view.usesMinMaxTime) {
            if (minTime < 0) {
                start.time(0).add(minTime);
            }
            if (maxTime > 24 * 60 * 60 * 1000) {
                end.time(maxTime - (24 * 60 * 60 * 1000));
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed computeGreatestUnit value of duration.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
        var alignment = this.opt('dateAlignment');
        var dateIncrementInput;
        var dateIncrementDuration;
        var start;
        var end;
        var res;
        // compute what the alignment should be
        if (!alignment) {
            dateIncrementInput = this.opt('dateIncrement');
            if (dateIncrementInput) {
                dateIncrementDuration = moment.duration(dateIncrementInput);
                // use the smaller of the two units
                if (dateIncrementDuration < duration) {
                    alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
                }
                else {
                    alignment = unit;
                }
            }
            else {
                alignment = unit;
            }
        }
        // if the view displays a single day or smaller
        if (duration.as('days') <= 1) {
            if (this._view.isHiddenDay(start)) {
                start = this._view.skipHiddenDays(start, direction);
                start.startOf('day');
            }
        }
        function computeRes() {
            start = date.clone().startOf(alignment);
            end = start.clone().add(duration);
            res = new UnzonedRange_1.default(start, end);
        }
        computeRes();
        // if range is completely enveloped by hidden days, go past the hidden days
        if (!this.trimHiddenDays(res)) {
            date = this._view.skipHiddenDays(date, direction);
            computeRes();
        }
        return res;
    };
    // Builds the "current" range when a dayCount is specified.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
        var customAlignment = this.opt('dateAlignment');
        var runningCount = 0;
        var start = date.clone();
        var end;
        if (customAlignment) {
            start.startOf(customAlignment);
        }
        start.startOf('day');
        start = this._view.skipHiddenDays(start, direction);
        end = start.clone();
        do {
            end.add(1, 'day');
            if (!this._view.isHiddenDay(end)) {
                runningCount++;
            }
        } while (runningCount < dayCount);
        return new UnzonedRange_1.default(start, end);
    };
    // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
        var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations
        );
        if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {
            return null;
        }
        return visibleUnzonedRange;
    };
    // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        return currentUnzonedRange.clone();
    };
    // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.
    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
        var dateIncrementInput = this.opt('dateIncrement');
        var customAlignment;
        if (dateIncrementInput) {
            return moment.duration(dateIncrementInput);
        }
        else if ((customAlignment = this.opt('dateAlignment'))) {
            return moment.duration(1, customAlignment);
        }
        else if (fallback) {
            return fallback;
        }
        else {
            return moment.duration({ days: 1 });
        }
    };
    return DateProfileGenerator;
}());
exports.default = DateProfileGenerator;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var namespace_hooks_1 = __webpack_require__(7);
var util_1 = __webpack_require__(2);
var moment_ext_1 = __webpack_require__(9);
var ListenerMixin_1 = __webpack_require__(6);
var HitDragListener_1 = __webpack_require__(18);
var SingleEventDef_1 = __webpack_require__(11);
var EventInstanceGroup_1 = __webpack_require__(17);
var EventSource_1 = __webpack_require__(5);
var Interaction_1 = __webpack_require__(13);
var ExternalDropping = /** @class */ (function (_super) {
    tslib_1.__extends(ExternalDropping, _super);
    function ExternalDropping() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDragging = false; // jqui-dragging an external element? boolean
        return _this;
    }
    /*
    component impements:
        - eventRangesToEventFootprints
        - isEventInstanceGroupAllowed
        - isExternalInstanceGroupAllowed
        - renderDrag
        - unrenderDrag
    */
    ExternalDropping.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    ExternalDropping.prototype.bindToDocument = function () {
        this.listenTo($(document), {
            dragstart: this.handleDragStart,
            sortstart: this.handleDragStart // jqui
        });
    };
    ExternalDropping.prototype.unbindFromDocument = function () {
        this.stopListeningTo($(document));
    };
    // Called when a jQuery UI drag is initiated anywhere in the DOM
    ExternalDropping.prototype.handleDragStart = function (ev, ui) {
        var el;
        var accept;
        if (this.opt('droppable')) {
            el = $((ui ? ui.item : null) || ev.target);
            // Test that the dragged element passes the dropAccept selector or filter function.
            // FYI, the default is "*" (matches all)
            accept = this.opt('dropAccept');
            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                if (!this.isDragging) {
                    this.listenToExternalDrag(el, ev, ui);
                }
            }
        }
    };
    // Called when a jQuery UI drag starts and it needs to be monitored for dropping
    ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
        var singleEventDef; // a null value signals an unsuccessful drag
        // listener that tracks mouse movement over date-associated pixel regions
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            interactionStart: function () {
                _this.isDragging = true;
            },
            hitOver: function (hit) {
                var isAllowed = true;
                var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid
                var mutatedEventInstanceGroup;
                if (hitFootprint) {
                    singleEventDef = _this.computeExternalDrop(hitFootprint, meta);
                    if (singleEventDef) {
                        mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());
                        isAllowed = meta.eventProps ? // isEvent?
                            component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :
                            component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    singleEventDef = null;
                    util_1.disableCursor();
                }
                if (singleEventDef) {
                    component.renderDrag(// called without a seg parameter
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));
                }
            },
            hitOut: function () {
                singleEventDef = null; // signal unsuccessful
            },
            hitDone: function () {
                util_1.enableCursor();
                component.unrenderDrag();
            },
            interactionEnd: function (ev) {
                if (singleEventDef) {
                    view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent
                    Boolean(meta.stick), // isSticky
                    el, ev, ui);
                }
                _this.isDragging = false;
                _this.dragListener = null;
            }
        });
        dragListener.startDrag(ev); // start listening immediately
    };
    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
    // Returning a null value signals an invalid drop hit.
    // DOES NOT consider overlap/constraint.
    // Assumes both footprints are non-open-ended.
    ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {
        var calendar = this.view.calendar;
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();
        var end;
        var eventDef;
        if (componentFootprint.isAllDay) {
            // if dropped on an all-day span, and element's metadata specified a time, set it
            if (meta.startTime) {
                start.time(meta.startTime);
            }
            else {
                start.stripTime();
            }
        }
        if (meta.duration) {
            end = start.clone().add(meta.duration);
        }
        start = calendar.applyTimezone(start);
        if (end) {
            end = calendar.applyTimezone(end);
        }
        eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {
            start: start,
            end: end
        }), new EventSource_1.default(calendar));
        return eventDef;
    };
    return ExternalDropping;
}(Interaction_1.default));
exports.default = ExternalDropping;
ListenerMixin_1.default.mixInto(ExternalDropping);
/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/
// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
    var prefix = namespace_hooks_1.default.dataAttrPrefix;
    var eventProps; // properties for creating the event, not related to date/time
    var startTime; // a Duration
    var duration;
    var stick;
    if (prefix) {
        prefix += '-';
    }
    eventProps = el.data(prefix + 'event') || null;
    if (eventProps) {
        if (typeof eventProps === 'object') {
            eventProps = $.extend({}, eventProps); // make a copy
        }
        else {
            eventProps = {};
        }
        // pluck special-cased date/time properties
        startTime = eventProps.start;
        if (startTime == null) {
            startTime = eventProps.time;
        } // accept 'time' as well
        duration = eventProps.duration;
        stick = eventProps.stick;
        delete eventProps.start;
        delete eventProps.time;
        delete eventProps.duration;
        delete eventProps.stick;
    }
    // fallback to standalone attribute values for each of the date/time properties
    if (startTime == null) {
        startTime = el.data(prefix + 'start');
    }
    if (startTime == null) {
        startTime = el.data(prefix + 'time');
    } // accept 'time' as well
    if (duration == null) {
        duration = el.data(prefix + 'duration');
    }
    if (stick == null) {
        stick = el.data(prefix + 'stick');
    }
    // massage into correct data types
    startTime = startTime != null ? moment.duration(startTime) : null;
    duration = duration != null ? moment.duration(duration) : null;
    stick = Boolean(stick);
    return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventDefMutation_1 = __webpack_require__(26);
var EventDefDateMutation_1 = __webpack_require__(35);
var HitDragListener_1 = __webpack_require__(18);
var Interaction_1 = __webpack_require__(13);
var EventResizing = /** @class */ (function (_super) {
    tslib_1.__extends(EventResizing, _super);
    /*
    component impements:
        - bindSegHandlerToEl
        - publiclyTrigger
        - diffDates
        - eventRangesToEventFootprints
        - isEventInstanceGroupAllowed
        - getSafeHitFootprint
    */
    function EventResizing(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isResizing = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventResizing.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventResizing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventResizing.prototype.handleMouseDown = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev, { distance: 5 });
        }
    };
    EventResizing.prototype.handleTouchStart = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev);
        }
    };
    // Creates a listener that tracks the user as they resize an event segment.
    // Generic enough to work with any type of Grid.
    EventResizing.prototype.buildDragListener = function (seg, isStart) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance;
        var isDragging;
        var resizeMutation; // zoned event date properties. falsy if invalid resize
        // Tracks mouse movement over the *grid's* coordinate map
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            interactionStart: function () {
                isDragging = false;
            },
            dragStart: function (ev) {
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segResizeStart(seg, ev);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origHitFootprint = component.getSafeHitFootprint(origHit);
                var hitFootprint = component.getSafeHitFootprint(hit);
                var mutatedEventInstanceGroup;
                if (origHitFootprint && hitFootprint) {
                    resizeMutation = isStart ?
                        _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :
                        _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);
                    if (resizeMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    resizeMutation = null;
                    util_1.disableCursor();
                }
                else if (resizeMutation.isEmpty()) {
                    // no change. (FYI, event dates might have zones)
                    resizeMutation = null;
                }
                if (resizeMutation) {
                    view.hideEventsWithId(seg.footprint.eventDef.id);
                    view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);
                }
            },
            hitOut: function () {
                resizeMutation = null;
            },
            hitDone: function () {
                view.unrenderEventResize(seg);
                view.showEventsWithId(seg.footprint.eventDef.id);
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                if (isDragging) {
                    _this.segResizeStop(seg, ev);
                }
                if (resizeMutation) {
                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                    view.reportEventResize(eventInstance, resizeMutation, el, ev);
                }
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment resizing starts
    EventResizing.prototype.segResizeStart = function (seg, ev) {
        this.isResizing = true;
        this.component.publiclyTrigger('eventResizeStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment resizing stops
    EventResizing.prototype.segResizeStop = function (seg, ev) {
        this.isResizing = false;
        this.component.publiclyTrigger('eventResizeStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Returns new date-information for an event segment being resized from its start
    EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getStart().add(startDelta) < origRange.getEnd()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setStartDelta(startDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    // Returns new date-information for an event segment being resized from its end
    EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getEnd().add(endDelta) > origRange.getStart()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setEndDelta(endDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    return EventResizing;
}(Interaction_1.default));
exports.default = EventResizing;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var EventDefMutation_1 = __webpack_require__(26);
var EventDefDateMutation_1 = __webpack_require__(35);
var DragListener_1 = __webpack_require__(39);
var HitDragListener_1 = __webpack_require__(18);
var MouseFollower_1 = __webpack_require__(81);
var Interaction_1 = __webpack_require__(13);
var EventDragging = /** @class */ (function (_super) {
    tslib_1.__extends(EventDragging, _super);
    /*
    component implements:
        - bindSegHandlerToEl
        - publiclyTrigger
        - diffDates
        - eventRangesToEventFootprints
        - isEventInstanceGroupAllowed
    */
    function EventDragging(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isDragging = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventDragging.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventDragging.prototype.getSelectionDelay = function () {
        var delay = this.opt('eventLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    EventDragging.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventDragging.prototype.handleMousedown = function (seg, ev) {
        if (this.component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, { distance: 5 });
        }
    };
    EventDragging.prototype.handleTouchStart = function (seg, ev) {
        var component = this.component;
        var settings = {
            delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?
                0 : this.getSelectionDelay()
        };
        if (component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, settings);
        }
        else if (component.canStartSelection(seg, ev)) {
            this.buildSelectListener(seg).startInteraction(ev, settings);
        }
    };
    // seg isn't draggable, but let's use a generic DragListener
    // simply for the delay, so it can be selected.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildSelectListener = function (seg) {
        var _this = this;
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        if (this.dragListener) {
            return this.dragListener;
        }
        var dragListener = this.dragListener = new DragListener_1.default({
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
            },
            interactionEnd: function (ev) {
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Builds a listener that will track user-dragging on an event segment.
    // Generic enough to work with any type of Grid.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildDragListener = function (seg) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        var isDragging;
        var mouseFollower; // A clone of the original element that will move with the mouse
        var eventDefMutation;
        if (this.dragListener) {
            return this.dragListener;
        }
        // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
        // of the view.
        var dragListener = this.dragListener = new HitDragListener_1.default(view, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            subjectCenter: true,
            interactionStart: function (ev) {
                seg.component = component; // for renderDrag
                isDragging = false;
                mouseFollower = new MouseFollower_1.default(seg.el, {
                    additionalClass: 'fc-dragging',
                    parentEl: view.el,
                    opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),
                    revertDuration: _this.opt('dragRevertDuration'),
                    zIndex: 2 // one above the .fc-view
                });
                mouseFollower.hide(); // don't show until we know this is a real drag
                mouseFollower.start(ev);
            },
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segDragStart(seg, ev);
                view.hideEventsWithId(seg.footprint.eventDef.id);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origFootprint;
                var footprint;
                var mutatedEventInstanceGroup;
                // starting hit could be forced (DayGrid.limit)
                if (seg.hit) {
                    origHit = seg.hit;
                }
                // hit might not belong to this grid, so query origin grid
                origFootprint = origHit.component.getSafeHitFootprint(origHit);
                footprint = hit.component.getSafeHitFootprint(hit);
                if (origFootprint && footprint) {
                    eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);
                    if (eventDefMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    eventDefMutation = null;
                    util_1.disableCursor();
                }
                // if a valid drop location, have the subclass render a visual indication
                if (eventDefMutation &&
                    view.renderDrag(// truthy if rendered something
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {
                    mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
                }
                else {
                    mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
                }
                if (isOrig) {
                    // needs to have moved hits to be a valid drop
                    eventDefMutation = null;
                }
            },
            hitOut: function () {
                view.unrenderDrag(seg); // unrender whatever was done in renderDrag
                mouseFollower.show(); // show in case we are moving out of all hits
                eventDefMutation = null;
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                delete seg.component; // prevent side effects
                // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
                mouseFollower.stop(!eventDefMutation, function () {
                    if (isDragging) {
                        view.unrenderDrag(seg);
                        _this.segDragStop(seg, ev);
                    }
                    view.showEventsWithId(seg.footprint.eventDef.id);
                    if (eventDefMutation) {
                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                        view.reportEventDrop(eventInstance, eventDefMutation, el, ev);
                    }
                });
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment dragging starts
    EventDragging.prototype.segDragStart = function (seg, ev) {
        this.isDragging = true;
        this.component.publiclyTrigger('eventDragStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment dragging stops
    EventDragging.prototype.segDragStop = function (seg, ev) {
        this.isDragging = false;
        this.component.publiclyTrigger('eventDragStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // DOES NOT consider overlap/constraint
    EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {
        var eventDefMutation = new EventDefMutation_1.default();
        eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));
        return eventDefMutation;
    };
    EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {
        var date0 = startFootprint.unzonedRange.getStart();
        var date1 = endFootprint.unzonedRange.getStart();
        var clearEnd = false;
        var forceTimed = false;
        var forceAllDay = false;
        var dateDelta;
        var dateMutation;
        if (startFootprint.isAllDay !== endFootprint.isAllDay) {
            clearEnd = true;
            if (endFootprint.isAllDay) {
                forceAllDay = true;
                date0.stripTime();
            }
            else {
                forceTimed = true;
            }
        }
        dateDelta = this.component.diffDates(date1, date0);
        dateMutation = new EventDefDateMutation_1.default();
        dateMutation.clearEnd = clearEnd;
        dateMutation.forceTimed = forceTimed;
        dateMutation.forceAllDay = forceAllDay;
        dateMutation.setDateDelta(dateDelta);
        return dateMutation;
    };
    return EventDragging;
}(Interaction_1.default));
exports.default = EventDragging;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var HitDragListener_1 = __webpack_require__(18);
var ComponentFootprint_1 = __webpack_require__(10);
var UnzonedRange_1 = __webpack_require__(4);
var Interaction_1 = __webpack_require__(13);
var DateSelecting = /** @class */ (function (_super) {
    tslib_1.__extends(DateSelecting, _super);
    /*
    component must implement:
        - bindDateHandlerToEl
        - getSafeHitFootprint
        - renderHighlight
        - unrenderHighlight
    */
    function DateSelecting(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateSelecting.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateSelecting.prototype.getDelay = function () {
        var delay = this.opt('selectLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    DateSelecting.prototype.bindToEl = function (el) {
        var _this = this;
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev, {
                    distance: _this.opt('selectMinDistance')
                });
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev, {
                    delay: _this.getDelay()
                });
            }
        });
        util_1.preventSelection(el);
    };
    // Creates a listener that tracks the user's drag across day elements, for day selecting.
    DateSelecting.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var selectionFootprint; // null if invalid selection
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                selectionFootprint = null;
            },
            dragStart: function (ev) {
                _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one
            },
            hitOver: function (hit, isOrig, origHit) {
                var origHitFootprint;
                var hitFootprint;
                if (origHit) {
                    origHitFootprint = component.getSafeHitFootprint(origHit);
                    hitFootprint = component.getSafeHitFootprint(hit);
                    if (origHitFootprint && hitFootprint) {
                        selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);
                    }
                    else {
                        selectionFootprint = null;
                    }
                    if (selectionFootprint) {
                        component.renderSelectionFootprint(selectionFootprint);
                    }
                    else if (selectionFootprint === false) {
                        util_1.disableCursor();
                    }
                }
            },
            hitOut: function () {
                selectionFootprint = null;
                component.unrenderSelection();
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev, isCancelled) {
                if (!isCancelled && selectionFootprint) {
                    // the selection will already have been rendered. just report it
                    _this.view.reportSelection(selectionFootprint, ev);
                }
            }
        });
        return dragListener;
    };
    // Given the first and last date-spans of a selection, returns another date-span object.
    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().
    // Will return false if the selection is invalid and this should be indicated to the user.
    // Will return null/undefined if a selection invalid but no error should be reported.
    DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {
        var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);
        if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {
            return false;
        }
        return wholeFootprint;
    };
    // Given two spans, must return the combination of the two.
    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
    // Assumes both footprints are non-open-ended.
    DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {
        var ms = [
            footprint0.unzonedRange.startMs,
            footprint0.unzonedRange.endMs,
            footprint1.unzonedRange.startMs,
            footprint1.unzonedRange.endMs
        ];
        ms.sort(util_1.compareNumbers);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);
    };
    DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&
            this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);
    };
    return DateSelecting;
}(Interaction_1.default));
exports.default = DateSelecting;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Scroller_1 = __webpack_require__(28);
var View_1 = __webpack_require__(30);
var TimeGrid_1 = __webpack_require__(68);
var DayGrid_1 = __webpack_require__(46);
var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
var AgendaView = /** @class */ (function (_super) {
    tslib_1.__extends(AgendaView, _super);
    function AgendaView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering
        _this.timeGrid = _this.instantiateTimeGrid();
        _this.addChild(_this.timeGrid);
        if (_this.opt('allDaySlot')) {
            _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view
            _this.addChild(_this.dayGrid);
        }
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
    AgendaView.prototype.instantiateTimeGrid = function () {
        var SubClass = makeTimeGridSubclass(this.timeGridClass);
        return new SubClass(this);
    };
    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
    AgendaView.prototype.instantiateDayGrid = function () {
        var SubClass = makeDayGridSubclass(this.dayGridClass);
        return new SubClass(this);
    };
    /* Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.renderSkeleton = function () {
        var timeGridWrapEl;
        var timeGridEl;
        this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
        timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
        this.el.find('.fc-body > tr > td').append(timeGridWrapEl);
        this.timeGrid.headContainerEl = this.el.find('.fc-head-container');
        this.timeGrid.setElement(timeGridEl);
        if (this.dayGrid) {
            this.dayGrid.setElement(this.el.find('.fc-day-grid'));
            // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
        }
    };
    AgendaView.prototype.unrenderSkeleton = function () {
        this.timeGrid.removeElement();
        if (this.dayGrid) {
            this.dayGrid.removeElement();
        }
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid and time-grid components will render inside containers defined by this HTML.
    AgendaView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '">' +
            (this.dayGrid ?
                '<div class="fc-day-grid"/>' +
                    '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '"/>' :
                '') +
            '</td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the axis, if it is known
    AgendaView.prototype.axisStyleAttr = function () {
        if (this.axisWidth != null) {
            return 'style="width:' + this.axisWidth + 'px"';
        }
        return '';
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.getNowIndicatorUnit = function () {
        return this.timeGrid.getNowIndicatorUnit();
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Adjusts the vertical dimensions of the view to the specified values
    AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit;
        var scrollerHeight;
        var scrollbarWidths;
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        // make all axis cells line up, and record the width so newly created axis cells will have it
        this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));
        // hack to give the view some height prior to timeGrid's columns being rendered
        // TODO: separate setting height from scroller VS timeGrid.
        if (!this.timeGrid.colEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        // set of fake row elements that must compensate when scroller has scrollbars
        var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');
        // reset all dimensions back to the original state
        this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
        this.scroller.clear(); // sets height to 'auto' and clears overflow
        util_1.uncompensateScroll(noScrollRowEls);
        // limit number of events in the all-day area
        if (this.dayGrid) {
            this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
            eventLimit = this.opt('eventLimit');
            if (eventLimit && typeof eventLimit !== 'number') {
                eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
            }
            if (eventLimit) {
                this.dayGrid.limitRows(eventLimit);
            }
        }
        if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) {
                // make the all-day and header rows lines up
                util_1.compensateScroll(noScrollRowEls, scrollbarWidths);
                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                // and reapply the desired height to the scroller.
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
            // if there's any space below the slats, show the horizontal rule.
            // this won't cause any new overflow, because lockOverflow already called.
            if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                this.timeGrid.bottomRuleEl.show();
            }
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    AgendaView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes the initial pre-configured scroll state prior to allowing the user to change it
    AgendaView.prototype.computeInitialDateScroll = function () {
        var scrollTime = moment.duration(this.opt('scrollTime'));
        var top = this.timeGrid.computeTimeTop(scrollTime);
        // zoom can give weird floating-point values. rather scroll a little bit further
        top = Math.ceil(top);
        if (top) {
            top++; // to overcome top border that slots beyond the first have. looks better
        }
        return { top: top };
    };
    AgendaView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    AgendaView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    /* Hit Areas
    ------------------------------------------------------------------------------------------------------------------*/
    // forward all hit-related method calls to the grids (dayGrid might not be defined)
    AgendaView.prototype.getHitFootprint = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitFootprint(hit);
    };
    AgendaView.prototype.getHitEl = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitEl(hit);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.executeEventRender = function (eventsPayload) {
        var dayEventsPayload = {};
        var timedEventsPayload = {};
        var id, eventInstanceGroup;
        // separate the events into all-day and timed
        for (id in eventsPayload) {
            eventInstanceGroup = eventsPayload[id];
            if (eventInstanceGroup.getEventDef().isAllDay()) {
                dayEventsPayload[id] = eventInstanceGroup;
            }
            else {
                timedEventsPayload[id] = eventInstanceGroup;
            }
        }
        this.timeGrid.executeEventRender(timedEventsPayload);
        if (this.dayGrid) {
            this.dayGrid.executeEventRender(dayEventsPayload);
        }
    };
    /* Dragging/Resizing Routing
    ------------------------------------------------------------------------------------------------------------------*/
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        var renderedHelper = false;
        renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;
        }
        return renderedHelper;
    };
    AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        this.timeGrid.renderEventResize(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);
        }
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection
    AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (!componentFootprint.isAllDay) {
            this.timeGrid.renderSelectionFootprint(componentFootprint);
        }
        else if (this.dayGrid) {
            this.dayGrid.renderSelectionFootprint(componentFootprint);
        }
    };
    return AgendaView;
}(View_1.default));
exports.default = AgendaView;
AgendaView.prototype.timeGridClass = TimeGrid_1.default;
AgendaView.prototype.dayGridClass = DayGrid_1.default;
// Will customize the rendering behavior of the AgendaView's timeGrid
function makeTimeGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Generates the HTML that will go before the day-of week header cells
        SubClass.prototype.renderHeadIntroHtml = function () {
            var view = this.view;
            var calendar = view.calendar;
            var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);
            var weekText;
            if (this.opt('weekNumbers')) {
                weekText = weekStart.format(this.opt('smallWeekFormat'));
                return '' +
                    '<th class="fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '>' +
                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                    { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML
                    ) +
                    '</th>';
            }
            else {
                return '<th class="fc-axis ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '></th>';
            }
        };
        // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            return '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '></td>';
        };
        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        };
        return SubClass;
    }(SuperClass));
}
;
// Will customize the rendering behavior of the AgendaView's dayGrid
function makeDayGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Generates the HTML that goes before the all-day cells
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            return '' +
                '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
                '<span>' + // needed for matchCellWidths
                view.getAllDayHtml() +
                '</span>' +
                '</td>';
        };
        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        };
        return SubClass;
    }(SuperClass));
}
;
function groupEventFootprintsByAllDay(eventFootprints) {
    var allDay = [];
    var timed = [];
    var i;
    for (i = 0; i < eventFootprints.length; i++) {
        if (eventFootprints[i].componentFootprint.isAllDay) {
            allDay.push(eventFootprints[i]);
        }
        else {
            timed.push(eventFootprints[i]);
        }
    }
    return { allDay: allDay, timed: timed };
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var InteractiveDateComponent_1 = __webpack_require__(29);
var BusinessHourRenderer_1 = __webpack_require__(41);
var StandardInteractionsMixin_1 = __webpack_require__(45);
var DayTableMixin_1 = __webpack_require__(40);
var CoordCache_1 = __webpack_require__(38);
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var TimeGridEventRenderer_1 = __webpack_require__(83);
var TimeGridHelperRenderer_1 = __webpack_require__(84);
var TimeGridFillRenderer_1 = __webpack_require__(85);
/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days
// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
    { hours: 1 },
    { minutes: 30 },
    { minutes: 15 },
    { seconds: 30 },
    { seconds: 15 }
];
var TimeGrid = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGrid, _super);
    function TimeGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.processOptions();
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);
        var i;
        for (i = 0; i < segs.length; i++) {
            if (this.isRTL) {
                segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
            }
            else {
                segs[i].col = segs[i].dayIndex;
            }
        }
        return segs;
    };
    /* Date Handling
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {
        var segs = [];
        var segRange;
        var dayIndex;
        for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
            segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);
            if (segRange) {
                segs.push({
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                });
            }
        }
        return segs;
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Parses various options into properties of this object
    TimeGrid.prototype.processOptions = function () {
        var slotDuration = this.opt('slotDuration');
        var snapDuration = this.opt('snapDuration');
        var input;
        slotDuration = moment.duration(slotDuration);
        snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
        this.slotDuration = slotDuration;
        this.snapDuration = snapDuration;
        this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?
        // might be an array value (for TimelineView).
        // if so, getting the most granular entry (the last one probably).
        input = this.opt('slotLabelFormat');
        if ($.isArray(input)) {
            input = input[input.length - 1];
        }
        this.labelFormat = input ||
            this.opt('smallTimeFormat'); // the computed default
        input = this.opt('slotLabelInterval');
        this.labelInterval = input ?
            moment.duration(input) :
            this.computeLabelInterval(slotDuration);
    };
    // Computes an automatic value for slotLabelInterval
    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
        var i;
        var labelInterval;
        var slotsPerLabel;
        // find the smallest stock label interval that results in more than one slots-per-label
        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
            slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);
            if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {
                return labelInterval;
            }
        }
        return moment.duration(slotDuration); // fall back. clone
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderSlats();
        this.renderColumns();
    };
    TimeGrid.prototype.unrenderDates = function () {
        //this.unrenderSlats(); // don't need this because repeated .html() calls clear
        this.unrenderColumns();
    };
    TimeGrid.prototype.renderSkeleton = function () {
        var theme = this.view.calendar.theme;
        this.el.html('<div class="fc-bg"></div>' +
            '<div class="fc-slats"></div>' +
            '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" style="display:none" />');
        this.bottomRuleEl = this.el.find('hr');
    };
    TimeGrid.prototype.renderSlats = function () {
        var theme = this.view.calendar.theme;
        this.slatContainerEl = this.el.find('> .fc-slats')
            .html(// avoids needing ::unrenderSlats()
        '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderSlatRowHtml() +
            '</table>');
        this.slatEls = this.slatContainerEl.find('tr');
        this.slatCoordCache = new CoordCache_1.default({
            els: this.slatEls,
            isVertical: true
        });
    };
    // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
    TimeGrid.prototype.renderSlatRowHtml = function () {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var isRTL = this.isRTL;
        var dateProfile = this.dateProfile;
        var html = '';
        var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations
        var slotIterator = moment.duration(0);
        var slotDate; // will be on the view's first day, but we only care about its time
        var isLabeled;
        var axisHtml;
        // Calculate the time for each slot
        while (slotTime < dateProfile.maxTime) {
            slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);
            isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));
            axisHtml =
                '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
                    (isLabeled ?
                        '<span>' + // for matchCellWidths
                            util_1.htmlEscape(slotDate.format(this.labelFormat)) +
                            '</span>' :
                        '') +
                    '</td>';
            html +=
                '<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
                    (isLabeled ? '' : ' class="fc-minor"') +
                    '>' +
                    (!isRTL ? axisHtml : '') +
                    '<td class="' + theme.getClass('widgetContent') + '"/>' +
                    (isRTL ? axisHtml : '') +
                    "</tr>";
            slotTime.add(this.slotDuration);
            slotIterator.add(this.slotDuration);
        }
        return html;
    };
    TimeGrid.prototype.renderColumns = function () {
        var dateProfile = this.dateProfile;
        var theme = this.view.calendar.theme;
        this.dayRanges = this.dayDates.map(function (dayDate) {
            return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));
        });
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        this.el.find('> .fc-bg').html('<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(0) + // row=0
            '</table>');
        this.colEls = this.el.find('.fc-day, .fc-disabled-day');
        this.colCoordCache = new CoordCache_1.default({
            els: this.colEls,
            isHorizontal: true
        });
        this.renderContentSkeleton();
    };
    TimeGrid.prototype.unrenderColumns = function () {
        this.unrenderContentSkeleton();
    };
    /* Content Skeleton
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders the DOM that the view's content will live in
    TimeGrid.prototype.renderContentSkeleton = function () {
        var cellHtml = '';
        var i;
        var skeletonEl;
        for (i = 0; i < this.colCnt; i++) {
            cellHtml +=
                '<td>' +
                    '<div class="fc-content-col">' +
                    '<div class="fc-event-container fc-helper-container"></div>' +
                    '<div class="fc-event-container"></div>' +
                    '<div class="fc-highlight-container"></div>' +
                    '<div class="fc-bgevent-container"></div>' +
                    '<div class="fc-business-container"></div>' +
                    '</div>' +
                    '</td>';
        }
        skeletonEl = this.contentSkeletonEl = $('<div class="fc-content-skeleton">' +
            '<table>' +
            '<tr>' + cellHtml + '</tr>' +
            '</table>' +
            '</div>');
        this.colContainerEls = skeletonEl.find('.fc-content-col');
        this.helperContainerEls = skeletonEl.find('.fc-helper-container');
        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
        this.businessContainerEls = skeletonEl.find('.fc-business-container');
        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
        this.el.append(skeletonEl);
    };
    TimeGrid.prototype.unrenderContentSkeleton = function () {
        this.contentSkeletonEl.remove();
        this.contentSkeletonEl = null;
        this.colContainerEls = null;
        this.helperContainerEls = null;
        this.fgContainerEls = null;
        this.bgContainerEls = null;
        this.highlightContainerEls = null;
        this.businessContainerEls = null;
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
    TimeGrid.prototype.groupSegsByCol = function (segs) {
        var segsByCol = [];
        var i;
        for (i = 0; i < this.colCnt; i++) {
            segsByCol.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segsByCol[segs[i].col].push(segs[i]);
        }
        return segsByCol;
    };
    // Given segments grouped by column, insert the segments' elements into a parallel array of container
    // elements, each living within a column.
    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
        var col;
        var segs;
        var i;
        for (col = 0; col < this.colCnt; col++) {
            segs = segsByCol[col];
            for (i = 0; i < segs.length; i++) {
                containerEls.eq(col).append(segs[i].el);
            }
        }
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.getNowIndicatorUnit = function () {
        return 'minute'; // will refresh on the minute
    };
    TimeGrid.prototype.renderNowIndicator = function (date) {
        // HACK: if date columns not ready for some reason (scheduler)
        if (!this.colContainerEls) {
            return;
        }
        // seg system might be overkill, but it handles scenario where line needs to be rendered
        //  more than once because of columns with the same date (resources columns for example)
        var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range
        false // all-day
        ));
        var top = this.computeDateTop(date, date);
        var nodes = [];
        var i;
        // render lines within the columns
        for (i = 0; i < segs.length; i++) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
                .css('top', top)
                .appendTo(this.colContainerEls.eq(segs[i].col))[0]);
        }
        // render an arrow over the axis
        if (segs.length > 0) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
                .css('top', top)
                .appendTo(this.el.find('.fc-content-skeleton'))[0]);
        }
        this.nowIndicatorEls = $(nodes);
    };
    TimeGrid.prototype.unrenderNowIndicator = function () {
        if (this.nowIndicatorEls) {
            this.nowIndicatorEls.remove();
            this.nowIndicatorEls = null;
        }
    };
    /* Coordinates
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        this.slatCoordCache.build();
        if (isResize) {
            this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));
        }
    };
    TimeGrid.prototype.getTotalSlatHeight = function () {
        return this.slatContainerEl.outerHeight();
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // `ms` can be a millisecond UTC time OR a UTC moment.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
    TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {
        return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
    TimeGrid.prototype.computeTimeTop = function (time) {
        var len = this.slatEls.length;
        var dateProfile = this.dateProfile;
        var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered
        var slatIndex;
        var slatRemainder;
        // compute a floating-point number for how many slats should be progressed through.
        // from 0 to number of slats (inclusive)
        // constrained because minTime/maxTime might be customized.
        slatCoverage = Math.max(0, slatCoverage);
        slatCoverage = Math.min(len, slatCoverage);
        // an integer index of the furthest whole slat
        // from 0 to number slats (*exclusive*, so len-1)
        slatIndex = Math.floor(slatCoverage);
        slatIndex = Math.min(slatIndex, len - 1);
        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
        // could be 1.0 if slatCoverage is covering *all* the slots
        slatRemainder = slatCoverage - slatIndex;
        return this.slatCoordCache.getTopPosition(slatIndex) +
            this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
    };
    // Refreshes the CSS top/bottom coordinates for each segment element.
    // Works when called after initial render, after a window resize/zoom for example.
    TimeGrid.prototype.updateSegVerticals = function (segs) {
        this.computeSegVerticals(segs);
        this.assignSegVerticals(segs);
    };
    // For each segment in an array, computes and assigns its top and bottom properties
    TimeGrid.prototype.computeSegVerticals = function (segs) {
        var eventMinHeight = this.opt('agendaEventMinHeight');
        var i, seg;
        var dayDate;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            dayDate = this.dayDates[seg.dayIndex];
            seg.top = this.computeDateTop(seg.startMs, dayDate);
            seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));
        }
    };
    // Given segments that already have their top/bottom properties computed, applies those values to
    // the segments' elements.
    TimeGrid.prototype.assignSegVerticals = function (segs) {
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateSegVerticalCss(seg));
        }
    };
    // Generates an object with CSS properties for the top/bottom coordinates of a segment element
    TimeGrid.prototype.generateSegVerticalCss = function (seg) {
        return {
            top: seg.top,
            bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
        };
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.slatCoordCache.build();
    };
    TimeGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
    };
    TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {
        var snapsPerSlot = this.snapsPerSlot;
        var colCoordCache = this.colCoordCache;
        var slatCoordCache = this.slatCoordCache;
        if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
            var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
            var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
            if (colIndex != null && slatIndex != null) {
                var slatTop = slatCoordCache.getTopOffset(slatIndex);
                var slatHeight = slatCoordCache.getHeight(slatIndex);
                var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
                var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;
                return {
                    col: colIndex,
                    snap: snapIndex,
                    component: this,
                    left: colCoordCache.getLeftOffset(colIndex),
                    right: colCoordCache.getRightOffset(colIndex),
                    top: snapTop,
                    bottom: snapBottom
                };
            }
        }
    };
    TimeGrid.prototype.getHitFootprint = function (hit) {
        var start = this.getCellDate(0, hit.col); // row=0
        var time = this.computeSnapTime(hit.snap); // pass in the snap-index
        var end;
        start.time(time);
        end = start.clone().add(this.snapDuration);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?
        );
    };
    // Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
    TimeGrid.prototype.computeSnapTime = function (snapIndex) {
        return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);
    };
    TimeGrid.prototype.getHitEl = function (hit) {
        return this.colEls.eq(hit.col);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being dragged over the specified date(s).
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        if (seg) {
            if (eventFootprints.length) {
                this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
                // signal that a helper has been rendered
                return true;
            }
        }
        else {
            for (i = 0; i < eventFootprints.length; i++) {
                this.renderHighlight(eventFootprints[i].componentFootprint);
            }
        }
    };
    // Unrenders any visual indication of an event being dragged
    TimeGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders any visual indication of an event being resized
    TimeGrid.prototype.unrenderEventResize = function () {
        this.helperRenderer.unrender();
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
    TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (this.opt('selectHelper')) {
            this.helperRenderer.renderComponentFootprint(componentFootprint);
        }
        else {
            this.renderHighlight(componentFootprint);
        }
    };
    // Unrenders any visual indication of a selection
    TimeGrid.prototype.unrenderSelection = function () {
        this.helperRenderer.unrender();
        this.unrenderHighlight();
    };
    return TimeGrid;
}(InteractiveDateComponent_1.default));
exports.default = TimeGrid;
TimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;
TimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
TimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;
TimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(TimeGrid);
DayTableMixin_1.default.mixInto(TimeGrid);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UnzonedRange_1 = __webpack_require__(4);
var DateProfileGenerator_1 = __webpack_require__(62);
var BasicViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(BasicViewDateProfileGenerator, _super);
    function BasicViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        // year and month views should be aligned with weeks. this is already done for week
        if (/^(year|month)$/.test(currentRangeUnit)) {
            start.startOf('week');
            // make end-of-week if not already
            if (end.weekday()) {
                end.add(1, 'week').startOf('week'); // exclusively move backwards
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    return BasicViewDateProfileGenerator;
}(DateProfileGenerator_1.default));
exports.default = BasicViewDateProfileGenerator;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(4);
var BasicView_1 = __webpack_require__(47);
var BasicViewDateProfileGenerator_1 = __webpack_require__(69);
/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/
var MonthViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(MonthViewDateProfileGenerator, _super);
    function MonthViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        var rowCnt;
        // ensure 6 weeks
        if (this.opt('fixedWeekCount')) {
            rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
            end.diff(start, 'weeks', true) // dontRound=true
            );
            end.add(6 - rowCnt, 'weeks');
        }
        return new UnzonedRange_1.default(start, end);
    };
    return MonthViewDateProfileGenerator;
}(BasicViewDateProfileGenerator_1.default));
var MonthView = /** @class */ (function (_super) {
    tslib_1.__extends(MonthView, _super);
    function MonthView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Overrides the default BasicView behavior to have special multi-week auto-height logic
    MonthView.prototype.setGridHeight = function (height, isAuto) {
        // if auto, make the height of each row the height that it would be if there were 6 weeks
        if (isAuto) {
            height *= this.dayGrid.rowCnt / 6;
        }
        util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
    };
    MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize
    };
    return MonthView;
}(BasicView_1.default));
exports.default = MonthView;
MonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(4);
var View_1 = __webpack_require__(30);
var Scroller_1 = __webpack_require__(28);
var ListEventRenderer_1 = __webpack_require__(90);
var ListEventPointing_1 = __webpack_require__(91);
/*
Responsible for the scroller, and forwarding event-related actions into the "grid".
*/
var ListView = /** @class */ (function (_super) {
    tslib_1.__extends(ListView, _super);
    function ListView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.segSelector = '.fc-list-item'; // which elements accept event actions
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    ListView.prototype.renderSkeleton = function () {
        this.el.addClass('fc-list-view ' +
            this.calendar.theme.getClass('listView'));
        this.scroller.render();
        this.scroller.el.appendTo(this.el);
        this.contentEl = this.scroller.scrollEl; // shortcut
    };
    ListView.prototype.unrenderSkeleton = function () {
        this.scroller.destroy(); // will remove the Grid too
    };
    ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
    };
    ListView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    ListView.prototype.renderDates = function (dateProfile) {
        var calendar = this.calendar;
        var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);
        var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);
        var dayDates = [];
        var dayRanges = [];
        while (dayStart < viewEnd) {
            dayDates.push(dayStart.clone());
            dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));
            dayStart.add(1, 'day');
        }
        this.dayDates = dayDates;
        this.dayRanges = dayRanges;
        // all real rendering happens in EventRenderer
    };
    // slices by day
    ListView.prototype.componentFootprintToSegs = function (footprint) {
        var dayRanges = this.dayRanges;
        var dayIndex;
        var segRange;
        var seg;
        var segs = [];
        for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {
            segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);
            if (segRange) {
                seg = {
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                };
                segs.push(seg);
                // detect when footprint won't go fully into the next day,
                // and mutate the latest seg to the be the end.
                if (!seg.isEnd && !footprint.isAllDay &&
                    dayIndex + 1 < dayRanges.length &&
                    footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {
                    seg.endMs = footprint.unzonedRange.endMs;
                    seg.isEnd = true;
                    break;
                }
            }
        }
        return segs;
    };
    ListView.prototype.renderEmptyMessage = function () {
        this.contentEl.html('<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
            '<div class="fc-list-empty-wrap1">' +
            '<div class="fc-list-empty">' +
            util_1.htmlEscape(this.opt('noEventsMessage')) +
            '</div>' +
            '</div>' +
            '</div>');
    };
    // render the event segments in the view
    ListView.prototype.renderSegList = function (allSegs) {
        var segsByDay = this.groupSegsByDay(allSegs); // sparse array
        var dayIndex;
        var daySegs;
        var i;
        var tableEl = $('<table class="fc-list-table ' + this.calendar.theme.getClass('tableList') + '"><tbody/></table>');
        var tbodyEl = tableEl.find('tbody');
        for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
            daySegs = segsByDay[dayIndex];
            if (daySegs) {
                // append a day header
                tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));
                this.eventRenderer.sortEventSegs(daySegs);
                for (i = 0; i < daySegs.length; i++) {
                    tbodyEl.append(daySegs[i].el); // append event row
                }
            }
        }
        this.contentEl.empty().append(tableEl);
    };
    // Returns a sparse array of arrays, segs grouped by their dayIndex
    ListView.prototype.groupSegsByDay = function (segs) {
        var segsByDay = []; // sparse array
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
                .push(seg);
        }
        return segsByDay;
    };
    // generates the HTML for the day headers that live amongst the event rows
    ListView.prototype.dayHeaderHtml = function (dayDate) {
        var mainFormat = this.opt('listDayFormat');
        var altFormat = this.opt('listDayAltFormat');
        return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
            '<td class="' + this.calendar.theme.getClass('widgetHeader') + '" colspan="3">' +
            (mainFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML
                ) :
                '') +
            (altFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML
                ) :
                '') +
            '</td>' +
            '</tr>';
    };
    return ListView;
}(View_1.default));
exports.default = ListView;
ListView.prototype.eventRendererClass = ListEventRenderer_1.default;
ListView.prototype.eventPointingClass = ListEventPointing_1.default;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var namespace_hooks_1 = __webpack_require__(7);
var namespaceExports = __webpack_require__(73);
var util_1 = __webpack_require__(2);
var Calendar_1 = __webpack_require__(48);
// for intentional side-effects
__webpack_require__(9);
__webpack_require__(37);
__webpack_require__(92);
__webpack_require__(93);
__webpack_require__(95);
__webpack_require__(96);
__webpack_require__(97);
$.fullCalendar = $.extend(namespace_hooks_1.default, namespaceExports); // graft over the original hooks object
$.fn.fullCalendar = function (options) {
    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
    var res = this; // what this function will return (this jQuery object by default)
    this.each(function (i, _element) {
        var element = $(_element);
        var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
        var singleRes; // the returned value of this single method call
        // a method call
        if (typeof options === 'string') {
            if (options === 'getCalendar') {
                if (!i) {
                    res = calendar;
                }
            }
            else if (options === 'destroy') {
                if (calendar) {
                    calendar.destroy();
                    element.removeData('fullCalendar');
                }
            }
            else if (!calendar) {
                util_1.warn("Attempting to call a FullCalendar method on an element with no calendar.");
            }
            else if ($.isFunction(calendar[options])) {
                singleRes = calendar[options].apply(calendar, args);
                if (!i) {
                    res = singleRes; // record the first method call result
                }
                if (options === 'destroy') {
                    element.removeData('fullCalendar');
                }
            }
            else {
                util_1.warn("'" + options + "' is an unknown FullCalendar method.");
            }
        }
        else if (!calendar) {
            calendar = new Calendar_1.default(element, options);
            element.data('fullCalendar', calendar);
            calendar.render();
        }
    });
    return res;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// TODO: linter?
// after merge: put MonthViewDateProfileGenerator after
// "abstract" issue
// ensure $ always gets a local module reference
// better UMD solution
Object.defineProperty(exports, "__esModule", { value: true });
var Calendar_1 = __webpack_require__(48);
exports.Calendar = Calendar_1.default;
var options_1 = __webpack_require__(19);
Calendar_1.default.defaults = options_1.globalDefaults;
Calendar_1.default.englishDefaults = options_1.englishDefaults;
Calendar_1.default.rtlDefaults = options_1.rtlDefaults;
var util_1 = __webpack_require__(2);
exports.applyAll = util_1.applyAll;
exports.debounce = util_1.debounce;
exports.isInt = util_1.isInt;
exports.htmlEscape = util_1.htmlEscape;
exports.cssToStr = util_1.cssToStr;
exports.proxy = util_1.proxy;
exports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;
exports.getOuterRect = util_1.getOuterRect;
exports.getClientRect = util_1.getClientRect;
exports.getContentRect = util_1.getContentRect;
exports.getScrollbarWidths = util_1.getScrollbarWidths;
exports.preventDefault = util_1.preventDefault;
exports.parseFieldSpecs = util_1.parseFieldSpecs;
exports.compareByFieldSpecs = util_1.compareByFieldSpecs;
exports.compareByFieldSpec = util_1.compareByFieldSpec;
exports.flexibleCompare = util_1.flexibleCompare;
exports.computeGreatestUnit = util_1.computeGreatestUnit;
exports.divideRangeByDuration = util_1.divideRangeByDuration;
exports.divideDurationByDuration = util_1.divideDurationByDuration;
exports.multiplyDuration = util_1.multiplyDuration;
exports.durationHasTime = util_1.durationHasTime;
exports.log = util_1.log;
exports.warn = util_1.warn;
exports.removeExact = util_1.removeExact;
exports.intersectRects = util_1.intersectRects;
var date_formatting_1 = __webpack_require__(37);
exports.formatDate = date_formatting_1.formatDate;
exports.formatRange = date_formatting_1.formatRange;
exports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;
var locale_1 = __webpack_require__(20);
exports.datepickerLocale = locale_1.datepickerLocale;
exports.locale = locale_1.locale;
var moment_ext_1 = __webpack_require__(9);
exports.moment = moment_ext_1.default;
var EmitterMixin_1 = __webpack_require__(8);
exports.EmitterMixin = EmitterMixin_1.default;
var ListenerMixin_1 = __webpack_require__(6);
exports.ListenerMixin = ListenerMixin_1.default;
var Model_1 = __webpack_require__(32);
exports.Model = Model_1.default;
var Constraints_1 = __webpack_require__(49);
exports.Constraints = Constraints_1.default;
var UnzonedRange_1 = __webpack_require__(4);
exports.UnzonedRange = UnzonedRange_1.default;
var ComponentFootprint_1 = __webpack_require__(10);
exports.ComponentFootprint = ComponentFootprint_1.default;
var BusinessHourGenerator_1 = __webpack_require__(54);
exports.BusinessHourGenerator = BusinessHourGenerator_1.default;
var EventDef_1 = __webpack_require__(22);
exports.EventDef = EventDef_1.default;
var EventDefMutation_1 = __webpack_require__(26);
exports.EventDefMutation = EventDefMutation_1.default;
var EventSourceParser_1 = __webpack_require__(25);
exports.EventSourceParser = EventSourceParser_1.default;
var EventSource_1 = __webpack_require__(5);
exports.EventSource = EventSource_1.default;
var ThemeRegistry_1 = __webpack_require__(36);
exports.ThemeRegistry = ThemeRegistry_1.default;
var EventInstanceGroup_1 = __webpack_require__(17);
exports.EventInstanceGroup = EventInstanceGroup_1.default;
var ArrayEventSource_1 = __webpack_require__(34);
exports.ArrayEventSource = ArrayEventSource_1.default;
var FuncEventSource_1 = __webpack_require__(57);
exports.FuncEventSource = FuncEventSource_1.default;
var JsonFeedEventSource_1 = __webpack_require__(58);
exports.JsonFeedEventSource = JsonFeedEventSource_1.default;
var EventFootprint_1 = __webpack_require__(24);
exports.EventFootprint = EventFootprint_1.default;
var Class_1 = __webpack_require__(21);
exports.Class = Class_1.default;
var Mixin_1 = __webpack_require__(12);
exports.Mixin = Mixin_1.default;
var CoordCache_1 = __webpack_require__(38);
exports.CoordCache = CoordCache_1.default;
var DragListener_1 = __webpack_require__(39);
exports.DragListener = DragListener_1.default;
var Promise_1 = __webpack_require__(16);
exports.Promise = Promise_1.default;
var TaskQueue_1 = __webpack_require__(59);
exports.TaskQueue = TaskQueue_1.default;
var RenderQueue_1 = __webpack_require__(60);
exports.RenderQueue = RenderQueue_1.default;
var Scroller_1 = __webpack_require__(28);
exports.Scroller = Scroller_1.default;
var Theme_1 = __webpack_require__(27);
exports.Theme = Theme_1.default;
var DateComponent_1 = __webpack_require__(61);
exports.DateComponent = DateComponent_1.default;
var InteractiveDateComponent_1 = __webpack_require__(29);
exports.InteractiveDateComponent = InteractiveDateComponent_1.default;
var View_1 = __webpack_require__(30);
exports.View = View_1.default;
var DayTableMixin_1 = __webpack_require__(40);
exports.DayTableMixin = DayTableMixin_1.default;
var BusinessHourRenderer_1 = __webpack_require__(41);
exports.BusinessHourRenderer = BusinessHourRenderer_1.default;
var EventRenderer_1 = __webpack_require__(31);
exports.EventRenderer = EventRenderer_1.default;
var FillRenderer_1 = __webpack_require__(42);
exports.FillRenderer = FillRenderer_1.default;
var HelperRenderer_1 = __webpack_require__(43);
exports.HelperRenderer = HelperRenderer_1.default;
var ExternalDropping_1 = __webpack_require__(63);
exports.ExternalDropping = ExternalDropping_1.default;
var EventResizing_1 = __webpack_require__(64);
exports.EventResizing = EventResizing_1.default;
var EventPointing_1 = __webpack_require__(44);
exports.EventPointing = EventPointing_1.default;
var EventDragging_1 = __webpack_require__(65);
exports.EventDragging = EventDragging_1.default;
var DateSelecting_1 = __webpack_require__(66);
exports.DateSelecting = DateSelecting_1.default;
var StandardInteractionsMixin_1 = __webpack_require__(45);
exports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;
var AgendaView_1 = __webpack_require__(67);
exports.AgendaView = AgendaView_1.default;
var TimeGrid_1 = __webpack_require__(68);
exports.TimeGrid = TimeGrid_1.default;
var DayGrid_1 = __webpack_require__(46);
exports.DayGrid = DayGrid_1.default;
var BasicView_1 = __webpack_require__(47);
exports.BasicView = BasicView_1.default;
var MonthView_1 = __webpack_require__(70);
exports.MonthView = MonthView_1.default;
var ListView_1 = __webpack_require__(71);
exports.ListView = ListView_1.default;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Iterator = /** @class */ (function () {
    function Iterator(items) {
        this.items = items || [];
    }
    /* Calls a method on every item passing the arguments through */
    Iterator.prototype.proxyCall = function (methodName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var results = [];
        this.items.forEach(function (item) {
            results.push(item[methodName].apply(item, args));
        });
        return results;
    };
    return Iterator;
}());
exports.default = Iterator;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/
var Toolbar = /** @class */ (function () {
    function Toolbar(calendar, toolbarOptions) {
        this.el = null; // mirrors local `el`
        this.viewsWithButtons = [];
        this.calendar = calendar;
        this.toolbarOptions = toolbarOptions;
    }
    // method to update toolbar-specific options, not calendar-wide options
    Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {
        this.toolbarOptions = newToolbarOptions;
    };
    // can be called repeatedly and will rerender
    Toolbar.prototype.render = function () {
        var sections = this.toolbarOptions.layout;
        var el = this.el;
        if (sections) {
            if (!el) {
                el = this.el = $("<div class='fc-toolbar " + this.toolbarOptions.extraClasses + "'/>");
            }
            else {
                el.empty();
            }
            el.append(this.renderSection('left'))
                .append(this.renderSection('right'))
                .append(this.renderSection('center'))
                .append('<div class="fc-clear"/>');
        }
        else {
            this.removeElement();
        }
    };
    Toolbar.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    Toolbar.prototype.renderSection = function (position) {
        var _this = this;
        var calendar = this.calendar;
        var theme = calendar.theme;
        var optionsManager = calendar.optionsManager;
        var viewSpecManager = calendar.viewSpecManager;
        var sectionEl = $('<div class="fc-' + position + '"/>');
        var buttonStr = this.toolbarOptions.layout[position];
        var calendarCustomButtons = optionsManager.get('customButtons') || {};
        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
        var calendarButtonText = optionsManager.get('buttonText') || {};
        if (buttonStr) {
            $.each(buttonStr.split(' '), function (i, buttonGroupStr) {
                var groupChildren = $();
                var isOnlyButtons = true;
                var groupEl;
                $.each(buttonGroupStr.split(','), function (j, buttonName) {
                    var customButtonProps;
                    var viewSpec;
                    var buttonClick;
                    var buttonIcon; // only one of these will be set
                    var buttonText; // "
                    var buttonInnerHtml;
                    var buttonClasses;
                    var buttonEl;
                    if (buttonName == 'title') {
                        groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
                        isOnlyButtons = false;
                    }
                    else {
                        if ((customButtonProps = calendarCustomButtons[buttonName])) {
                            buttonClick = function (ev) {
                                if (customButtonProps.click) {
                                    customButtonProps.click.call(buttonEl[0], ev);
                                }
                            };
                            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = customButtonProps.text);
                        }
                        else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {
                            _this.viewsWithButtons.push(buttonName);
                            buttonClick = function () {
                                calendar.changeView(buttonName);
                            };
                            (buttonText = viewSpec.buttonTextOverride) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = viewSpec.buttonTextDefault);
                        }
                        else if (calendar[buttonName]) {
                            buttonClick = function () {
                                calendar[buttonName]();
                            };
                            (buttonText = calendarButtonTextOverrides[buttonName]) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = calendarButtonText[buttonName]);
                            //            ^ everything else is considered default
                        }
                        if (buttonClick) {
                            buttonClasses = [
                                'fc-' + buttonName + '-button',
                                theme.getClass('button'),
                                theme.getClass('stateDefault')
                            ];
                            if (buttonText) {
                                buttonInnerHtml = util_1.htmlEscape(buttonText);
                            }
                            else if (buttonIcon) {
                                buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                            }
                            buttonEl = $(// type="button" so that it doesn't submit a form
                            '<button type="button" class="' + buttonClasses.join(' ') + '">' +
                                buttonInnerHtml +
                                '</button>')
                                .click(function (ev) {
                                // don't process clicks for disabled buttons
                                if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                    buttonClick(ev);
                                    // after the click action, if the button becomes the "active" tab, or disabled,
                                    // it should never have a hover class, so remove it now.
                                    if (buttonEl.hasClass(theme.getClass('stateActive')) ||
                                        buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                        buttonEl.removeClass(theme.getClass('stateHover'));
                                    }
                                }
                            })
                                .mousedown(function () {
                                // the *down* effect (mouse pressed in).
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateDown'));
                            })
                                .mouseup(function () {
                                // undo the *down* effect
                                buttonEl.removeClass(theme.getClass('stateDown'));
                            })
                                .hover(function () {
                                // the *hover* effect.
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateHover'));
                            }, function () {
                                // undo the *hover* effect
                                buttonEl
                                    .removeClass(theme.getClass('stateHover'))
                                    .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup
                            });
                            groupChildren = groupChildren.add(buttonEl);
                        }
                    }
                });
                if (isOnlyButtons) {
                    groupChildren
                        .first().addClass(theme.getClass('cornerLeft')).end()
                        .last().addClass(theme.getClass('cornerRight')).end();
                }
                if (groupChildren.length > 1) {
                    groupEl = $('<div/>');
                    if (isOnlyButtons) {
                        groupEl.addClass(theme.getClass('buttonGroup'));
                    }
                    groupEl.append(groupChildren);
                    sectionEl.append(groupEl);
                }
                else {
                    sectionEl.append(groupChildren); // 1 or 0 children
                }
            });
        }
        return sectionEl;
    };
    Toolbar.prototype.updateTitle = function (text) {
        if (this.el) {
            this.el.find('h2').text(text);
        }
    };
    Toolbar.prototype.activateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .addClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.deactivateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .removeClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.disableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', true)
                .addClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.enableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', false)
                .removeClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.getViewsWithButtons = function () {
        return this.viewsWithButtons;
    };
    return Toolbar;
}());
exports.default = Toolbar;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var options_1 = __webpack_require__(19);
var locale_1 = __webpack_require__(20);
var Model_1 = __webpack_require__(32);
var OptionsManager = /** @class */ (function (_super) {
    tslib_1.__extends(OptionsManager, _super);
    function OptionsManager(_calendar, overrides) {
        var _this = _super.call(this) || this;
        _this._calendar = _calendar;
        _this.overrides = $.extend({}, overrides); // make a copy
        _this.dynamicOverrides = {};
        _this.compute();
        return _this;
    }
    OptionsManager.prototype.add = function (newOptionHash) {
        var optionCnt = 0;
        var optionName;
        this.recordOverrides(newOptionHash); // will trigger this model's watchers
        for (optionName in newOptionHash) {
            optionCnt++;
        }
        // special-case handling of single option change.
        // if only one option change, `optionName` will be its name.
        if (optionCnt === 1) {
            if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
                this._calendar.updateViewSize(true); // isResize=true
                return;
            }
            else if (optionName === 'defaultDate') {
                return; // can't change date this way. use gotoDate instead
            }
            else if (optionName === 'businessHours') {
                return; // this model already reacts to this
            }
            else if (optionName === 'timezone') {
                this._calendar.view.flash('initialEvents');
                return;
            }
        }
        // catch-all. rerender the header and footer and rebuild/rerender the current view
        this._calendar.renderHeader();
        this._calendar.renderFooter();
        // even non-current views will be affected by this option change. do before rerender
        // TODO: detangle
        this._calendar.viewsByType = {};
        this._calendar.reinitView();
    };
    // Computes the flattened options hash for the calendar and assigns to `this.options`.
    // Assumes this.overrides and this.dynamicOverrides have already been initialized.
    OptionsManager.prototype.compute = function () {
        var locale, localeDefaults;
        var isRTL, dirDefaults;
        var rawOptions;
        locale = util_1.firstDefined(// explicit locale option given?
        this.dynamicOverrides.locale, this.overrides.locale);
        localeDefaults = locale_1.localeOptionHash[locale];
        if (!localeDefaults) {
            locale = options_1.globalDefaults.locale;
            localeDefaults = locale_1.localeOptionHash[locale] || {};
        }
        isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?
        this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);
        dirDefaults = isRTL ? options_1.rtlDefaults : {};
        this.dirDefaults = dirDefaults;
        this.localeDefaults = localeDefaults;
        rawOptions = options_1.mergeOptions([
            options_1.globalDefaults,
            dirDefaults,
            localeDefaults,
            this.overrides,
            this.dynamicOverrides
        ]);
        locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options
        this.reset(rawOptions);
    };
    // stores the new options internally, but does not rerender anything.
    OptionsManager.prototype.recordOverrides = function (newOptionHash) {
        var optionName;
        for (optionName in newOptionHash) {
            this.dynamicOverrides[optionName] = newOptionHash[optionName];
        }
        this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it
        this.compute(); // this.options needs to be recomputed after the dynamic override
    };
    return OptionsManager;
}(Model_1.default));
exports.default = OptionsManager;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
var namespace_hooks_1 = __webpack_require__(7);
var util_1 = __webpack_require__(2);
var options_1 = __webpack_require__(19);
var locale_1 = __webpack_require__(20);
var ViewSpecManager = /** @class */ (function () {
    function ViewSpecManager(optionsManager, _calendar) {
        this.optionsManager = optionsManager;
        this._calendar = _calendar;
        this.clearCache();
    }
    ViewSpecManager.prototype.clearCache = function () {
        this.viewSpecCache = {};
    };
    // Gets information about how to create a view. Will use a cache.
    ViewSpecManager.prototype.getViewSpec = function (viewType) {
        var cache = this.viewSpecCache;
        return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
    };
    // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.
    ViewSpecManager.prototype.getUnitViewSpec = function (unit) {
        var viewTypes;
        var i;
        var spec;
        if ($.inArray(unit, util_1.unitsDesc) != -1) {
            // put views that have buttons first. there will be duplicates, but oh well
            viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?
            $.each(namespace_hooks_1.default.views, function (viewType) {
                viewTypes.push(viewType);
            });
            for (i = 0; i < viewTypes.length; i++) {
                spec = this.getViewSpec(viewTypes[i]);
                if (spec) {
                    if (spec.singleUnit == unit) {
                        return spec;
                    }
                }
            }
        }
    };
    // Builds an object with information on how to create a given view
    ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {
        var viewOverrides = this.optionsManager.overrides.views || {};
        var specChain = []; // for the view. lowest to highest priority
        var defaultsChain = []; // for the view. lowest to highest priority
        var overridesChain = []; // for the view. lowest to highest priority
        var viewType = requestedViewType;
        var spec; // for the view
        var overrides; // for the view
        var durationInput;
        var duration;
        var unit;
        // iterate from the specific view definition to a more general one until we hit an actual View class
        while (viewType) {
            spec = namespace_hooks_1.default.views[viewType];
            overrides = viewOverrides[viewType];
            viewType = null; // clear. might repopulate for another iteration
            if (typeof spec === 'function') {
                spec = { 'class': spec };
            }
            if (spec) {
                specChain.unshift(spec);
                defaultsChain.unshift(spec.defaults || {});
                durationInput = durationInput || spec.duration;
                viewType = viewType || spec.type;
            }
            if (overrides) {
                overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
                durationInput = durationInput || overrides.duration;
                viewType = viewType || overrides.type;
            }
        }
        spec = util_1.mergeProps(specChain);
        spec.type = requestedViewType;
        if (!spec['class']) {
            return false;
        }
        // fall back to top-level `duration` option
        durationInput = durationInput ||
            this.optionsManager.dynamicOverrides.duration ||
            this.optionsManager.overrides.duration;
        if (durationInput) {
            duration = moment.duration(durationInput);
            if (duration.valueOf()) {
                unit = util_1.computeDurationGreatestUnit(duration, durationInput);
                spec.duration = duration;
                spec.durationUnit = unit;
                // view is a single-unit duration, like "week" or "day"
                // incorporate options for this. lowest priority
                if (duration.as(unit) === 1) {
                    spec.singleUnit = unit;
                    overridesChain.unshift(viewOverrides[unit] || {});
                }
            }
        }
        spec.defaults = options_1.mergeOptions(defaultsChain);
        spec.overrides = options_1.mergeOptions(overridesChain);
        this.buildViewSpecOptions(spec);
        this.buildViewSpecButtonText(spec, requestedViewType);
        return spec;
    };
    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides
    ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {
        var optionsManager = this.optionsManager;
        spec.options = options_1.mergeOptions([
            options_1.globalDefaults,
            spec.defaults,
            optionsManager.dirDefaults,
            optionsManager.localeDefaults,
            optionsManager.overrides,
            spec.overrides,
            optionsManager.dynamicOverrides // dynamically set via setter. highest precedence
        ]);
        locale_1.populateInstanceComputableOptions(spec.options);
    };
    // Computes and assigns a view spec's buttonText-related options
    ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {
        var optionsManager = this.optionsManager;
        // given an options object with a possible `buttonText` hash, lookup the buttonText for the
        // requested view, falling back to a generic unit entry like "week" or "day"
        function queryButtonText(options) {
            var buttonText = options.buttonText || {};
            return buttonText[requestedViewType] ||
                // view can decide to look up a certain key
                (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
                // a key like "month"
                (spec.singleUnit ? buttonText[spec.singleUnit] : null);
        }
        // highest to lowest priority
        spec.buttonTextOverride =
            queryButtonText(optionsManager.dynamicOverrides) ||
                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
                spec.overrides.buttonText; // `buttonText` for view-specific options is a string
        // highest to lowest priority. mirrors buildViewSpecOptions
        spec.buttonTextDefault =
            queryButtonText(optionsManager.localeDefaults) ||
                queryButtonText(optionsManager.dirDefaults) ||
                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
                queryButtonText(options_1.globalDefaults) ||
                (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like "3 days"
                requestedViewType; // fall back to given view name
    };
    return ViewSpecManager;
}());
exports.default = ViewSpecManager;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventPeriod_1 = __webpack_require__(79);
var ArrayEventSource_1 = __webpack_require__(34);
var EventSource_1 = __webpack_require__(5);
var EventSourceParser_1 = __webpack_require__(25);
var SingleEventDef_1 = __webpack_require__(11);
var EventInstanceGroup_1 = __webpack_require__(17);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var EventManager = /** @class */ (function () {
    function EventManager(calendar) {
        this.calendar = calendar;
        this.stickySource = new ArrayEventSource_1.default(calendar);
        this.otherSources = [];
    }
    EventManager.prototype.requestEvents = function (start, end, timezone, force) {
        if (force ||
            !this.currentPeriod ||
            !this.currentPeriod.isWithinRange(start, end) ||
            timezone !== this.currentPeriod.timezone) {
            this.setPeriod(// will change this.currentPeriod
            new EventPeriod_1.default(start, end, timezone));
        }
        return this.currentPeriod.whenReleased();
    };
    // Source Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.addSource = function (eventSource) {
        this.otherSources.push(eventSource);
        if (this.currentPeriod) {
            this.currentPeriod.requestSource(eventSource); // might release
        }
    };
    EventManager.prototype.removeSource = function (doomedSource) {
        util_1.removeExact(this.otherSources, doomedSource);
        if (this.currentPeriod) {
            this.currentPeriod.purgeSource(doomedSource); // might release
        }
    };
    EventManager.prototype.removeAllSources = function () {
        this.otherSources = [];
        if (this.currentPeriod) {
            this.currentPeriod.purgeAllSources(); // might release
        }
    };
    // Source Refetching
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.refetchSource = function (eventSource) {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeSource(eventSource);
            currentPeriod.requestSource(eventSource);
            currentPeriod.thaw();
        }
    };
    EventManager.prototype.refetchAllSources = function () {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeAllSources();
            currentPeriod.requestSources(this.getSources());
            currentPeriod.thaw();
        }
    };
    // Source Querying
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getSources = function () {
        return [this.stickySource].concat(this.otherSources);
    };
    // like querySources, but accepts multple match criteria (like multiple IDs)
    EventManager.prototype.multiQuerySources = function (matchInputs) {
        // coerce into an array
        if (!matchInputs) {
            matchInputs = [];
        }
        else if (!$.isArray(matchInputs)) {
            matchInputs = [matchInputs];
        }
        var matchingSources = [];
        var i;
        // resolve raw inputs to real event source objects
        for (i = 0; i < matchInputs.length; i++) {
            matchingSources.push.apply(// append
            matchingSources, this.querySources(matchInputs[i]));
        }
        return matchingSources;
    };
    // matchInput can either by a real event source object, an ID, or the function/URL for the source.
    // returns an array of matching source objects.
    EventManager.prototype.querySources = function (matchInput) {
        var sources = this.otherSources;
        var i, source;
        // given a proper event source object
        for (i = 0; i < sources.length; i++) {
            source = sources[i];
            if (source === matchInput) {
                return [source];
            }
        }
        // an ID match
        source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));
        if (source) {
            return [source];
        }
        // parse as an event source
        matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);
        if (matchInput) {
            return $.grep(sources, function (source) {
                return isSourcesEquivalent(matchInput, source);
            });
        }
    };
    /*
    ID assumed to already be normalized
    */
    EventManager.prototype.getSourceById = function (id) {
        return $.grep(this.otherSources, function (source) {
            return source.id && source.id === id;
        })[0];
    };
    // Event-Period
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.setPeriod = function (eventPeriod) {
        if (this.currentPeriod) {
            this.unbindPeriod(this.currentPeriod);
            this.currentPeriod = null;
        }
        this.currentPeriod = eventPeriod;
        this.bindPeriod(eventPeriod);
        eventPeriod.requestSources(this.getSources());
    };
    EventManager.prototype.bindPeriod = function (eventPeriod) {
        this.listenTo(eventPeriod, 'release', function (eventsPayload) {
            this.trigger('release', eventsPayload);
        });
    };
    EventManager.prototype.unbindPeriod = function (eventPeriod) {
        this.stopListeningTo(eventPeriod);
    };
    // Event Getting/Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getEventDefByUid = function (uid) {
        if (this.currentPeriod) {
            return this.currentPeriod.getEventDefByUid(uid);
        }
    };
    EventManager.prototype.addEventDef = function (eventDef, isSticky) {
        if (isSticky) {
            this.stickySource.addEventDef(eventDef);
        }
        if (this.currentPeriod) {
            this.currentPeriod.addEventDef(eventDef); // might release
        }
    };
    EventManager.prototype.removeEventDefsById = function (eventId) {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeEventDefsById(eventId);
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeEventDefsById(eventId); // might release
        }
    };
    EventManager.prototype.removeAllEventDefs = function () {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeAllEventDefs();
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeAllEventDefs();
        }
    };
    // Event Mutating
    // -----------------------------------------------------------------------------------------------------------------
    /*
    Returns an undo function.
    */
    EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {
        var currentPeriod = this.currentPeriod;
        var eventDefs;
        var undoFuncs = [];
        if (currentPeriod) {
            currentPeriod.freeze();
            eventDefs = currentPeriod.getEventDefsById(eventDefId);
            eventDefs.forEach(function (eventDef) {
                // add/remove esp because id might change
                currentPeriod.removeEventDef(eventDef);
                undoFuncs.push(eventDefMutation.mutateSingle(eventDef));
                currentPeriod.addEventDef(eventDef);
            });
            currentPeriod.thaw();
            return function () {
                currentPeriod.freeze();
                for (var i = 0; i < eventDefs.length; i++) {
                    currentPeriod.removeEventDef(eventDefs[i]);
                    undoFuncs[i]();
                    currentPeriod.addEventDef(eventDefs[i]);
                }
                currentPeriod.thaw();
            };
        }
        return function () { };
    };
    /*
    copies and then mutates
    */
    EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {
        var eventDefs = this.getEventDefsById(eventDefId);
        var i;
        var defCopy;
        var allInstances = [];
        for (i = 0; i < eventDefs.length; i++) {
            defCopy = eventDefs[i].clone();
            if (defCopy instanceof SingleEventDef_1.default) {
                eventDefMutation.mutateSingle(defCopy);
                allInstances.push.apply(allInstances, // append
                defCopy.buildInstances());
            }
        }
        return new EventInstanceGroup_1.default(allInstances);
    };
    // Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.freeze = function () {
        if (this.currentPeriod) {
            this.currentPeriod.freeze();
        }
    };
    EventManager.prototype.thaw = function () {
        if (this.currentPeriod) {
            this.currentPeriod.thaw();
        }
    };
    // methods that simply forward to EventPeriod
    EventManager.prototype.getEventDefsById = function (eventDefId) {
        return this.currentPeriod.getEventDefsById(eventDefId);
    };
    EventManager.prototype.getEventInstances = function () {
        return this.currentPeriod.getEventInstances();
    };
    EventManager.prototype.getEventInstancesWithId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithId(eventDefId);
    };
    EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithoutId(eventDefId);
    };
    return EventManager;
}());
exports.default = EventManager;
EmitterMixin_1.default.mixInto(EventManager);
ListenerMixin_1.default.mixInto(EventManager);
function isSourcesEquivalent(source0, source1) {
    return source0.getPrimitive() == source1.getPrimitive();
}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Promise_1 = __webpack_require__(16);
var EmitterMixin_1 = __webpack_require__(8);
var UnzonedRange_1 = __webpack_require__(4);
var EventInstanceGroup_1 = __webpack_require__(17);
var EventPeriod = /** @class */ (function () {
    function EventPeriod(start, end, timezone) {
        this.pendingCnt = 0;
        this.freezeDepth = 0;
        this.stuntedReleaseCnt = 0;
        this.releaseCnt = 0;
        this.start = start;
        this.end = end;
        this.timezone = timezone;
        this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());
        this.requestsByUid = {};
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
    }
    EventPeriod.prototype.isWithinRange = function (start, end) {
        // TODO: use a range util function?
        return !start.isBefore(this.start) && !end.isAfter(this.end);
    };
    // Requesting and Purging
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.requestSources = function (sources) {
        this.freeze();
        for (var i = 0; i < sources.length; i++) {
            this.requestSource(sources[i]);
        }
        this.thaw();
    };
    EventPeriod.prototype.requestSource = function (source) {
        var _this = this;
        var request = { source: source, status: 'pending', eventDefs: null };
        this.requestsByUid[source.uid] = request;
        this.pendingCnt += 1;
        source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {
            if (request.status !== 'cancelled') {
                request.status = 'completed';
                request.eventDefs = eventDefs;
                _this.addEventDefs(eventDefs);
                _this.pendingCnt--;
                _this.tryRelease();
            }
        }, function () {
            if (request.status !== 'cancelled') {
                request.status = 'failed';
                _this.pendingCnt--;
                _this.tryRelease();
            }
        });
    };
    EventPeriod.prototype.purgeSource = function (source) {
        var request = this.requestsByUid[source.uid];
        if (request) {
            delete this.requestsByUid[source.uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
                this.pendingCnt--;
                this.tryRelease();
            }
            else if (request.status === 'completed') {
                request.eventDefs.forEach(this.removeEventDef.bind(this));
            }
        }
    };
    EventPeriod.prototype.purgeAllSources = function () {
        var requestsByUid = this.requestsByUid;
        var uid, request;
        var completedCnt = 0;
        for (uid in requestsByUid) {
            request = requestsByUid[uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
            }
            else if (request.status === 'completed') {
                completedCnt++;
            }
        }
        this.requestsByUid = {};
        this.pendingCnt = 0;
        if (completedCnt) {
            this.removeAllEventDefs(); // might release
        }
    };
    // Event Definitions
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {
        return this.eventDefsByUid[eventDefUid];
    };
    EventPeriod.prototype.getEventDefsById = function (eventDefId) {
        var a = this.eventDefsById[eventDefId];
        if (a) {
            return a.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.addEventDefs = function (eventDefs) {
        for (var i = 0; i < eventDefs.length; i++) {
            this.addEventDef(eventDefs[i]);
        }
    };
    EventPeriod.prototype.addEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefId = eventDef.id;
        var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);
        var eventInstances = eventDef.buildInstances(this.unzonedRange);
        var i;
        eventDefs.push(eventDef);
        this.eventDefsByUid[eventDef.uid] = eventDef;
        for (i = 0; i < eventInstances.length; i++) {
            this.addEventInstance(eventInstances[i], eventDefId);
        }
    };
    EventPeriod.prototype.removeEventDefsById = function (eventDefId) {
        var _this = this;
        this.getEventDefsById(eventDefId).forEach(function (eventDef) {
            _this.removeEventDef(eventDef);
        });
    };
    EventPeriod.prototype.removeAllEventDefs = function () {
        var isEmpty = $.isEmptyObject(this.eventDefsByUid);
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
        if (!isEmpty) {
            this.tryRelease();
        }
    };
    EventPeriod.prototype.removeEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefs = eventDefsById[eventDef.id];
        delete this.eventDefsByUid[eventDef.uid];
        if (eventDefs) {
            util_1.removeExact(eventDefs, eventDef);
            if (!eventDefs.length) {
                delete eventDefsById[eventDef.id];
            }
            this.removeEventInstancesForDef(eventDef);
        }
    };
    // Event Instances
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventInstances = function () {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            eventInstances.push.apply(eventInstances, // append
            eventInstanceGroupsById[id].eventInstances);
        }
        return eventInstances;
    };
    EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {
        var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];
        if (eventInstanceGroup) {
            return eventInstanceGroup.eventInstances.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var matchingInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            if (id !== eventDefId) {
                matchingInstances.push.apply(matchingInstances, // append
                eventInstanceGroupsById[id].eventInstances);
            }
        }
        return matchingInstances;
    };
    EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||
            (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());
        eventInstanceGroup.eventInstances.push(eventInstance);
        this.tryRelease();
    };
    EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];
        var removeCnt;
        if (eventInstanceGroup) {
            removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {
                return currentEventInstance.def === eventDef;
            });
            if (!eventInstanceGroup.eventInstances.length) {
                delete eventInstanceGroupsById[eventDef.id];
            }
            if (removeCnt) {
                this.tryRelease();
            }
        }
    };
    // Releasing and Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.tryRelease = function () {
        if (!this.pendingCnt) {
            if (!this.freezeDepth) {
                this.release();
            }
            else {
                this.stuntedReleaseCnt++;
            }
        }
    };
    EventPeriod.prototype.release = function () {
        this.releaseCnt++;
        this.trigger('release', this.eventInstanceGroupsById);
    };
    EventPeriod.prototype.whenReleased = function () {
        var _this = this;
        if (this.releaseCnt) {
            return Promise_1.default.resolve(this.eventInstanceGroupsById);
        }
        else {
            return Promise_1.default.construct(function (onResolve) {
                _this.one('release', onResolve);
            });
        }
    };
    EventPeriod.prototype.freeze = function () {
        if (!(this.freezeDepth++)) {
            this.stuntedReleaseCnt = 0;
        }
    };
    EventPeriod.prototype.thaw = function () {
        if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {
            this.release();
        }
    };
    return EventPeriod;
}());
exports.default = EventPeriod;
EmitterMixin_1.default.mixInto(EventPeriod);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Model_1 = __webpack_require__(32);
var Component = /** @class */ (function (_super) {
    tslib_1.__extends(Component, _super);
    function Component() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Component.prototype.setElement = function (el) {
        this.el = el;
        this.bindGlobalHandlers();
        this.renderSkeleton();
        this.set('isInDom', true);
    };
    Component.prototype.removeElement = function () {
        this.unset('isInDom');
        this.unrenderSkeleton();
        this.unbindGlobalHandlers();
        this.el.remove();
        // NOTE: don't null-out this.el in case the View was destroyed within an API callback.
        // We don't null-out the View's other jQuery element references upon destroy,
        //  so we shouldn't kill this.el either.
    };
    Component.prototype.bindGlobalHandlers = function () {
    };
    Component.prototype.unbindGlobalHandlers = function () {
    };
    /*
    NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender
    */
    // Renders the basic structure of the view before any content is rendered
    Component.prototype.renderSkeleton = function () {
        // subclasses should implement
    };
    // Unrenders the basic structure of the view
    Component.prototype.unrenderSkeleton = function () {
        // subclasses should implement
    };
    return Component;
}(Model_1.default));
exports.default = Component;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var ListenerMixin_1 = __webpack_require__(6);
/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/
var MouseFollower = /** @class */ (function () {
    function MouseFollower(sourceEl, options) {
        this.isFollowing = false;
        this.isHidden = false;
        this.isAnimating = false; // doing the revert animation?
        this.options = options = options || {};
        this.sourceEl = sourceEl;
        this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
    }
    // Causes the element to start following the mouse
    MouseFollower.prototype.start = function (ev) {
        if (!this.isFollowing) {
            this.isFollowing = true;
            this.y0 = util_1.getEvY(ev);
            this.x0 = util_1.getEvX(ev);
            this.topDelta = 0;
            this.leftDelta = 0;
            if (!this.isHidden) {
                this.updatePosition();
            }
            if (util_1.getEvIsTouch(ev)) {
                this.listenTo($(document), 'touchmove', this.handleMove);
            }
            else {
                this.listenTo($(document), 'mousemove', this.handleMove);
            }
        }
    };
    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
    MouseFollower.prototype.stop = function (shouldRevert, callback) {
        var _this = this;
        var revertDuration = this.options.revertDuration;
        var complete = function () {
            _this.isAnimating = false;
            _this.removeElement();
            _this.top0 = _this.left0 = null; // reset state for future updatePosition calls
            if (callback) {
                callback();
            }
        };
        if (this.isFollowing && !this.isAnimating) {
            this.isFollowing = false;
            this.stopListeningTo($(document));
            if (shouldRevert && revertDuration && !this.isHidden) {
                this.isAnimating = true;
                this.el.animate({
                    top: this.top0,
                    left: this.left0
                }, {
                    duration: revertDuration,
                    complete: complete
                });
            }
            else {
                complete();
            }
        }
    };
    // Gets the tracking element. Create it if necessary
    MouseFollower.prototype.getEl = function () {
        var el = this.el;
        if (!el) {
            el = this.el = this.sourceEl.clone()
                .addClass(this.options.additionalClass || '')
                .css({
                position: 'absolute',
                visibility: '',
                display: this.isHidden ? 'none' : '',
                margin: 0,
                right: 'auto',
                bottom: 'auto',
                width: this.sourceEl.width(),
                height: this.sourceEl.height(),
                opacity: this.options.opacity || '',
                zIndex: this.options.zIndex
            });
            // we don't want long taps or any mouse interaction causing selection/menus.
            // would use preventSelection(), but that prevents selectstart, causing problems.
            el.addClass('fc-unselectable');
            el.appendTo(this.parentEl);
        }
        return el;
    };
    // Removes the tracking element if it has already been created
    MouseFollower.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    // Update the CSS position of the tracking element
    MouseFollower.prototype.updatePosition = function () {
        var sourceOffset;
        var origin;
        this.getEl(); // ensure this.el
        // make sure origin info was computed
        if (this.top0 == null) {
            sourceOffset = this.sourceEl.offset();
            origin = this.el.offsetParent().offset();
            this.top0 = sourceOffset.top - origin.top;
            this.left0 = sourceOffset.left - origin.left;
        }
        this.el.css({
            top: this.top0 + this.topDelta,
            left: this.left0 + this.leftDelta
        });
    };
    // Gets called when the user moves the mouse
    MouseFollower.prototype.handleMove = function (ev) {
        this.topDelta = util_1.getEvY(ev) - this.y0;
        this.leftDelta = util_1.getEvX(ev) - this.x0;
        if (!this.isHidden) {
            this.updatePosition();
        }
    };
    // Temporarily makes the tracking element invisible. Can be called before following starts
    MouseFollower.prototype.hide = function () {
        if (!this.isHidden) {
            this.isHidden = true;
            if (this.el) {
                this.el.hide();
            }
        }
    };
    // Show the tracking element after it has been temporarily hidden
    MouseFollower.prototype.show = function () {
        if (this.isHidden) {
            this.isHidden = false;
            this.updatePosition();
            this.getEl().show();
        }
    };
    return MouseFollower;
}());
exports.default = MouseFollower;
ListenerMixin_1.default.mixInto(MouseFollower);


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HitDragListener_1 = __webpack_require__(18);
var Interaction_1 = __webpack_require__(13);
var DateClicking = /** @class */ (function (_super) {
    tslib_1.__extends(DateClicking, _super);
    /*
    component must implement:
        - bindDateHandlerToEl
        - getSafeHitFootprint
        - getHitEl
    */
    function DateClicking(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateClicking.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateClicking.prototype.bindToEl = function (el) {
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (!component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev);
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (!component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev);
            }
        });
    };
    // Creates a listener that tracks the user's drag across day elements, for day clicking.
    DateClicking.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var dayClickHit; // null if invalid dayClick
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                dayClickHit = dragListener.origHit;
            },
            hitOver: function (hit, isOrig, origHit) {
                // if user dragged to another cell at any point, it can no longer be a dayClick
                if (!isOrig) {
                    dayClickHit = null;
                }
            },
            hitOut: function () {
                dayClickHit = null;
            },
            interactionEnd: function (ev, isCancelled) {
                var componentFootprint;
                if (!isCancelled && dayClickHit) {
                    componentFootprint = component.getSafeHitFootprint(dayClickHit);
                    if (componentFootprint) {
                        _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);
                    }
                }
            }
        });
        // because dragListener won't be called with any time delay, "dragging" will begin immediately,
        // which will kill any touchmoving/scrolling. Prevent this.
        dragListener.shouldCancelTouchScroll = false;
        dragListener.scrollAlwaysKills = true;
        return dragListener;
    };
    return DateClicking;
}(Interaction_1.default));
exports.default = DateClicking;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var EventRenderer_1 = __webpack_require__(31);
/*
Only handles foreground segs.
Does not own rendering. Use for low-level util methods by TimeGrid.
*/
var TimeGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridEventRenderer, _super);
    function TimeGridEventRenderer(timeGrid, fillRenderer) {
        var _this = _super.call(this, timeGrid, fillRenderer) || this;
        _this.timeGrid = timeGrid;
        return _this;
    }
    TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {
        this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);
    };
    // Given an array of foreground segments, render a DOM element for each, computes position,
    // and attaches to the column inner-container elements.
    TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {
        var segsByCol;
        var col;
        segsByCol = this.timeGrid.groupSegsByCol(segs);
        for (col = 0; col < this.timeGrid.colCnt; col++) {
            this.updateFgSegCoords(segsByCol[col]);
        }
        this.timeGrid.attachSegsByCol(segsByCol, containerEls);
    };
    TimeGridEventRenderer.prototype.unrenderFgSegs = function () {
        if (this.fgSegs) {
            this.fgSegs.forEach(function (seg) {
                seg.el.remove();
            });
        }
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    // Renders the HTML for a single event segment's default rendering
    TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var calendar = view.calendar;
        var componentFootprint = seg.footprint.componentFootprint;
        var isAllDay = componentFootprint.isAllDay;
        var eventDef = seg.footprint.eventDef;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeText;
        var fullTimeText; // more verbose time text. for the print stylesheet
        var startTimeText; // just the start time text
        classes.unshift('fc-time-grid-event', 'fc-v-event');
        // if the event appears to span more than one day...
        if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            // Don't display time text on segments that run entirely through a day.
            // That would appear as midnight-midnight and would look dumb.
            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
            if (seg.isStart || seg.isEnd) {
                var zonedStart = calendar.msToMoment(seg.startMs);
                var zonedEnd = calendar.msToMoment(seg.endMs);
                timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);
                fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');
                startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeText = this.getTimeText(seg.footprint);
            fullTimeText = this.getTimeText(seg.footprint, 'LT');
            startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false
        }
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (timeText ?
                '<div class="fc-time"' +
                    ' data-start="' + util_1.htmlEscape(startTimeText) + '"' +
                    ' data-full="' + util_1.htmlEscape(fullTimeText) + '"' +
                    '>' +
                    '<span>' + util_1.htmlEscape(timeText) + '</span>' +
                    '</div>' :
                '') +
            (eventDef.title ?
                '<div class="fc-title">' +
                    util_1.htmlEscape(eventDef.title) +
                    '</div>' :
                '') +
            '</div>' +
            '<div class="fc-bg"/>' +
            /* TODO: write CSS for this
            (isResizableFromStart ?
                '<div class="fc-resizer fc-start-resizer" />' :
                ''
                ) +
            */
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                '') +
            '</a>';
    };
    // Given segments that are assumed to all live in the *same column*,
    // compute their verical/horizontal coordinates and assign to their elements.
    TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {
        this.timeGrid.computeSegVerticals(segs); // horizontals relies on this
        this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
        this.timeGrid.assignSegVerticals(segs);
        this.assignFgSegHorizontals(segs);
    };
    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
    // NOTE: Also reorders the given array by date!
    TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {
        var levels;
        var level0;
        var i;
        this.sortEventSegs(segs); // order by certain criteria
        levels = buildSlotSegLevels(segs);
        computeForwardSlotSegs(levels);
        if ((level0 = levels[0])) {
            for (i = 0; i < level0.length; i++) {
                computeSlotSegPressures(level0[i]);
            }
            for (i = 0; i < level0.length; i++) {
                this.computeFgSegForwardBack(level0[i], 0, 0);
            }
        }
    };
    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
    // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
    //
    // The segment might be part of a "series", which means consecutive segments with the same pressure
    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
    // coordinate of the first segment in the series.
    TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
        var forwardSegs = seg.forwardSegs;
        var i;
        if (seg.forwardCoord === undefined) {
            if (!forwardSegs.length) {
                // if there are no forward segments, this segment should butt up against the edge
                seg.forwardCoord = 1;
            }
            else {
                // sort highest pressure first
                this.sortForwardSegs(forwardSegs);
                // this segment's forwardCoord will be calculated from the backwardCoord of the
                // highest-pressure forward segment.
                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                seg.forwardCoord = forwardSegs[0].backwardCoord;
            }
            // calculate the backwardCoord from the forwardCoord. consider the series
            seg.backwardCoord = seg.forwardCoord -
                (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                    (seriesBackwardPressure + 1); // # of segments in the series
            // use this segment's coordinates to computed the coordinates of the less-pressurized
            // forward segments
            for (i = 0; i < forwardSegs.length; i++) {
                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
            }
        }
    };
    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
        forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));
    };
    // A cmp function for determining which forward segment to rely on more when computing coordinates.
    TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {
        // put higher-pressure first
        return seg2.forwardPressure - seg1.forwardPressure ||
            // put segments that are closer to initial edge first (and favor ones with no coords yet)
            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
            // do normal sorting...
            this.compareEventSegs(seg1, seg2);
    };
    // Given foreground event segments that have already had their position coordinates computed,
    // assigns position-related CSS values to their elements.
    TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateFgSegHorizontalCss(seg));
            // if the height is short, add a className for alternate styling
            if (seg.bottom - seg.top < 30) {
                seg.el.addClass('fc-short');
            }
        }
    };
    // Generates an object with CSS properties/values that should be applied to an event segment element.
    // Contains important positioning-related properties that should be applied to any event element, customized or not.
    TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {
        var shouldOverlap = this.opt('slotEventOverlap');
        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first
        var isRTL = this.timeGrid.isRTL;
        var left; // amount of space from left edge, a fraction of the total width
        var right; // amount of space from right edge, a fraction of the total width
        if (shouldOverlap) {
            // double the width, but don't go beyond the maximum forward coordinate (1.0)
            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
        }
        if (isRTL) {
            left = 1 - forwardCoord;
            right = backwardCoord;
        }
        else {
            left = backwardCoord;
            right = 1 - forwardCoord;
        }
        props.zIndex = seg.level + 1; // convert from 0-base to 1-based
        props.left = left * 100 + '%';
        props.right = right * 100 + '%';
        if (shouldOverlap && seg.forwardPressure) {
            // add padding to the edge so that forward stacked events don't cover the resizer's icon
            props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
        }
        return props;
    };
    return TimeGridEventRenderer;
}(EventRenderer_1.default));
exports.default = TimeGridEventRenderer;
// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
    var levels = [];
    var i, seg;
    var j;
    for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        // go through all the levels and stop on the first level where there are no collisions
        for (j = 0; j < levels.length; j++) {
            if (!computeSlotSegCollisions(seg, levels[j]).length) {
                break;
            }
        }
        seg.level = j;
        (levels[j] || (levels[j] = [])).push(seg);
    }
    return levels;
}
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
    var i, level;
    var j, seg;
    var k;
    for (i = 0; i < levels.length; i++) {
        level = levels[i];
        for (j = 0; j < level.length; j++) {
            seg = level[j];
            seg.forwardSegs = [];
            for (k = i + 1; k < levels.length; k++) {
                computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
            }
        }
    }
}
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
    var forwardSegs = seg.forwardSegs;
    var forwardPressure = 0;
    var i, forwardSeg;
    if (seg.forwardPressure === undefined) {
        for (i = 0; i < forwardSegs.length; i++) {
            forwardSeg = forwardSegs[i];
            // figure out the child's maximum forward path
            computeSlotSegPressures(forwardSeg);
            // either use the existing maximum, or use the child's forward pressure
            // plus one (for the forwardSeg itself)
            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
        }
        seg.forwardPressure = forwardPressure;
    }
}
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
    if (results === void 0) { results = []; }
    for (var i = 0; i < otherSegs.length; i++) {
        if (isSlotSegCollision(seg, otherSegs[i])) {
            results.push(otherSegs[i]);
        }
    }
    return results;
}
// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var HelperRenderer_1 = __webpack_require__(43);
var TimeGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridHelperRenderer, _super);
    function TimeGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var i, seg;
        var sourceEl;
        // TODO: not good to call eventRenderer this way
        this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);
        // Try to make the segment that is in the same row as sourceSeg look the same
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (sourceSeg && sourceSeg.col === seg.col) {
                sourceEl = sourceSeg.el;
                seg.el.css({
                    left: sourceEl.css('left'),
                    right: sourceEl.css('right'),
                    'margin-left': sourceEl.css('margin-left'),
                    'margin-right': sourceEl.css('margin-right')
                });
            }
            helperNodes.push(seg.el[0]);
        }
        return $(helperNodes); // must return the elements rendered
    };
    return TimeGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = TimeGridHelperRenderer;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var FillRenderer_1 = __webpack_require__(42);
var TimeGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridFillRenderer, _super);
    function TimeGridFillRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var timeGrid = this.component;
        var containerEls;
        // TODO: more efficient lookup
        if (type === 'bgEvent') {
            containerEls = timeGrid.bgContainerEls;
        }
        else if (type === 'businessHours') {
            containerEls = timeGrid.businessContainerEls;
        }
        else if (type === 'highlight') {
            containerEls = timeGrid.highlightContainerEls;
        }
        timeGrid.updateSegVerticals(segs);
        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
        return segs.map(function (seg) {
            return seg.el[0];
        });
    };
    return TimeGridFillRenderer;
}(FillRenderer_1.default));
exports.default = TimeGridFillRenderer;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
    - className (string)
    - content (HTML string or jQuery element set)
    - parentEl
    - top
    - left
    - right (the x coord of where the right edge should be. not a "CSS" right)
    - autoHide (boolean)
    - show (callback)
    - hide (callback)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var ListenerMixin_1 = __webpack_require__(6);
var Popover = /** @class */ (function () {
    function Popover(options) {
        this.isHidden = true;
        this.margin = 10; // the space required between the popover and the edges of the scroll container
        this.options = options || {};
    }
    // Shows the popover on the specified position. Renders it if not already
    Popover.prototype.show = function () {
        if (this.isHidden) {
            if (!this.el) {
                this.render();
            }
            this.el.show();
            this.position();
            this.isHidden = false;
            this.trigger('show');
        }
    };
    // Hides the popover, through CSS, but does not remove it from the DOM
    Popover.prototype.hide = function () {
        if (!this.isHidden) {
            this.el.hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    };
    // Creates `this.el` and renders content inside of it
    Popover.prototype.render = function () {
        var _this = this;
        var options = this.options;
        this.el = $('<div class="fc-popover"/>')
            .addClass(options.className || '')
            .css({
            // position initially to the top left to avoid creating scrollbars
            top: 0,
            left: 0
        })
            .append(options.content)
            .appendTo(options.parentEl);
        // when a click happens on anything inside with a 'fc-close' className, hide the popover
        this.el.on('click', '.fc-close', function () {
            _this.hide();
        });
        if (options.autoHide) {
            this.listenTo($(document), 'mousedown', this.documentMousedown);
        }
    };
    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
    Popover.prototype.documentMousedown = function (ev) {
        // only hide the popover if the click happened outside the popover
        if (this.el && !$(ev.target).closest(this.el).length) {
            this.hide();
        }
    };
    // Hides and unregisters any handlers
    Popover.prototype.removeElement = function () {
        this.hide();
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
        this.stopListeningTo($(document), 'mousedown');
    };
    // Positions the popover optimally, using the top/left/right options
    Popover.prototype.position = function () {
        var options = this.options;
        var origin = this.el.offsetParent().offset();
        var width = this.el.outerWidth();
        var height = this.el.outerHeight();
        var windowEl = $(window);
        var viewportEl = util_1.getScrollParent(this.el);
        var viewportTop;
        var viewportLeft;
        var viewportOffset;
        var top; // the "position" (not "offset") values for the popover
        var left; //
        // compute top and left
        top = options.top || 0;
        if (options.left !== undefined) {
            left = options.left;
        }
        else if (options.right !== undefined) {
            left = options.right - width; // derive the left value from the right value
        }
        else {
            left = 0;
        }
        if (viewportEl.is(window) || viewportEl.is(document)) {
            viewportEl = windowEl;
            viewportTop = 0; // the window is always at the top left
            viewportLeft = 0; // (and .offset() won't work if called here)
        }
        else {
            viewportOffset = viewportEl.offset();
            viewportTop = viewportOffset.top;
            viewportLeft = viewportOffset.left;
        }
        // if the window is scrolled, it causes the visible area to be further down
        viewportTop += windowEl.scrollTop();
        viewportLeft += windowEl.scrollLeft();
        // constrain to the view port. if constrained by two edges, give precedence to top/left
        if (options.viewportConstrain !== false) {
            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
            top = Math.max(top, viewportTop + this.margin);
            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
            left = Math.max(left, viewportLeft + this.margin);
        }
        this.el.css({
            top: top - origin.top,
            left: left - origin.left
        });
    };
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    // TODO: better code reuse for this. Repeat code
    Popover.prototype.trigger = function (name) {
        if (this.options[name]) {
            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
        }
    };
    return Popover;
}());
exports.default = Popover;
ListenerMixin_1.default.mixInto(Popover);


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventRenderer_1 = __webpack_require__(31);
/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/
var DayGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridEventRenderer, _super);
    function DayGridEventRenderer(dayGrid, fillRenderer) {
        var _this = _super.call(this, dayGrid, fillRenderer) || this;
        _this.dayGrid = dayGrid;
        return _this;
    }
    DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {
        // don't render timed background events
        eventRanges = $.grep(eventRanges, function (eventRange) {
            return eventRange.eventDef.isAllDay();
        });
        _super.prototype.renderBgRanges.call(this, eventRanges);
    };
    // Renders the given foreground event segments onto the grid
    DayGridEventRenderer.prototype.renderFgSegs = function (segs) {
        var rowStructs = this.rowStructs = this.renderSegRows(segs);
        // append to each row's content skeleton
        this.dayGrid.rowEls.each(function (i, rowNode) {
            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);
        });
    };
    // Unrenders all currently rendered foreground event segments
    DayGridEventRenderer.prototype.unrenderFgSegs = function () {
        var rowStructs = this.rowStructs || [];
        var rowStruct;
        while ((rowStruct = rowStructs.pop())) {
            rowStruct.tbodyEl.remove();
        }
        this.rowStructs = null;
    };
    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
    DayGridEventRenderer.prototype.renderSegRows = function (segs) {
        var rowStructs = [];
        var segRows;
        var row;
        segRows = this.groupSegRows(segs); // group into nested arrays
        // iterate each row of segment groupings
        for (row = 0; row < segRows.length; row++) {
            rowStructs.push(this.renderSegRow(row, segRows[row]));
        }
        return rowStructs;
    };
    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
    // the segments. Returns object with a bunch of internal data about how the render was calculated.
    // NOTE: modifies rowSegs
    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
        var colCnt = this.dayGrid.colCnt;
        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
        var tbody = $('<tbody/>');
        var segMatrix = []; // lookup for which segments are rendered into which level+col cells
        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
        var i, levelSegs;
        var col;
        var tr;
        var j, seg;
        var td;
        // populates empty cells from the current column (`col`) to `endCol`
        function emptyCellsUntil(endCol) {
            while (col < endCol) {
                // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                td = (loneCellMatrix[i - 1] || [])[col];
                if (td) {
                    td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);
                }
                else {
                    td = $('<td/>');
                    tr.append(td);
                }
                cellMatrix[i][col] = td;
                loneCellMatrix[i][col] = td;
                col++;
            }
        }
        for (i = 0; i < levelCnt; i++) {
            levelSegs = segLevels[i];
            col = 0;
            tr = $('<tr/>');
            segMatrix.push([]);
            cellMatrix.push([]);
            loneCellMatrix.push([]);
            // levelCnt might be 1 even though there are no actual levels. protect against this.
            // this single empty row is useful for styling.
            if (levelSegs) {
                for (j = 0; j < levelSegs.length; j++) {
                    seg = levelSegs[j];
                    emptyCellsUntil(seg.leftCol);
                    // create a container that occupies or more columns. append the event element.
                    td = $('<td class="fc-event-container"/>').append(seg.el);
                    if (seg.leftCol != seg.rightCol) {
                        td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                    }
                    else {
                        loneCellMatrix[i][col] = td;
                    }
                    while (col <= seg.rightCol) {
                        cellMatrix[i][col] = td;
                        segMatrix[i][col] = seg;
                        col++;
                    }
                    tr.append(td);
                }
            }
            emptyCellsUntil(colCnt); // finish off the row
            this.dayGrid.bookendCells(tr);
            tbody.append(tr);
        }
        return {
            row: row,
            tbodyEl: tbody,
            cellMatrix: cellMatrix,
            segMatrix: segMatrix,
            segLevels: segLevels,
            segs: rowSegs
        };
    };
    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
    // NOTE: modifies segs
    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
        var levels = [];
        var i, seg;
        var j;
        // Give preference to elements with certain criteria, so they have
        // a chance to be closer to the top.
        this.sortEventSegs(segs);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
            for (j = 0; j < levels.length; j++) {
                if (!isDaySegCollision(seg, levels[j])) {
                    break;
                }
            }
            // `j` now holds the desired subrow index
            seg.level = j;
            // create new level array if needed and append segment
            (levels[j] || (levels[j] = [])).push(seg);
        }
        // order segments left-to-right. very important if calendar is RTL
        for (j = 0; j < levels.length; j++) {
            levels[j].sort(compareDaySegCols);
        }
        return levels;
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
    DayGridEventRenderer.prototype.groupSegRows = function (segs) {
        var segRows = [];
        var i;
        for (i = 0; i < this.dayGrid.rowCnt; i++) {
            segRows.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segRows[segs[i].row].push(segs[i]);
        }
        return segRows;
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    DayGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
    };
    // Builds the HTML to be used for the default element for an individual segment
    DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var isAllDay = seg.footprint.componentFootprint.isAllDay;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && isAllDay &&
            seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && isAllDay &&
            seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeHtml = '';
        var timeText;
        var titleHtml;
        classes.unshift('fc-day-grid-event', 'fc-h-event');
        // Only display a timed events time if it is the starting segment
        if (seg.isStart) {
            timeText = this.getTimeText(seg.footprint);
            if (timeText) {
                timeHtml = '<span class="fc-time">' + util_1.htmlEscape(timeText) + '</span>';
            }
        }
        titleHtml =
            '<span class="fc-title">' +
                (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height
                '</span>';
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (this.dayGrid.isRTL ?
                titleHtml + ' ' + timeHtml : // put a natural space in between
                timeHtml + ' ' + titleHtml //
            ) +
            '</div>' +
            (isResizableFromStart ?
                '<div class="fc-resizer fc-start-resizer" />' :
                '') +
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                '') +
            '</a>';
    };
    return DayGridEventRenderer;
}(EventRenderer_1.default));
exports.default = DayGridEventRenderer;
// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
    var i, otherSeg;
    for (i = 0; i < otherSegs.length; i++) {
        otherSeg = otherSegs[i];
        if (otherSeg.leftCol <= seg.rightCol &&
            otherSeg.rightCol >= seg.leftCol) {
            return true;
        }
    }
    return false;
}
// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
    return a.leftCol - b.leftCol;
}


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var HelperRenderer_1 = __webpack_require__(43);
var DayGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridHelperRenderer, _super);
    function DayGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
    DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var rowStructs;
        // TODO: not good to call eventRenderer this way
        rowStructs = this.eventRenderer.renderSegRows(segs);
        // inject each new event skeleton into each associated row
        this.component.rowEls.each(function (row, rowNode) {
            var rowEl = $(rowNode); // the .fc-row
            var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
            var skeletonTopEl;
            var skeletonTop;
            // If there is an original segment, match the top position. Otherwise, put it at the row's top level
            if (sourceSeg && sourceSeg.row === row) {
                skeletonTop = sourceSeg.el.position().top;
            }
            else {
                skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');
                if (!skeletonTopEl.length) {
                    skeletonTopEl = rowEl.find('.fc-content-skeleton table');
                }
                skeletonTop = skeletonTopEl.position().top;
            }
            skeletonEl.css('top', skeletonTop)
                .find('table')
                .append(rowStructs[row].tbodyEl);
            rowEl.append(skeletonEl);
            helperNodes.push(skeletonEl[0]);
        });
        return $(helperNodes); // must return the elements rendered
    };
    return DayGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = DayGridHelperRenderer;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var FillRenderer_1 = __webpack_require__(42);
var DayGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridFillRenderer, _super);
    function DayGridFillRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fillSegTag = 'td'; // override the default tag name
        return _this;
    }
    DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var nodes = [];
        var i, seg;
        var skeletonEl;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            skeletonEl = this.renderFillRow(type, seg);
            this.component.rowEls.eq(seg.row).append(skeletonEl);
            nodes.push(skeletonEl[0]);
        }
        return nodes;
    };
    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
        var colCnt = this.component.colCnt;
        var startCol = seg.leftCol;
        var endCol = seg.rightCol + 1;
        var className;
        var skeletonEl;
        var trEl;
        if (type === 'businessHours') {
            className = 'bgevent';
        }
        else {
            className = type.toLowerCase();
        }
        skeletonEl = $('<div class="fc-' + className + '-skeleton">' +
            '<table><tr/></table>' +
            '</div>');
        trEl = skeletonEl.find('tr');
        if (startCol > 0) {
            trEl.append('<td colspan="' + startCol + '"/>');
        }
        trEl.append(seg.el.attr('colspan', endCol - startCol));
        if (endCol < colCnt) {
            trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
        }
        this.component.bookendCells(trEl);
        return skeletonEl;
    };
    return DayGridFillRenderer;
}(FillRenderer_1.default));
exports.default = DayGridFillRenderer;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var EventRenderer_1 = __webpack_require__(31);
var ListEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventRenderer, _super);
    function ListEventRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListEventRenderer.prototype.renderFgSegs = function (segs) {
        if (!segs.length) {
            this.component.renderEmptyMessage();
        }
        else {
            this.component.renderSegList(segs);
        }
    };
    // generates the HTML for a single event row
    ListEventRenderer.prototype.fgSegHtml = function (seg) {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var eventFootprint = seg.footprint;
        var eventDef = eventFootprint.eventDef;
        var componentFootprint = eventFootprint.componentFootprint;
        var url = eventDef.url;
        var classes = ['fc-list-item'].concat(this.getClasses(eventDef));
        var bgColor = this.getBgColor(eventDef);
        var timeHtml;
        if (componentFootprint.isAllDay) {
            timeHtml = view.getAllDayHtml();
        }
        else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            if (seg.isStart || seg.isEnd) {
                timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));
            }
            else {
                timeHtml = view.getAllDayHtml();
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));
        }
        if (url) {
            classes.push('fc-has-url');
        }
        return '<tr class="' + classes.join(' ') + '">' +
            (this.displayEventTime ?
                '<td class="fc-list-item-time ' + theme.getClass('widgetContent') + '">' +
                    (timeHtml || '') +
                    '</td>' :
                '') +
            '<td class="fc-list-item-marker ' + theme.getClass('widgetContent') + '">' +
            '<span class="fc-event-dot"' +
            (bgColor ?
                ' style="background-color:' + bgColor + '"' :
                '') +
            '></span>' +
            '</td>' +
            '<td class="fc-list-item-title ' + theme.getClass('widgetContent') + '">' +
            '<a' + (url ? ' href="' + util_1.htmlEscape(url) + '"' : '') + '>' +
            util_1.htmlEscape(eventDef.title || '') +
            '</a>' +
            '</td>' +
            '</tr>';
    };
    // like "4:00am"
    ListEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('mediumTimeFormat');
    };
    return ListEventRenderer;
}(EventRenderer_1.default));
exports.default = ListEventRenderer;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var EventPointing_1 = __webpack_require__(44);
var ListEventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventPointing, _super);
    function ListEventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // for events with a url, the whole <tr> should be clickable,
    // but it's impossible to wrap with an <a> tag. simulate this.
    ListEventPointing.prototype.handleClick = function (seg, ev) {
        var url;
        _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action
        // not clicking on or within an <a> with an href
        if (!$(ev.target).closest('a[href]').length) {
            url = seg.footprint.eventDef.url;
            if (url && !ev.isDefaultPrevented()) {
                window.location.href = url; // simulate link click
            }
        }
    };
    return ListEventPointing;
}(EventPointing_1.default));
exports.default = ListEventPointing;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventSourceParser_1 = __webpack_require__(25);
var ArrayEventSource_1 = __webpack_require__(34);
var FuncEventSource_1 = __webpack_require__(57);
var JsonFeedEventSource_1 = __webpack_require__(58);
EventSourceParser_1.default.registerClass(ArrayEventSource_1.default);
EventSourceParser_1.default.registerClass(FuncEventSource_1.default);
EventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ThemeRegistry_1 = __webpack_require__(36);
var StandardTheme_1 = __webpack_require__(55);
var JqueryUiTheme_1 = __webpack_require__(56);
var BootstrapTheme_1 = __webpack_require__(94);
ThemeRegistry_1.default.register('standard', StandardTheme_1.default);
ThemeRegistry_1.default.register('jquery-ui', JqueryUiTheme_1.default);
ThemeRegistry_1.default.register('bootstrap3', BootstrapTheme_1.default);


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Theme_1 = __webpack_require__(27);
var BootstrapTheme = /** @class */ (function (_super) {
    tslib_1.__extends(BootstrapTheme, _super);
    function BootstrapTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BootstrapTheme;
}(Theme_1.default));
exports.default = BootstrapTheme;
BootstrapTheme.prototype.classes = {
    widget: 'fc-bootstrap3',
    tableGrid: 'table-bordered',
    tableList: 'table table-striped',
    buttonGroup: 'btn-group',
    button: 'btn btn-default',
    stateActive: 'active',
    stateDisabled: 'disabled',
    today: 'alert alert-info',
    popover: 'panel panel-default',
    popoverHeader: 'panel-heading',
    popoverContent: 'panel-body',
    // day grid
    headerRow: 'panel-default',
    dayRow: 'panel-default',
    // list view
    listView: 'panel panel-default'
};
BootstrapTheme.prototype.baseIconClass = 'glyphicon';
BootstrapTheme.prototype.iconClasses = {
    close: 'glyphicon-remove',
    prev: 'glyphicon-chevron-left',
    next: 'glyphicon-chevron-right',
    prevYear: 'glyphicon-backward',
    nextYear: 'glyphicon-forward'
};
BootstrapTheme.prototype.iconOverrideOption = 'bootstrapGlyphicons';
BootstrapTheme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';
BootstrapTheme.prototype.iconOverridePrefix = 'glyphicon-';


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var namespace_hooks_1 = __webpack_require__(7);
var BasicView_1 = __webpack_require__(47);
var MonthView_1 = __webpack_require__(70);
var views = namespace_hooks_1.default.views;
views.basic = {
    'class': BasicView_1.default
};
views.basicDay = {
    type: 'basic',
    duration: { days: 1 }
};
views.basicWeek = {
    type: 'basic',
    duration: { weeks: 1 }
};
views.month = {
    'class': MonthView_1.default,
    duration: { months: 1 },
    defaults: {
        fixedWeekCount: true
    }
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var namespace_hooks_1 = __webpack_require__(7);
var AgendaView_1 = __webpack_require__(67);
var views = namespace_hooks_1.default.views;
views.agenda = {
    'class': AgendaView_1.default,
    defaults: {
        allDaySlot: true,
        slotDuration: '00:30:00',
        slotEventOverlap: true // a bad name. confused with overlap/constraint system
    }
};
views.agendaDay = {
    type: 'agenda',
    duration: { days: 1 }
};
views.agendaWeek = {
    type: 'agenda',
    duration: { weeks: 1 }
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var namespace_hooks_1 = __webpack_require__(7);
var ListView_1 = __webpack_require__(71);
var views = namespace_hooks_1.default.views;
views.list = {
    'class': ListView_1.default,
    buttonTextKey: 'list',
    defaults: {
        buttonText: 'list',
        listDayFormat: 'LL',
        noEventsMessage: 'No events to display'
    }
};
views.listDay = {
    type: 'list',
    duration: { days: 1 },
    defaults: {
        listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
    }
};
views.listWeek = {
    type: 'list',
    duration: { weeks: 1 },
    defaults: {
        listDayFormat: 'dddd',
        listDayAltFormat: 'LL'
    }
};
views.listMonth = {
    type: 'list',
    duration: { month: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
};
views.listYear = {
    type: 'list',
    duration: { year: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
};


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/moment/locale recursive ^\\.\\/.*$":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "./node_modules/moment/locale/af.js",
	"./af.js": "./node_modules/moment/locale/af.js",
	"./ar": "./node_modules/moment/locale/ar.js",
	"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
	"./ar.js": "./node_modules/moment/locale/ar.js",
	"./az": "./node_modules/moment/locale/az.js",
	"./az.js": "./node_modules/moment/locale/az.js",
	"./be": "./node_modules/moment/locale/be.js",
	"./be.js": "./node_modules/moment/locale/be.js",
	"./bg": "./node_modules/moment/locale/bg.js",
	"./bg.js": "./node_modules/moment/locale/bg.js",
	"./bm": "./node_modules/moment/locale/bm.js",
	"./bm.js": "./node_modules/moment/locale/bm.js",
	"./bn": "./node_modules/moment/locale/bn.js",
	"./bn.js": "./node_modules/moment/locale/bn.js",
	"./bo": "./node_modules/moment/locale/bo.js",
	"./bo.js": "./node_modules/moment/locale/bo.js",
	"./br": "./node_modules/moment/locale/br.js",
	"./br.js": "./node_modules/moment/locale/br.js",
	"./bs": "./node_modules/moment/locale/bs.js",
	"./bs.js": "./node_modules/moment/locale/bs.js",
	"./ca": "./node_modules/moment/locale/ca.js",
	"./ca.js": "./node_modules/moment/locale/ca.js",
	"./cs": "./node_modules/moment/locale/cs.js",
	"./cs.js": "./node_modules/moment/locale/cs.js",
	"./cv": "./node_modules/moment/locale/cv.js",
	"./cv.js": "./node_modules/moment/locale/cv.js",
	"./cy": "./node_modules/moment/locale/cy.js",
	"./cy.js": "./node_modules/moment/locale/cy.js",
	"./da": "./node_modules/moment/locale/da.js",
	"./da.js": "./node_modules/moment/locale/da.js",
	"./de": "./node_modules/moment/locale/de.js",
	"./de-at": "./node_modules/moment/locale/de-at.js",
	"./de-at.js": "./node_modules/moment/locale/de-at.js",
	"./de-ch": "./node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
	"./de.js": "./node_modules/moment/locale/de.js",
	"./dv": "./node_modules/moment/locale/dv.js",
	"./dv.js": "./node_modules/moment/locale/dv.js",
	"./el": "./node_modules/moment/locale/el.js",
	"./el.js": "./node_modules/moment/locale/el.js",
	"./en-au": "./node_modules/moment/locale/en-au.js",
	"./en-au.js": "./node_modules/moment/locale/en-au.js",
	"./en-ca": "./node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
	"./en-gb": "./node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
	"./en-ie": "./node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
	"./en-nz": "./node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
	"./eo": "./node_modules/moment/locale/eo.js",
	"./eo.js": "./node_modules/moment/locale/eo.js",
	"./es": "./node_modules/moment/locale/es.js",
	"./es-do": "./node_modules/moment/locale/es-do.js",
	"./es-do.js": "./node_modules/moment/locale/es-do.js",
	"./es-us": "./node_modules/moment/locale/es-us.js",
	"./es-us.js": "./node_modules/moment/locale/es-us.js",
	"./es.js": "./node_modules/moment/locale/es.js",
	"./et": "./node_modules/moment/locale/et.js",
	"./et.js": "./node_modules/moment/locale/et.js",
	"./eu": "./node_modules/moment/locale/eu.js",
	"./eu.js": "./node_modules/moment/locale/eu.js",
	"./fa": "./node_modules/moment/locale/fa.js",
	"./fa.js": "./node_modules/moment/locale/fa.js",
	"./fi": "./node_modules/moment/locale/fi.js",
	"./fi.js": "./node_modules/moment/locale/fi.js",
	"./fo": "./node_modules/moment/locale/fo.js",
	"./fo.js": "./node_modules/moment/locale/fo.js",
	"./fr": "./node_modules/moment/locale/fr.js",
	"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
	"./fr.js": "./node_modules/moment/locale/fr.js",
	"./fy": "./node_modules/moment/locale/fy.js",
	"./fy.js": "./node_modules/moment/locale/fy.js",
	"./gd": "./node_modules/moment/locale/gd.js",
	"./gd.js": "./node_modules/moment/locale/gd.js",
	"./gl": "./node_modules/moment/locale/gl.js",
	"./gl.js": "./node_modules/moment/locale/gl.js",
	"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
	"./gu": "./node_modules/moment/locale/gu.js",
	"./gu.js": "./node_modules/moment/locale/gu.js",
	"./he": "./node_modules/moment/locale/he.js",
	"./he.js": "./node_modules/moment/locale/he.js",
	"./hi": "./node_modules/moment/locale/hi.js",
	"./hi.js": "./node_modules/moment/locale/hi.js",
	"./hr": "./node_modules/moment/locale/hr.js",
	"./hr.js": "./node_modules/moment/locale/hr.js",
	"./hu": "./node_modules/moment/locale/hu.js",
	"./hu.js": "./node_modules/moment/locale/hu.js",
	"./hy-am": "./node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
	"./id": "./node_modules/moment/locale/id.js",
	"./id.js": "./node_modules/moment/locale/id.js",
	"./is": "./node_modules/moment/locale/is.js",
	"./is.js": "./node_modules/moment/locale/is.js",
	"./it": "./node_modules/moment/locale/it.js",
	"./it.js": "./node_modules/moment/locale/it.js",
	"./ja": "./node_modules/moment/locale/ja.js",
	"./ja.js": "./node_modules/moment/locale/ja.js",
	"./jv": "./node_modules/moment/locale/jv.js",
	"./jv.js": "./node_modules/moment/locale/jv.js",
	"./ka": "./node_modules/moment/locale/ka.js",
	"./ka.js": "./node_modules/moment/locale/ka.js",
	"./kk": "./node_modules/moment/locale/kk.js",
	"./kk.js": "./node_modules/moment/locale/kk.js",
	"./km": "./node_modules/moment/locale/km.js",
	"./km.js": "./node_modules/moment/locale/km.js",
	"./kn": "./node_modules/moment/locale/kn.js",
	"./kn.js": "./node_modules/moment/locale/kn.js",
	"./ko": "./node_modules/moment/locale/ko.js",
	"./ko.js": "./node_modules/moment/locale/ko.js",
	"./ky": "./node_modules/moment/locale/ky.js",
	"./ky.js": "./node_modules/moment/locale/ky.js",
	"./lb": "./node_modules/moment/locale/lb.js",
	"./lb.js": "./node_modules/moment/locale/lb.js",
	"./lo": "./node_modules/moment/locale/lo.js",
	"./lo.js": "./node_modules/moment/locale/lo.js",
	"./lt": "./node_modules/moment/locale/lt.js",
	"./lt.js": "./node_modules/moment/locale/lt.js",
	"./lv": "./node_modules/moment/locale/lv.js",
	"./lv.js": "./node_modules/moment/locale/lv.js",
	"./me": "./node_modules/moment/locale/me.js",
	"./me.js": "./node_modules/moment/locale/me.js",
	"./mi": "./node_modules/moment/locale/mi.js",
	"./mi.js": "./node_modules/moment/locale/mi.js",
	"./mk": "./node_modules/moment/locale/mk.js",
	"./mk.js": "./node_modules/moment/locale/mk.js",
	"./ml": "./node_modules/moment/locale/ml.js",
	"./ml.js": "./node_modules/moment/locale/ml.js",
	"./mr": "./node_modules/moment/locale/mr.js",
	"./mr.js": "./node_modules/moment/locale/mr.js",
	"./ms": "./node_modules/moment/locale/ms.js",
	"./ms-my": "./node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
	"./ms.js": "./node_modules/moment/locale/ms.js",
	"./my": "./node_modules/moment/locale/my.js",
	"./my.js": "./node_modules/moment/locale/my.js",
	"./nb": "./node_modules/moment/locale/nb.js",
	"./nb.js": "./node_modules/moment/locale/nb.js",
	"./ne": "./node_modules/moment/locale/ne.js",
	"./ne.js": "./node_modules/moment/locale/ne.js",
	"./nl": "./node_modules/moment/locale/nl.js",
	"./nl-be": "./node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
	"./nl.js": "./node_modules/moment/locale/nl.js",
	"./nn": "./node_modules/moment/locale/nn.js",
	"./nn.js": "./node_modules/moment/locale/nn.js",
	"./pa-in": "./node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
	"./pl": "./node_modules/moment/locale/pl.js",
	"./pl.js": "./node_modules/moment/locale/pl.js",
	"./pt": "./node_modules/moment/locale/pt.js",
	"./pt-br": "./node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
	"./pt.js": "./node_modules/moment/locale/pt.js",
	"./ro": "./node_modules/moment/locale/ro.js",
	"./ro.js": "./node_modules/moment/locale/ro.js",
	"./ru": "./node_modules/moment/locale/ru.js",
	"./ru.js": "./node_modules/moment/locale/ru.js",
	"./sd": "./node_modules/moment/locale/sd.js",
	"./sd.js": "./node_modules/moment/locale/sd.js",
	"./se": "./node_modules/moment/locale/se.js",
	"./se.js": "./node_modules/moment/locale/se.js",
	"./si": "./node_modules/moment/locale/si.js",
	"./si.js": "./node_modules/moment/locale/si.js",
	"./sk": "./node_modules/moment/locale/sk.js",
	"./sk.js": "./node_modules/moment/locale/sk.js",
	"./sl": "./node_modules/moment/locale/sl.js",
	"./sl.js": "./node_modules/moment/locale/sl.js",
	"./sq": "./node_modules/moment/locale/sq.js",
	"./sq.js": "./node_modules/moment/locale/sq.js",
	"./sr": "./node_modules/moment/locale/sr.js",
	"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "./node_modules/moment/locale/sr.js",
	"./ss": "./node_modules/moment/locale/ss.js",
	"./ss.js": "./node_modules/moment/locale/ss.js",
	"./sv": "./node_modules/moment/locale/sv.js",
	"./sv.js": "./node_modules/moment/locale/sv.js",
	"./sw": "./node_modules/moment/locale/sw.js",
	"./sw.js": "./node_modules/moment/locale/sw.js",
	"./ta": "./node_modules/moment/locale/ta.js",
	"./ta.js": "./node_modules/moment/locale/ta.js",
	"./te": "./node_modules/moment/locale/te.js",
	"./te.js": "./node_modules/moment/locale/te.js",
	"./tet": "./node_modules/moment/locale/tet.js",
	"./tet.js": "./node_modules/moment/locale/tet.js",
	"./th": "./node_modules/moment/locale/th.js",
	"./th.js": "./node_modules/moment/locale/th.js",
	"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
	"./tlh": "./node_modules/moment/locale/tlh.js",
	"./tlh.js": "./node_modules/moment/locale/tlh.js",
	"./tr": "./node_modules/moment/locale/tr.js",
	"./tr.js": "./node_modules/moment/locale/tr.js",
	"./tzl": "./node_modules/moment/locale/tzl.js",
	"./tzl.js": "./node_modules/moment/locale/tzl.js",
	"./tzm": "./node_modules/moment/locale/tzm.js",
	"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "./node_modules/moment/locale/tzm.js",
	"./uk": "./node_modules/moment/locale/uk.js",
	"./uk.js": "./node_modules/moment/locale/uk.js",
	"./ur": "./node_modules/moment/locale/ur.js",
	"./ur.js": "./node_modules/moment/locale/ur.js",
	"./uz": "./node_modules/moment/locale/uz.js",
	"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
	"./uz.js": "./node_modules/moment/locale/uz.js",
	"./vi": "./node_modules/moment/locale/vi.js",
	"./vi.js": "./node_modules/moment/locale/vi.js",
	"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
	"./yo": "./node_modules/moment/locale/yo.js",
	"./yo.js": "./node_modules/moment/locale/yo.js",
	"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
	"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/moment/locale recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/moment/locale/af.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var af = moment.defineLocale('af', {
    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM : function (input) {
        return /^nm$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'vm' : 'VM';
        } else {
            return isLower ? 'nm' : 'NM';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Vandag om] LT',
        nextDay : '[Mre om] LT',
        nextWeek : 'dddd [om] LT',
        lastDay : '[Gister om] LT',
        lastWeek : '[Laas] dddd [om] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'oor %s',
        past : '%s gelede',
        s : '\'n paar sekondes',
        m : '\'n minuut',
        mm : '%d minute',
        h : '\'n uur',
        hh : '%d ure',
        d : '\'n dag',
        dd : '%d dae',
        M : '\'n maand',
        MM : '%d maande',
        y : '\'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week : {
        dow : 1, // Maandag is die eerste dag van die week.
        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
    }
});

return af;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-dz.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arDz = moment.defineLocale('ar-dz', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 4  // The week that contains Jan 1st is the first week of the year.
    }
});

return arDz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-kw.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arKw = moment.defineLocale('ar-kw', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return arKw;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-ly.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    '0': '0'
};
var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals = {
    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
};
var pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
            str = plurals[u][pluralForm(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var arLy = moment.defineLocale('ar-ly', {
    months : months,
    monthsShort : months,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : pluralize('s'),
        m : pluralize('m'),
        mm : pluralize('m'),
        h : pluralize('h'),
        hh : pluralize('h'),
        d : pluralize('d'),
        dd : pluralize('d'),
        M : pluralize('M'),
        MM : pluralize('M'),
        y : pluralize('y'),
        yy : pluralize('y')
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return arLy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-ma.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arMa = moment.defineLocale('ar-ma', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return arMa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-sa.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var arSa = moment.defineLocale('ar-sa', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return arSa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-tn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arTn = moment.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: ' %s',
        past: ' %s',
        s: '',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

return arTn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};
var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals = {
    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
};
var pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
            str = plurals[u][pluralForm(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months = [
    '  ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    '  ',
    '  ',
    '  '
];

var ar = moment.defineLocale('ar', {
    months : months,
    monthsShort : months,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : pluralize('s'),
        m : pluralize('m'),
        mm : pluralize('m'),
        h : pluralize('h'),
        hh : pluralize('h'),
        d : pluralize('d'),
        dd : pluralize('d'),
        M : pluralize('M'),
        MM : pluralize('M'),
        y : pluralize('y'),
        yy : pluralize('y')
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return ar;

})));


/***/ }),

/***/ "./node_modules/moment/locale/az.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
};

var az = moment.defineLocale('az', {
    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugn saat] LT',
        nextDay : '[sabah saat] LT',
        nextWeek : '[gln hft] dddd [saat] LT',
        lastDay : '[dnn] LT',
        lastWeek : '[ken hft] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s vvl',
        s : 'birne saniyy',
        m : 'bir dqiq',
        mm : '%d dqiq',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gn',
        dd : '%d gn',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir il',
        yy : '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM : function (input) {
        return /^(gndz|axam)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'gec';
        } else if (hour < 12) {
            return 'shr';
        } else if (hour < 17) {
            return 'gndz';
        } else {
            return 'axam';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '-nc';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return az;

})));


/***/ }),

/***/ "./node_modules/moment/locale/be.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else if (key === 'h') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}

var be = moment.defineLocale('be', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : {
        format: '______'.split('_'),
        standalone: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        lastDay: '[ ] LT',
        nextWeek: function () {
            return '[] dddd [] LT';
        },
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : relativeTimeWithPlural,
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM : function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return be;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bg.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var bg = moment.defineLocale('bg', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-';
        } else if (last2Digits === 0) {
            return number + '-';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-';
        } else if (lastDigit === 1) {
            return number + '-';
        } else if (lastDigit === 2) {
            return number + '-';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-';
        } else {
            return number + '-';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return bg;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bm.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

// Language contact person : Abdoufata Kane : https://github.com/abdoufata

var bm = moment.defineLocale('bm', {
    months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
    weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'MMMM [tile] D [san] YYYY',
        LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',
        LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
    },
    calendar : {
        sameDay : '[Bi lr] LT',
        nextDay : '[Sini lr] LT',
        nextWeek : 'dddd [don lr] LT',
        lastDay : '[Kunu lr] LT',
        lastWeek : 'dddd [tmnen lr] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s kn',
        past : 'a b %s b',
        s : 'sanga dama dama',
        m : 'miniti kelen',
        mm : 'miniti %d',
        h : 'lr kelen',
        hh : 'lr %d',
        d : 'tile kelen',
        dd : 'tile %d',
        M : 'kalo kelen',
        MM : 'kalo %d',
        y : 'san kelen',
        yy : 'san %d'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return bm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var bn = moment.defineLocale('bn', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                (meridiem === '' && hour < 5) ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return bn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var bo = moment.defineLocale('bo', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[], LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                (meridiem === '' && hour < 5) ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return bo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/br.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
        'mm': 'munutenn',
        'MM': 'miz',
        'dd': 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
}
function specialMutationForYears(number) {
    switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
    }
}
function lastNumber(number) {
    if (number > 9) {
        return lastNumber(number % 10);
    }
    return number;
}
function mutation(text, number) {
    if (number === 2) {
        return softMutation(text);
    }
    return text;
}
function softMutation(text) {
    var mutationTable = {
        'm': 'v',
        'b': 'v',
        'd': 'z'
    };
    if (mutationTable[text.charAt(0)] === undefined) {
        return text;
    }
    return mutationTable[text.charAt(0)] + text.substring(1);
}

var br = moment.defineLocale('br', {
    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h[e]mm A',
        LTS : 'h[e]mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [a viz] MMMM YYYY',
        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
    },
    calendar : {
        sameDay : '[Hiziv da] LT',
        nextDay : '[Warc\'hoazh da] LT',
        nextWeek : 'dddd [da] LT',
        lastDay : '[Dec\'h da] LT',
        lastWeek : 'dddd [paset da] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'a-benn %s',
        past : '%s \'zo',
        s : 'un nebeud segondenno',
        m : 'ur vunutenn',
        mm : relativeTimeWithMutation,
        h : 'un eur',
        hh : '%d eur',
        d : 'un devezh',
        dd : relativeTimeWithMutation,
        M : 'ur miz',
        MM : relativeTimeWithMutation,
        y : 'ur bloaz',
        yy : specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal : function (number) {
        var output = (number === 1) ? 'a' : 'vet';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return br;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bs.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

var bs = moment.defineLocale('bs', {
    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate,
        mm     : translate,
        h      : translate,
        hh     : translate,
        d      : 'dan',
        dd     : translate,
        M      : 'mjesec',
        MM     : translate,
        y      : 'godinu',
        yy     : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return bs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ca.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ca = moment.defineLocale('ca', {
    months : {
        standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
        isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM [de] YYYY',
        ll : 'D MMM YYYY',
        LLL : 'D MMMM [de] YYYY [a les] H:mm',
        lll : 'D MMM YYYY, H:mm',
        LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
        llll : 'ddd D MMM YYYY, H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextDay : function () {
            return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastDay : function () {
            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'd\'aqu %s',
        past : 'fa %s',
        s : 'uns segons',
        m : 'un minut',
        mm : '%d minuts',
        h : 'una hora',
        hh : '%d hores',
        d : 'un dia',
        dd : '%d dies',
        M : 'un mes',
        MM : '%d mesos',
        y : 'un any',
        yy : '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal : function (number, period) {
        var output = (number === 1) ? 'r' :
            (number === 2) ? 'n' :
            (number === 3) ? 'r' :
            (number === 4) ? 't' : '';
        if (period === 'w' || period === 'W') {
            output = 'a';
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ca;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cs.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
function plural(n) {
    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dny' : 'dn');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'msce' : 'msc');
            } else {
                return result + 'msci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
    }
}

var cs = moment.defineLocale('cs', {
    months : months,
    monthsShort : monthsShort,
    monthsParse : (function (months, monthsShort) {
        var i, _monthsParse = [];
        for (i = 0; i < 12; i++) {
            // use custom parser to solve problem with July (ervenec)
            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
        }
        return _monthsParse;
    }(months, monthsShort)),
    shortMonthsParse : (function (monthsShort) {
        var i, _shortMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
        }
        return _shortMonthsParse;
    }(monthsShort)),
    longMonthsParse : (function (months) {
        var i, _longMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
        }
        return _longMonthsParse;
    }(months)),
    weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm',
        l : 'D. M. YYYY'
    },
    calendar : {
        sameDay: '[dnes v] LT',
        nextDay: '[ztra v] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve stedu v] LT';
                case 4:
                    return '[ve tvrtek v] LT';
                case 5:
                    return '[v ptek v] LT';
                case 6:
                    return '[v sobotu v] LT';
            }
        },
        lastDay: '[vera v] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minulou nedli v] LT';
                case 1:
                case 2:
                    return '[minul] dddd [v] LT';
                case 3:
                    return '[minulou stedu v] LT';
                case 4:
                case 5:
                    return '[minul] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'ped %s',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse : /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return cs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var cv = moment.defineLocale('cv', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'YYYY [] MMMM [] D[-]',
        LLL : 'YYYY [] MMMM [] D[-], HH:mm',
        LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar : {
        sameDay: '[] LT []',
        nextDay: '[] LT []',
        lastDay: '[] LT []',
        nextWeek: '[] dddd LT []',
        lastWeek: '[] dddd LT []',
        sameElse: 'L'
    },
    relativeTime : {
        future : function (output) {
            var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
            return output + affix;
        },
        past : '%s ',
        s : '- ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal : '%d-',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return cv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cy.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    // time formats are the same as en-gb
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[Heddiw am] LT',
        nextDay: '[Yfory am] LT',
        nextWeek: 'dddd [am] LT',
        lastDay: '[Ddoe am] LT',
        lastWeek: 'dddd [diwethaf am] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'mewn %s',
        past: '%s yn l',
        s: 'ychydig eiliadau',
        m: 'munud',
        mm: '%d munud',
        h: 'awr',
        hh: '%d awr',
        d: 'diwrnod',
        dd: '%d diwrnod',
        M: 'mis',
        MM: '%d mis',
        y: 'blwyddyn',
        yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
        var b = number,
            output = '',
            lookup = [
                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
            ];
        if (b > 20) {
            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                output = 'fed'; // not 30ain, 70ain or 90ain
            } else {
                output = 'ain';
            }
        } else if (b > 0) {
            output = lookup[b];
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return cy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/da.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var da = moment.defineLocale('da', {
    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay : '[i dag kl.] LT',
        nextDay : '[i morgen kl.] LT',
        nextWeek : 'p dddd [kl.] LT',
        lastDay : '[i gr kl.] LT',
        lastWeek : '[i] dddd[s kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'f sekunder',
        m : 'et minut',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dage',
        M : 'en mned',
        MM : '%d mneder',
        y : 'et r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return da;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de-at.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var deAt = moment.defineLocale('de-at', {
    months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return deAt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de-ch.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


// based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var deCh = moment.defineLocale('de-ch', {
    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH.mm',
        LTS: 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH.mm',
        LLLL : 'dddd, D. MMMM YYYY HH.mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return deCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var de = moment.defineLocale('de', {
    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return de;

})));


/***/ }),

/***/ "./node_modules/moment/locale/dv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var weekdays = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var dv = moment.defineLocale('dv', {
    months : months,
    monthsShort : months,
    weekdays : weekdays,
    weekdaysShort : weekdays,
    weekdaysMin : '______'.split('_'),
    longDateFormat : {

        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/M/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : ' %d',
        h : '',
        hh : ' %d',
        d : '',
        dd : ' %d',
        M : '',
        MM : ' %d',
        y : '',
        yy : ' %d'
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 7,  // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return dv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/el.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}


var el = moment.defineLocale('el', {
    monthsNominativeEl : '___________'.split('_'),
    monthsGenitiveEl : '___________'.split('_'),
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return this._monthsNominativeEl;
        } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
            return this._monthsGenitiveEl[momentToFormat.month()];
        } else {
            return this._monthsNominativeEl[momentToFormat.month()];
        }
    },
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? '' : '';
        } else {
            return isLower ? '' : '';
        }
    },
    isPM : function (input) {
        return ((input + '').toLowerCase()[0] === '');
    },
    meridiemParse : /[]\.??\.?/i,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl : {
        sameDay : '[ {}] LT',
        nextDay : '[ {}] LT',
        nextWeek : 'dddd [{}] LT',
        lastDay : '[ {}] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 6:
                    return '[ ] dddd [{}] LT';
                default:
                    return '[ ] dddd [{}] LT';
            }
        },
        sameElse : 'L'
    },
    calendar : function (key, mom) {
        var output = this._calendarEl[key],
            hours = mom && mom.hours();
        if (isFunction(output)) {
            output = output.apply(mom);
        }
        return output.replace('{}', (hours % 12 === 1 ? '' : ''));
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4st is the first week of the year.
    }
});

return el;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-au.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enAu = moment.defineLocale('en-au', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enAu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-ca.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enCa = moment.defineLocale('en-ca', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'YYYY-MM-DD',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

return enCa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-gb.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enGb = moment.defineLocale('en-gb', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enGb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-ie.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enIe = moment.defineLocale('en-ie', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enIe;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-nz.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enNz = moment.defineLocale('en-nz', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enNz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/eo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var eo = moment.defineLocale('eo', {
    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
    weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D[-a de] MMMM, YYYY',
        LLL : 'D[-a de] MMMM, YYYY HH:mm',
        LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
        return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p.t.m.' : 'P.T.M.';
        } else {
            return isLower ? 'a.t.m.' : 'A.T.M.';
        }
    },
    calendar : {
        sameDay : '[Hodia je] LT',
        nextDay : '[Morga je] LT',
        nextWeek : 'dddd [je] LT',
        lastDay : '[Hiera je] LT',
        lastWeek : '[pasinta] dddd [je] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'post %s',
        past : 'anta %s',
        s : 'sekundoj',
        m : 'minuto',
        mm : '%d minutoj',
        h : 'horo',
        hh : '%d horoj',
        d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
        dd : '%d tagoj',
        M : 'monato',
        MM : '%d monatoj',
        y : 'jaro',
        yy : '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal : '%da',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return eo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-do.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

var esDo = moment.defineLocale('es-do', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY h:mm A',
        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return esDo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-us.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish(United State) [es-us]
//! author : bustta : https://github.com/bustta

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

var esUs = moment.defineLocale('es-us', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'MM/DD/YYYY',
        LL : 'MMMM [de] D [de] YYYY',
        LLL : 'MMMM [de] D [de] YYYY H:mm',
        LLLL : 'dddd, MMMM [de] D [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return esUs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

var es = moment.defineLocale('es', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsRegex : monthsRegex,
    monthsShortRegex : monthsRegex,
    monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return es;

})));


/***/ }),

/***/ "./node_modules/moment/locale/et.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
        'm' : ['he minuti', 'ks minut'],
        'mm': [number + ' minuti', number + ' minutit'],
        'h' : ['he tunni', 'tund aega', 'ks tund'],
        'hh': [number + ' tunni', number + ' tundi'],
        'd' : ['he peva', 'ks pev'],
        'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
        'MM': [number + ' kuu', number + ' kuud'],
        'y' : ['he aasta', 'aasta', 'ks aasta'],
        'yy': [number + ' aasta', number + ' aastat']
    };
    if (withoutSuffix) {
        return format[key][2] ? format[key][2] : format[key][1];
    }
    return isFuture ? format[key][0] : format[key][1];
}

var et = moment.defineLocale('et', {
    months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat : {
        LT   : 'H:mm',
        LTS : 'H:mm:ss',
        L    : 'DD.MM.YYYY',
        LL   : 'D. MMMM YYYY',
        LLL  : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[Tna,] LT',
        nextDay  : '[Homme,] LT',
        nextWeek : '[Jrgmine] dddd LT',
        lastDay  : '[Eile,] LT',
        lastWeek : '[Eelmine] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s prast',
        past   : '%s tagasi',
        s      : processRelativeTime,
        m      : processRelativeTime,
        mm     : processRelativeTime,
        h      : processRelativeTime,
        hh     : processRelativeTime,
        d      : processRelativeTime,
        dd     : '%d peva',
        M      : processRelativeTime,
        MM     : processRelativeTime,
        y      : processRelativeTime,
        yy     : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return et;

})));


/***/ }),

/***/ "./node_modules/moment/locale/eu.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var eu = moment.defineLocale('eu', {
    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact : true,
    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY[ko] MMMM[ren] D[a]',
        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
        l : 'YYYY-M-D',
        ll : 'YYYY[ko] MMM D[a]',
        lll : 'YYYY[ko] MMM D[a] HH:mm',
        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar : {
        sameDay : '[gaur] LT[etan]',
        nextDay : '[bihar] LT[etan]',
        nextWeek : 'dddd LT[etan]',
        lastDay : '[atzo] LT[etan]',
        lastWeek : '[aurreko] dddd LT[etan]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s barru',
        past : 'duela %s',
        s : 'segundo batzuk',
        m : 'minutu bat',
        mm : '%d minutu',
        h : 'ordu bat',
        hh : '%d ordu',
        d : 'egun bat',
        dd : '%d egun',
        M : 'hilabete bat',
        MM : '%d hilabete',
        y : 'urte bat',
        yy : '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return eu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fa.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var fa = moment.defineLocale('fa', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function (input) {
        return /  /.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '  ';
        } else {
            return '  ';
        }
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : 'dddd [] [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[-]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12 // The week that contains Jan 1st is the first week of the year.
    }
});

return fa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
var numbersFuture = [
        'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
        numbersPast[7], numbersPast[8], numbersPast[9]
    ];
function translate(number, withoutSuffix, key, isFuture) {
    var result = '';
    switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'pivn' : 'piv';
        case 'dd':
            result = isFuture ? 'pivn' : 'piv';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
    }
    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
}
function verbalNumber(number, isFuture) {
    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
}

var fi = moment.defineLocale('fi', {
    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'Do MMMM[ta] YYYY',
        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
        l : 'D.M.YYYY',
        ll : 'Do MMM YYYY',
        lll : 'Do MMM YYYY, [klo] HH.mm',
        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar : {
        sameDay : '[tnn] [klo] LT',
        nextDay : '[huomenna] [klo] LT',
        nextWeek : 'dddd [klo] LT',
        lastDay : '[eilen] [klo] LT',
        lastWeek : '[viime] dddd[na] [klo] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s pst',
        past : '%s sitten',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var fo = moment.defineLocale('fo', {
    months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ dag kl.] LT',
        nextDay : '[ morgin kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[ gjr kl.] LT',
        lastWeek : '[sstu] dddd [kl] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'um %s',
        past : '%s sani',
        s : 'f sekund',
        m : 'ein minutt',
        mm : '%d minuttir',
        h : 'ein tmi',
        hh : '%d tmar',
        d : 'ein dagur',
        dd : '%d dagar',
        M : 'ein mnai',
        MM : '%d mnair',
        y : 'eitt r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr-ca.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var frCa = moment.defineLocale('fr-ca', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    }
});

return frCa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr-ch.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var frCh = moment.defineLocale('fr-ch', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return frCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var fr = moment.defineLocale('fr', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal : function (number, period) {
        switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case 'D':
                return number + (number === 1 ? 'er' : '');

            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fy.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

var fy = moment.defineLocale('fy', {
    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[hjoed om] LT',
        nextDay: '[moarn om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[juster om] LT',
        lastWeek: '[frne] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'oer %s',
        past : '%s lyn',
        s : 'in pear sekonden',
        m : 'ien mint',
        mm : '%d minuten',
        h : 'ien oere',
        hh : '%d oeren',
        d : 'ien dei',
        dd : '%d dagen',
        M : 'ien moanne',
        MM : '%d moannen',
        y : 'ien jier',
        yy : '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gd.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
];

var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

var gd = moment.defineLocale('gd', {
    months : months,
    monthsShort : monthsShort,
    monthsParseExact : true,
    weekdays : weekdays,
    weekdaysShort : weekdaysShort,
    weekdaysMin : weekdaysMin,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[An-diugh aig] LT',
        nextDay : '[A-mireach aig] LT',
        nextWeek : 'dddd [aig] LT',
        lastDay : '[An-d aig] LT',
        lastWeek : 'dddd [seo chaidh] [aig] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ann an %s',
        past : 'bho chionn %s',
        s : 'beagan diogan',
        m : 'mionaid',
        mm : '%d mionaidean',
        h : 'uair',
        hh : '%d uairean',
        d : 'latha',
        dd : '%d latha',
        M : 'mos',
        MM : '%d mosan',
        y : 'bliadhna',
        yy : '%d bliadhna'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
    ordinal : function (number) {
        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return gd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var gl = moment.defineLocale('gl', {
    months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
        },
        lastDay : function () {
            return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
        },
        lastWeek : function () {
            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : function (str) {
            if (str.indexOf('un') === 0) {
                return 'n' + str;
            }
            return 'en ' + str;
        },
        past : 'hai %s',
        s : 'uns segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'unha hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return gl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gom-latn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['thodde secondanim', 'thodde second'],
        'm': ['eka mintan', 'ek minute'],
        'mm': [number + ' mintanim', number + ' mintam'],
        'h': ['eka horan', 'ek hor'],
        'hh': [number + ' horanim', number + ' hor'],
        'd': ['eka disan', 'ek dis'],
        'dd': [number + ' disanim', number + ' dis'],
        'M': ['eka mhoinean', 'ek mhoino'],
        'MM': [number + ' mhoineanim', number + ' mhoine'],
        'y': ['eka vorsan', 'ek voros'],
        'yy': [number + ' vorsanim', number + ' vorsam']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var gomLatn = moment.defineLocale('gom-latn', {
    months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
    monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
    weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm [vazta]',
        LTS : 'A h:mm:ss [vazta]',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY A h:mm [vazta]',
        LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
        llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar : {
        sameDay: '[Aiz] LT',
        nextDay: '[Faleam] LT',
        nextWeek: '[Ieta to] dddd[,] LT',
        lastDay: '[Kal] LT',
        lastWeek: '[Fatlo] dddd[,] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s adim',
        s : processRelativeTime,
        m : processRelativeTime,
        mm : processRelativeTime,
        h : processRelativeTime,
        hh : processRelativeTime,
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
    ordinal : function (number, period) {
        switch (period) {
            // the ordinal 'er' only applies to day of the month
            case 'D':
                return number + 'er';
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
            case 'w':
            case 'W':
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    },
    meridiemParse: /rati|sokalli|donparam|sanje/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'rati') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'sokalli') {
            return hour;
        } else if (meridiem === 'donparam') {
            return hour > 12 ? hour : hour + 12;
        } else if (meridiem === 'sanje') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'rati';
        } else if (hour < 12) {
            return 'sokalli';
        } else if (hour < 16) {
            return 'donparam';
        } else if (hour < 20) {
            return 'sanje';
        } else {
            return 'rati';
        }
    }
});

return gomLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gu.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

var gu = moment.defineLocale('gu', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
        LT: 'A h:mm ',
        LTS: 'A h:mm:ss ',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm ',
        LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
        sameDay: '[] LT',
        nextDay: '[] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[] LT',
        lastWeek: '[] dddd, LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: '%s ',
        past: '%s ',
        s: ' ',
        m: ' ',
        mm: '%d ',
        h: ' ',
        hh: '%d ',
        d: ' ',
        dd: '%d ',
        M: ' ',
        MM: '%d ',
        y: ' ',
        yy: '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem: function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week: {
        dow: 0, // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 1st is the first week of the year.
    }
});

return gu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/he.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var he = moment.defineLocale('he', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D []MMMM YYYY',
        LLL : 'D []MMMM YYYY HH:mm',
        LLLL : 'dddd, D []MMMM YYYY HH:mm',
        l : 'D/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ]LT',
        nextDay : '[ ]LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ]LT',
        lastWeek : '[] dddd [ ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        d : '',
        dd : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        M : '',
        MM : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        y : '',
        yy : function (number) {
            if (number === 2) {
                return '';
            } else if (number % 10 === 0 && number !== 10) {
                return number + ' ';
            }
            return number + ' ';
        }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM : function (input) {
        return /^("| |)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 5) {
            return ' ';
        } else if (hour < 10) {
            return '';
        } else if (hour < 12) {
            return isLower ? '"' : ' ';
        } else if (hour < 18) {
            return isLower ? '"' : ' ';
        } else {
            return '';
        }
    }
});

return he;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var hi = moment.defineLocale('hi', {
    months : '___________'.split('_'),
    monthsShort : '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return hi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

var hr = moment.defineLocale('hr', {
    months : {
        format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
        standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate,
        mm     : translate,
        h      : translate,
        hh     : translate,
        d      : 'dan',
        dd     : translate,
        M      : 'mjesec',
        MM     : translate,
        y      : 'godinu',
        yy     : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return hr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hu.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
function translate(number, withoutSuffix, key, isFuture) {
    var num = number,
        suffix;
    switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }
    return '';
}
function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
}

var hu = moment.defineLocale('hu', {
    months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
    weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'YYYY.MM.DD.',
        LL : 'YYYY. MMMM D.',
        LLL : 'YYYY. MMMM D. H:mm',
        LLLL : 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
        return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower === true ? 'de' : 'DE';
        } else {
            return isLower === true ? 'du' : 'DU';
        }
    },
    calendar : {
        sameDay : '[ma] LT[-kor]',
        nextDay : '[holnap] LT[-kor]',
        nextWeek : function () {
            return week.call(this, true);
        },
        lastDay : '[tegnap] LT[-kor]',
        lastWeek : function () {
            return week.call(this, false);
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s mlva',
        past : '%s',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return hu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hy-am.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var hyAm = moment.defineLocale('hy-am', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[] LT',
        nextDay: '[] LT',
        lastDay: '[] LT',
        nextWeek: function () {
            return 'dddd [ ] LT';
        },
        lastWeek: function () {
            return '[] dddd [ ] LT';
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    meridiemParse: /|||/,
    isPM: function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-';
                }
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return hyAm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/id.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var id = moment.defineLocale('id', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'siang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sore' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'siang';
        } else if (hours < 19) {
            return 'sore';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Besok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kemarin pukul] LT',
        lastWeek : 'dddd [lalu pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lalu',
        s : 'beberapa detik',
        m : 'semenit',
        mm : '%d menit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return id;

})));


/***/ }),

/***/ "./node_modules/moment/locale/is.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(n) {
    if (n % 100 === 11) {
        return true;
    } else if (n % 10 === 1) {
        return false;
    }
    return true;
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
        case 'm':
            return withoutSuffix ? 'mnta' : 'mntu';
        case 'mm':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
            } else if (withoutSuffix) {
                return result + 'mnta';
            }
            return result + 'mntu';
        case 'hh':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dgum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mnuur';
            }
            return isFuture ? 'mnu' : 'mnui';
        case 'MM':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'mnuir';
                }
                return result + (isFuture ? 'mnui' : 'mnuum');
            } else if (withoutSuffix) {
                return result + 'mnuur';
            }
            return result + (isFuture ? 'mnu' : 'mnui');
        case 'y':
            return withoutSuffix || isFuture ? 'r' : 'ri';
        case 'yy':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
            }
            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
}

var is = moment.defineLocale('is', {
    months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar : {
        sameDay : '[ dag kl.] LT',
        nextDay : '[ morgun kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[ gr kl.] LT',
        lastWeek : '[sasta] dddd [kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'eftir %s',
        past : 'fyrir %s san',
        s : translate,
        m : translate,
        mm : translate,
        h : 'klukkustund',
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return is;

})));


/***/ }),

/***/ "./node_modules/moment/locale/it.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var it = moment.defineLocale('it', {
    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Oggi alle] LT',
        nextDay: '[Domani alle] LT',
        nextWeek: 'dddd [alle] LT',
        lastDay: '[Ieri alle] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[la scorsa] dddd [alle] LT';
                default:
                    return '[lo scorso] dddd [alle] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : function (s) {
            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
        },
        past : '%s fa',
        s : 'alcuni secondi',
        m : 'un minuto',
        mm : '%d minuti',
        h : 'un\'ora',
        hh : '%d ore',
        d : 'un giorno',
        dd : '%d giorni',
        M : 'un mese',
        MM : '%d mesi',
        y : 'un anno',
        yy : '%d anni'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return it;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ja.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ja = moment.defineLocale('ja', {
    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYYMD',
        LLL : 'YYYYMD HH:mm',
        LLLL : 'YYYYMD HH:mm dddd',
        l : 'YYYY/MM/DD',
        ll : 'YYYYMD',
        lll : 'YYYYMD HH:mm',
        llll : 'YYYYMD HH:mm dddd'
    },
    meridiemParse: /|/i,
    isPM : function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[]dddd LT',
        lastDay : '[] LT',
        lastWeek : '[]dddd LT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1',
        mm : '%d',
        h : '1',
        hh : '%d',
        d : '1',
        dd : '%d',
        M : '1',
        MM : '%d',
        y : '1',
        yy : '%d'
    }
});

return ja;

})));


/***/ }),

/***/ "./node_modules/moment/locale/jv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var jv = moment.defineLocale('jv', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'enjing') {
            return hour;
        } else if (meridiem === 'siyang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'enjing';
        } else if (hours < 15) {
            return 'siyang';
        } else if (hours < 19) {
            return 'sonten';
        } else {
            return 'ndalu';
        }
    },
    calendar : {
        sameDay : '[Dinten puniko pukul] LT',
        nextDay : '[Mbenjang pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kala wingi pukul] LT',
        lastWeek : 'dddd [kepengker pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'wonten ing %s',
        past : '%s ingkang kepengker',
        s : 'sawetawis detik',
        m : 'setunggal menit',
        mm : '%d menit',
        h : 'setunggal jam',
        hh : '%d jam',
        d : 'sedinten',
        dd : '%d dinten',
        M : 'sewulan',
        MM : '%d wulan',
        y : 'setaun',
        yy : '%d taun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return jv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ka.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ka = moment.defineLocale('ka', {
    months : {
        standalone: '___________'.split('_'),
        format: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /(|)/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[] LT[-]',
        nextDay : '[] LT[-]',
        lastDay : '[] LT[-]',
        nextWeek : '[] dddd LT[-]',
        lastWeek : '[] dddd LT-',
        sameElse : 'L'
    },
    relativeTime : {
        future : function (s) {
            return (/(|||)/).test(s) ?
                s.replace(/$/, '') :
                s + '';
        },
        past : function (s) {
            if ((/(||||)/).test(s)) {
                return s.replace(/(|)$/, ' ');
            }
            if ((//).test(s)) {
                return s.replace(/$/, ' ');
            }
        },
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal : function (number) {
        if (number === 0) {
            return number;
        }
        if (number === 1) {
            return number + '-';
        }
        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
            return '-' + number;
        }
        return number + '-';
    },
    week : {
        dow : 1,
        doy : 7
    }
});

return ka;

})));


/***/ }),

/***/ "./node_modules/moment/locale/kk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
};

var kk = moment.defineLocale('kk', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : '[ ] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return kk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/km.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var km = moment.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[ ] LT',
        lastWeek: 'dddd [] [] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: '%s',
        past: '%s',
        s: '',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

return km;

})));


/***/ }),

/***/ "./node_modules/moment/locale/kn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var kn = moment.defineLocale('kn', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal : function (number) {
        return number + '';
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return kn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ko.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ko = moment.defineLocale('ko', {
    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'YYYY.MM.DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D A h:mm',
        LLLL : 'YYYY MMMM D dddd A h:mm',
        l : 'YYYY.MM.DD',
        ll : 'YYYY MMMM D',
        lll : 'YYYY MMMM D A h:mm',
        llll : 'YYYY MMMM D dddd A h:mm'
    },
    calendar : {
        sameDay : ' LT',
        nextDay : ' LT',
        nextWeek : 'dddd LT',
        lastDay : ' LT',
        lastWeek : ' dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        ss : '%d',
        m : '1',
        mm : '%d',
        h : ' ',
        hh : '%d',
        d : '',
        dd : '%d',
        M : ' ',
        MM : '%d',
        y : ' ',
        yy : '%d'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
        }
    },
    meridiemParse : /|/,
    isPM : function (token) {
        return token === '';
    },
    meridiem : function (hour, minute, isUpper) {
        return hour < 12 ? '' : '';
    }
});

return ko;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ky.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
};

var ky = moment.defineLocale('ky', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : '[ ] dddd [] [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return ky;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lb.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eng Minutt', 'enger Minutt'],
        'h': ['eng Stonn', 'enger Stonn'],
        'd': ['een Dag', 'engem Dag'],
        'M': ['ee Mount', 'engem Mount'],
        'y': ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}
function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'a ' + string;
    }
    return 'an ' + string;
}
function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'viru ' + string;
    }
    return 'virun ' + string;
}
/**
 * Returns true if the word before the given number loses the '-n' ending.
 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
 *
 * @param number {integer}
 * @returns {boolean}
 */
function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);
    if (isNaN(number)) {
        return false;
    }
    if (number < 0) {
        // Negative Number --> always true
        return true;
    } else if (number < 10) {
        // Only 1 digit
        if (4 <= number && number <= 7) {
            return true;
        }
        return false;
    } else if (number < 100) {
        // 2 digits
        var lastDigit = number % 10, firstDigit = number / 10;
        if (lastDigit === 0) {
            return eifelerRegelAppliesToNumber(firstDigit);
        }
        return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
        // 3 or 4 digits --> recursively check first digit
        while (number >= 10) {
            number = number / 10;
        }
        return eifelerRegelAppliesToNumber(number);
    } else {
        // Anything larger than 4 digits: recursively check first n-3 digits
        number = number / 1000;
        return eifelerRegelAppliesToNumber(number);
    }
}

var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm [Auer]',
        LTS: 'H:mm:ss [Auer]',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm [Auer]',
        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
        sameDay: '[Haut um] LT',
        sameElse: 'L',
        nextDay: '[Muer um] LT',
        nextWeek: 'dddd [um] LT',
        lastDay: '[Gschter um] LT',
        lastWeek: function () {
            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
            switch (this.day()) {
                case 2:
                case 4:
                    return '[Leschten] dddd [um] LT';
                default:
                    return '[Leschte] dddd [um] LT';
            }
        }
    },
    relativeTime : {
        future : processFutureTime,
        past : processPastTime,
        s : 'e puer Sekonnen',
        m : processRelativeTime,
        mm : '%d Minutten',
        h : processRelativeTime,
        hh : '%d Stonnen',
        d : processRelativeTime,
        dd : '%d Deeg',
        M : processRelativeTime,
        MM : '%d Mint',
        y : processRelativeTime,
        yy : '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return lb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var lo = moment.defineLocale('lo', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[]dddd[] LT',
        lastDay : '[] LT',
        lastWeek : '[]dddd[] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal : function (number) {
        return '' + number;
    }
});

return lo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lt.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var units = {
    'm' : 'minut_minuts_minut',
    'mm': 'minuts_minui_minutes',
    'h' : 'valanda_valandos_valand',
    'hh': 'valandos_valand_valandas',
    'd' : 'diena_dienos_dien',
    'dd': 'dienos_dien_dienas',
    'M' : 'mnuo_mnesio_mnes',
    'MM': 'mnesiai_mnesi_mnesius',
    'y' : 'metai_met_metus',
    'yy': 'metai_met_metus'
};
function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
        return 'kelios sekunds';
    } else {
        return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
}
function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
}
function special(number) {
    return number % 10 === 0 || (number > 10 && number < 20);
}
function forms(key) {
    return units[key].split('_');
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    if (number === 1) {
        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
        if (isFuture) {
            return result + forms(key)[1];
        } else {
            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
        }
    }
}
var lt = moment.defineLocale('lt', {
    months : {
        format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
        standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays : {
        format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
        standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
        isFormat: /dddd HH:mm/
    },
    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY [m.] MMMM D [d.]',
        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
        l : 'YYYY-MM-DD',
        ll : 'YYYY [m.] MMMM D [d.]',
        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar : {
        sameDay : '[iandien] LT',
        nextDay : '[Rytoj] LT',
        nextWeek : 'dddd LT',
        lastDay : '[Vakar] LT',
        lastWeek : '[Prajus] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'po %s',
        past : 'prie %s',
        s : translateSeconds,
        m : translateSingular,
        mm : translate,
        h : translateSingular,
        hh : translate,
        d : translateSingular,
        dd : translate,
        M : translateSingular,
        MM : translate,
        y : translateSingular,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal : function (number) {
        return number + '-oji';
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return lt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var units = {
    'm': 'mintes_mintm_minte_mintes'.split('_'),
    'mm': 'mintes_mintm_minte_mintes'.split('_'),
    'h': 'stundas_stundm_stunda_stundas'.split('_'),
    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
    'd': 'dienas_dienm_diena_dienas'.split('_'),
    'dd': 'dienas_dienm_diena_dienas'.split('_'),
    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'y': 'gada_gadiem_gads_gadi'.split('_'),
    'yy': 'gada_gadiem_gads_gadi'.split('_')
};
/**
 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
 */
function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
        // E.g. "21 minte", "3 mintes".
        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
        // E.g. "21 mintes" as in "pc 21 mintes".
        // E.g. "3 mintm" as in "pc 3 mintm".
        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
}
function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
}
function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
}

var lv = moment.defineLocale('lv', {
    months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY.',
        LL : 'YYYY. [gada] D. MMMM',
        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar : {
        sameDay : '[odien pulksten] LT',
        nextDay : '[Rt pulksten] LT',
        nextWeek : 'dddd [pulksten] LT',
        lastDay : '[Vakar pulksten] LT',
        lastWeek : '[Pagju] dddd [pulksten] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'pc %s',
        past : 'pirms %s',
        s : relativeSeconds,
        m : relativeTimeWithSingular,
        mm : relativeTimeWithPlural,
        h : relativeTimeWithSingular,
        hh : relativeTimeWithPlural,
        d : relativeTimeWithSingular,
        dd : relativeTimeWithPlural,
        M : relativeTimeWithSingular,
        MM : relativeTimeWithPlural,
        y : relativeTimeWithSingular,
        yy : relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return lv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/me.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var translator = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jednog minuta'],
        mm: ['minut', 'minuta', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mjesec', 'mjeseca', 'mjeseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact : true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sjutra u] LT',

        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jue u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prole] [nedjelje] [u] LT',
                '[prolog] [ponedjeljka] [u] LT',
                '[prolog] [utorka] [u] LT',
                '[prole] [srijede] [u] LT',
                '[prolog] [etvrtka] [u] LT',
                '[prolog] [petka] [u] LT',
                '[prole] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'nekoliko sekundi',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : 'dan',
        dd     : translator.translate,
        M      : 'mjesec',
        MM     : translator.translate,
        y      : 'godinu',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return me;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var mi = moment.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY [i] HH:mm',
        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
        sameDay: '[i teie mahana, i] LT',
        nextDay: '[apopo i] LT',
        nextWeek: 'dddd [i] LT',
        lastDay: '[inanahi i] LT',
        lastWeek: 'dddd [whakamutunga i] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'i roto i %s',
        past: '%s i mua',
        s: 'te hkona ruarua',
        m: 'he meneti',
        mm: '%d meneti',
        h: 'te haora',
        hh: '%d haora',
        d: 'he ra',
        dd: '%d ra',
        M: 'he marama',
        MM: '%d marama',
        y: 'he tau',
        yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return mi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var mk = moment.defineLocale('mk', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : 'e_o_____a'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : '[] dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-';
        } else if (last2Digits === 0) {
            return number + '-';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-';
        } else if (lastDigit === 1) {
            return number + '-';
        } else if (lastDigit === 2) {
            return number + '-';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-';
        } else {
            return number + '-';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return mk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ml.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ml = moment.defineLocale('ml', {
    months : '___________'.split('_'),
    monthsShort : '._._._.___._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm -',
        LTS : 'A h:mm:ss -',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm -',
        LLLL : 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                meridiem === ' ' ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return ' ';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    }
});

return ml;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

function relativeTimeMr(number, withoutSuffix, string, isFuture)
{
    var output = '';
    if (withoutSuffix) {
        switch (string) {
            case 's': output = ' '; break;
            case 'm': output = ' '; break;
            case 'mm': output = '%d '; break;
            case 'h': output = ' '; break;
            case 'hh': output = '%d '; break;
            case 'd': output = ' '; break;
            case 'dd': output = '%d '; break;
            case 'M': output = ' '; break;
            case 'MM': output = '%d '; break;
            case 'y': output = ' '; break;
            case 'yy': output = '%d '; break;
        }
    }
    else {
        switch (string) {
            case 's': output = ' '; break;
            case 'm': output = ' '; break;
            case 'mm': output = '%d '; break;
            case 'h': output = ' '; break;
            case 'hh': output = '%d '; break;
            case 'd': output = ' '; break;
            case 'dd': output = '%d '; break;
            case 'M': output = ' '; break;
            case 'MM': output = '%d '; break;
            case 'y': output = ' '; break;
            case 'yy': output = '%d '; break;
        }
    }
    return output.replace(/%d/i, number);
}

var mr = moment.defineLocale('mr', {
    months : '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek: '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future: '%s',
        past: '%s',
        s: relativeTimeMr,
        m: relativeTimeMr,
        mm: relativeTimeMr,
        h: relativeTimeMr,
        hh: relativeTimeMr,
        d: relativeTimeMr,
        dd: relativeTimeMr,
        M: relativeTimeMr,
        MM: relativeTimeMr,
        y: relativeTimeMr,
        yy: relativeTimeMr
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem: function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return mr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ms-my.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var msMy = moment.defineLocale('ms-my', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return msMy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ms.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ms = moment.defineLocale('ms', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return ms;

})));


/***/ }),

/***/ "./node_modules/moment/locale/my.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var my = moment.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),

    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[.] LT []',
        nextDay: '[] LT []',
        nextWeek: 'dddd LT []',
        lastDay: '[.] LT []',
        lastWeek: '[] dddd LT []',
        sameElse: 'L'
    },
    relativeTime: {
        future: ' %s ',
        past: ' %s ',
        s: '.',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 1st is the first week of the year.
    }
});

return my;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nb.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var nb = moment.defineLocale('nb', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[i dag kl.] LT',
        nextDay: '[i morgen kl.] LT',
        nextWeek: 'dddd [kl.] LT',
        lastDay: '[i gr kl.] LT',
        lastWeek: '[forrige] dddd [kl.] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'noen sekunder',
        m : 'ett minutt',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dager',
        M : 'en mned',
        MM : '%d mneder',
        y : 'ett r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ne.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var ne = moment.defineLocale('ne', {
    months : '___________'.split('_'),
    monthsShort : '._.__.___._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '._._._._._._.'.split('_'),
    weekdaysMin : '._._._._._._.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 3) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 16) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[] dddd[,] LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd[,] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return ne;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nl-be.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

var nlBe = moment.defineLocale('nl-be', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },

    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'n minuut',
        mm : '%d minuten',
        h : 'n uur',
        hh : '%d uur',
        d : 'n dag',
        dd : '%d dagen',
        M : 'n maand',
        MM : '%d maanden',
        y : 'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nlBe;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

var nl = moment.defineLocale('nl', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },

    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'n minuut',
        mm : '%d minuten',
        h : 'n uur',
        hh : '%d uur',
        d : 'n dag',
        dd : '%d dagen',
        M : 'n maand',
        MM : '%d maanden',
        y : 'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! author : https://github.com/mechuwind

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var nn = moment.defineLocale('nn', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
    weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[I dag klokka] LT',
        nextDay: '[I morgon klokka] LT',
        nextWeek: 'dddd [klokka] LT',
        lastDay: '[I gr klokka] LT',
        lastWeek: '[Fregande] dddd [klokka] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s sidan',
        s : 'nokre sekund',
        m : 'eit minutt',
        mm : '%d minutt',
        h : 'ein time',
        hh : '%d timar',
        d : 'ein dag',
        dd : '%d dagar',
        M : 'ein mnad',
        MM : '%d mnader',
        y : 'eit r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pa-in.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return paIn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
function plural(n) {
    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
}
function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minut';
        case 'mm':
            return result + (plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzin';
        case 'hh':
            return result + (plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural(number) ? 'miesice' : 'miesicy');
        case 'yy':
            return result + (plural(number) ? 'lata' : 'lat');
    }
}

var pl = moment.defineLocale('pl', {
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return monthsNominative;
        } else if (format === '') {
            // Hack: if format empty we know this is used to generate
            // RegExp by moment. Give then back both valid forms of months
            // in RegExp ready format.
            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
        } else if (/D MMMM/.test(format)) {
            return monthsSubjective[momentToFormat.month()];
        } else {
            return monthsNominative[momentToFormat.month()];
        }
    },
    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Dzi o] LT',
        nextDay: '[Jutro o] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[W niedziel o] LT';

                case 2:
                    return '[We wtorek o] LT';

                case 3:
                    return '[W rod o] LT';

                case 6:
                    return '[W sobot o] LT';

                default:
                    return '[W] dddd [o] LT';
            }
        },
        lastDay: '[Wczoraj o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[W zesz niedziel o] LT';
                case 3:
                    return '[W zesz rod o] LT';
                case 6:
                    return '[W zesz sobot o] LT';
                default:
                    return '[W zeszy] dddd [o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : '%s temu',
        s : 'kilka sekund',
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : '1 dzie',
        dd : '%d dni',
        M : 'miesic',
        MM : translate,
        y : 'rok',
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return pl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pt-br.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ptBr = moment.defineLocale('pt-br', {
    months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar : {
        sameDay: '[Hoje s] LT',
        nextDay: '[Amanh s] LT',
        nextWeek: 'dddd [s] LT',
        lastDay: '[Ontem s] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : '%s atrs',
        s : 'poucos segundos',
        ss : '%d segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um ms',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d'
});

return ptBr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pt.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var pt = moment.defineLocale('pt', {
    months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hoje s] LT',
        nextDay: '[Amanh s] LT',
        nextWeek: 'dddd [s] LT',
        lastDay: '[Ontem s] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : 'h %s',
        s : 'segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um ms',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return pt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ro.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
            'mm': 'minute',
            'hh': 'ore',
            'dd': 'zile',
            'MM': 'luni',
            'yy': 'ani'
        },
        separator = ' ';
    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
        separator = ' de ';
    }
    return number + separator + format[key];
}

var ro = moment.defineLocale('ro', {
    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[azi la] LT',
        nextDay: '[mine la] LT',
        nextWeek: 'dddd [la] LT',
        lastDay: '[ieri la] LT',
        lastWeek: '[fosta] dddd [la] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'peste %s',
        past : '%s n urm',
        s : 'cteva secunde',
        m : 'un minut',
        mm : relativeTimeWithPlural,
        h : 'o or',
        hh : relativeTimeWithPlural,
        d : 'o zi',
        dd : relativeTimeWithPlural,
        M : 'o lun',
        MM : relativeTimeWithPlural,
        y : 'un an',
        yy : relativeTimeWithPlural
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return ro;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ru.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}
var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

// http://new.gramota.ru/spravka/rules/139-prop :  103
//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
var ru = moment.defineLocale('ru', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : {
        //  CLDR  "."  ".",        ?
        format: '._._._.____._._._._.'.split('_'),
        standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays : {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        lastDay: '[ ] LT',
        nextWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[] dddd [] LT';
                } else {
                    return '[] dddd [] LT';
                }
            }
        },
        lastWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[] dddd [] LT';
                } else {
                    return '[] dddd [] LT';
                }
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : '',
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    meridiemParse: /|||/i,
    isPM : function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ru;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sd.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var days = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var sd = moment.defineLocale('sd', {
    months : months,
    monthsShort : months,
    weekdays : days,
    weekdaysShort : days,
    weekdaysMin : days,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        }
        return '';
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd [  ] LT',
        lastDay : '[] LT',
        lastWeek : '[ ] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/se.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



var se = moment.defineLocale('se', {
    months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'MMMM D. [b.] YYYY',
        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar : {
        sameDay: '[otne ti] LT',
        nextDay: '[ihttin ti] LT',
        nextWeek: 'dddd [ti] LT',
        lastDay: '[ikte ti] LT',
        lastWeek: '[ovddit] dddd [ti] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s geaes',
        past : 'mait %s',
        s : 'moadde sekunddat',
        m : 'okta minuhta',
        mm : '%d minuhtat',
        h : 'okta diimmu',
        hh : '%d diimmut',
        d : 'okta beaivi',
        dd : '%d beaivvit',
        M : 'okta mnnu',
        MM : '%d mnut',
        y : 'okta jahki',
        yy : '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return se;

})));


/***/ }),

/***/ "./node_modules/moment/locale/si.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


/*jshint -W100*/
var si = moment.defineLocale('si', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'a h:mm',
        LTS : 'a h:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D, a h:mm',
        LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar : {
        sameDay : '[] LT[]',
        nextDay : '[] LT[]',
        nextWeek : 'dddd LT[]',
        lastDay : '[] LT[]',
        lastWeek : '[] dddd LT[]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s ',
        s : ' ',
        m : '',
        mm : ' %d',
        h : '',
        hh : ' %d',
        d : '',
        dd : ' %d',
        M : '',
        MM : ' %d',
        y : '',
        yy : ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal : function (number) {
        return number + ' ';
    },
    meridiemParse : / | |.|../,
    isPM : function (input) {
        return input === '..' || input === ' ';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? '..' : ' ';
        } else {
            return isLower ? '..' : ' ';
        }
    }
});

return si;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
function plural(n) {
    return (n > 1) && (n < 5);
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minty' : 'mint');
            } else {
                return result + 'mintami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodn');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de' : 'dom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dni' : 'dn');
            } else {
                return result + 'dami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
    }
}

var sk = moment.defineLocale('sk', {
    months : months,
    monthsShort : monthsShort,
    weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[dnes o] LT',
        nextDay: '[zajtra o] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedeu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
            }
        },
        lastDay: '[vera o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minul nedeu o] LT';
                case 1:
                case 2:
                    return '[minul] dddd [o] LT';
                case 3:
                    return '[minul stredu o] LT';
                case 4:
                case 5:
                    return '[minul] dddd [o] LT';
                case 6:
                    return '[minul sobotu o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'pred %s',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
    }
}

var sl = moment.defineLocale('sl', {
    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danes ob] LT',
        nextDay  : '[jutri ob] LT',

        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
            }
        },
        lastDay  : '[veraj ob] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[prejnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejnji] dddd [ob] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ez %s',
        past   : 'pred %s',
        s      : processRelativeTime,
        m      : processRelativeTime,
        mm     : processRelativeTime,
        h      : processRelativeTime,
        hh     : processRelativeTime,
        d      : processRelativeTime,
        dd     : processRelativeTime,
        M      : processRelativeTime,
        MM     : processRelativeTime,
        y      : processRelativeTime,
        yy     : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return sl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sq.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var sq = moment.defineLocale('sq', {
    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
        return input.charAt(0) === 'M';
    },
    meridiem : function (hours, minutes, isLower) {
        return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Sot n] LT',
        nextDay : '[Nesr n] LT',
        nextWeek : 'dddd [n] LT',
        lastDay : '[Dje n] LT',
        lastWeek : 'dddd [e kaluar n] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'n %s',
        past : '%s m par',
        s : 'disa sekonda',
        m : 'nj minut',
        mm : '%d minuta',
        h : 'nj or',
        hh : '%d or',
        d : 'nj dit',
        dd : '%d dit',
        M : 'nj muaj',
        MM : '%d muaj',
        y : 'nj vit',
        yy : '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sq;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sr-cyrl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var translator = {
    words: { //Different grammatical cases
        m: [' ', ' '],
        mm: ['', '', ''],
        h: [' ', ' '],
        hh: ['', '', ''],
        dd: ['', '', ''],
        MM: ['', '', ''],
        yy: ['', '', '']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

var srCyrl = moment.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[] [] [] LT';
                case 3:
                    return '[] [] [] LT';
                case 6:
                    return '[] [] [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
            }
        },
        lastDay  : '[ ] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past   : ' %s',
        s      : ' ',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : '',
        dd     : translator.translate,
        M      : '',
        MM     : translator.translate,
        y      : '',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return srCyrl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var translator = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jedne minute'],
        mm: ['minut', 'minute', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mesec', 'meseca', 'meseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sutra u] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jue u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prole] [nedelje] [u] LT',
                '[prolog] [ponedeljka] [u] LT',
                '[prolog] [utorka] [u] LT',
                '[prole] [srede] [u] LT',
                '[prolog] [etvrtka] [u] LT',
                '[prolog] [petka] [u] LT',
                '[prole] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'pre %s',
        s      : 'nekoliko sekundi',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : 'dan',
        dd     : translator.translate,
        M      : 'mesec',
        MM     : translator.translate,
        y      : 'godinu',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return sr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ss.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



var ss = moment.defineLocale('ss', {
    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Namuhla nga] LT',
        nextDay : '[Kusasa nga] LT',
        nextWeek : 'dddd [nga] LT',
        lastDay : '[Itolo nga] LT',
        lastWeek : 'dddd [leliphelile] [nga] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'nga %s',
        past : 'wenteka nga %s',
        s : 'emizuzwana lomcane',
        m : 'umzuzu',
        mm : '%d emizuzu',
        h : 'lihora',
        hh : '%d emahora',
        d : 'lilanga',
        dd : '%d emalanga',
        M : 'inyanga',
        MM : '%d tinyanga',
        y : 'umnyaka',
        yy : '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'ekuseni';
        } else if (hours < 15) {
            return 'emini';
        } else if (hours < 19) {
            return 'entsambama';
        } else {
            return 'ebusuku';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'ekuseni') {
            return hour;
        } else if (meridiem === 'emini') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
            if (hour === 0) {
                return 0;
            }
            return hour + 12;
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ss;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var sv = moment.defineLocale('sv', {
    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Idag] LT',
        nextDay: '[Imorgon] LT',
        lastDay: '[Igr] LT',
        nextWeek: '[P] dddd LT',
        lastWeek: '[I] dddd[s] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : 'fr %s sedan',
        s : 'ngra sekunder',
        m : 'en minut',
        mm : '%d minuter',
        h : 'en timme',
        hh : '%d timmar',
        d : 'en dag',
        dd : '%d dagar',
        M : 'en mnad',
        MM : '%d mnader',
        y : 'ett r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'e' :
            (b === 1) ? 'a' :
            (b === 2) ? 'a' :
            (b === 3) ? 'e' : 'e';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sw.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var sw = moment.defineLocale('sw', {
    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[leo saa] LT',
        nextDay : '[kesho saa] LT',
        nextWeek : '[wiki ijayo] dddd [saat] LT',
        lastDay : '[jana] LT',
        lastWeek : '[wiki iliyopita] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s baadaye',
        past : 'tokea %s',
        s : 'hivi punde',
        m : 'dakika moja',
        mm : 'dakika %d',
        h : 'saa limoja',
        hh : 'masaa %d',
        d : 'siku moja',
        dd : 'masiku %d',
        M : 'mwezi mmoja',
        MM : 'miezi %d',
        y : 'mwaka mmoja',
        yy : 'miaka %d'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return sw;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ta.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var ta = moment.defineLocale('ta', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, HH:mm',
        LLLL : 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[ ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : ' ',
        mm : '%d ',
        h : '  ',
        hh : '%d  ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number + '';
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem : function (hour, minute, isLower) {
        if (hour < 2) {
            return ' ';
        } else if (hour < 6) {
            return ' ';  // 
        } else if (hour < 10) {
            return ' '; // 
        } else if (hour < 14) {
            return ' '; // 
        } else if (hour < 18) {
            return ' '; // 
        } else if (hour < 22) {
            return ' '; // 
        } else {
            return ' ';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 2 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else {
            return hour + 12;
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return ta;

})));


/***/ }),

/***/ "./node_modules/moment/locale/te.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var te = moment.defineLocale('te', {
    months : '___________'.split('_'),
    monthsShort : '._.__.____._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return te;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tet.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tet = moment.defineLocale('tet', {
    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Ohin iha] LT',
        nextDay: '[Aban iha] LT',
        nextWeek: 'dddd [iha] LT',
        lastDay: '[Horiseik iha] LT',
        lastWeek: 'dddd [semana kotuk] [iha] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'iha %s',
        past : '%s liuba',
        s : 'minutu balun',
        m : 'minutu ida',
        mm : 'minutus %d',
        h : 'horas ida',
        hh : 'horas %d',
        d : 'loron ida',
        dd : 'loron %d',
        M : 'fulan ida',
        MM : 'fulan %d',
        y : 'tinan ida',
        yy : 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return tet;

})));


/***/ }),

/***/ "./node_modules/moment/locale/th.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var th = moment.defineLocale('th', {
    months : '___________'.split('_'),
    monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'), // yes, three characters difference
    weekdaysMin : '._._._._._._.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY  H:mm',
        LLLL : 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd[ ] LT',
        lastDay : '[ ] LT',
        lastWeek : '[]dddd[ ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

return th;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tl-ph.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tlPh = moment.defineLocale('tl-ph', {
    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'MM/D/YYYY',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY HH:mm',
        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar : {
        sameDay: 'LT [ngayong araw]',
        nextDay: '[Bukas ng] LT',
        nextWeek: 'LT [sa susunod na] dddd',
        lastDay: 'LT [kahapon]',
        lastWeek: 'LT [noong nakaraang] dddd',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'sa loob ng %s',
        past : '%s ang nakalipas',
        s : 'ilang segundo',
        m : 'isang minuto',
        mm : '%d minuto',
        h : 'isang oras',
        hh : '%d oras',
        d : 'isang araw',
        dd : '%d araw',
        M : 'isang buwan',
        MM : '%d buwan',
        y : 'isang taon',
        yy : '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return tlPh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tlh.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

function translateFuture(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'leS' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'waQ' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'nem' :
    time + ' pIq';
    return time;
}

function translatePast(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'Hu' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'wen' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'ben' :
    time + ' ret';
    return time;
}

function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);
    switch (string) {
        case 'mm':
            return numberNoun + ' tup';
        case 'hh':
            return numberNoun + ' rep';
        case 'dd':
            return numberNoun + ' jaj';
        case 'MM':
            return numberNoun + ' jar';
        case 'yy':
            return numberNoun + ' DIS';
    }
}

function numberAsNoun(number) {
    var hundred = Math.floor((number % 1000) / 100),
    ten = Math.floor((number % 100) / 10),
    one = number % 10,
    word = '';
    if (hundred > 0) {
        word += numbersNouns[hundred] + 'vatlh';
    }
    if (ten > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
    }
    if (one > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
    }
    return (word === '') ? 'pagh' : word;
}

var tlh = moment.defineLocale('tlh', {
    months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact : true,
    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[DaHjaj] LT',
        nextDay: '[waleS] LT',
        nextWeek: 'LLL',
        lastDay: '[waHu] LT',
        lastWeek: 'LLL',
        sameElse: 'L'
    },
    relativeTime : {
        future : translateFuture,
        past : translatePast,
        s : 'puS lup',
        m : 'wa tup',
        mm : translate,
        h : 'wa rep',
        hh : translate,
        d : 'wa jaj',
        dd : translate,
        M : 'wa jar',
        MM : translate,
        y : 'wa DIS',
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return tlh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var suffixes = {
    1: '\'inci',
    5: '\'inci',
    8: '\'inci',
    70: '\'inci',
    80: '\'inci',
    2: '\'nci',
    7: '\'nci',
    20: '\'nci',
    50: '\'nci',
    3: '\'nc',
    4: '\'nc',
    100: '\'nc',
    6: '\'nc',
    9: '\'uncu',
    10: '\'uncu',
    30: '\'uncu',
    60: '\'nc',
    90: '\'nc'
};

var tr = moment.defineLocale('tr', {
    months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
    weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugn saat] LT',
        nextDay : '[yarn saat] LT',
        nextWeek : '[gelecek] dddd [saat] LT',
        lastDay : '[dn] LT',
        lastWeek : '[geen] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s nce',
        s : 'birka saniye',
        m : 'bir dakika',
        mm : '%d dakika',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gn',
        dd : '%d gn',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir yl',
        yy : '%d yl'
    },
    dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '\'nc';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return tr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
// This is currently too difficult (maybe even impossible) to add.
var tzl = moment.defineLocale('tzl', {
    months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM [dallas] YYYY',
        LLL : 'D. MMMM [dallas] YYYY HH.mm',
        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM : function (input) {
        return 'd\'o' === input.toLowerCase();
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'd\'o' : 'D\'O';
        } else {
            return isLower ? 'd\'a' : 'D\'A';
        }
    },
    calendar : {
        sameDay : '[oxhi ] LT',
        nextDay : '[dem ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ieiri ] LT',
        lastWeek : '[sr el] dddd [lasteu ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'osprei %s',
        past : 'ja%s',
        s : processRelativeTime,
        m : processRelativeTime,
        mm : processRelativeTime,
        h : processRelativeTime,
        hh : processRelativeTime,
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['viensas secunds', '\'iensas secunds'],
        'm': ['\'n mut', '\'iens mut'],
        'mm': [number + ' muts', '' + number + ' muts'],
        'h': ['\'n ora', '\'iensa ora'],
        'hh': [number + ' oras', '' + number + ' oras'],
        'd': ['\'n ziua', '\'iensa ziua'],
        'dd': [number + ' ziuas', '' + number + ' ziuas'],
        'M': ['\'n mes', '\'iens mes'],
        'MM': [number + ' mesen', '' + number + ' mesen'],
        'y': ['\'n ar', '\'iens ar'],
        'yy': [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
}

return tzl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzm-latn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tzmLatn = moment.defineLocale('tzm-latn', {
    months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[asdkh g] LT',
        nextDay: '[aska g] LT',
        nextWeek: 'dddd [g] LT',
        lastDay: '[assant g] LT',
        lastWeek: 'dddd [g] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'dadkh s yan %s',
        past : 'yan %s',
        s : 'imik',
        m : 'minu',
        mm : '%d minu',
        h : 'saa',
        hh : '%d tassain',
        d : 'ass',
        dd : '%d ossan',
        M : 'ayowr',
        MM : '%d iyyirn',
        y : 'asgas',
        yy : '%d isgasn'
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return tzmLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzm.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tzm = moment.defineLocale('tzm', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[ ] LT',
        lastWeek: 'dddd [] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '   %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d o',
        M : 'o',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return tzm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else if (key === 'h') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}
function weekdaysCaseReplace(m, format) {
    var weekdays = {
        'nominative': '______'.split('_'),
        'accusative': '______'.split('_'),
        'genitive': '______'.split('_')
    };

    if (!m) {
        return weekdays['nominative'];
    }

    var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
        'accusative' :
        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
            'genitive' :
            'nominative');
    return weekdays[nounCase][m.day()];
}
function processHoursFunction(str) {
    return function () {
        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
}

var uk = moment.defineLocale('uk', {
    months : {
        'format': '___________'.split('_'),
        'standalone': '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : weekdaysCaseReplace,
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: processHoursFunction('[ '),
        nextDay: processHoursFunction('[ '),
        lastDay: processHoursFunction('[ '),
        nextWeek: processHoursFunction('[] dddd ['),
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[] dddd [').call(this);
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : '',
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return uk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ur.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var days = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var ur = moment.defineLocale('ur', {
    months : months,
    monthsShort : months,
    weekdays : days,
    weekdaysShort : days,
    weekdaysMin : days,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        }
        return '';
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[  ] LT',
        lastWeek : '[] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ur;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uz-latn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var uzLatn = moment.defineLocale('uz-latn', {
    months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[Bugun soat] LT [da]',
        nextDay : '[Ertaga] LT [da]',
        nextWeek : 'dddd [kuni soat] LT [da]',
        lastDay : '[Kecha soat] LT [da]',
        lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'Yaqin %s ichida',
        past : 'Bir necha %s oldin',
        s : 'soniya',
        m : 'bir daqiqa',
        mm : '%d daqiqa',
        h : 'bir soat',
        hh : '%d soat',
        d : 'bir kun',
        dd : '%d kun',
        M : 'bir oy',
        MM : '%d oy',
        y : 'bir yil',
        yy : '%d yil'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return uzLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uz.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var uz = moment.defineLocale('uz', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT []',
        nextDay : '[] LT []',
        nextWeek : 'dddd [ ] LT []',
        lastDay : '[ ] LT []',
        lastWeek : '[] dddd [ ] LT []',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s ',
        past : '  %s ',
        s : '',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 4th is the first week of the year.
    }
});

return uz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/vi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var vi = moment.defineLocale('vi', {
    months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
    monthsParseExact : true,
    weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /sa|ch/i,
    isPM : function (input) {
        return /^ch$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'sa' : 'SA';
        } else {
            return isLower ? 'ch' : 'CH';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM [nm] YYYY',
        LLL : 'D MMMM [nm] YYYY HH:mm',
        LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
        l : 'DD/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hm nay lc] LT',
        nextDay: '[Ngy mai lc] LT',
        nextWeek: 'dddd [tun ti lc] LT',
        lastDay: '[Hm qua lc] LT',
        lastWeek: 'dddd [tun ri lc] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s ti',
        past : '%s trc',
        s : 'vi giy',
        m : 'mt pht',
        mm : '%d pht',
        h : 'mt gi',
        hh : '%d gi',
        d : 'mt ngy',
        dd : '%d ngy',
        M : 'mt thng',
        MM : '%d thng',
        y : 'mt nm',
        yy : '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return vi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/x-pseudo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var xPseudo = moment.defineLocale('x-pseudo', {
    months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact : true,
    weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[T~d~ t] LT',
        nextDay : '[T~m~rr~w t] LT',
        nextWeek : 'dddd [t] LT',
        lastDay : '[~st~rd~ t] LT',
        lastWeek : '[L~st] dddd [t] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '~ %s',
        past : '%s ~g',
        s : ' ~fw ~sc~ds',
        m : ' ~m~t',
        mm : '%d m~~ts',
        h : '~ h~r',
        hh : '%d h~rs',
        d : ' ~d',
        dd : '%d d~s',
        M : ' ~m~th',
        MM : '%d m~t~hs',
        y : ' ~r',
        yy : '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return xPseudo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/yo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var yo = moment.defineLocale('yo', {
    months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Oni ni] LT',
        nextDay : '[la ni] LT',
        nextWeek : 'dddd [s ton\'b] [ni] LT',
        lastDay : '[Ana ni] LT',
        lastWeek : 'dddd [s tol] [ni] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ni %s',
        past : '%s kja',
        s : 'isju aaya die',
        m : 'isju kan',
        mm : 'isju %d',
        h : 'wakati kan',
        hh : 'wakati %d',
        d : 'j kan',
        dd : 'j %d',
        M : 'osu kan',
        MM : 'osu %d',
        y : 'dun kan',
        yy : 'dun %d'
    },
    dayOfMonthOrdinalParse : /j\s\d{1,2}/,
    ordinal : 'j %d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4 // The week that contains Jan 4th is the first week of the year.
    }
});

return yo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-cn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var zhCn = moment.defineLocale('zh-cn', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMDAhmm',
        LLLL : 'YYYYMMMDddddAhmm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' ||
                meridiem === '') {
            return hour;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        } else {
            // ''
            return hour >= 11 ? hour : hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    },
    week : {
        // GB/T 7408-1994ISO 8601:1988
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return zhCn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-hk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var zhHk = moment.defineLocale('zh-hk', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMD HH:mm',
        LLLL : 'YYYYMMMDdddd HH:mm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

return zhHk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-tw.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var zhTw = moment.defineLocale('zh-tw', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMD HH:mm',
        LLLL : 'YYYYMMMDdddd HH:mm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

return zhTw;

})));


/***/ }),

/***/ "./node_modules/moment/moment.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js
//! version : 2.19.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            __webpack_require__("./node_modules/moment/locale recursive ^\\.\\/.*$")("./" + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.19.2';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

},["./app/Resources/assets/js/pages/dayOff.js"]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvUmVzb3VyY2VzL2Fzc2V0cy9qcy9wYWdlcy9kYXlPZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC1kYXRlcGlja2VyL2Rpc3QvanMvYm9vdHN0cmFwLWRhdGVwaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGVyYW5nZXBpY2tlci9kYXRlcmFuZ2VwaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSBeXFwuXFwvLiokIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWR6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWt3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLW1hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXRuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2F6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2R2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLXVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2Z5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dvbS1sYXRuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2d1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2phLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2thLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2trLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ttLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2t5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21pLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLW15LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL215LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLWJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BhLWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3J1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsLXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLWxhdG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LWxhdG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveC1wc2V1ZG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtdHcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyJdLCJuYW1lcyI6WyJldmVudCIsIiQiLCJkYXRlcmFuZ2VwaWNrZXIiLCJkYXRlc0Rpc2FibGVkIiwiSlNPTiIsInBhcnNlIiwiYXJyYXkiLCJsb2NhbGUiLCJmb3JtYXQiLCJkYXlzT2ZXZWVrRGlzYWJsZWQiLCJ0b2RheUhpZ2hsaWdodCIsImRlZmF1bHREYXRlIiwiRGF0ZSIsImlzSW52YWxpZERhdGUiLCJkYXRlIiwiZGF5IiwiaW5BcnJheSIsImZ1bGxDYWxlbmRhciIsImV2ZW50U291cmNlcyIsImV2ZW50cyIsImZyZWVEYXlzIiwiY29sb3IiLCJ0ZXh0Q29sb3IiLCJldmVudENsaWNrIiwianNFdmVudCIsInZpZXciLCJpZCIsInVuZGVmaW5lZCIsInVzZXJJZCIsIm1vZGFsIiwiYmFja2Ryb3AiLCJrZXlib2FyZCIsImF0dHIiLCJ3ZWVrZW5kcyIsImVhY2giLCJkYXlzT2ZmIiwia2V5IiwidmFsdWUiLCJldmVudDEiLCJhbGxEYXkiLCJuZXh0RGF5VGhyZXNob2xkIiwiZGF0ZXBpY2tlciIsImF1dG9jbG9zZSIsIm1pbkRhdGUiLCJvbiIsImUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQSxRQUFRLEVBQVo7QUFDQSw4Q0FBQUMsQ0FBRSxZQUFZO0FBQ1ZBLElBQUEsOENBQUFBLENBQUUseUJBQUYsRUFBNkJDLGVBQTdCLENBQ0k7QUFDSUMsdUJBQWVDLEtBQUtDLEtBQUwsQ0FBV0MsS0FBWCxDQURuQjtBQUVJQyxnQkFBUTtBQUNKQyxvQkFBUSxZQURKO0FBRUpDLGdDQUFvQixJQUZoQjtBQUdKQyw0QkFBZ0IsSUFIWjtBQUlKQyx5QkFBYSxJQUFJQyxJQUFKO0FBSlQsU0FGWjtBQVFJQyx1QkFBZSx1QkFBVUMsSUFBVixFQUFnQjtBQUMzQixnQkFBSUEsS0FBS0MsR0FBTCxPQUFlLENBQWYsSUFBb0JELEtBQUtDLEdBQUwsT0FBZSxDQUFuQyxJQUF3Qyw4Q0FBQWQsQ0FBRWUsT0FBRixDQUFVRixLQUFLTixNQUFMLENBQVksWUFBWixDQUFWLEVBQXFDSixLQUFLQyxLQUFMLENBQVdDLEtBQVgsQ0FBckMsTUFBNEQsQ0FBQyxDQUF6RyxFQUE0RztBQUN4Ryx1QkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFaTCxLQURKO0FBa0JILENBbkJEO0FBb0JBLDhDQUFBTCxDQUFFLFlBQVk7QUFDVkEsSUFBQSw4Q0FBQUEsQ0FBRSxXQUFGLEVBQWVnQixZQUFmLENBQTRCOztBQUVwQkMsc0JBQWMsQ0FDVjtBQUNJQyxvQkFBUWYsS0FBS0MsS0FBTCxDQUFXZSxRQUFYLENBRFo7QUFFSUMsbUJBQU8sU0FGWCxFQUUwQjtBQUN0QkMsdUJBQVcsT0FIZixDQUd1Qjs7QUFIdkIsU0FEVSxDQUZNOztBQVdwQkMsb0JBQVksb0JBQVV2QixLQUFWLEVBQWlCd0IsT0FBakIsRUFBMEJDLElBQTFCLEVBQWdDO0FBQ3hDLGdCQUFJQyxLQUFLMUIsTUFBTTBCLEVBQWY7O0FBRUEsZ0JBQUlBLE9BQU9DLFNBQVgsRUFBc0I7QUFDbEIsdUJBQU8sS0FBUDtBQUNILGFBRkQsTUFHSyxJQUFJQyxNQUFKLEVBQVk7QUFDYjNCLGdCQUFBLDhDQUFBQSxDQUFFLFdBQUYsRUFBZTRCLEtBQWYsQ0FBcUI7QUFDakJDLDhCQUFVLFFBRE87QUFFakJDLDhCQUFVO0FBRk8saUJBQXJCO0FBSUE5QixnQkFBQSw4Q0FBQUEsQ0FBRSxlQUFGLEVBQW1CK0IsSUFBbkIsQ0FBd0IsU0FBeEIsRUFBbUMsNEJBQTRCTixFQUE1QixHQUFpQyxHQUFwRTtBQUNIO0FBQ0osU0F4Qm1CO0FBeUJwQk8sa0JBQVU7QUF6QlUsS0FBNUI7O0FBNkJBaEMsSUFBQSw4Q0FBQUEsQ0FBRWlDLElBQUYsQ0FBTzlCLEtBQUtDLEtBQUwsQ0FBVzhCLE9BQVgsQ0FBUCxFQUE0QixVQUFVQyxHQUFWLEVBQWVDLEtBQWYsRUFBc0I7QUFDOUMsWUFBSUMsU0FBUztBQUNUbkIsb0JBQVFrQixNQUFNLFNBQU4sQ0FEQztBQUVURSxvQkFBUSxJQUZDO0FBR1RDLDhCQUFrQixVQUhUO0FBSVRuQixtQkFBT2dCLE1BQU0sT0FBTixDQUpFLEVBSWtCO0FBQzNCZix1QkFBVyxPQUxGLENBS1U7O0FBTFYsU0FBYjs7QUFTQXJCLFFBQUEsOENBQUFBLENBQUUsV0FBRixFQUFlZ0IsWUFBZixDQUE0QixnQkFBNUIsRUFBOENxQixNQUE5QztBQUNILEtBWEQ7QUFZSCxDQTFDRDs7QUE0Q0EsOENBQUFyQyxDQUFFLFlBQVk7QUFDVkEsSUFBQSw4Q0FBQUEsQ0FBRSxXQUFGLEVBQWV3QyxVQUFmLENBQTBCO0FBQ1JDLG1CQUFXLElBREgsRUFDWTtBQUNwQmxDLGdCQUFRLFlBRkE7QUFHUkwsdUJBQWVDLEtBQUtDLEtBQUwsQ0FBV0MsS0FBWCxDQUhQO0FBSVJHLDRCQUFvQixJQUpaO0FBS1JDLHdCQUFnQixJQUxSO0FBTVJpQyxpQkFBUzs7QUFORCxLQUExQixFQVVlQyxFQVZmLENBVWtCLFlBVmxCLEVBVWdDLFVBQVVDLENBQVYsRUFBYSxDQUM5QixDQVhmO0FBWUgsQ0FiRCxFOzs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEIsNkNBQTZDO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1DQUFtQyxhQUFhLEVBQUU7QUFDbEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQzs7Ozs7Ozs7QUM3K0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUFBO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDZDQUE2QyxJQUFJOztBQUUzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsU0FBUztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxTQUFTOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxzQkFBc0IsRUFBRTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGNBQWMsRUFBRTs7QUFFeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7Ozs7O0FDMWxERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUMvRTtBQUNBLGtCQUFrQix1REFBdUQ7O0FBRXpFO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxpRkFBaUY7QUFDakYscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RCxjQUFjLHlCQUF5QixFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUNBQXVDO0FBQ3hELGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDLG1DQUFtQyxFQUFFO0FBQ3JDLCtCQUErQjtBQUMvQjtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRCwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsZ0RBQWdEO0FBQ2hELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsOEVBQThFO0FBQzlFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QyxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4REFBOEQ7QUFDOUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUJBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQyxRQUFRLDBCQUEwQjtBQUNsQyxRQUFRLHlCQUF5QjtBQUNqQyxRQUFRLHlCQUF5QjtBQUNqQyxRQUFRLHdCQUF3QjtBQUNoQyxRQUFRLHdCQUF3QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3R0FBd0c7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdHQUFnRztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFDQUFxQztBQUM5RDtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakUsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakUsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUIscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1REFBdUQ7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxQkFBcUIsY0FBYztBQUNuQyx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsR0FBRyw0QkFBNEI7QUFDeEc7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJCQUEyQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBNkQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxTQUFTO0FBQ1Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0RBQWtEOzs7QUFHbEQsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0Esb0NBQW9DO0FBQ3BDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0NBQXNDO0FBQ3RDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHFDQUFxQztBQUNyQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVDQUF1QztBQUN2QyxxQ0FBcUM7QUFDckM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBMkQ7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssV0FBVztBQUNoQixLQUFLLGNBQWM7QUFDbkIsS0FBSyxjQUFjO0FBQ25CLEtBQUssY0FBYztBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0Msa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQ0FBa0M7QUFDckY7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlDQUFpQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLHdEQUF3RDtBQUN4RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQztBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1Qyw4REFBOEQ7QUFDOUQ7QUFDQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0MsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHFEQUFxRDtBQUNyRDtBQUNBLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxDQUFDLEU7Ozs7Ozs7QUM1MmNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFOzs7Ozs7O0FDNVBBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0Esd0ZBQXdGO0FBQ3hGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4RUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDeEdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0lEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDeEdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3JJRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3pGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN0SEQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3RIRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlJRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3ZGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0tEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlERDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNoRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3RUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ25HRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7O0FBRTVCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnR0FBZ0c7QUFDekc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbkdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbEVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM5REQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDeEVEO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbEZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzRkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQy9FRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDakVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzREQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3pFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM1RUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekhEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNIRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsR0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0hEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDaEpEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzVHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJLElBQUksSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM5RkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbEZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM5SEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3JFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQy9FRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBDQUEwQyxJQUFJLElBQUksSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3RGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3pERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7Ozs7QUFJNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN2RkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hJRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNyRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDcEhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2hHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RCx5REFBeUQsSUFBSTtBQUM3RCx3REFBd0QsSUFBSTtBQUM1RCw4REFBOEQsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDL0REO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2hGRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUMsd0NBQXdDO0FBQ3hDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0MseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDLDRDQUE0QztBQUM1Qyw2Q0FBNkM7QUFDN0MsOENBQThDO0FBQzlDLDJDQUEyQztBQUMzQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlKRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2pGRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMvRkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3ZGRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN2RkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzSEQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNIRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3REQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDaEVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN0TEQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNqR0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7O0FBSTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM1REQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN0RUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNySkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2pLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDckVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3R0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7Ozs7QUFJNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4RkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDcEVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxREQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsU0FBUztBQUNULDJCQUEyQjtBQUMzQixTQUFTO0FBQ1QsOEJBQThCO0FBQzlCLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUIsU0FBUztBQUNULDJCQUEyQjtBQUMzQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNqSUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4RkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ25FRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3ZIRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekREO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN0SkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3pERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3pERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbkVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDLElBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzREQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4R0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7OENDdkdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLElBQUk7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdMQUF3TCxJQUFJOztBQUU1TCxpRUFBaUUsSUFBSTs7QUFFckU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHlCQUF5QixFQUFFLEVBQUU7QUFDN0IseUJBQXlCLEVBQUUsRUFBRTtBQUM3Qiw4QkFBOEIsRUFBRSxFQUFFO0FBQ2xDLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLHlCQUF5QixJQUFJLEVBQUU7QUFDL0IseUJBQXlCLElBQUksRUFBRTtBQUMvQiw4QkFBOEIsSUFBSSxFQUFFOztBQUVwQywyQkFBMkI7QUFDM0IsZ0NBQWdDOztBQUVoQywwQ0FBMEM7QUFDMUMsaURBQWlEOztBQUVqRCxvQ0FBb0MsSUFBSSxJQUFJOztBQUU1QztBQUNBO0FBQ0EsNEhBQTRILElBQUk7OztBQUdoSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSxJQUFJLEVBQUU7QUFDL0Msb0NBQW9DLEVBQUUsSUFBSSxFQUFFOztBQUU1Qzs7QUFFQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CLHVCQUF1QixFQUFFO0FBQ3pCLHlCQUF5QixFQUFFO0FBQzNCLHVCQUF1QixFQUFFO0FBQ3pCLHFCQUFxQixFQUFFLElBQUksRUFBRTtBQUM3QixvQkFBb0IsRUFBRTtBQUN0QiwyQkFBMkIsR0FBRztBQUM5QixxQkFBcUIsRUFBRTtBQUN2QjtBQUNBLHVCQUF1QixFQUFFLElBQUksRUFBRTtBQUMvQixzQkFBc0IsRUFBRSxJQUFJLEVBQUU7QUFDOUIsb0JBQW9CLEVBQUU7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxJQUFJLDBEQUEwRCxJQUFJLHFFQUFxRSxFQUFFOztBQUVuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQscURBQXFEO0FBQ3JELDJEQUEyRDtBQUMzRCxvREFBb0QsT0FBTztBQUMzRCxvREFBb0QsT0FBTztBQUMzRCxtREFBbUQsT0FBTztBQUMxRCwrREFBK0QsT0FBTztBQUN0RSxpRUFBaUUsT0FBTztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BELEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7QUNsNklEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJkYXlPZmYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgJ2Jvb3RzdHJhcC1zYXNzJztcclxuaW1wb3J0ICdib290c3RyYXAtZGF0ZXBpY2tlcic7XHJcbmltcG9ydCAnZGF0ZXJhbmdlcGlja2VyJztcclxuaW1wb3J0ICdmdWxsY2FsZW5kYXInO1xyXG5cclxudmFyIGV2ZW50ID0gW107XHJcbiQoZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZVwiXScpLmRhdGVyYW5nZXBpY2tlcihcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRhdGVzRGlzYWJsZWQ6IEpTT04ucGFyc2UoYXJyYXkpLFxyXG4gICAgICAgICAgICBsb2NhbGU6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogJ01NL0REL1lZWVknLFxyXG4gICAgICAgICAgICAgICAgZGF5c09mV2Vla0Rpc2FibGVkOiAnMDYnLFxyXG4gICAgICAgICAgICAgICAgdG9kYXlIaWdobGlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGF0ZTogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNJbnZhbGlkRGF0ZTogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlLmRheSgpID09PSAwIHx8IGRhdGUuZGF5KCkgPT09IDYgfHwgJC5pbkFycmF5KGRhdGUuZm9ybWF0KCdNTS9ERC9ZWVlZJyksIEpTT04ucGFyc2UoYXJyYXkpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufSk7XHJcbiQoZnVuY3Rpb24gKCkge1xyXG4gICAgJCgnI2NhbGVuZGFyJykuZnVsbENhbGVuZGFyKHtcclxuXHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogSlNPTi5wYXJzZShmcmVlRGF5cyksXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjYTk0NDQyJywgICAgIC8vIGFuIG9wdGlvbiFcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZScsLy8gYW4gb3B0aW9uIVxyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcblxyXG4gICAgICAgICAgICBldmVudENsaWNrOiBmdW5jdGlvbiAoZXZlbnQsIGpzRXZlbnQsIHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IGV2ZW50LmlkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXNlcklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnI2FkZE1vZGFsJykubW9kYWwoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogJ3N0YXRpYycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICQoJyNtb2RhbFNhdmVCdG4nKS5hdHRyKCdvbmNsaWNrJywgJ2phdmFzY3JpcHQ6bW92ZUZyZWVEYXkoJyArIGlkICsgJyknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2Vla2VuZHM6IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICApO1xyXG5cclxuICAgICQuZWFjaChKU09OLnBhcnNlKGRheXNPZmYpLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGxldCBldmVudDEgPSB7XHJcbiAgICAgICAgICAgIGV2ZW50czogdmFsdWVbJ2RheXNPZmYnXSxcclxuICAgICAgICAgICAgYWxsRGF5OiB0cnVlLFxyXG4gICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkOiBcIjAwOjAwOjAwXCIsXHJcbiAgICAgICAgICAgIGNvbG9yOiB2YWx1ZVsnY29sb3InXSwgICAgIC8vIGFuIG9wdGlvbiFcclxuICAgICAgICAgICAgdGV4dENvbG9yOiAnd2hpdGUnIC8vIGFuIG9wdGlvbiFcclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgJCgnI2NhbGVuZGFyJykuZnVsbENhbGVuZGFyKCdhZGRFdmVudFNvdXJjZScsIGV2ZW50MSk7XHJcbiAgICB9KTtcclxufSk7XHJcblxyXG4kKGZ1bmN0aW9uICgpIHtcclxuICAgICQoJyNkYXRldGltZScpLmRhdGVwaWNrZXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgYXV0b2Nsb3NlOiB0cnVlLCAgICAvLyBJdCBpcyBmYWxzZSwgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnbW0vZGQveXl5eScsXHJcbiAgICAgICAgICAgICAgICAgICAgICBkYXRlc0Rpc2FibGVkOiBKU09OLnBhcnNlKGFycmF5KSxcclxuICAgICAgICAgICAgICAgICAgICAgIGRheXNPZldlZWtEaXNhYmxlZDogJzA2JyxcclxuICAgICAgICAgICAgICAgICAgICAgIHRvZGF5SGlnaGxpZ2h0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgbWluRGF0ZTogMFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIC5vbignY2hhbmdlRGF0ZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG59KTtcclxuXHJcblxyXG5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL1Jlc291cmNlcy9hc3NldHMvanMvcGFnZXMvZGF5T2ZmLmpzIiwiLyohXHJcbiAqIERhdGVwaWNrZXIgZm9yIEJvb3RzdHJhcCB2MS43LjEgKGh0dHBzOi8vZ2l0aHViLmNvbS91eHNvbHV0aW9ucy9ib290c3RyYXAtZGF0ZXBpY2tlcilcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlIHYyLjAgKGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMClcclxuICovXHJcblxyXG4oZnVuY3Rpb24oZmFjdG9yeSl7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoW1wianF1ZXJ5XCJdLCBmYWN0b3J5KTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcclxuICAgIH1cclxufShmdW5jdGlvbigkLCB1bmRlZmluZWQpe1xyXG5cdGZ1bmN0aW9uIFVUQ0RhdGUoKXtcclxuXHRcdHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShEYXRlLCBhcmd1bWVudHMpKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gVVRDVG9kYXkoKXtcclxuXHRcdHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XHJcblx0XHRyZXR1cm4gVVRDRGF0ZSh0b2RheS5nZXRGdWxsWWVhcigpLCB0b2RheS5nZXRNb250aCgpLCB0b2RheS5nZXREYXRlKCkpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBpc1VUQ0VxdWFscyhkYXRlMSwgZGF0ZTIpIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdGRhdGUxLmdldFVUQ0Z1bGxZZWFyKCkgPT09IGRhdGUyLmdldFVUQ0Z1bGxZZWFyKCkgJiZcclxuXHRcdFx0ZGF0ZTEuZ2V0VVRDTW9udGgoKSA9PT0gZGF0ZTIuZ2V0VVRDTW9udGgoKSAmJlxyXG5cdFx0XHRkYXRlMS5nZXRVVENEYXRlKCkgPT09IGRhdGUyLmdldFVUQ0RhdGUoKVxyXG5cdFx0KTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gYWxpYXMobWV0aG9kLCBkZXByZWNhdGlvbk1zZyl7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYgKGRlcHJlY2F0aW9uTXNnICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQkLmZuLmRhdGVwaWNrZXIuZGVwcmVjYXRlZChkZXByZWNhdGlvbk1zZyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGlzVmFsaWREYXRlKGQpIHtcclxuXHRcdHJldHVybiBkICYmICFpc05hTihkLmdldFRpbWUoKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgRGF0ZUFycmF5ID0gKGZ1bmN0aW9uKCl7XHJcblx0XHR2YXIgZXh0cmFzID0ge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKGkpe1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNsaWNlKGkpWzBdO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjb250YWluczogZnVuY3Rpb24oZCl7XHJcblx0XHRcdFx0Ly8gQXJyYXkuaW5kZXhPZiBpcyBub3QgY3Jvc3MtYnJvd3NlcjtcclxuXHRcdFx0XHQvLyAkLmluQXJyYXkgZG9lc24ndCB3b3JrIHdpdGggRGF0ZXNcclxuXHRcdFx0XHR2YXIgdmFsID0gZCAmJiBkLnZhbHVlT2YoKTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIGw9dGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAvLyBVc2UgZGF0ZSBhcml0aG1ldGljIHRvIGFsbG93IGRhdGVzIHdpdGggZGlmZmVyZW50IHRpbWVzIHRvIG1hdGNoXHJcbiAgICAgICAgICBpZiAoMCA8PSB0aGlzW2ldLnZhbHVlT2YoKSAtIHZhbCAmJiB0aGlzW2ldLnZhbHVlT2YoKSAtIHZhbCA8IDEwMDAqNjAqNjAqMjQpXHJcblx0XHRcdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fSxcclxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbihpKXtcclxuXHRcdFx0XHR0aGlzLnNwbGljZShpLDEpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZXBsYWNlOiBmdW5jdGlvbihuZXdfYXJyYXkpe1xyXG5cdFx0XHRcdGlmICghbmV3X2FycmF5KVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdGlmICghJC5pc0FycmF5KG5ld19hcnJheSkpXHJcblx0XHRcdFx0XHRuZXdfYXJyYXkgPSBbbmV3X2FycmF5XTtcclxuXHRcdFx0XHR0aGlzLmNsZWFyKCk7XHJcblx0XHRcdFx0dGhpcy5wdXNoLmFwcGx5KHRoaXMsIG5ld19hcnJheSk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGNsZWFyOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHRoaXMubGVuZ3RoID0gMDtcclxuXHRcdFx0fSxcclxuXHRcdFx0Y29weTogZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR2YXIgYSA9IG5ldyBEYXRlQXJyYXkoKTtcclxuXHRcdFx0XHRhLnJlcGxhY2UodGhpcyk7XHJcblx0XHRcdFx0cmV0dXJuIGE7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBhID0gW107XHJcblx0XHRcdGEucHVzaC5hcHBseShhLCBhcmd1bWVudHMpO1xyXG5cdFx0XHQkLmV4dGVuZChhLCBleHRyYXMpO1xyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdH07XHJcblx0fSkoKTtcclxuXHJcblxyXG5cdC8vIFBpY2tlciBvYmplY3RcclxuXHJcblx0dmFyIERhdGVwaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKXtcclxuXHRcdCQuZGF0YShlbGVtZW50LCAnZGF0ZXBpY2tlcicsIHRoaXMpO1xyXG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuZGF0ZXMgPSBuZXcgRGF0ZUFycmF5KCk7XHJcblx0XHR0aGlzLnZpZXdEYXRlID0gdGhpcy5vLmRlZmF1bHRWaWV3RGF0ZTtcclxuXHRcdHRoaXMuZm9jdXNEYXRlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xyXG5cdFx0dGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpO1xyXG5cdFx0dGhpcy5pbnB1dEZpZWxkID0gdGhpcy5pc0lucHV0ID8gdGhpcy5lbGVtZW50IDogdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0Jyk7XHJcblx0XHR0aGlzLmNvbXBvbmVudCA9IHRoaXMuZWxlbWVudC5oYXNDbGFzcygnZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24sIC5pbnB1dC1ncm91cC1hZGRvbiwgLmJ0bicpIDogZmFsc2U7XHJcblx0XHRpZiAodGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQubGVuZ3RoID09PSAwKVxyXG5cdFx0XHR0aGlzLmNvbXBvbmVudCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5pc0lubGluZSA9ICF0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmVsZW1lbnQuaXMoJ2RpdicpO1xyXG5cclxuXHRcdHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSk7XHJcblxyXG5cdFx0Ly8gQ2hlY2tpbmcgdGVtcGxhdGVzIGFuZCBpbnNlcnRpbmdcclxuXHRcdGlmICh0aGlzLl9jaGVja190ZW1wbGF0ZSh0aGlzLm8udGVtcGxhdGVzLmxlZnRBcnJvdykpIHtcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5odG1sKHRoaXMuby50ZW1wbGF0ZXMubGVmdEFycm93KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fY2hlY2tfdGVtcGxhdGUodGhpcy5vLnRlbXBsYXRlcy5yaWdodEFycm93KSkge1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmh0bWwodGhpcy5vLnRlbXBsYXRlcy5yaWdodEFycm93KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9idWlsZEV2ZW50cygpO1xyXG5cdFx0dGhpcy5fYXR0YWNoRXZlbnRzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNJbmxpbmUpe1xyXG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1pbmxpbmUnKS5hcHBlbmRUbyh0aGlzLmVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWRyb3Bkb3duIGRyb3Bkb3duLW1lbnUnKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5vLnJ0bCl7XHJcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLXJ0bCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm8uY2FsZW5kYXJXZWVrcykge1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIC5kYXRlcGlja2VyLXN3aXRjaCwgdGhlYWQgLmRhdGVwaWNrZXItdGl0bGUsIHRmb290IC50b2RheSwgdGZvb3QgLmNsZWFyJylcclxuXHRcdFx0XHQuYXR0cignY29sc3BhbicsIGZ1bmN0aW9uKGksIHZhbCl7XHJcblx0XHRcdFx0XHRyZXR1cm4gTnVtYmVyKHZhbCkgKyAxO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Byb2Nlc3Nfb3B0aW9ucyh7XHJcblx0XHRcdHN0YXJ0RGF0ZTogdGhpcy5fby5zdGFydERhdGUsXHJcblx0XHRcdGVuZERhdGU6IHRoaXMuX28uZW5kRGF0ZSxcclxuXHRcdFx0ZGF5c09mV2Vla0Rpc2FibGVkOiB0aGlzLm8uZGF5c09mV2Vla0Rpc2FibGVkLFxyXG5cdFx0XHRkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ6IHRoaXMuby5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQsXHJcblx0XHRcdGRhdGVzRGlzYWJsZWQ6IHRoaXMuby5kYXRlc0Rpc2FibGVkXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuc2V0Vmlld01vZGUodGhpcy5vLnN0YXJ0Vmlldyk7XHJcblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuZmlsbERvdygpO1xyXG5cdFx0dGhpcy5maWxsTW9udGhzKCk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRpZiAodGhpcy5pc0lubGluZSl7XHJcblx0XHRcdHRoaXMuc2hvdygpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdERhdGVwaWNrZXIucHJvdG90eXBlID0ge1xyXG5cdFx0Y29uc3RydWN0b3I6IERhdGVwaWNrZXIsXHJcblxyXG5cdFx0X3Jlc29sdmVWaWV3TmFtZTogZnVuY3Rpb24odmlldyl7XHJcblx0XHRcdCQuZWFjaChEUEdsb2JhbC52aWV3TW9kZXMsIGZ1bmN0aW9uKGksIHZpZXdNb2RlKXtcclxuXHRcdFx0XHRpZiAodmlldyA9PT0gaSB8fCAkLmluQXJyYXkodmlldywgdmlld01vZGUubmFtZXMpICE9PSAtMSl7XHJcblx0XHRcdFx0XHR2aWV3ID0gaTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHZpZXc7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9yZXNvbHZlRGF5c09mV2VlazogZnVuY3Rpb24oZGF5c09mV2Vlayl7XHJcblx0XHRcdGlmICghJC5pc0FycmF5KGRheXNPZldlZWspKVxyXG5cdFx0XHRcdGRheXNPZldlZWsgPSBkYXlzT2ZXZWVrLnNwbGl0KC9bLFxcc10qLyk7XHJcblx0XHRcdHJldHVybiAkLm1hcChkYXlzT2ZXZWVrLCBOdW1iZXIpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfY2hlY2tfdGVtcGxhdGU6IGZ1bmN0aW9uKHRtcCl7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Ly8gSWYgZW1wdHlcclxuXHRcdFx0XHRpZiAodG1wID09PSB1bmRlZmluZWQgfHwgdG1wID09PSBcIlwiKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIElmIG5vIGh0bWwsIGV2ZXJ5dGhpbmcgb2tcclxuXHRcdFx0XHRpZiAoKHRtcC5tYXRjaCgvWzw+XS9nKSB8fCBbXSkubGVuZ3RoIDw9IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBDaGVja2luZyBpZiBodG1sIGlzIGZpbmVcclxuXHRcdFx0XHR2YXIgakRvbSA9ICQodG1wKTtcclxuXHRcdFx0XHRyZXR1cm4gakRvbS5sZW5ndGggPiAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhdGNoIChleCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRfcHJvY2Vzc19vcHRpb25zOiBmdW5jdGlvbihvcHRzKXtcclxuXHRcdFx0Ly8gU3RvcmUgcmF3IG9wdGlvbnMgZm9yIHJlZmVyZW5jZVxyXG5cdFx0XHR0aGlzLl9vID0gJC5leHRlbmQoe30sIHRoaXMuX28sIG9wdHMpO1xyXG5cdFx0XHQvLyBQcm9jZXNzZWQgb3B0aW9uc1xyXG5cdFx0XHR2YXIgbyA9IHRoaXMubyA9ICQuZXh0ZW5kKHt9LCB0aGlzLl9vKTtcclxuXHJcblx0XHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxyXG5cdFx0XHQvLyBmYWxsYmFjayB0byAyIGxldHRlciBjb2RlIGVnIFwiZGVcIlxyXG5cdFx0XHR2YXIgbGFuZyA9IG8ubGFuZ3VhZ2U7XHJcblx0XHRcdGlmICghZGF0ZXNbbGFuZ10pe1xyXG5cdFx0XHRcdGxhbmcgPSBsYW5nLnNwbGl0KCctJylbMF07XHJcblx0XHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcclxuXHRcdFx0XHRcdGxhbmcgPSBkZWZhdWx0cy5sYW5ndWFnZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvLmxhbmd1YWdlID0gbGFuZztcclxuXHJcblx0XHRcdC8vIFJldHJpZXZlIHZpZXcgaW5kZXggZnJvbSBhbnkgYWxpYXNlc1xyXG5cdFx0XHRvLnN0YXJ0VmlldyA9IHRoaXMuX3Jlc29sdmVWaWV3TmFtZShvLnN0YXJ0Vmlldyk7XHJcblx0XHRcdG8ubWluVmlld01vZGUgPSB0aGlzLl9yZXNvbHZlVmlld05hbWUoby5taW5WaWV3TW9kZSk7XHJcblx0XHRcdG8ubWF4Vmlld01vZGUgPSB0aGlzLl9yZXNvbHZlVmlld05hbWUoby5tYXhWaWV3TW9kZSk7XHJcblxyXG5cdFx0XHQvLyBDaGVjayB2aWV3IGlzIGJldHdlZW4gbWluIGFuZCBtYXhcclxuXHRcdFx0by5zdGFydFZpZXcgPSBNYXRoLm1heCh0aGlzLm8ubWluVmlld01vZGUsIE1hdGgubWluKHRoaXMuby5tYXhWaWV3TW9kZSwgby5zdGFydFZpZXcpKTtcclxuXHJcblx0XHRcdC8vIHRydWUsIGZhbHNlLCBvciBOdW1iZXIgPiAwXHJcblx0XHRcdGlmIChvLm11bHRpZGF0ZSAhPT0gdHJ1ZSl7XHJcblx0XHRcdFx0by5tdWx0aWRhdGUgPSBOdW1iZXIoby5tdWx0aWRhdGUpIHx8IGZhbHNlO1xyXG5cdFx0XHRcdGlmIChvLm11bHRpZGF0ZSAhPT0gZmFsc2UpXHJcblx0XHRcdFx0XHRvLm11bHRpZGF0ZSA9IE1hdGgubWF4KDAsIG8ubXVsdGlkYXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvLm11bHRpZGF0ZVNlcGFyYXRvciA9IFN0cmluZyhvLm11bHRpZGF0ZVNlcGFyYXRvcik7XHJcblxyXG5cdFx0XHRvLndlZWtTdGFydCAlPSA3O1xyXG5cdFx0XHRvLndlZWtFbmQgPSAoby53ZWVrU3RhcnQgKyA2KSAlIDc7XHJcblxyXG5cdFx0XHR2YXIgZm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoby5mb3JtYXQpO1xyXG5cdFx0XHRpZiAoby5zdGFydERhdGUgIT09IC1JbmZpbml0eSl7XHJcblx0XHRcdFx0aWYgKCEhby5zdGFydERhdGUpe1xyXG5cdFx0XHRcdFx0aWYgKG8uc3RhcnREYXRlIGluc3RhbmNlb2YgRGF0ZSlcclxuXHRcdFx0XHRcdFx0by5zdGFydERhdGUgPSB0aGlzLl9sb2NhbF90b191dGModGhpcy5femVyb190aW1lKG8uc3RhcnREYXRlKSk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdG8uc3RhcnREYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKG8uc3RhcnREYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UsIG8uYXNzdW1lTmVhcmJ5WWVhcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0by5zdGFydERhdGUgPSAtSW5maW5pdHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvLmVuZERhdGUgIT09IEluZmluaXR5KXtcclxuXHRcdFx0XHRpZiAoISFvLmVuZERhdGUpe1xyXG5cdFx0XHRcdFx0aWYgKG8uZW5kRGF0ZSBpbnN0YW5jZW9mIERhdGUpXHJcblx0XHRcdFx0XHRcdG8uZW5kRGF0ZSA9IHRoaXMuX2xvY2FsX3RvX3V0Yyh0aGlzLl96ZXJvX3RpbWUoby5lbmREYXRlKSk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdG8uZW5kRGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShvLmVuZERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSwgby5hc3N1bWVOZWFyYnlZZWFyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRvLmVuZERhdGUgPSBJbmZpbml0eTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG8uZGF5c09mV2Vla0Rpc2FibGVkID0gdGhpcy5fcmVzb2x2ZURheXNPZldlZWsoby5kYXlzT2ZXZWVrRGlzYWJsZWR8fFtdKTtcclxuXHRcdFx0by5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSB0aGlzLl9yZXNvbHZlRGF5c09mV2VlayhvLmRheXNPZldlZWtIaWdobGlnaHRlZHx8W10pO1xyXG5cclxuXHRcdFx0by5kYXRlc0Rpc2FibGVkID0gby5kYXRlc0Rpc2FibGVkfHxbXTtcclxuXHRcdFx0aWYgKCEkLmlzQXJyYXkoby5kYXRlc0Rpc2FibGVkKSkge1xyXG5cdFx0XHRcdG8uZGF0ZXNEaXNhYmxlZCA9IG8uZGF0ZXNEaXNhYmxlZC5zcGxpdCgnLCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG8uZGF0ZXNEaXNhYmxlZCA9ICQubWFwKG8uZGF0ZXNEaXNhYmxlZCwgZnVuY3Rpb24oZCl7XHJcblx0XHRcdFx0cmV0dXJuIERQR2xvYmFsLnBhcnNlRGF0ZShkLCBmb3JtYXQsIG8ubGFuZ3VhZ2UsIG8uYXNzdW1lTmVhcmJ5WWVhcik7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dmFyIHBsYyA9IFN0cmluZyhvLm9yaWVudGF0aW9uKS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrL2cpLFxyXG5cdFx0XHRcdF9wbGMgPSBvLm9yaWVudGF0aW9uLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdHBsYyA9ICQuZ3JlcChwbGMsIGZ1bmN0aW9uKHdvcmQpe1xyXG5cdFx0XHRcdHJldHVybiAvXmF1dG98bGVmdHxyaWdodHx0b3B8Ym90dG9tJC8udGVzdCh3b3JkKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdG8ub3JpZW50YXRpb24gPSB7eDogJ2F1dG8nLCB5OiAnYXV0byd9O1xyXG5cdFx0XHRpZiAoIV9wbGMgfHwgX3BsYyA9PT0gJ2F1dG8nKVxyXG5cdFx0XHRcdDsgLy8gbm8gYWN0aW9uXHJcblx0XHRcdGVsc2UgaWYgKHBsYy5sZW5ndGggPT09IDEpe1xyXG5cdFx0XHRcdHN3aXRjaCAocGxjWzBdKXtcclxuXHRcdFx0XHRcdGNhc2UgJ3RvcCc6XHJcblx0XHRcdFx0XHRjYXNlICdib3R0b20nOlxyXG5cdFx0XHRcdFx0XHRvLm9yaWVudGF0aW9uLnkgPSBwbGNbMF07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnbGVmdCc6XHJcblx0XHRcdFx0XHRjYXNlICdyaWdodCc6XHJcblx0XHRcdFx0XHRcdG8ub3JpZW50YXRpb24ueCA9IHBsY1swXTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdF9wbGMgPSAkLmdyZXAocGxjLCBmdW5jdGlvbih3b3JkKXtcclxuXHRcdFx0XHRcdHJldHVybiAvXmxlZnR8cmlnaHQkLy50ZXN0KHdvcmQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdG8ub3JpZW50YXRpb24ueCA9IF9wbGNbMF0gfHwgJ2F1dG8nO1xyXG5cclxuXHRcdFx0XHRfcGxjID0gJC5ncmVwKHBsYywgZnVuY3Rpb24od29yZCl7XHJcblx0XHRcdFx0XHRyZXR1cm4gL150b3B8Ym90dG9tJC8udGVzdCh3b3JkKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRvLm9yaWVudGF0aW9uLnkgPSBfcGxjWzBdIHx8ICdhdXRvJztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoby5kZWZhdWx0Vmlld0RhdGUgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBvLmRlZmF1bHRWaWV3RGF0ZSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRvLmRlZmF1bHRWaWV3RGF0ZSA9IERQR2xvYmFsLnBhcnNlRGF0ZShvLmRlZmF1bHRWaWV3RGF0ZSwgZm9ybWF0LCBvLmxhbmd1YWdlLCBvLmFzc3VtZU5lYXJieVllYXIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG8uZGVmYXVsdFZpZXdEYXRlKSB7XHJcblx0XHRcdFx0dmFyIHllYXIgPSBvLmRlZmF1bHRWaWV3RGF0ZS55ZWFyIHx8IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcclxuXHRcdFx0XHR2YXIgbW9udGggPSBvLmRlZmF1bHRWaWV3RGF0ZS5tb250aCB8fCAwO1xyXG5cdFx0XHRcdHZhciBkYXkgPSBvLmRlZmF1bHRWaWV3RGF0ZS5kYXkgfHwgMTtcclxuXHRcdFx0XHRvLmRlZmF1bHRWaWV3RGF0ZSA9IFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0by5kZWZhdWx0Vmlld0RhdGUgPSBVVENUb2RheSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0X2V2ZW50czogW10sXHJcblx0XHRfc2Vjb25kYXJ5RXZlbnRzOiBbXSxcclxuXHRcdF9hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcclxuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgY2gsIGV2OyBpIDwgZXZzLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHRlbCA9IGV2c1tpXVswXTtcclxuXHRcdFx0XHRpZiAoZXZzW2ldLmxlbmd0aCA9PT0gMil7XHJcblx0XHRcdFx0XHRjaCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZXZzW2ldLmxlbmd0aCA9PT0gMyl7XHJcblx0XHRcdFx0XHRjaCA9IGV2c1tpXVsxXTtcclxuXHRcdFx0XHRcdGV2ID0gZXZzW2ldWzJdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbC5vbihldiwgY2gpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0X3VuYXBwbHlFdmVudHM6IGZ1bmN0aW9uKGV2cyl7XHJcblx0XHRcdGZvciAodmFyIGk9MCwgZWwsIGV2LCBjaDsgaSA8IGV2cy5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0ZWwgPSBldnNbaV1bMF07XHJcblx0XHRcdFx0aWYgKGV2c1tpXS5sZW5ndGggPT09IDIpe1xyXG5cdFx0XHRcdFx0Y2ggPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGV2c1tpXS5sZW5ndGggPT09IDMpe1xyXG5cdFx0XHRcdFx0Y2ggPSBldnNbaV1bMV07XHJcblx0XHRcdFx0XHRldiA9IGV2c1tpXVsyXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWwub2ZmKGV2LCBjaCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRfYnVpbGRFdmVudHM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB7XHJcbiAgICAgICAgICAgICAgICBrZXl1cDogJC5wcm94eShmdW5jdGlvbihlKXtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGUua2V5Q29kZSwgWzI3LCAzNywgMzksIDM4LCA0MCwgMzIsIDEzLCA5XSkgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICBrZXlkb3duOiAkLnByb3h5KHRoaXMua2V5ZG93biwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICBwYXN0ZTogJC5wcm94eSh0aGlzLnBhc3RlLCB0aGlzKVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuby5zaG93T25Gb2N1cyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLmZvY3VzID0gJC5wcm94eSh0aGlzLnNob3csIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0KSB7IC8vIHNpbmdsZSBpbnB1dFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmVsZW1lbnQsIGV2ZW50c11cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29tcG9uZW50OiBpbnB1dCArIGJ1dHRvblxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmlucHV0RmllbGQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHJlYWRvbmx5LCBhbGxvdyBrZXlib2FyZCBuYXZcclxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5pbnB1dEZpZWxkLCBldmVudHNdLFxyXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljazogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5fZXZlbnRzID0gW1xyXG5cdFx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xyXG5cdFx0XHRcdFx0XHRjbGljazogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxyXG5cdFx0XHRcdFx0XHRrZXlkb3duOiAkLnByb3h5KHRoaXMua2V5ZG93biwgdGhpcylcclxuXHRcdFx0XHRcdH1dXHJcblx0XHRcdFx0XTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9ldmVudHMucHVzaChcclxuXHRcdFx0XHQvLyBDb21wb25lbnQ6IGxpc3RlbiBmb3IgYmx1ciBvbiBlbGVtZW50IGRlc2NlbmRhbnRzXHJcblx0XHRcdFx0W3RoaXMuZWxlbWVudCwgJyonLCB7XHJcblx0XHRcdFx0XHRibHVyOiAkLnByb3h5KGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9mb2N1c2VkX2Zyb20gPSBlLnRhcmdldDtcclxuXHRcdFx0XHRcdH0sIHRoaXMpXHJcblx0XHRcdFx0fV0sXHJcblx0XHRcdFx0Ly8gSW5wdXQ6IGxpc3RlbiBmb3IgYmx1ciBvbiBlbGVtZW50XHJcblx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xyXG5cdFx0XHRcdFx0Ymx1cjogJC5wcm94eShmdW5jdGlvbihlKXtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZm9jdXNlZF9mcm9tID0gZS50YXJnZXQ7XHJcblx0XHRcdFx0XHR9LCB0aGlzKVxyXG5cdFx0XHRcdH1dXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vLmltbWVkaWF0ZVVwZGF0ZXMpIHtcclxuXHRcdFx0XHQvLyBUcmlnZ2VyIGlucHV0IHVwZGF0ZXMgaW1tZWRpYXRlbHkgb24gY2hhbmdlZCB5ZWFyL21vbnRoXHJcblx0XHRcdFx0dGhpcy5fZXZlbnRzLnB1c2goW3RoaXMuZWxlbWVudCwge1xyXG5cdFx0XHRcdFx0J2NoYW5nZVllYXIgY2hhbmdlTW9udGgnOiAkLnByb3h5KGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZShlLmRhdGUpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcylcclxuXHRcdFx0XHR9XSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3NlY29uZGFyeUV2ZW50cyA9IFtcclxuXHRcdFx0XHRbdGhpcy5waWNrZXIsIHtcclxuXHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMuY2xpY2ssIHRoaXMpXHJcblx0XHRcdFx0fV0sXHJcblx0XHRcdFx0W3RoaXMucGlja2VyLCAnLnByZXYsIC5uZXh0Jywge1xyXG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5uYXZBcnJvd3NDbGljaywgdGhpcylcclxuXHRcdFx0XHR9XSxcclxuXHRcdFx0XHRbdGhpcy5waWNrZXIsICcuZGF5Om5vdCguZGlzYWJsZWQpJywge1xyXG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5kYXlDZWxsQ2xpY2ssIHRoaXMpXHJcblx0XHRcdFx0fV0sXHJcblx0XHRcdFx0WyQod2luZG93KSwge1xyXG5cdFx0XHRcdFx0cmVzaXplOiAkLnByb3h5KHRoaXMucGxhY2UsIHRoaXMpXHJcblx0XHRcdFx0fV0sXHJcblx0XHRcdFx0WyQoZG9jdW1lbnQpLCB7XHJcblx0XHRcdFx0XHQnbW91c2Vkb3duIHRvdWNoc3RhcnQnOiAkLnByb3h5KGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdFx0XHQvLyBDbGlja2VkIG91dHNpZGUgdGhlIGRhdGVwaWNrZXIsIGhpZGUgaXRcclxuXHRcdFx0XHRcdFx0aWYgKCEoXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmlzKGUudGFyZ2V0KSB8fFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKGUudGFyZ2V0KS5sZW5ndGggfHxcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5pcyhlLnRhcmdldCkgfHxcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKGUudGFyZ2V0KS5sZW5ndGggfHxcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmlzSW5saW5lXHJcblx0XHRcdFx0XHRcdCkpe1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKVxyXG5cdFx0XHRcdH1dXHJcblx0XHRcdF07XHJcblx0XHR9LFxyXG5cdFx0X2F0dGFjaEV2ZW50czogZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy5fZGV0YWNoRXZlbnRzKCk7XHJcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX2V2ZW50cyk7XHJcblx0XHR9LFxyXG5cdFx0X2RldGFjaEV2ZW50czogZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9ldmVudHMpO1xyXG5cdFx0fSxcclxuXHRcdF9hdHRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHRoaXMuX2RldGFjaFNlY29uZGFyeUV2ZW50cygpO1xyXG5cdFx0XHR0aGlzLl9hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xyXG5cdFx0fSxcclxuXHRcdF9kZXRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHRoaXMuX3VuYXBwbHlFdmVudHModGhpcy5fc2Vjb25kYXJ5RXZlbnRzKTtcclxuXHRcdH0sXHJcblx0XHRfdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGFsdGRhdGUpe1xyXG5cdFx0XHR2YXIgZGF0ZSA9IGFsdGRhdGUgfHwgdGhpcy5kYXRlcy5nZXQoLTEpLFxyXG5cdFx0XHRcdGxvY2FsX2RhdGUgPSB0aGlzLl91dGNfdG9fbG9jYWwoZGF0ZSk7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlcih7XHJcblx0XHRcdFx0dHlwZTogZXZlbnQsXHJcblx0XHRcdFx0ZGF0ZTogbG9jYWxfZGF0ZSxcclxuXHRcdFx0XHR2aWV3TW9kZTogdGhpcy52aWV3TW9kZSxcclxuXHRcdFx0XHRkYXRlczogJC5tYXAodGhpcy5kYXRlcywgdGhpcy5fdXRjX3RvX2xvY2FsKSxcclxuXHRcdFx0XHRmb3JtYXQ6ICQucHJveHkoZnVuY3Rpb24oaXgsIGZvcm1hdCl7XHJcblx0XHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCl7XHJcblx0XHRcdFx0XHRcdGl4ID0gdGhpcy5kYXRlcy5sZW5ndGggLSAxO1xyXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSB0aGlzLm8uZm9ybWF0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgaXggPT09ICdzdHJpbmcnKXtcclxuXHRcdFx0XHRcdFx0Zm9ybWF0ID0gaXg7XHJcblx0XHRcdFx0XHRcdGl4ID0gdGhpcy5kYXRlcy5sZW5ndGggLSAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuby5mb3JtYXQ7XHJcblx0XHRcdFx0XHR2YXIgZGF0ZSA9IHRoaXMuZGF0ZXMuZ2V0KGl4KTtcclxuXHRcdFx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlKTtcclxuXHRcdFx0XHR9LCB0aGlzKVxyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0c2hvdzogZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYgKHRoaXMuaW5wdXRGaWVsZC5wcm9wKCdkaXNhYmxlZCcpIHx8ICh0aGlzLmlucHV0RmllbGQucHJvcCgncmVhZG9ubHknKSAmJiB0aGlzLm8uZW5hYmxlT25SZWFkb25seSA9PT0gZmFsc2UpKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0aWYgKCF0aGlzLmlzSW5saW5lKVxyXG5cdFx0XHRcdHRoaXMucGlja2VyLmFwcGVuZFRvKHRoaXMuby5jb250YWluZXIpO1xyXG5cdFx0XHR0aGlzLnBsYWNlKCk7XHJcblx0XHRcdHRoaXMucGlja2VyLnNob3coKTtcclxuXHRcdFx0dGhpcy5fYXR0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XHJcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ3Nob3cnKTtcclxuXHRcdFx0aWYgKCh3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHwgJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQpICYmIHRoaXMuby5kaXNhYmxlVG91Y2hLZXlib2FyZCkge1xyXG5cdFx0XHRcdCQodGhpcy5lbGVtZW50KS5ibHVyKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdGhpZGU6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdGlmICh0aGlzLmlzSW5saW5lIHx8ICF0aGlzLnBpY2tlci5pcygnOnZpc2libGUnKSlcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xyXG5cdFx0XHR0aGlzLnBpY2tlci5oaWRlKCkuZGV0YWNoKCk7XHJcblx0XHRcdHRoaXMuX2RldGFjaFNlY29uZGFyeUV2ZW50cygpO1xyXG5cdFx0XHR0aGlzLnNldFZpZXdNb2RlKHRoaXMuby5zdGFydFZpZXcpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuby5mb3JjZVBhcnNlICYmIHRoaXMuaW5wdXRGaWVsZC52YWwoKSlcclxuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XHJcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ2hpZGUnKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0XHR0aGlzLl9kZXRhY2hFdmVudHMoKTtcclxuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XHJcblx0XHRcdHRoaXMucGlja2VyLnJlbW92ZSgpO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlcGlja2VyO1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNJbnB1dCl7XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0cGFzdGU6IGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHR2YXIgZGF0ZVN0cmluZztcclxuXHRcdFx0aWYgKGUub3JpZ2luYWxFdmVudC5jbGlwYm9hcmREYXRhICYmIGUub3JpZ2luYWxFdmVudC5jbGlwYm9hcmREYXRhLnR5cGVzXHJcblx0XHRcdFx0JiYgJC5pbkFycmF5KCd0ZXh0L3BsYWluJywgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMpICE9PSAtMSkge1xyXG5cdFx0XHRcdGRhdGVTdHJpbmcgPSBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XHJcblx0XHRcdH0gZWxzZSBpZiAod2luZG93LmNsaXBib2FyZERhdGEpIHtcclxuXHRcdFx0XHRkYXRlU3RyaW5nID0gd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNldERhdGUoZGF0ZVN0cmluZyk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X3V0Y190b19sb2NhbDogZnVuY3Rpb24odXRjKXtcclxuXHRcdFx0aWYgKCF1dGMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRjO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbG9jYWwgPSBuZXcgRGF0ZSh1dGMuZ2V0VGltZSgpICsgKHV0Yy5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApKTtcclxuXHJcblx0XHRcdGlmIChsb2NhbC5nZXRUaW1lem9uZU9mZnNldCgpICE9PSB1dGMuZ2V0VGltZXpvbmVPZmZzZXQoKSkge1xyXG5cdFx0XHRcdGxvY2FsID0gbmV3IERhdGUodXRjLmdldFRpbWUoKSArIChsb2NhbC5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGxvY2FsO1xyXG5cdFx0fSxcclxuXHRcdF9sb2NhbF90b191dGM6IGZ1bmN0aW9uKGxvY2FsKXtcclxuXHRcdFx0cmV0dXJuIGxvY2FsICYmIG5ldyBEYXRlKGxvY2FsLmdldFRpbWUoKSAtIChsb2NhbC5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwKSk7XHJcblx0XHR9LFxyXG5cdFx0X3plcm9fdGltZTogZnVuY3Rpb24obG9jYWwpe1xyXG5cdFx0XHRyZXR1cm4gbG9jYWwgJiYgbmV3IERhdGUobG9jYWwuZ2V0RnVsbFllYXIoKSwgbG9jYWwuZ2V0TW9udGgoKSwgbG9jYWwuZ2V0RGF0ZSgpKTtcclxuXHRcdH0sXHJcblx0XHRfemVyb191dGNfdGltZTogZnVuY3Rpb24odXRjKXtcclxuXHRcdFx0cmV0dXJuIHV0YyAmJiBVVENEYXRlKHV0Yy5nZXRVVENGdWxsWWVhcigpLCB1dGMuZ2V0VVRDTW9udGgoKSwgdXRjLmdldFVUQ0RhdGUoKSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGdldERhdGVzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRyZXR1cm4gJC5tYXAodGhpcy5kYXRlcywgdGhpcy5fdXRjX3RvX2xvY2FsKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0VVRDRGF0ZXM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHJldHVybiAkLm1hcCh0aGlzLmRhdGVzLCBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoZCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRnZXREYXRlOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fdXRjX3RvX2xvY2FsKHRoaXMuZ2V0VVRDRGF0ZSgpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0VVRDRGF0ZTogZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIHNlbGVjdGVkX2RhdGUgPSB0aGlzLmRhdGVzLmdldCgtMSk7XHJcblx0XHRcdGlmIChzZWxlY3RlZF9kYXRlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoc2VsZWN0ZWRfZGF0ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xlYXJEYXRlczogZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy5pbnB1dEZpZWxkLnZhbCgnJyk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm8uYXV0b2Nsb3NlKSB7XHJcblx0XHRcdFx0dGhpcy5oaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RGF0ZXM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBhcmdzID0gJC5pc0FycmF5KGFyZ3VtZW50c1swXSkgPyBhcmd1bWVudHNbMF0gOiBhcmd1bWVudHM7XHJcblx0XHRcdHRoaXMudXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XHJcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFVUQ0RhdGVzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgYXJncyA9ICQuaXNBcnJheShhcmd1bWVudHNbMF0pID8gYXJndW1lbnRzWzBdIDogYXJndW1lbnRzO1xyXG5cdFx0XHR0aGlzLnNldERhdGVzLmFwcGx5KHRoaXMsICQubWFwKGFyZ3MsIHRoaXMuX3V0Y190b19sb2NhbCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RGF0ZTogYWxpYXMoJ3NldERhdGVzJyksXHJcblx0XHRzZXRVVENEYXRlOiBhbGlhcygnc2V0VVRDRGF0ZXMnKSxcclxuXHRcdHJlbW92ZTogYWxpYXMoJ2Rlc3Ryb3knLCAnTWV0aG9kIGByZW1vdmVgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDIuMC4gVXNlIGBkZXN0cm95YCBpbnN0ZWFkJyksXHJcblxyXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBmb3JtYXR0ZWQgPSB0aGlzLmdldEZvcm1hdHRlZERhdGUoKTtcclxuXHRcdFx0dGhpcy5pbnB1dEZpZWxkLnZhbChmb3JtYXR0ZWQpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Rm9ybWF0dGVkRGF0ZTogZnVuY3Rpb24oZm9ybWF0KXtcclxuXHRcdFx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdGZvcm1hdCA9IHRoaXMuby5mb3JtYXQ7XHJcblxyXG5cdFx0XHR2YXIgbGFuZyA9IHRoaXMuby5sYW5ndWFnZTtcclxuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuZGF0ZXMsIGZ1bmN0aW9uKGQpe1xyXG5cdFx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKGQsIGZvcm1hdCwgbGFuZyk7XHJcblx0XHRcdH0pLmpvaW4odGhpcy5vLm11bHRpZGF0ZVNlcGFyYXRvcik7XHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFN0YXJ0RGF0ZTogZnVuY3Rpb24oKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuby5zdGFydERhdGU7XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFN0YXJ0RGF0ZTogZnVuY3Rpb24oc3RhcnREYXRlKXtcclxuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtzdGFydERhdGU6IHN0YXJ0RGF0ZX0pO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0RW5kRGF0ZTogZnVuY3Rpb24oKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMuby5lbmREYXRlO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRFbmREYXRlOiBmdW5jdGlvbihlbmREYXRlKXtcclxuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtlbmREYXRlOiBlbmREYXRlfSk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlTmF2QXJyb3dzKCk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREYXlzT2ZXZWVrRGlzYWJsZWQ6IGZ1bmN0aW9uKGRheXNPZldlZWtEaXNhYmxlZCl7XHJcblx0XHRcdHRoaXMuX3Byb2Nlc3Nfb3B0aW9ucyh7ZGF5c09mV2Vla0Rpc2FibGVkOiBkYXlzT2ZXZWVrRGlzYWJsZWR9KTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldERheXNPZldlZWtIaWdobGlnaHRlZDogZnVuY3Rpb24oZGF5c09mV2Vla0hpZ2hsaWdodGVkKXtcclxuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ6IGRheXNPZldlZWtIaWdobGlnaHRlZH0pO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RGF0ZXNEaXNhYmxlZDogZnVuY3Rpb24oZGF0ZXNEaXNhYmxlZCl7XHJcblx0XHRcdHRoaXMuX3Byb2Nlc3Nfb3B0aW9ucyh7ZGF0ZXNEaXNhYmxlZDogZGF0ZXNEaXNhYmxlZH0pO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0cGxhY2U6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdGlmICh0aGlzLmlzSW5saW5lKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR2YXIgY2FsZW5kYXJXaWR0aCA9IHRoaXMucGlja2VyLm91dGVyV2lkdGgoKSxcclxuXHRcdFx0XHRjYWxlbmRhckhlaWdodCA9IHRoaXMucGlja2VyLm91dGVySGVpZ2h0KCksXHJcblx0XHRcdFx0dmlzdWFsUGFkZGluZyA9IDEwLFxyXG5cdFx0XHRcdGNvbnRhaW5lciA9ICQodGhpcy5vLmNvbnRhaW5lciksXHJcblx0XHRcdFx0d2luZG93V2lkdGggPSBjb250YWluZXIud2lkdGgoKSxcclxuXHRcdFx0XHRzY3JvbGxUb3AgPSB0aGlzLm8uY29udGFpbmVyID09PSAnYm9keScgPyAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA6IGNvbnRhaW5lci5zY3JvbGxUb3AoKSxcclxuXHRcdFx0XHRhcHBlbmRPZmZzZXQgPSBjb250YWluZXIub2Zmc2V0KCk7XHJcblxyXG5cdFx0XHR2YXIgcGFyZW50c1ppbmRleCA9IFswXTtcclxuXHRcdFx0dGhpcy5lbGVtZW50LnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0dmFyIGl0ZW1aSW5kZXggPSAkKHRoaXMpLmNzcygnei1pbmRleCcpO1xyXG5cdFx0XHRcdGlmIChpdGVtWkluZGV4ICE9PSAnYXV0bycgJiYgTnVtYmVyKGl0ZW1aSW5kZXgpICE9PSAwKSBwYXJlbnRzWmluZGV4LnB1c2goTnVtYmVyKGl0ZW1aSW5kZXgpKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHZhciB6SW5kZXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBwYXJlbnRzWmluZGV4KSArIHRoaXMuby56SW5kZXhPZmZzZXQ7XHJcblx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmNvbXBvbmVudCA/IHRoaXMuY29tcG9uZW50LnBhcmVudCgpLm9mZnNldCgpIDogdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xyXG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodChmYWxzZSk7XHJcblx0XHRcdHZhciB3aWR0aCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJXaWR0aCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKTtcclxuXHRcdFx0dmFyIGxlZnQgPSBvZmZzZXQubGVmdCAtIGFwcGVuZE9mZnNldC5sZWZ0O1xyXG5cdFx0XHR2YXIgdG9wID0gb2Zmc2V0LnRvcCAtIGFwcGVuZE9mZnNldC50b3A7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vLmNvbnRhaW5lciAhPT0gJ2JvZHknKSB7XHJcblx0XHRcdFx0dG9wICs9IHNjcm9sbFRvcDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5waWNrZXIucmVtb3ZlQ2xhc3MoXHJcblx0XHRcdFx0J2RhdGVwaWNrZXItb3JpZW50LXRvcCBkYXRlcGlja2VyLW9yaWVudC1ib3R0b20gJytcclxuXHRcdFx0XHQnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQgZGF0ZXBpY2tlci1vcmllbnQtbGVmdCdcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm8ub3JpZW50YXRpb24ueCAhPT0gJ2F1dG8nKXtcclxuXHRcdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1vcmllbnQtJyArIHRoaXMuby5vcmllbnRhdGlvbi54KTtcclxuXHRcdFx0XHRpZiAodGhpcy5vLm9yaWVudGF0aW9uLnggPT09ICdyaWdodCcpXHJcblx0XHRcdFx0XHRsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSB3aWR0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBhdXRvIHggb3JpZW50YXRpb24gaXMgYmVzdC1wbGFjZW1lbnQ6IGlmIGl0IGNyb3NzZXMgYSB3aW5kb3dcclxuXHRcdFx0Ly8gZWRnZSwgZnVkZ2UgaXQgc2lkZXdheXNcclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYgKG9mZnNldC5sZWZ0IDwgMCkge1xyXG5cdFx0XHRcdFx0Ly8gY29tcG9uZW50IGlzIG91dHNpZGUgdGhlIHdpbmRvdyBvbiB0aGUgbGVmdCBzaWRlLiBNb3ZlIGl0IGludG8gdmlzaWJsZSByYW5nZVxyXG5cdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LWxlZnQnKTtcclxuXHRcdFx0XHRcdGxlZnQgLT0gb2Zmc2V0LmxlZnQgLSB2aXN1YWxQYWRkaW5nO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobGVmdCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3dXaWR0aCkge1xyXG5cdFx0XHRcdFx0Ly8gdGhlIGNhbGVuZGFyIHBhc3NlcyB0aGUgd2lkb3cgcmlnaHQgZWRnZS4gQWxpZ24gaXQgdG8gY29tcG9uZW50IHJpZ2h0IHNpZGVcclxuXHRcdFx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLW9yaWVudC1yaWdodCcpO1xyXG5cdFx0XHRcdFx0bGVmdCArPSB3aWR0aCAtIGNhbGVuZGFyV2lkdGg7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLm8ucnRsKSB7XHJcblx0XHRcdFx0XHRcdC8vIERlZmF1bHQgdG8gcmlnaHRcclxuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LXJpZ2h0Jyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHRvIGxlZnRcclxuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LWxlZnQnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGF1dG8geSBvcmllbnRhdGlvbiBpcyBiZXN0LXNpdHVhdGlvbjogdG9wIG9yIGJvdHRvbSwgbm8gZnVkZ2luZyxcclxuXHRcdFx0Ly8gZGVjaXNpb24gYmFzZWQgb24gd2hpY2ggc2hvd3MgbW9yZSBvZiB0aGUgY2FsZW5kYXJcclxuXHRcdFx0dmFyIHlvcmllbnQgPSB0aGlzLm8ub3JpZW50YXRpb24ueSxcclxuXHRcdFx0XHR0b3Bfb3ZlcmZsb3c7XHJcblx0XHRcdGlmICh5b3JpZW50ID09PSAnYXV0bycpe1xyXG5cdFx0XHRcdHRvcF9vdmVyZmxvdyA9IC1zY3JvbGxUb3AgKyB0b3AgLSBjYWxlbmRhckhlaWdodDtcclxuXHRcdFx0XHR5b3JpZW50ID0gdG9wX292ZXJmbG93IDwgMCA/ICdib3R0b20nIDogJ3RvcCc7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLW9yaWVudC0nICsgeW9yaWVudCk7XHJcblx0XHRcdGlmICh5b3JpZW50ID09PSAndG9wJylcclxuXHRcdFx0XHR0b3AgLT0gY2FsZW5kYXJIZWlnaHQgKyBwYXJzZUludCh0aGlzLnBpY2tlci5jc3MoJ3BhZGRpbmctdG9wJykpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dG9wICs9IGhlaWdodDtcclxuXHJcblx0XHRcdGlmICh0aGlzLm8ucnRsKSB7XHJcblx0XHRcdFx0dmFyIHJpZ2h0ID0gd2luZG93V2lkdGggLSAobGVmdCArIHdpZHRoKTtcclxuXHRcdFx0XHR0aGlzLnBpY2tlci5jc3Moe1xyXG5cdFx0XHRcdFx0dG9wOiB0b3AsXHJcblx0XHRcdFx0XHRyaWdodDogcmlnaHQsXHJcblx0XHRcdFx0XHR6SW5kZXg6IHpJbmRleFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMucGlja2VyLmNzcyh7XHJcblx0XHRcdFx0XHR0b3A6IHRvcCxcclxuXHRcdFx0XHRcdGxlZnQ6IGxlZnQsXHJcblx0XHRcdFx0XHR6SW5kZXg6IHpJbmRleFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfYWxsb3dfdXBkYXRlOiB0cnVlLFxyXG5cdFx0dXBkYXRlOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSlcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdHZhciBvbGREYXRlcyA9IHRoaXMuZGF0ZXMuY29weSgpLFxyXG5cdFx0XHRcdGRhdGVzID0gW10sXHJcblx0XHRcdFx0ZnJvbUFyZ3MgPSBmYWxzZTtcclxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpe1xyXG5cdFx0XHRcdCQuZWFjaChhcmd1bWVudHMsICQucHJveHkoZnVuY3Rpb24oaSwgZGF0ZSl7XHJcblx0XHRcdFx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpXHJcblx0XHRcdFx0XHRcdGRhdGUgPSB0aGlzLl9sb2NhbF90b191dGMoZGF0ZSk7XHJcblx0XHRcdFx0XHRkYXRlcy5wdXNoKGRhdGUpO1xyXG5cdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdFx0XHRmcm9tQXJncyA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGF0ZXMgPSB0aGlzLmlzSW5wdXRcclxuXHRcdFx0XHRcdFx0PyB0aGlzLmVsZW1lbnQudmFsKClcclxuXHRcdFx0XHRcdFx0OiB0aGlzLmVsZW1lbnQuZGF0YSgnZGF0ZScpIHx8IHRoaXMuaW5wdXRGaWVsZC52YWwoKTtcclxuXHRcdFx0XHRpZiAoZGF0ZXMgJiYgdGhpcy5vLm11bHRpZGF0ZSlcclxuXHRcdFx0XHRcdGRhdGVzID0gZGF0ZXMuc3BsaXQodGhpcy5vLm11bHRpZGF0ZVNlcGFyYXRvcik7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0ZGF0ZXMgPSBbZGF0ZXNdO1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRhdGVzID0gJC5tYXAoZGF0ZXMsICQucHJveHkoZnVuY3Rpb24oZGF0ZSl7XHJcblx0XHRcdFx0cmV0dXJuIERQR2xvYmFsLnBhcnNlRGF0ZShkYXRlLCB0aGlzLm8uZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UsIHRoaXMuby5hc3N1bWVOZWFyYnlZZWFyKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRkYXRlcyA9ICQuZ3JlcChkYXRlcywgJC5wcm94eShmdW5jdGlvbihkYXRlKXtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0IXRoaXMuZGF0ZVdpdGhpblJhbmdlKGRhdGUpIHx8XHJcblx0XHRcdFx0XHQhZGF0ZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sIHRoaXMpLCB0cnVlKTtcclxuXHRcdFx0dGhpcy5kYXRlcy5yZXBsYWNlKGRhdGVzKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm8udXBkYXRlVmlld0RhdGUpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRlcy5sZW5ndGgpXHJcblx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5kYXRlcy5nZXQoLTEpKTtcclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnZpZXdEYXRlIDwgdGhpcy5vLnN0YXJ0RGF0ZSlcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnZpZXdEYXRlID4gdGhpcy5vLmVuZERhdGUpXHJcblx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5vLmVuZERhdGUpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm8uZGVmYXVsdFZpZXdEYXRlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZnJvbUFyZ3Mpe1xyXG5cdFx0XHRcdC8vIHNldHRpbmcgZGF0ZSBieSBjbGlja2luZ1xyXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuY2hhbmdlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAodGhpcy5kYXRlcy5sZW5ndGgpe1xyXG5cdFx0XHRcdC8vIHNldHRpbmcgZGF0ZSBieSB0eXBpbmdcclxuXHRcdFx0XHRpZiAoU3RyaW5nKG9sZERhdGVzKSAhPT0gU3RyaW5nKHRoaXMuZGF0ZXMpICYmIGZyb21BcmdzKSB7XHJcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XHJcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuY2hhbmdlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghdGhpcy5kYXRlcy5sZW5ndGggJiYgb2xkRGF0ZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2xlYXJEYXRlJyk7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50LmNoYW5nZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdGZpbGxEb3c6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmICh0aGlzLm8uc2hvd1dlZWtEYXlzKSB7XHJcblx0XHRcdHZhciBkb3dDbnQgPSB0aGlzLm8ud2Vla1N0YXJ0LFxyXG5cdFx0XHRcdGh0bWwgPSAnPHRyPic7XHJcblx0XHRcdGlmICh0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XHJcblx0XHRcdFx0aHRtbCArPSAnPHRoIGNsYXNzPVwiY3dcIj4mIzE2MDs8L3RoPic7XHJcblx0XHRcdH1cclxuXHRcdFx0d2hpbGUgKGRvd0NudCA8IHRoaXMuby53ZWVrU3RhcnQgKyA3KXtcclxuXHRcdFx0XHRodG1sICs9ICc8dGggY2xhc3M9XCJkb3cnO1xyXG4gICAgICAgIGlmICgkLmluQXJyYXkoZG93Q250LCB0aGlzLm8uZGF5c09mV2Vla0Rpc2FibGVkKSAhPT0gLTEpXHJcbiAgICAgICAgICBodG1sICs9ICcgZGlzYWJsZWQnO1xyXG4gICAgICAgIGh0bWwgKz0gJ1wiPicrZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5kYXlzTWluWyhkb3dDbnQrKyklN10rJzwvdGg+JztcclxuXHRcdFx0fVxyXG5cdFx0XHRodG1sICs9ICc8L3RyPic7XHJcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XHJcbiAgICAgIH1cclxuXHRcdH0sXHJcblxyXG5cdFx0ZmlsbE1vbnRoczogZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIGxvY2FsRGF0ZSA9IHRoaXMuX3V0Y190b19sb2NhbCh0aGlzLnZpZXdEYXRlKTtcclxuXHRcdFx0dmFyIGh0bWwgPSAnJztcclxuXHRcdFx0dmFyIGZvY3VzZWQ7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKyl7XHJcblx0XHRcdFx0Zm9jdXNlZCA9IGxvY2FsRGF0ZSAmJiBsb2NhbERhdGUuZ2V0TW9udGgoKSA9PT0gaSA/ICcgZm9jdXNlZCcgOiAnJztcclxuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cIm1vbnRoJyArIGZvY3VzZWQgKyAnXCI+JyArIGRhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzU2hvcnRbaV0gKyAnPC9zcGFuPic7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzIHRkJykuaHRtbChodG1sKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0UmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKXtcclxuXHRcdFx0aWYgKCFyYW5nZSB8fCAhcmFuZ2UubGVuZ3RoKVxyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLnJhbmdlO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQubWFwKHJhbmdlLCBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHRcdHJldHVybiBkLnZhbHVlT2YoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0dGhpcy5maWxsKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGdldENsYXNzTmFtZXM6IGZ1bmN0aW9uKGRhdGUpe1xyXG5cdFx0XHR2YXIgY2xzID0gW10sXHJcblx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcclxuXHRcdFx0XHRtb250aCA9IHRoaXMudmlld0RhdGUuZ2V0VVRDTW9udGgoKSxcclxuXHRcdFx0XHR0b2RheSA9IFVUQ1RvZGF5KCk7XHJcblx0XHRcdGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPCB5ZWFyIHx8IChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZGF0ZS5nZXRVVENNb250aCgpIDwgbW9udGgpKXtcclxuXHRcdFx0XHRjbHMucHVzaCgnb2xkJyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoZGF0ZS5nZXRVVENGdWxsWWVhcigpID4geWVhciB8fCAoZGF0ZS5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA+IG1vbnRoKSl7XHJcblx0XHRcdFx0Y2xzLnB1c2goJ25ldycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmZvY3VzRGF0ZSAmJiBkYXRlLnZhbHVlT2YoKSA9PT0gdGhpcy5mb2N1c0RhdGUudmFsdWVPZigpKVxyXG5cdFx0XHRcdGNscy5wdXNoKCdmb2N1c2VkJyk7XHJcblx0XHRcdC8vIENvbXBhcmUgaW50ZXJuYWwgVVRDIGRhdGUgd2l0aCBVVEMgdG9kYXksIG5vdCBsb2NhbCB0b2RheVxyXG5cdFx0XHRpZiAodGhpcy5vLnRvZGF5SGlnaGxpZ2h0ICYmIGlzVVRDRXF1YWxzKGRhdGUsIHRvZGF5KSkge1xyXG5cdFx0XHRcdGNscy5wdXNoKCd0b2RheScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmRhdGVzLmNvbnRhaW5zKGRhdGUpICE9PSAtMSlcclxuXHRcdFx0XHRjbHMucHVzaCgnYWN0aXZlJyk7XHJcblx0XHRcdGlmICghdGhpcy5kYXRlV2l0aGluUmFuZ2UoZGF0ZSkpe1xyXG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLmRhdGVJc0Rpc2FibGVkKGRhdGUpKXtcclxuXHRcdFx0XHRjbHMucHVzaCgnZGlzYWJsZWQnLCAnZGlzYWJsZWQtZGF0ZScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICgkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtIaWdobGlnaHRlZCkgIT09IC0xKXtcclxuXHRcdFx0XHRjbHMucHVzaCgnaGlnaGxpZ2h0ZWQnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMucmFuZ2Upe1xyXG5cdFx0XHRcdGlmIChkYXRlID4gdGhpcy5yYW5nZVswXSAmJiBkYXRlIDwgdGhpcy5yYW5nZVt0aGlzLnJhbmdlLmxlbmd0aC0xXSl7XHJcblx0XHRcdFx0XHRjbHMucHVzaCgncmFuZ2UnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCQuaW5BcnJheShkYXRlLnZhbHVlT2YoKSwgdGhpcy5yYW5nZSkgIT09IC0xKXtcclxuXHRcdFx0XHRcdGNscy5wdXNoKCdzZWxlY3RlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoZGF0ZS52YWx1ZU9mKCkgPT09IHRoaXMucmFuZ2VbMF0pe1xyXG4gICAgICAgICAgY2xzLnB1c2goJ3JhbmdlLXN0YXJ0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRlLnZhbHVlT2YoKSA9PT0gdGhpcy5yYW5nZVt0aGlzLnJhbmdlLmxlbmd0aC0xXSl7XHJcbiAgICAgICAgICBjbHMucHVzaCgncmFuZ2UtZW5kJyk7XHJcbiAgICAgICAgfVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBjbHM7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9maWxsX3llYXJzVmlldzogZnVuY3Rpb24oc2VsZWN0b3IsIGNzc0NsYXNzLCBmYWN0b3IsIHllYXIsIHN0YXJ0WWVhciwgZW5kWWVhciwgYmVmb3JlRm4pe1xyXG5cdFx0XHR2YXIgaHRtbCA9ICcnO1xyXG5cdFx0XHR2YXIgc3RlcCA9IGZhY3RvciAvIDEwO1xyXG5cdFx0XHR2YXIgdmlldyA9IHRoaXMucGlja2VyLmZpbmQoc2VsZWN0b3IpO1xyXG5cdFx0XHR2YXIgc3RhcnRWYWwgPSBNYXRoLmZsb29yKHllYXIgLyBmYWN0b3IpICogZmFjdG9yO1xyXG5cdFx0XHR2YXIgZW5kVmFsID0gc3RhcnRWYWwgKyBzdGVwICogOTtcclxuXHRcdFx0dmFyIGZvY3VzZWRWYWwgPSBNYXRoLmZsb29yKHRoaXMudmlld0RhdGUuZ2V0RnVsbFllYXIoKSAvIHN0ZXApICogc3RlcDtcclxuXHRcdFx0dmFyIHNlbGVjdGVkID0gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7XHJcblx0XHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoZC5nZXRVVENGdWxsWWVhcigpIC8gc3RlcCkgKiBzdGVwO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHZhciBjbGFzc2VzLCB0b29sdGlwLCBiZWZvcmU7XHJcblx0XHRcdGZvciAodmFyIGN1cnJWYWwgPSBzdGFydFZhbCAtIHN0ZXA7IGN1cnJWYWwgPD0gZW5kVmFsICsgc3RlcDsgY3VyclZhbCArPSBzdGVwKSB7XHJcblx0XHRcdFx0Y2xhc3NlcyA9IFtjc3NDbGFzc107XHJcblx0XHRcdFx0dG9vbHRpcCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGlmIChjdXJyVmFsID09PSBzdGFydFZhbCAtIHN0ZXApIHtcclxuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnb2xkJyk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyVmFsID09PSBlbmRWYWwgKyBzdGVwKSB7XHJcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goJ25ldycpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoJC5pbkFycmF5KGN1cnJWYWwsIHNlbGVjdGVkKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnYWN0aXZlJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChjdXJyVmFsIDwgc3RhcnRZZWFyIHx8IGN1cnJWYWwgPiBlbmRZZWFyKSB7XHJcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goJ2Rpc2FibGVkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChjdXJyVmFsID09PSBmb2N1c2VkVmFsKSB7XHJcblx0XHRcdFx0ICBjbGFzc2VzLnB1c2goJ2ZvY3VzZWQnKTtcclxuICAgICAgICB9XHJcblxyXG5cdFx0XHRcdGlmIChiZWZvcmVGbiAhPT0gJC5ub29wKSB7XHJcblx0XHRcdFx0XHRiZWZvcmUgPSBiZWZvcmVGbihuZXcgRGF0ZShjdXJyVmFsLCAwLCAxKSk7XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge307XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBiZWZvcmUgPT09ICdib29sZWFuJykge1xyXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7ZW5hYmxlZDogYmVmb3JlfTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGJlZm9yZSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2NsYXNzZXM6IGJlZm9yZX07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmVuYWJsZWQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnZGlzYWJsZWQnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChiZWZvcmUuY2xhc3Nlcykge1xyXG5cdFx0XHRcdFx0XHRjbGFzc2VzID0gY2xhc3Nlcy5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLnRvb2x0aXApIHtcclxuXHRcdFx0XHRcdFx0dG9vbHRpcCA9IGJlZm9yZS50b29sdGlwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aHRtbCArPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgKHRvb2x0aXAgPyAnIHRpdGxlPVwiJyArIHRvb2x0aXAgKyAnXCInIDogJycpICsgJz4nICsgY3VyclZhbCArICc8L3NwYW4+JztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmlldy5maW5kKCcuZGF0ZXBpY2tlci1zd2l0Y2gnKS50ZXh0KHN0YXJ0VmFsICsgJy0nICsgZW5kVmFsKTtcclxuXHRcdFx0dmlldy5maW5kKCd0ZCcpLmh0bWwoaHRtbCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGZpbGw6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBkID0gbmV3IERhdGUodGhpcy52aWV3RGF0ZSksXHJcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcclxuXHRcdFx0XHRtb250aCA9IGQuZ2V0VVRDTW9udGgoKSxcclxuXHRcdFx0XHRzdGFydFllYXIgPSB0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgPyB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgOiAtSW5maW5pdHksXHJcblx0XHRcdFx0c3RhcnRNb250aCA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDTW9udGgoKSA6IC1JbmZpbml0eSxcclxuXHRcdFx0XHRlbmRZZWFyID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IEluZmluaXR5LFxyXG5cdFx0XHRcdGVuZE1vbnRoID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDTW9udGgoKSA6IEluZmluaXR5LFxyXG5cdFx0XHRcdHRvZGF5dHh0ID0gZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS50b2RheSB8fCBkYXRlc1snZW4nXS50b2RheSB8fCAnJyxcclxuXHRcdFx0XHRjbGVhcnR4dCA9IGRhdGVzW3RoaXMuby5sYW5ndWFnZV0uY2xlYXIgfHwgZGF0ZXNbJ2VuJ10uY2xlYXIgfHwgJycsXHJcblx0XHRcdFx0dGl0bGVGb3JtYXQgPSBkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLnRpdGxlRm9ybWF0IHx8IGRhdGVzWydlbiddLnRpdGxlRm9ybWF0LFxyXG5cdFx0XHRcdHRvb2x0aXAsXHJcblx0XHRcdFx0YmVmb3JlO1xyXG5cdFx0XHRpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyAuZGF0ZXBpY2tlci1zd2l0Y2gnKVxyXG5cdFx0XHRcdFx0XHQudGV4dChEUEdsb2JhbC5mb3JtYXREYXRlKGQsIHRpdGxlRm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpKTtcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgLnRvZGF5JylcclxuXHRcdFx0XHRcdFx0LnRleHQodG9kYXl0eHQpXHJcblx0XHRcdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCB0aGlzLm8udG9kYXlCdG4gPT09IHRydWUgfHwgdGhpcy5vLnRvZGF5QnRuID09PSAnbGlua2VkJyA/ICd0YWJsZS1jZWxsJyA6ICdub25lJyk7XHJcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IC5jbGVhcicpXHJcblx0XHRcdFx0XHRcdC50ZXh0KGNsZWFydHh0KVxyXG5cdFx0XHRcdFx0XHQuY3NzKCdkaXNwbGF5JywgdGhpcy5vLmNsZWFyQnRuID09PSB0cnVlID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnKTtcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGhlYWQgLmRhdGVwaWNrZXItdGl0bGUnKVxyXG5cdFx0XHRcdFx0XHQudGV4dCh0aGlzLm8udGl0bGUpXHJcblx0XHRcdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCB0eXBlb2YgdGhpcy5vLnRpdGxlID09PSAnc3RyaW5nJyAmJiB0aGlzLm8udGl0bGUgIT09ICcnID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnKTtcclxuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcclxuXHRcdFx0dGhpcy5maWxsTW9udGhzKCk7XHJcblx0XHRcdHZhciBwcmV2TW9udGggPSBVVENEYXRlKHllYXIsIG1vbnRoLCAwKSxcclxuXHRcdFx0XHRkYXkgPSBwcmV2TW9udGguZ2V0VVRDRGF0ZSgpO1xyXG5cdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShkYXkgLSAocHJldk1vbnRoLmdldFVUQ0RheSgpIC0gdGhpcy5vLndlZWtTdGFydCArIDcpJTcpO1xyXG5cdFx0XHR2YXIgbmV4dE1vbnRoID0gbmV3IERhdGUocHJldk1vbnRoKTtcclxuXHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENGdWxsWWVhcigpIDwgMTAwKXtcclxuICAgICAgICBuZXh0TW9udGguc2V0VVRDRnVsbFllYXIocHJldk1vbnRoLmdldFVUQ0Z1bGxZZWFyKCkpO1xyXG4gICAgICB9XHJcblx0XHRcdG5leHRNb250aC5zZXRVVENEYXRlKG5leHRNb250aC5nZXRVVENEYXRlKCkgKyA0Mik7XHJcblx0XHRcdG5leHRNb250aCA9IG5leHRNb250aC52YWx1ZU9mKCk7XHJcblx0XHRcdHZhciBodG1sID0gW107XHJcblx0XHRcdHZhciB3ZWVrRGF5LCBjbHNOYW1lO1xyXG5cdFx0XHR3aGlsZSAocHJldk1vbnRoLnZhbHVlT2YoKSA8IG5leHRNb250aCl7XHJcblx0XHRcdFx0d2Vla0RheSA9IHByZXZNb250aC5nZXRVVENEYXkoKTtcclxuXHRcdFx0XHRpZiAod2Vla0RheSA9PT0gdGhpcy5vLndlZWtTdGFydCl7XHJcblx0XHRcdFx0XHRodG1sLnB1c2goJzx0cj4nKTtcclxuXHRcdFx0XHRcdGlmICh0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XHJcblx0XHRcdFx0XHRcdC8vIElTTyA4NjAxOiBGaXJzdCB3ZWVrIGNvbnRhaW5zIGZpcnN0IHRodXJzZGF5LlxyXG5cdFx0XHRcdFx0XHQvLyBJU08gYWxzbyBzdGF0ZXMgd2VlayBzdGFydHMgb24gTW9uZGF5LCBidXQgd2UgY2FuIGJlIG1vcmUgYWJzdHJhY3QgaGVyZS5cclxuXHRcdFx0XHRcdFx0dmFyXHJcblx0XHRcdFx0XHRcdFx0Ly8gU3RhcnQgb2YgY3VycmVudCB3ZWVrOiBiYXNlZCBvbiB3ZWVrc3RhcnQvY3VycmVudCBkYXRlXHJcblx0XHRcdFx0XHRcdFx0d3MgPSBuZXcgRGF0ZSgrcHJldk1vbnRoICsgKHRoaXMuby53ZWVrU3RhcnQgLSB3ZWVrRGF5IC0gNykgJSA3ICogODY0ZTUpLFxyXG5cdFx0XHRcdFx0XHRcdC8vIFRodXJzZGF5IG9mIHRoaXMgd2Vla1xyXG5cdFx0XHRcdFx0XHRcdHRoID0gbmV3IERhdGUoTnVtYmVyKHdzKSArICg3ICsgNCAtIHdzLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXHJcblx0XHRcdFx0XHRcdFx0Ly8gRmlyc3QgVGh1cnNkYXkgb2YgeWVhciwgeWVhciBmcm9tIHRodXJzZGF5XHJcblx0XHRcdFx0XHRcdFx0eXRoID0gbmV3IERhdGUoTnVtYmVyKHl0aCA9IFVUQ0RhdGUodGguZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpICsgKDcgKyA0IC0geXRoLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXHJcblx0XHRcdFx0XHRcdFx0Ly8gQ2FsZW5kYXIgd2VlazogbXMgYmV0d2VlbiB0aHVyc2RheXMsIGRpdiBtcyBwZXIgZGF5LCBkaXYgNyBkYXlzXHJcblx0XHRcdFx0XHRcdFx0Y2FsV2VlayA9ICh0aCAtIHl0aCkgLyA4NjRlNSAvIDcgKyAxO1xyXG5cdFx0XHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cImN3XCI+JysgY2FsV2VlayArJzwvdGQ+Jyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNsc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZXMocHJldk1vbnRoKTtcclxuXHRcdFx0XHRjbHNOYW1lLnB1c2goJ2RheScpO1xyXG5cclxuXHRcdFx0XHR2YXIgY29udGVudCA9IHByZXZNb250aC5nZXRVVENEYXRlKCk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLm8uYmVmb3JlU2hvd0RheSAhPT0gJC5ub29wKXtcclxuXHRcdFx0XHRcdGJlZm9yZSA9IHRoaXMuby5iZWZvcmVTaG93RGF5KHRoaXMuX3V0Y190b19sb2NhbChwcmV2TW9udGgpKTtcclxuXHRcdFx0XHRcdGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge307XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnYm9vbGVhbicpXHJcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtlbmFibGVkOiBiZWZvcmV9O1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGJlZm9yZSA9PT0gJ3N0cmluZycpXHJcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtjbGFzc2VzOiBiZWZvcmV9O1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5lbmFibGVkID09PSBmYWxzZSlcclxuXHRcdFx0XHRcdFx0Y2xzTmFtZS5wdXNoKCdkaXNhYmxlZCcpO1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5jbGFzc2VzKVxyXG5cdFx0XHRcdFx0XHRjbHNOYW1lID0gY2xzTmFtZS5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLnRvb2x0aXApXHJcblx0XHRcdFx0XHRcdHRvb2x0aXAgPSBiZWZvcmUudG9vbHRpcDtcclxuXHRcdFx0XHRcdGlmIChiZWZvcmUuY29udGVudClcclxuXHRcdFx0XHRcdFx0Y29udGVudCA9IGJlZm9yZS5jb250ZW50O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9DaGVjayBpZiB1bmlxdWVTb3J0IGV4aXN0cyAoc3VwcG9ydGVkIGJ5IGpxdWVyeSA+PTEuMTIgYW5kID49Mi4yKVxyXG5cdFx0XHRcdC8vRmFsbGJhY2sgdG8gdW5pcXVlIGZ1bmN0aW9uIGZvciBvbGRlciBqcXVlcnkgdmVyc2lvbnNcclxuXHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKCQudW5pcXVlU29ydCkpIHtcclxuXHRcdFx0XHRcdGNsc05hbWUgPSAkLnVuaXF1ZVNvcnQoY2xzTmFtZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNsc05hbWUgPSAkLnVuaXF1ZShjbHNOYW1lKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGh0bWwucHVzaCgnPHRkIGNsYXNzPVwiJytjbHNOYW1lLmpvaW4oJyAnKSsnXCInICsgKHRvb2x0aXAgPyAnIHRpdGxlPVwiJyt0b29sdGlwKydcIicgOiAnJykgKyAnIGRhdGEtZGF0ZT1cIicgKyBwcmV2TW9udGguZ2V0VGltZSgpLnRvU3RyaW5nKCkgKyAnXCI+JyArIGNvbnRlbnQgKyAnPC90ZD4nKTtcclxuXHRcdFx0XHR0b29sdGlwID0gbnVsbDtcclxuXHRcdFx0XHRpZiAod2Vla0RheSA9PT0gdGhpcy5vLndlZWtFbmQpe1xyXG5cdFx0XHRcdFx0aHRtbC5wdXNoKCc8L3RyPicpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShwcmV2TW9udGguZ2V0VVRDRGF0ZSgpICsgMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmh0bWwoaHRtbC5qb2luKCcnKSk7XHJcblxyXG5cdFx0XHR2YXIgbW9udGhzVGl0bGUgPSBkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLm1vbnRoc1RpdGxlIHx8IGRhdGVzWydlbiddLm1vbnRoc1RpdGxlIHx8ICdNb250aHMnO1xyXG5cdFx0XHR2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJylcclxuXHRcdFx0XHRcdFx0LmZpbmQoJy5kYXRlcGlja2VyLXN3aXRjaCcpXHJcblx0XHRcdFx0XHRcdFx0LnRleHQodGhpcy5vLm1heFZpZXdNb2RlIDwgMiA/IG1vbnRoc1RpdGxlIDogeWVhcilcclxuXHRcdFx0XHRcdFx0XHQuZW5kKClcclxuXHRcdFx0XHRcdFx0LmZpbmQoJ3Rib2R5IHNwYW4nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcblxyXG5cdFx0XHQkLmVhY2godGhpcy5kYXRlcywgZnVuY3Rpb24oaSwgZCl7XHJcblx0XHRcdFx0aWYgKGQuZ2V0VVRDRnVsbFllYXIoKSA9PT0geWVhcilcclxuXHRcdFx0XHRcdG1vbnRocy5lcShkLmdldFVUQ01vbnRoKCkpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhcil7XHJcblx0XHRcdFx0bW9udGhzLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh5ZWFyID09PSBzdGFydFllYXIpe1xyXG5cdFx0XHRcdG1vbnRocy5zbGljZSgwLCBzdGFydE1vbnRoKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeWVhciA9PT0gZW5kWWVhcil7XHJcblx0XHRcdFx0bW9udGhzLnNsaWNlKGVuZE1vbnRoKzEpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vLmJlZm9yZVNob3dNb250aCAhPT0gJC5ub29wKXtcclxuXHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XHJcblx0XHRcdFx0JC5lYWNoKG1vbnRocywgZnVuY3Rpb24oaSwgbW9udGgpe1xyXG4gICAgICAgICAgdmFyIG1vRGF0ZSA9IG5ldyBEYXRlKHllYXIsIGksIDEpO1xyXG4gICAgICAgICAgdmFyIGJlZm9yZSA9IHRoYXQuby5iZWZvcmVTaG93TW9udGgobW9EYXRlKTtcclxuXHRcdFx0XHRcdGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge307XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnYm9vbGVhbicpXHJcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtlbmFibGVkOiBiZWZvcmV9O1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGJlZm9yZSA9PT0gJ3N0cmluZycpXHJcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtjbGFzc2VzOiBiZWZvcmV9O1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5lbmFibGVkID09PSBmYWxzZSAmJiAhJChtb250aCkuaGFzQ2xhc3MoJ2Rpc2FibGVkJykpXHJcblx0XHRcdFx0XHQgICAgJChtb250aCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmNsYXNzZXMpXHJcblx0XHRcdFx0XHQgICAgJChtb250aCkuYWRkQ2xhc3MoYmVmb3JlLmNsYXNzZXMpO1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZS50b29sdGlwKVxyXG5cdFx0XHRcdFx0ICAgICQobW9udGgpLnByb3AoJ3RpdGxlJywgYmVmb3JlLnRvb2x0aXApO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBHZW5lcmF0aW5nIGRlY2FkZS95ZWFycyBwaWNrZXJcclxuXHRcdFx0dGhpcy5fZmlsbF95ZWFyc1ZpZXcoXHJcblx0XHRcdFx0Jy5kYXRlcGlja2VyLXllYXJzJyxcclxuXHRcdFx0XHQneWVhcicsXHJcblx0XHRcdFx0MTAsXHJcblx0XHRcdFx0eWVhcixcclxuXHRcdFx0XHRzdGFydFllYXIsXHJcblx0XHRcdFx0ZW5kWWVhcixcclxuXHRcdFx0XHR0aGlzLm8uYmVmb3JlU2hvd1llYXJcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdC8vIEdlbmVyYXRpbmcgY2VudHVyeS9kZWNhZGVzIHBpY2tlclxyXG5cdFx0XHR0aGlzLl9maWxsX3llYXJzVmlldyhcclxuXHRcdFx0XHQnLmRhdGVwaWNrZXItZGVjYWRlcycsXHJcblx0XHRcdFx0J2RlY2FkZScsXHJcblx0XHRcdFx0MTAwLFxyXG5cdFx0XHRcdHllYXIsXHJcblx0XHRcdFx0c3RhcnRZZWFyLFxyXG5cdFx0XHRcdGVuZFllYXIsXHJcblx0XHRcdFx0dGhpcy5vLmJlZm9yZVNob3dEZWNhZGVcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdC8vIEdlbmVyYXRpbmcgbWlsbGVubml1bS9jZW50dXJpZXMgcGlja2VyXHJcblx0XHRcdHRoaXMuX2ZpbGxfeWVhcnNWaWV3KFxyXG5cdFx0XHRcdCcuZGF0ZXBpY2tlci1jZW50dXJpZXMnLFxyXG5cdFx0XHRcdCdjZW50dXJ5JyxcclxuXHRcdFx0XHQxMDAwLFxyXG5cdFx0XHRcdHllYXIsXHJcblx0XHRcdFx0c3RhcnRZZWFyLFxyXG5cdFx0XHRcdGVuZFllYXIsXHJcblx0XHRcdFx0dGhpcy5vLmJlZm9yZVNob3dDZW50dXJ5XHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZU5hdkFycm93czogZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcclxuXHRcdFx0XHR5ZWFyID0gZC5nZXRVVENGdWxsWWVhcigpLFxyXG5cdFx0XHRcdG1vbnRoID0gZC5nZXRVVENNb250aCgpLFxyXG5cdFx0XHRcdHN0YXJ0WWVhciA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IC1JbmZpbml0eSxcclxuXHRcdFx0XHRzdGFydE1vbnRoID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpIDogLUluZmluaXR5LFxyXG5cdFx0XHRcdGVuZFllYXIgPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENGdWxsWWVhcigpIDogSW5maW5pdHksXHJcblx0XHRcdFx0ZW5kTW9udGggPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpIDogSW5maW5pdHksXHJcblx0XHRcdFx0cHJldklzRGlzYWJsZWQsXHJcblx0XHRcdFx0bmV4dElzRGlzYWJsZWQsXHJcblx0XHRcdFx0ZmFjdG9yID0gMTtcclxuXHRcdFx0c3dpdGNoICh0aGlzLnZpZXdNb2RlKXtcclxuXHRcdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0XHRwcmV2SXNEaXNhYmxlZCA9IHllYXIgPD0gc3RhcnRZZWFyICYmIG1vbnRoIDw9IHN0YXJ0TW9udGg7XHJcblx0XHRcdFx0XHRuZXh0SXNEaXNhYmxlZCA9IHllYXIgPj0gZW5kWWVhciAmJiBtb250aCA+PSBlbmRNb250aDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdGZhY3RvciAqPSAxMDtcclxuXHRcdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cclxuXHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRmYWN0b3IgKj0gMTA7XHJcblx0XHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXHJcblx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0ZmFjdG9yICo9IDEwO1xyXG5cdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cdFx0XHRcdGNhc2UgMTpcclxuXHRcdFx0XHRcdHByZXZJc0Rpc2FibGVkID0gTWF0aC5mbG9vcih5ZWFyIC8gZmFjdG9yKSAqIGZhY3RvciA8PSBzdGFydFllYXI7XHJcblx0XHRcdFx0XHRuZXh0SXNEaXNhYmxlZCA9IE1hdGguZmxvb3IoeWVhciAvIGZhY3RvcikgKiBmYWN0b3IgKyBmYWN0b3IgPj0gZW5kWWVhcjtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsIHByZXZJc0Rpc2FibGVkKTtcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCBuZXh0SXNEaXNhYmxlZCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGNsaWNrOiBmdW5jdGlvbihlKXtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuXHRcdFx0dmFyIHRhcmdldCwgZGlyLCBkYXksIHllYXIsIG1vbnRoO1xyXG5cdFx0XHR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcclxuXHJcblx0XHRcdC8vIENsaWNrZWQgb24gdGhlIHN3aXRjaFxyXG5cdFx0XHRpZiAodGFyZ2V0Lmhhc0NsYXNzKCdkYXRlcGlja2VyLXN3aXRjaCcpICYmIHRoaXMudmlld01vZGUgIT09IHRoaXMuby5tYXhWaWV3TW9kZSl7XHJcblx0XHRcdFx0dGhpcy5zZXRWaWV3TW9kZSh0aGlzLnZpZXdNb2RlICsgMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENsaWNrZWQgb24gdG9kYXkgYnV0dG9uXHJcblx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ3RvZGF5JykgJiYgIXRhcmdldC5oYXNDbGFzcygnZGF5Jykpe1xyXG5cdFx0XHRcdHRoaXMuc2V0Vmlld01vZGUoMCk7XHJcblx0XHRcdFx0dGhpcy5fc2V0RGF0ZShVVENUb2RheSgpLCB0aGlzLm8udG9kYXlCdG4gPT09ICdsaW5rZWQnID8gbnVsbCA6ICd2aWV3Jyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENsaWNrZWQgb24gY2xlYXIgYnV0dG9uXHJcblx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2NsZWFyJykpe1xyXG5cdFx0XHRcdHRoaXMuY2xlYXJEYXRlcygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXRhcmdldC5oYXNDbGFzcygnZGlzYWJsZWQnKSl7XHJcblx0XHRcdFx0Ly8gQ2xpY2tlZCBvbiBhIG1vbnRoLCB5ZWFyLCBkZWNhZGUsIGNlbnR1cnlcclxuXHRcdFx0XHRpZiAodGFyZ2V0Lmhhc0NsYXNzKCdtb250aCcpXHJcblx0XHRcdFx0XHRcdHx8IHRhcmdldC5oYXNDbGFzcygneWVhcicpXHJcblx0XHRcdFx0XHRcdHx8IHRhcmdldC5oYXNDbGFzcygnZGVjYWRlJylcclxuXHRcdFx0XHRcdFx0fHwgdGFyZ2V0Lmhhc0NsYXNzKCdjZW50dXJ5JykpIHtcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUuc2V0VVRDRGF0ZSgxKTtcclxuXHJcblx0XHRcdFx0XHRkYXkgPSAxO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMudmlld01vZGUgPT09IDEpe1xyXG5cdFx0XHRcdFx0XHRtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcclxuXHRcdFx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENNb250aChtb250aCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRtb250aCA9IDA7XHJcblx0XHRcdFx0XHRcdHllYXIgPSBOdW1iZXIodGFyZ2V0LnRleHQoKSk7XHJcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUuc2V0VVRDRnVsbFllYXIoeWVhcik7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcihEUEdsb2JhbC52aWV3TW9kZXNbdGhpcy52aWV3TW9kZSAtIDFdLmUsIHRoaXMudmlld0RhdGUpO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0aGlzLnZpZXdNb2RlID09PSB0aGlzLm8ubWluVmlld01vZGUpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSkpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXRWaWV3TW9kZSh0aGlzLnZpZXdNb2RlIC0gMSk7XHJcblx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRoaXMucGlja2VyLmlzKCc6dmlzaWJsZScpICYmIHRoaXMuX2ZvY3VzZWRfZnJvbSl7XHJcblx0XHRcdFx0dGhpcy5fZm9jdXNlZF9mcm9tLmZvY3VzKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2ZvY3VzZWRfZnJvbTtcclxuXHRcdH0sXHJcblxyXG5cdFx0ZGF5Q2VsbENsaWNrOiBmdW5jdGlvbihlKXtcclxuXHRcdFx0dmFyICR0YXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XHJcblx0XHRcdHZhciB0aW1lc3RhbXAgPSAkdGFyZ2V0LmRhdGEoJ2RhdGUnKTtcclxuXHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuby51cGRhdGVWaWV3RGF0ZSkge1xyXG5cdFx0XHRcdGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgIT09IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlWWVhcicsIHRoaXMudmlld0RhdGUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGRhdGUuZ2V0VVRDTW9udGgoKSAhPT0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpKSB7XHJcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VNb250aCcsIHRoaXMudmlld0RhdGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9zZXREYXRlKGRhdGUpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBDbGlja2VkIG9uIHByZXYgb3IgbmV4dFxyXG5cdFx0bmF2QXJyb3dzQ2xpY2s6IGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHR2YXIgJHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0dmFyIGRpciA9ICR0YXJnZXQuaGFzQ2xhc3MoJ3ByZXYnKSA/IC0xIDogMTtcclxuXHRcdFx0aWYgKHRoaXMudmlld01vZGUgIT09IDApe1xyXG5cdFx0XHRcdGRpciAqPSBEUEdsb2JhbC52aWV3TW9kZXNbdGhpcy52aWV3TW9kZV0ubmF2U3RlcCAqIDEyO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLnZpZXdEYXRlLCBkaXIpO1xyXG5cdFx0XHR0aGlzLl90cmlnZ2VyKERQR2xvYmFsLnZpZXdNb2Rlc1t0aGlzLnZpZXdNb2RlXS5lLCB0aGlzLnZpZXdEYXRlKTtcclxuXHRcdFx0dGhpcy5maWxsKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdF90b2dnbGVfbXVsdGlkYXRlOiBmdW5jdGlvbihkYXRlKXtcclxuXHRcdFx0dmFyIGl4ID0gdGhpcy5kYXRlcy5jb250YWlucyhkYXRlKTtcclxuXHRcdFx0aWYgKCFkYXRlKXtcclxuXHRcdFx0XHR0aGlzLmRhdGVzLmNsZWFyKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpeCAhPT0gLTEpe1xyXG5cdFx0XHRcdGlmICh0aGlzLm8ubXVsdGlkYXRlID09PSB0cnVlIHx8IHRoaXMuby5tdWx0aWRhdGUgPiAxIHx8IHRoaXMuby50b2dnbGVBY3RpdmUpe1xyXG5cdFx0XHRcdFx0dGhpcy5kYXRlcy5yZW1vdmUoaXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm8ubXVsdGlkYXRlID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdHRoaXMuZGF0ZXMuY2xlYXIoKTtcclxuXHRcdFx0XHR0aGlzLmRhdGVzLnB1c2goZGF0ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5kYXRlcy5wdXNoKGRhdGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIHRoaXMuby5tdWx0aWRhdGUgPT09ICdudW1iZXInKVxyXG5cdFx0XHRcdHdoaWxlICh0aGlzLmRhdGVzLmxlbmd0aCA+IHRoaXMuby5tdWx0aWRhdGUpXHJcblx0XHRcdFx0XHR0aGlzLmRhdGVzLnJlbW92ZSgwKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X3NldERhdGU6IGZ1bmN0aW9uKGRhdGUsIHdoaWNoKXtcclxuXHRcdFx0aWYgKCF3aGljaCB8fCB3aGljaCA9PT0gJ2RhdGUnKVxyXG5cdFx0XHRcdHRoaXMuX3RvZ2dsZV9tdWx0aWRhdGUoZGF0ZSAmJiBuZXcgRGF0ZShkYXRlKSk7XHJcblx0XHRcdGlmICgoIXdoaWNoICYmIHRoaXMuby51cGRhdGVWaWV3RGF0ZSkgfHwgd2hpY2ggPT09ICd2aWV3JylcclxuXHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gZGF0ZSAmJiBuZXcgRGF0ZShkYXRlKTtcclxuXHJcblx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHR0aGlzLnNldFZhbHVlKCk7XHJcblx0XHRcdGlmICghd2hpY2ggfHwgd2hpY2ggIT09ICd2aWV3Jykge1xyXG5cdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmlucHV0RmllbGQudHJpZ2dlcignY2hhbmdlJyk7XHJcblx0XHRcdGlmICh0aGlzLm8uYXV0b2Nsb3NlICYmICghd2hpY2ggfHwgd2hpY2ggPT09ICdkYXRlJykpe1xyXG5cdFx0XHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdG1vdmVEYXk6IGZ1bmN0aW9uKGRhdGUsIGRpcil7XHJcblx0XHRcdHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcblx0XHRcdG5ld0RhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpcik7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3RGF0ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0bW92ZVdlZWs6IGZ1bmN0aW9uKGRhdGUsIGRpcil7XHJcblx0XHRcdHJldHVybiB0aGlzLm1vdmVEYXkoZGF0ZSwgZGlyICogNyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdG1vdmVNb250aDogZnVuY3Rpb24oZGF0ZSwgZGlyKXtcclxuXHRcdFx0aWYgKCFpc1ZhbGlkRGF0ZShkYXRlKSlcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vLmRlZmF1bHRWaWV3RGF0ZTtcclxuXHRcdFx0aWYgKCFkaXIpXHJcblx0XHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHRcdHZhciBuZXdfZGF0ZSA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpKSxcclxuXHRcdFx0XHRkYXkgPSBuZXdfZGF0ZS5nZXRVVENEYXRlKCksXHJcblx0XHRcdFx0bW9udGggPSBuZXdfZGF0ZS5nZXRVVENNb250aCgpLFxyXG5cdFx0XHRcdG1hZyA9IE1hdGguYWJzKGRpciksXHJcblx0XHRcdFx0bmV3X21vbnRoLCB0ZXN0O1xyXG5cdFx0XHRkaXIgPSBkaXIgPiAwID8gMSA6IC0xO1xyXG5cdFx0XHRpZiAobWFnID09PSAxKXtcclxuXHRcdFx0XHR0ZXN0ID0gZGlyID09PSAtMVxyXG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgYmFjayBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBub3QgY3VycmVudCBtb250aFxyXG5cdFx0XHRcdFx0Ly8gKGVnLCBNYXIgMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcclxuXHRcdFx0XHRcdD8gZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ld19kYXRlLmdldFVUQ01vbnRoKCkgPT09IG1vbnRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgZm9yd2FyZCBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBhcyBleHBlY3RlZFxyXG5cdFx0XHRcdFx0Ly8gKGVnLCBKYW4gMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcclxuXHRcdFx0XHRcdDogZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ld19kYXRlLmdldFVUQ01vbnRoKCkgIT09IG5ld19tb250aDtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0bmV3X21vbnRoID0gbW9udGggKyBkaXI7XHJcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDTW9udGgobmV3X21vbnRoKTtcclxuXHRcdFx0XHQvLyBEZWMgLT4gSmFuICgxMikgb3IgSmFuIC0+IERlYyAoLTEpIC0tIGxpbWl0IGV4cGVjdGVkIGRhdGUgdG8gMC0xMVxyXG5cdFx0XHRcdG5ld19tb250aCA9IChuZXdfbW9udGggKyAxMikgJSAxMjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBGb3IgbWFnbml0dWRlcyA+MSwgbW92ZSBvbmUgbW9udGggYXQgYSB0aW1lLi4uXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpIDwgbWFnOyBpKyspXHJcblx0XHRcdFx0XHQvLyAuLi53aGljaCBtaWdodCBkZWNyZWFzZSB0aGUgZGF5IChlZywgSmFuIDMxIHRvIEZlYiAyOCwgZXRjKS4uLlxyXG5cdFx0XHRcdFx0bmV3X2RhdGUgPSB0aGlzLm1vdmVNb250aChuZXdfZGF0ZSwgZGlyKTtcclxuXHRcdFx0XHQvLyAuLi50aGVuIHJlc2V0IHRoZSBkYXksIGtlZXBpbmcgaXQgaW4gdGhlIG5ldyBtb250aFxyXG5cdFx0XHRcdG5ld19tb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCk7XHJcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZShkYXkpO1xyXG5cdFx0XHRcdHRlc3QgPSBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ld19tb250aCAhPT0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIENvbW1vbiBkYXRlLXJlc2V0dGluZyBsb29wIC0tIGlmIGRhdGUgaXMgYmV5b25kIGVuZCBvZiBtb250aCwgbWFrZSBpdFxyXG5cdFx0XHQvLyBlbmQgb2YgbW9udGhcclxuXHRcdFx0d2hpbGUgKHRlc3QoKSl7XHJcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZSgtLWRheSk7XHJcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDTW9udGgobmV3X21vbnRoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbmV3X2RhdGU7XHJcblx0XHR9LFxyXG5cclxuXHRcdG1vdmVZZWFyOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tb3ZlTW9udGgoZGF0ZSwgZGlyKjEyKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0bW92ZUF2YWlsYWJsZURhdGU6IGZ1bmN0aW9uKGRhdGUsIGRpciwgZm4pe1xyXG5cdFx0XHRkbyB7XHJcblx0XHRcdFx0ZGF0ZSA9IHRoaXNbZm5dKGRhdGUsIGRpcik7XHJcblxyXG5cdFx0XHRcdGlmICghdGhpcy5kYXRlV2l0aGluUmFuZ2UoZGF0ZSkpXHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGZuID0gJ21vdmVEYXknO1xyXG5cdFx0XHR9XHJcblx0XHRcdHdoaWxlICh0aGlzLmRhdGVJc0Rpc2FibGVkKGRhdGUpKTtcclxuXHJcblx0XHRcdHJldHVybiBkYXRlO1xyXG5cdFx0fSxcclxuXHJcblx0XHR3ZWVrT2ZEYXRlSXNEaXNhYmxlZDogZnVuY3Rpb24oZGF0ZSl7XHJcblx0XHRcdHJldHVybiAkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xO1xyXG5cdFx0fSxcclxuXHJcblx0XHRkYXRlSXNEaXNhYmxlZDogZnVuY3Rpb24oZGF0ZSl7XHJcblx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0dGhpcy53ZWVrT2ZEYXRlSXNEaXNhYmxlZChkYXRlKSB8fFxyXG5cdFx0XHRcdCQuZ3JlcCh0aGlzLm8uZGF0ZXNEaXNhYmxlZCwgZnVuY3Rpb24oZCl7XHJcblx0XHRcdFx0XHRyZXR1cm4gaXNVVENFcXVhbHMoZGF0ZSwgZCk7XHJcblx0XHRcdFx0fSkubGVuZ3RoID4gMFxyXG5cdFx0XHQpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRkYXRlV2l0aGluUmFuZ2U6IGZ1bmN0aW9uKGRhdGUpe1xyXG5cdFx0XHRyZXR1cm4gZGF0ZSA+PSB0aGlzLm8uc3RhcnREYXRlICYmIGRhdGUgPD0gdGhpcy5vLmVuZERhdGU7XHJcblx0XHR9LFxyXG5cclxuXHRcdGtleWRvd246IGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRpZiAoIXRoaXMucGlja2VyLmlzKCc6dmlzaWJsZScpKXtcclxuXHRcdFx0XHRpZiAoZS5rZXlDb2RlID09PSA0MCB8fCBlLmtleUNvZGUgPT09IDI3KSB7IC8vIGFsbG93IGRvd24gdG8gcmUtc2hvdyBwaWNrZXJcclxuXHRcdFx0XHRcdHRoaXMuc2hvdygpO1xyXG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBkYXRlQ2hhbmdlZCA9IGZhbHNlLFxyXG5cdFx0XHRcdGRpciwgbmV3Vmlld0RhdGUsXHJcblx0XHRcdFx0Zm9jdXNEYXRlID0gdGhpcy5mb2N1c0RhdGUgfHwgdGhpcy52aWV3RGF0ZTtcclxuXHRcdFx0c3dpdGNoIChlLmtleUNvZGUpe1xyXG5cdFx0XHRcdGNhc2UgMjc6IC8vIGVzY2FwZVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuZm9jdXNEYXRlKXtcclxuXHRcdFx0XHRcdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gdGhpcy5kYXRlcy5nZXQoLTEpIHx8IHRoaXMudmlld0RhdGU7XHJcblx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDM3OiAvLyBsZWZ0XHJcblx0XHRcdFx0Y2FzZSAzODogLy8gdXBcclxuXHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxyXG5cdFx0XHRcdGNhc2UgNDA6IC8vIGRvd25cclxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbiB8fCB0aGlzLm8uZGF5c09mV2Vla0Rpc2FibGVkLmxlbmd0aCA9PT0gNylcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRkaXIgPSBlLmtleUNvZGUgPT09IDM3IHx8IGUua2V5Q29kZSA9PT0gMzggPyAtMSA6IDE7XHJcbiAgICAgICAgICBpZiAodGhpcy52aWV3TW9kZSA9PT0gMCkge1xyXG4gIFx0XHRcdFx0XHRpZiAoZS5jdHJsS2V5KXtcclxuICBcdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZUF2YWlsYWJsZURhdGUoZm9jdXNEYXRlLCBkaXIsICdtb3ZlWWVhcicpO1xyXG5cclxuICBcdFx0XHRcdFx0XHRpZiAobmV3Vmlld0RhdGUpXHJcbiAgXHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VZZWFyJywgdGhpcy52aWV3RGF0ZSk7XHJcbiAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoZS5zaGlmdEtleSl7XHJcbiAgXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZU1vbnRoJyk7XHJcblxyXG4gIFx0XHRcdFx0XHRcdGlmIChuZXdWaWV3RGF0ZSlcclxuICBcdFx0XHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZU1vbnRoJywgdGhpcy52aWV3RGF0ZSk7XHJcbiAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAzNyB8fCBlLmtleUNvZGUgPT09IDM5KXtcclxuICBcdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZUF2YWlsYWJsZURhdGUoZm9jdXNEYXRlLCBkaXIsICdtb3ZlRGF5Jyk7XHJcbiAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXRoaXMud2Vla09mRGF0ZUlzRGlzYWJsZWQoZm9jdXNEYXRlKSl7XHJcbiAgXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZVdlZWsnKTtcclxuICBcdFx0XHRcdFx0fVxyXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpZXdNb2RlID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDM4IHx8IGUua2V5Q29kZSA9PT0gNDApIHtcclxuICAgICAgICAgICAgICBkaXIgPSBkaXIgKiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlQXZhaWxhYmxlRGF0ZShmb2N1c0RhdGUsIGRpciwgJ21vdmVNb250aCcpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpZXdNb2RlID09PSAyKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDM4IHx8IGUua2V5Q29kZSA9PT0gNDApIHtcclxuICAgICAgICAgICAgICBkaXIgPSBkaXIgKiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlQXZhaWxhYmxlRGF0ZShmb2N1c0RhdGUsIGRpciwgJ21vdmVZZWFyJyk7XHJcbiAgICAgICAgICB9XHJcblx0XHRcdFx0XHRpZiAobmV3Vmlld0RhdGUpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLmZvY3VzRGF0ZSA9IHRoaXMudmlld0RhdGUgPSBuZXdWaWV3RGF0ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxMzogLy8gZW50ZXJcclxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmZvcmNlUGFyc2UpXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Zm9jdXNEYXRlID0gdGhpcy5mb2N1c0RhdGUgfHwgdGhpcy5kYXRlcy5nZXQoLTEpIHx8IHRoaXMudmlld0RhdGU7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl90b2dnbGVfbXVsdGlkYXRlKGZvY3VzRGF0ZSk7XHJcblx0XHRcdFx0XHRcdGRhdGVDaGFuZ2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuZm9jdXNEYXRlID0gbnVsbDtcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLmRhdGVzLmdldCgtMSkgfHwgdGhpcy52aWV3RGF0ZTtcclxuXHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcclxuXHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMucGlja2VyLmlzKCc6dmlzaWJsZScpKXtcclxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5vLmF1dG9jbG9zZSlcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgOTogLy8gdGFiXHJcblx0XHRcdFx0XHR0aGlzLmZvY3VzRGF0ZSA9IG51bGw7XHJcblx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gdGhpcy5kYXRlcy5nZXQoLTEpIHx8IHRoaXMudmlld0RhdGU7XHJcblx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGRhdGVDaGFuZ2VkKXtcclxuXHRcdFx0XHRpZiAodGhpcy5kYXRlcy5sZW5ndGgpXHJcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2xlYXJEYXRlJyk7XHJcblx0XHRcdFx0dGhpcy5pbnB1dEZpZWxkLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFZpZXdNb2RlOiBmdW5jdGlvbih2aWV3TW9kZSl7XHJcblx0XHRcdHRoaXMudmlld01vZGUgPSB2aWV3TW9kZTtcclxuXHRcdFx0dGhpcy5waWNrZXJcclxuXHRcdFx0XHQuY2hpbGRyZW4oJ2RpdicpXHJcblx0XHRcdFx0LmhpZGUoKVxyXG5cdFx0XHRcdC5maWx0ZXIoJy5kYXRlcGlja2VyLScgKyBEUEdsb2JhbC52aWV3TW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSlcclxuXHRcdFx0XHRcdC5zaG93KCk7XHJcblx0XHRcdHRoaXMudXBkYXRlTmF2QXJyb3dzKCk7XHJcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVZpZXdNb2RlJywgbmV3IERhdGUodGhpcy52aWV3RGF0ZSkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHZhciBEYXRlUmFuZ2VQaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKXtcclxuXHRcdCQuZGF0YShlbGVtZW50LCAnZGF0ZXBpY2tlcicsIHRoaXMpO1xyXG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcclxuXHRcdHRoaXMuaW5wdXRzID0gJC5tYXAob3B0aW9ucy5pbnB1dHMsIGZ1bmN0aW9uKGkpe1xyXG5cdFx0XHRyZXR1cm4gaS5qcXVlcnkgPyBpWzBdIDogaTtcclxuXHRcdH0pO1xyXG5cdFx0ZGVsZXRlIG9wdGlvbnMuaW5wdXRzO1xyXG5cclxuXHRcdHRoaXMua2VlcEVtcHR5VmFsdWVzID0gb3B0aW9ucy5rZWVwRW1wdHlWYWx1ZXM7XHJcblx0XHRkZWxldGUgb3B0aW9ucy5rZWVwRW1wdHlWYWx1ZXM7XHJcblxyXG5cdFx0ZGF0ZXBpY2tlclBsdWdpbi5jYWxsKCQodGhpcy5pbnB1dHMpLCBvcHRpb25zKVxyXG5cdFx0XHQub24oJ2NoYW5nZURhdGUnLCAkLnByb3h5KHRoaXMuZGF0ZVVwZGF0ZWQsIHRoaXMpKTtcclxuXHJcblx0XHR0aGlzLnBpY2tlcnMgPSAkLm1hcCh0aGlzLmlucHV0cywgZnVuY3Rpb24oaSl7XHJcblx0XHRcdHJldHVybiAkLmRhdGEoaSwgJ2RhdGVwaWNrZXInKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy51cGRhdGVEYXRlcygpO1xyXG5cdH07XHJcblx0RGF0ZVJhbmdlUGlja2VyLnByb3RvdHlwZSA9IHtcclxuXHRcdHVwZGF0ZURhdGVzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGlzLmRhdGVzID0gJC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihpKXtcclxuXHRcdFx0XHRyZXR1cm4gaS5nZXRVVENEYXRlKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZVJhbmdlcygpO1xyXG5cdFx0fSxcclxuXHRcdHVwZGF0ZVJhbmdlczogZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIHJhbmdlID0gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7XHJcblx0XHRcdFx0cmV0dXJuIGQudmFsdWVPZigpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0JC5lYWNoKHRoaXMucGlja2VycywgZnVuY3Rpb24oaSwgcCl7XHJcblx0XHRcdFx0cC5zZXRSYW5nZShyYW5nZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHRcdGRhdGVVcGRhdGVkOiBmdW5jdGlvbihlKXtcclxuXHRcdFx0Ly8gYHRoaXMudXBkYXRpbmdgIGlzIGEgd29ya2Fyb3VuZCBmb3IgcHJldmVudGluZyBpbmZpbml0ZSByZWN1cnNpb25cclxuXHRcdFx0Ly8gYmV0d2VlbiBgY2hhbmdlRGF0ZWAgdHJpZ2dlcmluZyBhbmQgYHNldFVUQ0RhdGVgIGNhbGxpbmcuICBVbnRpbFxyXG5cdFx0XHQvLyB0aGVyZSBpcyBhIGJldHRlciBtZWNoYW5pc20uXHJcblx0XHRcdGlmICh0aGlzLnVwZGF0aW5nKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XHJcblxyXG5cdFx0XHR2YXIgZHAgPSAkLmRhdGEoZS50YXJnZXQsICdkYXRlcGlja2VyJyk7XHJcblxyXG5cdFx0XHRpZiAoZHAgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG5ld19kYXRlID0gZHAuZ2V0VVRDRGF0ZSgpLFxyXG5cdFx0XHRcdGtlZXBfZW1wdHlfdmFsdWVzID0gdGhpcy5rZWVwRW1wdHlWYWx1ZXMsXHJcblx0XHRcdFx0aSA9ICQuaW5BcnJheShlLnRhcmdldCwgdGhpcy5pbnB1dHMpLFxyXG5cdFx0XHRcdGogPSBpIC0gMSxcclxuXHRcdFx0XHRrID0gaSArIDEsXHJcblx0XHRcdFx0bCA9IHRoaXMuaW5wdXRzLmxlbmd0aDtcclxuXHRcdFx0aWYgKGkgPT09IC0xKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdCQuZWFjaCh0aGlzLnBpY2tlcnMsIGZ1bmN0aW9uKGksIHApe1xyXG5cdFx0XHRcdGlmICghcC5nZXRVVENEYXRlKCkgJiYgKHAgPT09IGRwIHx8ICFrZWVwX2VtcHR5X3ZhbHVlcykpXHJcblx0XHRcdFx0XHRwLnNldFVUQ0RhdGUobmV3X2RhdGUpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmIChuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbal0pe1xyXG5cdFx0XHRcdC8vIERhdGUgYmVpbmcgbW92ZWQgZWFybGllci9sZWZ0XHJcblx0XHRcdFx0d2hpbGUgKGogPj0gMCAmJiBuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbal0pe1xyXG5cdFx0XHRcdFx0dGhpcy5waWNrZXJzW2otLV0uc2V0VVRDRGF0ZShuZXdfZGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKG5ld19kYXRlID4gdGhpcy5kYXRlc1trXSl7XHJcblx0XHRcdFx0Ly8gRGF0ZSBiZWluZyBtb3ZlZCBsYXRlci9yaWdodFxyXG5cdFx0XHRcdHdoaWxlIChrIDwgbCAmJiBuZXdfZGF0ZSA+IHRoaXMuZGF0ZXNba10pe1xyXG5cdFx0XHRcdFx0dGhpcy5waWNrZXJzW2srK10uc2V0VVRDRGF0ZShuZXdfZGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMudXBkYXRlRGF0ZXMoKTtcclxuXHJcblx0XHRcdGRlbGV0ZSB0aGlzLnVwZGF0aW5nO1xyXG5cdFx0fSxcclxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdCQubWFwKHRoaXMucGlja2VycywgZnVuY3Rpb24ocCl7IHAuZGVzdHJveSgpOyB9KTtcclxuXHRcdFx0JCh0aGlzLmlucHV0cykub2ZmKCdjaGFuZ2VEYXRlJywgdGhpcy5kYXRlVXBkYXRlZCk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XHJcblx0XHR9LFxyXG5cdFx0cmVtb3ZlOiBhbGlhcygnZGVzdHJveScsICdNZXRob2QgYHJlbW92ZWAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMi4wLiBVc2UgYGRlc3Ryb3lgIGluc3RlYWQnKVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIG9wdHNfZnJvbV9lbChlbCwgcHJlZml4KXtcclxuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gZWxlbWVudCBkYXRhLWF0dHJzXHJcblx0XHR2YXIgZGF0YSA9ICQoZWwpLmRhdGEoKSxcclxuXHRcdFx0b3V0ID0ge30sIGlua2V5LFxyXG5cdFx0XHRyZXBsYWNlID0gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgudG9Mb3dlckNhc2UoKSArICcoW0EtWl0pJyk7XHJcblx0XHRwcmVmaXggPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpKTtcclxuXHRcdGZ1bmN0aW9uIHJlX2xvd2VyKF8sYSl7XHJcblx0XHRcdHJldHVybiBhLnRvTG93ZXJDYXNlKCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKHZhciBrZXkgaW4gZGF0YSlcclxuXHRcdFx0aWYgKHByZWZpeC50ZXN0KGtleSkpe1xyXG5cdFx0XHRcdGlua2V5ID0ga2V5LnJlcGxhY2UocmVwbGFjZSwgcmVfbG93ZXIpO1xyXG5cdFx0XHRcdG91dFtpbmtleV0gPSBkYXRhW2tleV07XHJcblx0XHRcdH1cclxuXHRcdHJldHVybiBvdXQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fbG9jYWxlKGxhbmcpe1xyXG5cdFx0Ly8gRGVyaXZlIG9wdGlvbnMgZnJvbSBsb2NhbGUgcGx1Z2luc1xyXG5cdFx0dmFyIG91dCA9IHt9O1xyXG5cdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXHJcblx0XHQvLyBmYWxsYmFjayB0byAyIGxldHRlciBjb2RlIGVnIFwiZGVcIlxyXG5cdFx0aWYgKCFkYXRlc1tsYW5nXSl7XHJcblx0XHRcdGxhbmcgPSBsYW5nLnNwbGl0KCctJylbMF07XHJcblx0XHRcdGlmICghZGF0ZXNbbGFuZ10pXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGQgPSBkYXRlc1tsYW5nXTtcclxuXHRcdCQuZWFjaChsb2NhbGVfb3B0cywgZnVuY3Rpb24oaSxrKXtcclxuXHRcdFx0aWYgKGsgaW4gZClcclxuXHRcdFx0XHRvdXRba10gPSBkW2tdO1xyXG5cdFx0fSk7XHJcblx0XHRyZXR1cm4gb3V0O1xyXG5cdH1cclxuXHJcblx0dmFyIG9sZCA9ICQuZm4uZGF0ZXBpY2tlcjtcclxuXHR2YXIgZGF0ZXBpY2tlclBsdWdpbiA9IGZ1bmN0aW9uKG9wdGlvbil7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcblx0XHRhcmdzLnNoaWZ0KCk7XHJcblx0XHR2YXIgaW50ZXJuYWxfcmV0dXJuO1xyXG5cdFx0dGhpcy5lYWNoKGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyksXHJcblx0XHRcdFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSxcclxuXHRcdFx0XHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xyXG5cdFx0XHRpZiAoIWRhdGEpe1xyXG5cdFx0XHRcdHZhciBlbG9wdHMgPSBvcHRzX2Zyb21fZWwodGhpcywgJ2RhdGUnKSxcclxuXHRcdFx0XHRcdC8vIFByZWxpbWluYXJ5IG90aW9uc1xyXG5cdFx0XHRcdFx0eG9wdHMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGVsb3B0cywgb3B0aW9ucyksXHJcblx0XHRcdFx0XHRsb2NvcHRzID0gb3B0c19mcm9tX2xvY2FsZSh4b3B0cy5sYW5ndWFnZSksXHJcblx0XHRcdFx0XHQvLyBPcHRpb25zIHByaW9yaXR5OiBqcyBhcmdzLCBkYXRhLWF0dHJzLCBsb2NhbGVzLCBkZWZhdWx0c1xyXG5cdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgbG9jb3B0cywgZWxvcHRzLCBvcHRpb25zKTtcclxuXHRcdFx0XHRpZiAoJHRoaXMuaGFzQ2xhc3MoJ2lucHV0LWRhdGVyYW5nZScpIHx8IG9wdHMuaW5wdXRzKXtcclxuXHRcdFx0XHRcdCQuZXh0ZW5kKG9wdHMsIHtcclxuXHRcdFx0XHRcdFx0aW5wdXRzOiBvcHRzLmlucHV0cyB8fCAkdGhpcy5maW5kKCdpbnB1dCcpLnRvQXJyYXkoKVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRkYXRhID0gbmV3IERhdGVSYW5nZVBpY2tlcih0aGlzLCBvcHRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRkYXRhID0gbmV3IERhdGVwaWNrZXIodGhpcywgb3B0cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInLCBkYXRhKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGRhdGFbb3B0aW9uXSA9PT0gJ2Z1bmN0aW9uJyl7XHJcblx0XHRcdFx0aW50ZXJuYWxfcmV0dXJuID0gZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoXHJcblx0XHRcdGludGVybmFsX3JldHVybiA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdGludGVybmFsX3JldHVybiBpbnN0YW5jZW9mIERhdGVwaWNrZXIgfHxcclxuXHRcdFx0aW50ZXJuYWxfcmV0dXJuIGluc3RhbmNlb2YgRGF0ZVJhbmdlUGlja2VyXHJcblx0XHQpXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdGlmICh0aGlzLmxlbmd0aCA+IDEpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNpbmcgb25seSBhbGxvd2VkIGZvciB0aGUgY29sbGVjdGlvbiBvZiBhIHNpbmdsZSBlbGVtZW50ICgnICsgb3B0aW9uICsgJyBmdW5jdGlvbiknKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIGludGVybmFsX3JldHVybjtcclxuXHR9O1xyXG5cdCQuZm4uZGF0ZXBpY2tlciA9IGRhdGVwaWNrZXJQbHVnaW47XHJcblxyXG5cdHZhciBkZWZhdWx0cyA9ICQuZm4uZGF0ZXBpY2tlci5kZWZhdWx0cyA9IHtcclxuXHRcdGFzc3VtZU5lYXJieVllYXI6IGZhbHNlLFxyXG5cdFx0YXV0b2Nsb3NlOiBmYWxzZSxcclxuXHRcdGJlZm9yZVNob3dEYXk6ICQubm9vcCxcclxuXHRcdGJlZm9yZVNob3dNb250aDogJC5ub29wLFxyXG5cdFx0YmVmb3JlU2hvd1llYXI6ICQubm9vcCxcclxuXHRcdGJlZm9yZVNob3dEZWNhZGU6ICQubm9vcCxcclxuXHRcdGJlZm9yZVNob3dDZW50dXJ5OiAkLm5vb3AsXHJcblx0XHRjYWxlbmRhcldlZWtzOiBmYWxzZSxcclxuXHRcdGNsZWFyQnRuOiBmYWxzZSxcclxuXHRcdHRvZ2dsZUFjdGl2ZTogZmFsc2UsXHJcblx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxyXG5cdFx0ZGF5c09mV2Vla0hpZ2hsaWdodGVkOiBbXSxcclxuXHRcdGRhdGVzRGlzYWJsZWQ6IFtdLFxyXG5cdFx0ZW5kRGF0ZTogSW5maW5pdHksXHJcblx0XHRmb3JjZVBhcnNlOiB0cnVlLFxyXG5cdFx0Zm9ybWF0OiAnbW0vZGQveXl5eScsXHJcblx0XHRrZWVwRW1wdHlWYWx1ZXM6IGZhbHNlLFxyXG5cdFx0a2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxyXG5cdFx0bGFuZ3VhZ2U6ICdlbicsXHJcblx0XHRtaW5WaWV3TW9kZTogMCxcclxuXHRcdG1heFZpZXdNb2RlOiA0LFxyXG5cdFx0bXVsdGlkYXRlOiBmYWxzZSxcclxuXHRcdG11bHRpZGF0ZVNlcGFyYXRvcjogJywnLFxyXG5cdFx0b3JpZW50YXRpb246IFwiYXV0b1wiLFxyXG5cdFx0cnRsOiBmYWxzZSxcclxuXHRcdHN0YXJ0RGF0ZTogLUluZmluaXR5LFxyXG5cdFx0c3RhcnRWaWV3OiAwLFxyXG5cdFx0dG9kYXlCdG46IGZhbHNlLFxyXG5cdFx0dG9kYXlIaWdobGlnaHQ6IGZhbHNlLFxyXG5cdFx0dXBkYXRlVmlld0RhdGU6IHRydWUsXHJcblx0XHR3ZWVrU3RhcnQ6IDAsXHJcblx0XHRkaXNhYmxlVG91Y2hLZXlib2FyZDogZmFsc2UsXHJcblx0XHRlbmFibGVPblJlYWRvbmx5OiB0cnVlLFxyXG5cdFx0c2hvd09uRm9jdXM6IHRydWUsXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDEwLFxyXG5cdFx0Y29udGFpbmVyOiAnYm9keScsXHJcblx0XHRpbW1lZGlhdGVVcGRhdGVzOiBmYWxzZSxcclxuXHRcdHRpdGxlOiAnJyxcclxuXHRcdHRlbXBsYXRlczoge1xyXG5cdFx0XHRsZWZ0QXJyb3c6ICcmI3gwMEFCOycsXHJcblx0XHRcdHJpZ2h0QXJyb3c6ICcmI3gwMEJCOydcclxuXHRcdH0sXHJcbiAgICBzaG93V2Vla0RheXM6IHRydWVcclxuXHR9O1xyXG5cdHZhciBsb2NhbGVfb3B0cyA9ICQuZm4uZGF0ZXBpY2tlci5sb2NhbGVfb3B0cyA9IFtcclxuXHRcdCdmb3JtYXQnLFxyXG5cdFx0J3J0bCcsXHJcblx0XHQnd2Vla1N0YXJ0J1xyXG5cdF07XHJcblx0JC5mbi5kYXRlcGlja2VyLkNvbnN0cnVjdG9yID0gRGF0ZXBpY2tlcjtcclxuXHR2YXIgZGF0ZXMgPSAkLmZuLmRhdGVwaWNrZXIuZGF0ZXMgPSB7XHJcblx0XHRlbjoge1xyXG5cdFx0XHRkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcclxuXHRcdFx0ZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXHJcblx0XHRcdGRheXNNaW46IFtcIlN1XCIsIFwiTW9cIiwgXCJUdVwiLCBcIldlXCIsIFwiVGhcIiwgXCJGclwiLCBcIlNhXCJdLFxyXG5cdFx0XHRtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxyXG5cdFx0XHRtb250aHNTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLFxyXG5cdFx0XHR0b2RheTogXCJUb2RheVwiLFxyXG5cdFx0XHRjbGVhcjogXCJDbGVhclwiLFxyXG5cdFx0XHR0aXRsZUZvcm1hdDogXCJNTSB5eXl5XCJcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHR2YXIgRFBHbG9iYWwgPSB7XHJcblx0XHR2aWV3TW9kZXM6IFtcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWVzOiBbJ2RheXMnLCAnbW9udGgnXSxcclxuXHRcdFx0XHRjbHNOYW1lOiAnZGF5cycsXHJcblx0XHRcdFx0ZTogJ2NoYW5nZU1vbnRoJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZXM6IFsnbW9udGhzJywgJ3llYXInXSxcclxuXHRcdFx0XHRjbHNOYW1lOiAnbW9udGhzJyxcclxuXHRcdFx0XHRlOiAnY2hhbmdlWWVhcicsXHJcblx0XHRcdFx0bmF2U3RlcDogMVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZXM6IFsneWVhcnMnLCAnZGVjYWRlJ10sXHJcblx0XHRcdFx0Y2xzTmFtZTogJ3llYXJzJyxcclxuXHRcdFx0XHRlOiAnY2hhbmdlRGVjYWRlJyxcclxuXHRcdFx0XHRuYXZTdGVwOiAxMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZXM6IFsnZGVjYWRlcycsICdjZW50dXJ5J10sXHJcblx0XHRcdFx0Y2xzTmFtZTogJ2RlY2FkZXMnLFxyXG5cdFx0XHRcdGU6ICdjaGFuZ2VDZW50dXJ5JyxcclxuXHRcdFx0XHRuYXZTdGVwOiAxMDBcclxuXHRcdFx0fSxcclxuXHRcdFx0e1xyXG5cdFx0XHRcdG5hbWVzOiBbJ2NlbnR1cmllcycsICdtaWxsZW5uaXVtJ10sXHJcblx0XHRcdFx0Y2xzTmFtZTogJ2NlbnR1cmllcycsXHJcblx0XHRcdFx0ZTogJ2NoYW5nZU1pbGxlbm5pdW0nLFxyXG5cdFx0XHRcdG5hdlN0ZXA6IDEwMDBcclxuXHRcdFx0fVxyXG5cdFx0XSxcclxuXHRcdHZhbGlkUGFydHM6IC9kZD98REQ/fG1tP3xNTT98eXkoPzp5eSk/L2csXHJcblx0XHRub25wdW5jdHVhdGlvbjogL1teIC1cXC86LUBcXHU1ZTc0XFx1NjcwOFxcdTY1ZTVcXFstYHstflxcdFxcblxccl0rL2csXHJcblx0XHRwYXJzZUZvcm1hdDogZnVuY3Rpb24oZm9ybWF0KXtcclxuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQudG9WYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZm9ybWF0LnRvRGlzcGxheSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICAgICAgICAgIC8vIElFIHRyZWF0cyBcXDAgYXMgYSBzdHJpbmcgZW5kIGluIGlucHV0cyAodHJ1bmNhdGluZyB0aGUgdmFsdWUpLFxyXG5cdFx0XHQvLyBzbyBpdCdzIGEgYmFkIGZvcm1hdCBkZWxpbWl0ZXIsIGFueXdheVxyXG5cdFx0XHR2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5yZXBsYWNlKHRoaXMudmFsaWRQYXJ0cywgJ1xcMCcpLnNwbGl0KCdcXDAnKSxcclxuXHRcdFx0XHRwYXJ0cyA9IGZvcm1hdC5tYXRjaCh0aGlzLnZhbGlkUGFydHMpO1xyXG5cdFx0XHRpZiAoIXNlcGFyYXRvcnMgfHwgIXNlcGFyYXRvcnMubGVuZ3RoIHx8ICFwYXJ0cyB8fCBwYXJ0cy5sZW5ndGggPT09IDApe1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB7c2VwYXJhdG9yczogc2VwYXJhdG9ycywgcGFydHM6IHBhcnRzfTtcclxuXHRcdH0sXHJcblx0XHRwYXJzZURhdGU6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCwgbGFuZ3VhZ2UsIGFzc3VtZU5lYXJieSl7XHJcblx0XHRcdGlmICghZGF0ZSlcclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpXHJcblx0XHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcclxuXHRcdFx0XHRmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChmb3JtYXQpO1xyXG5cdFx0XHRpZiAoZm9ybWF0LnRvVmFsdWUpXHJcblx0XHRcdFx0cmV0dXJuIGZvcm1hdC50b1ZhbHVlKGRhdGUsIGZvcm1hdCwgbGFuZ3VhZ2UpO1xyXG5cdFx0XHR2YXIgZm5fbWFwID0ge1xyXG5cdFx0XHRcdFx0ZDogJ21vdmVEYXknLFxyXG5cdFx0XHRcdFx0bTogJ21vdmVNb250aCcsXHJcblx0XHRcdFx0XHR3OiAnbW92ZVdlZWsnLFxyXG5cdFx0XHRcdFx0eTogJ21vdmVZZWFyJ1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0ZGF0ZUFsaWFzZXMgPSB7XHJcblx0XHRcdFx0XHR5ZXN0ZXJkYXk6ICctMWQnLFxyXG5cdFx0XHRcdFx0dG9kYXk6ICcrMGQnLFxyXG5cdFx0XHRcdFx0dG9tb3Jyb3c6ICcrMWQnXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRwYXJ0cywgcGFydCwgZGlyLCBpLCBmbjtcclxuXHRcdFx0aWYgKGRhdGUgaW4gZGF0ZUFsaWFzZXMpe1xyXG5cdFx0XHRcdGRhdGUgPSBkYXRlQWxpYXNlc1tkYXRlXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoL15bXFwtK11cXGQrW2Rtd3ldKFtcXHMsXStbXFwtK11cXGQrW2Rtd3ldKSokL2kudGVzdChkYXRlKSl7XHJcblx0XHRcdFx0cGFydHMgPSBkYXRlLm1hdGNoKC8oW1xcLStdXFxkKykoW2Rtd3ldKS9naSk7XHJcblx0XHRcdFx0ZGF0ZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0Zm9yIChpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0XHRwYXJ0ID0gcGFydHNbaV0ubWF0Y2goLyhbXFwtK11cXGQrKShbZG13eV0pL2kpO1xyXG5cdFx0XHRcdFx0ZGlyID0gTnVtYmVyKHBhcnRbMV0pO1xyXG5cdFx0XHRcdFx0Zm4gPSBmbl9tYXBbcGFydFsyXS50b0xvd2VyQ2FzZSgpXTtcclxuXHRcdFx0XHRcdGRhdGUgPSBEYXRlcGlja2VyLnByb3RvdHlwZVtmbl0oZGF0ZSwgZGlyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIERhdGVwaWNrZXIucHJvdG90eXBlLl96ZXJvX3V0Y190aW1lKGRhdGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJ0cyA9IGRhdGUgJiYgZGF0ZS5tYXRjaCh0aGlzLm5vbnB1bmN0dWF0aW9uKSB8fCBbXTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGFwcGx5TmVhcmJ5WWVhcih5ZWFyLCB0aHJlc2hvbGQpe1xyXG5cdFx0XHRcdGlmICh0aHJlc2hvbGQgPT09IHRydWUpXHJcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSAxMDtcclxuXHJcblx0XHRcdFx0Ly8gaWYgeWVhciBpcyAyIGRpZ2l0cyBvciBsZXNzLCB0aGFuIHRoZSB1c2VyIG1vc3QgbGlrZWx5IGlzIHRyeWluZyB0byBnZXQgYSByZWNlbnQgY2VudHVyeVxyXG5cdFx0XHRcdGlmICh5ZWFyIDwgMTAwKXtcclxuXHRcdFx0XHRcdHllYXIgKz0gMjAwMDtcclxuXHRcdFx0XHRcdC8vIGlmIHRoZSBuZXcgeWVhciBpcyBtb3JlIHRoYW4gdGhyZXNob2xkIHllYXJzIGluIGFkdmFuY2UsIHVzZSBsYXN0IGNlbnR1cnlcclxuXHRcdFx0XHRcdGlmICh5ZWFyID4gKChuZXcgRGF0ZSgpKS5nZXRGdWxsWWVhcigpK3RocmVzaG9sZCkpe1xyXG5cdFx0XHRcdFx0XHR5ZWFyIC09IDEwMDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB5ZWFyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcGFyc2VkID0ge30sXHJcblx0XHRcdFx0c2V0dGVyc19vcmRlciA9IFsneXl5eScsICd5eScsICdNJywgJ01NJywgJ20nLCAnbW0nLCAnZCcsICdkZCddLFxyXG5cdFx0XHRcdHNldHRlcnNfbWFwID0ge1xyXG5cdFx0XHRcdFx0eXl5eTogZnVuY3Rpb24oZCx2KXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGQuc2V0VVRDRnVsbFllYXIoYXNzdW1lTmVhcmJ5ID8gYXBwbHlOZWFyYnlZZWFyKHYsIGFzc3VtZU5lYXJieSkgOiB2KTtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRtOiBmdW5jdGlvbihkLHYpe1xyXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4oZCkpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGQ7XHJcblx0XHRcdFx0XHRcdHYgLT0gMTtcclxuXHRcdFx0XHRcdFx0d2hpbGUgKHYgPCAwKSB2ICs9IDEyO1xyXG5cdFx0XHRcdFx0XHR2ICU9IDEyO1xyXG5cdFx0XHRcdFx0XHRkLnNldFVUQ01vbnRoKHYpO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoZC5nZXRVVENNb250aCgpICE9PSB2KVxyXG5cdFx0XHRcdFx0XHRcdGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKS0xKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGQ7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0ZDogZnVuY3Rpb24oZCx2KXtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGQuc2V0VVRDRGF0ZSh2KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHZhbCwgZmlsdGVyZWQ7XHJcblx0XHRcdHNldHRlcnNfbWFwWyd5eSddID0gc2V0dGVyc19tYXBbJ3l5eXknXTtcclxuXHRcdFx0c2V0dGVyc19tYXBbJ00nXSA9IHNldHRlcnNfbWFwWydNTSddID0gc2V0dGVyc19tYXBbJ21tJ10gPSBzZXR0ZXJzX21hcFsnbSddO1xyXG5cdFx0XHRzZXR0ZXJzX21hcFsnZGQnXSA9IHNldHRlcnNfbWFwWydkJ107XHJcblx0XHRcdGRhdGUgPSBVVENUb2RheSgpO1xyXG5cdFx0XHR2YXIgZnBhcnRzID0gZm9ybWF0LnBhcnRzLnNsaWNlKCk7XHJcblx0XHRcdC8vIFJlbW92ZSBub29wIHBhcnRzXHJcblx0XHRcdGlmIChwYXJ0cy5sZW5ndGggIT09IGZwYXJ0cy5sZW5ndGgpe1xyXG5cdFx0XHRcdGZwYXJ0cyA9ICQoZnBhcnRzKS5maWx0ZXIoZnVuY3Rpb24oaSxwKXtcclxuXHRcdFx0XHRcdHJldHVybiAkLmluQXJyYXkocCwgc2V0dGVyc19vcmRlcikgIT09IC0xO1xyXG5cdFx0XHRcdH0pLnRvQXJyYXkoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBQcm9jZXNzIHJlbWFpbmRlclxyXG5cdFx0XHRmdW5jdGlvbiBtYXRjaF9wYXJ0KCl7XHJcblx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXHJcblx0XHRcdFx0XHRwID0gcGFydHNbaV0uc2xpY2UoMCwgbS5sZW5ndGgpO1xyXG5cdFx0XHRcdHJldHVybiBtLnRvTG93ZXJDYXNlKCkgPT09IHAudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAocGFydHMubGVuZ3RoID09PSBmcGFydHMubGVuZ3RoKXtcclxuXHRcdFx0XHR2YXIgY250O1xyXG5cdFx0XHRcdGZvciAoaT0wLCBjbnQgPSBmcGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspe1xyXG5cdFx0XHRcdFx0dmFsID0gcGFyc2VJbnQocGFydHNbaV0sIDEwKTtcclxuXHRcdFx0XHRcdHBhcnQgPSBmcGFydHNbaV07XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4odmFsKSl7XHJcblx0XHRcdFx0XHRcdHN3aXRjaCAocGFydCl7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnTU0nOlxyXG5cdFx0XHRcdFx0XHRcdFx0ZmlsdGVyZWQgPSAkKGRhdGVzW2xhbmd1YWdlXS5tb250aHMpLmZpbHRlcihtYXRjaF9wYXJ0KTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykgKyAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnTSc6XHJcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KS5maWx0ZXIobWF0Y2hfcGFydCk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSAkLmluQXJyYXkoZmlsdGVyZWRbMF0sIGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydCkgKyAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHBhcnNlZFtwYXJ0XSA9IHZhbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIF9kYXRlLCBzO1xyXG5cdFx0XHRcdGZvciAoaT0wOyBpIDwgc2V0dGVyc19vcmRlci5sZW5ndGg7IGkrKyl7XHJcblx0XHRcdFx0XHRzID0gc2V0dGVyc19vcmRlcltpXTtcclxuXHRcdFx0XHRcdGlmIChzIGluIHBhcnNlZCAmJiAhaXNOYU4ocGFyc2VkW3NdKSl7XHJcblx0XHRcdFx0XHRcdF9kYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcblx0XHRcdFx0XHRcdHNldHRlcnNfbWFwW3NdKF9kYXRlLCBwYXJzZWRbc10pO1xyXG5cdFx0XHRcdFx0XHRpZiAoIWlzTmFOKF9kYXRlKSlcclxuXHRcdFx0XHRcdFx0XHRkYXRlID0gX2RhdGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBkYXRlO1xyXG5cdFx0fSxcclxuXHRcdGZvcm1hdERhdGU6IGZ1bmN0aW9uKGRhdGUsIGZvcm1hdCwgbGFuZ3VhZ2Upe1xyXG5cdFx0XHRpZiAoIWRhdGUpXHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHRpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpXHJcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcclxuXHRcdFx0aWYgKGZvcm1hdC50b0Rpc3BsYXkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnRvRGlzcGxheShkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKTtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHtcclxuXHRcdFx0XHRkOiBkYXRlLmdldFVUQ0RhdGUoKSxcclxuXHRcdFx0XHREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1Nob3J0W2RhdGUuZ2V0VVRDRGF5KCldLFxyXG5cdFx0XHRcdEREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1tkYXRlLmdldFVUQ0RheSgpXSxcclxuXHRcdFx0XHRtOiBkYXRlLmdldFVUQ01vbnRoKCkgKyAxLFxyXG5cdFx0XHRcdE06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydFtkYXRlLmdldFVUQ01vbnRoKCldLFxyXG5cdFx0XHRcdE1NOiBkYXRlc1tsYW5ndWFnZV0ubW9udGhzW2RhdGUuZ2V0VVRDTW9udGgoKV0sXHJcblx0XHRcdFx0eXk6IGRhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcclxuXHRcdFx0XHR5eXl5OiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcclxuXHRcdFx0fTtcclxuXHRcdFx0dmFsLmRkID0gKHZhbC5kIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwuZDtcclxuXHRcdFx0dmFsLm1tID0gKHZhbC5tIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwubTtcclxuXHRcdFx0ZGF0ZSA9IFtdO1xyXG5cdFx0XHR2YXIgc2VwcyA9ICQuZXh0ZW5kKFtdLCBmb3JtYXQuc2VwYXJhdG9ycyk7XHJcblx0XHRcdGZvciAodmFyIGk9MCwgY250ID0gZm9ybWF0LnBhcnRzLmxlbmd0aDsgaSA8PSBjbnQ7IGkrKyl7XHJcblx0XHRcdFx0aWYgKHNlcHMubGVuZ3RoKVxyXG5cdFx0XHRcdFx0ZGF0ZS5wdXNoKHNlcHMuc2hpZnQoKSk7XHJcblx0XHRcdFx0ZGF0ZS5wdXNoKHZhbFtmb3JtYXQucGFydHNbaV1dKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZS5qb2luKCcnKTtcclxuXHRcdH0sXHJcblx0XHRoZWFkVGVtcGxhdGU6ICc8dGhlYWQ+JytcclxuXHRcdFx0ICAgICAgICAgICAgICAnPHRyPicrXHJcblx0XHRcdCAgICAgICAgICAgICAgICAnPHRoIGNvbHNwYW49XCI3XCIgY2xhc3M9XCJkYXRlcGlja2VyLXRpdGxlXCI+PC90aD4nK1xyXG5cdFx0XHQgICAgICAgICAgICAgICc8L3RyPicrXHJcblx0XHRcdFx0XHRcdFx0Jzx0cj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjbGFzcz1cInByZXZcIj4nK2RlZmF1bHRzLnRlbXBsYXRlcy5sZWZ0QXJyb3crJzwvdGg+JytcclxuXHRcdFx0XHRcdFx0XHRcdCc8dGggY29sc3Bhbj1cIjVcIiBjbGFzcz1cImRhdGVwaWNrZXItc3dpdGNoXCI+PC90aD4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjbGFzcz1cIm5leHRcIj4nK2RlZmF1bHRzLnRlbXBsYXRlcy5yaWdodEFycm93Kyc8L3RoPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvdHI+JytcclxuXHRcdFx0XHRcdFx0JzwvdGhlYWQ+JyxcclxuXHRcdGNvbnRUZW1wbGF0ZTogJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+JyxcclxuXHRcdGZvb3RUZW1wbGF0ZTogJzx0Zm9vdD4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8dHI+JytcclxuXHRcdFx0XHRcdFx0XHRcdCc8dGggY29sc3Bhbj1cIjdcIiBjbGFzcz1cInRvZGF5XCI+PC90aD4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8L3RyPicrXHJcblx0XHRcdFx0XHRcdFx0Jzx0cj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwiY2xlYXJcIj48L3RoPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvdHI+JytcclxuXHRcdFx0XHRcdFx0JzwvdGZvb3Q+J1xyXG5cdH07XHJcblx0RFBHbG9iYWwudGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXJcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1kYXlzXCI+JytcclxuXHRcdFx0XHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHRcdCc8dGJvZHk+PC90Ym9keT4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1tb250aHNcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuY29udFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci15ZWFyc1wiPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JytcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXHJcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRlY2FkZXNcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuY29udFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlci1jZW50dXJpZXNcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuY29udFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5mb290VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xyXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xyXG5cdFx0XHRcdFx0XHQnPC9kaXY+JztcclxuXHJcblx0JC5mbi5kYXRlcGlja2VyLkRQR2xvYmFsID0gRFBHbG9iYWw7XHJcblxyXG5cclxuXHQvKiBEQVRFUElDS0VSIE5PIENPTkZMSUNUXHJcblx0KiA9PT09PT09PT09PT09PT09PT09ICovXHJcblxyXG5cdCQuZm4uZGF0ZXBpY2tlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKXtcclxuXHRcdCQuZm4uZGF0ZXBpY2tlciA9IG9sZDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qIERBVEVQSUNLRVIgVkVSU0lPTlxyXG5cdCAqID09PT09PT09PT09PT09PT09PT0gKi9cclxuXHQkLmZuLmRhdGVwaWNrZXIudmVyc2lvbiA9ICcxLjcuMSc7XHJcblxyXG5cdCQuZm4uZGF0ZXBpY2tlci5kZXByZWNhdGVkID0gZnVuY3Rpb24obXNnKXtcclxuXHRcdHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XHJcblx0XHRpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuXHRcdFx0Y29uc29sZS53YXJuKCdERVBSRUNBVEVEOiAnICsgbXNnKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0LyogREFURVBJQ0tFUiBEQVRBLUFQSVxyXG5cdCogPT09PT09PT09PT09PT09PT09ICovXHJcblxyXG5cdCQoZG9jdW1lbnQpLm9uKFxyXG5cdFx0J2ZvY3VzLmRhdGVwaWNrZXIuZGF0YS1hcGkgY2xpY2suZGF0ZXBpY2tlci5kYXRhLWFwaScsXHJcblx0XHQnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXJcIl0nLFxyXG5cdFx0ZnVuY3Rpb24oZSl7XHJcblx0XHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XHJcblx0XHRcdGlmICgkdGhpcy5kYXRhKCdkYXRlcGlja2VyJykpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdC8vIGNvbXBvbmVudCBjbGljayByZXF1aXJlcyB1cyB0byBleHBsaWNpdGx5IHNob3cgaXRcclxuXHRcdFx0ZGF0ZXBpY2tlclBsdWdpbi5jYWxsKCR0aGlzLCAnc2hvdycpO1xyXG5cdFx0fVxyXG5cdCk7XHJcblx0JChmdW5jdGlvbigpe1xyXG5cdFx0ZGF0ZXBpY2tlclBsdWdpbi5jYWxsKCQoJ1tkYXRhLXByb3ZpZGU9XCJkYXRlcGlja2VyLWlubGluZVwiXScpKTtcclxuXHR9KTtcclxuXHJcbn0pKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLWRhdGVwaWNrZXIvZGlzdC9qcy9ib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLWRhdGVwaWNrZXIvZGlzdC9qcy9ib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAzIiwiLyoqXHJcbiogQHZlcnNpb246IDIuMS4yNVxyXG4qIEBhdXRob3I6IERhbiBHcm9zc21hbiBodHRwOi8vd3d3LmRhbmdyb3NzbWFuLmluZm8vXHJcbiogQGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgRGFuIEdyb3NzbWFuLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4qIEBsaWNlbnNlOiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG4qIEB3ZWJzaXRlOiBodHRwOi8vd3d3LmRhdGVyYW5nZXBpY2tlci5jb20vXHJcbiovXHJcbi8vIEZvbGxvdyB0aGUgVU1EIHRlbXBsYXRlIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvdGVtcGxhdGVzL3JldHVybkV4cG9ydHNHbG9iYWwuanNcclxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBNYWtlIGdsb2JhbHkgYXZhaWxhYmxlIGFzIHdlbGxcclxuICAgICAgICBkZWZpbmUoWydtb21lbnQnLCAnanF1ZXJ5J10sIGZ1bmN0aW9uIChtb21lbnQsIGpxdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHJvb3QuZGF0ZXJhbmdlcGlja2VyID0gZmFjdG9yeShtb21lbnQsIGpxdWVyeSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIC8vIE5vZGUgLyBCcm93c2VyaWZ5XHJcbiAgICAgICAgLy9pc29tb3JwaGljIGlzc3VlXHJcbiAgICAgICAgdmFyIGpRdWVyeSA9ICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5qUXVlcnkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKCFqUXVlcnkpIHtcclxuICAgICAgICAgICAgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LmZuKSBqUXVlcnkuZm4gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vbWVudCA9ICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubW9tZW50ICE9ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5tb21lbnQgOiByZXF1aXJlKCdtb21lbnQnKTtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkobW9tZW50LCBqUXVlcnkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICByb290LmRhdGVyYW5nZXBpY2tlciA9IGZhY3Rvcnkocm9vdC5tb21lbnQsIHJvb3QualF1ZXJ5KTtcclxuICAgIH1cclxufSh0aGlzLCBmdW5jdGlvbihtb21lbnQsICQpIHtcclxuICAgIHZhciBEYXRlUmFuZ2VQaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zLCBjYikge1xyXG5cclxuICAgICAgICAvL2RlZmF1bHQgc2V0dGluZ3MgZm9yIG9wdGlvbnNcclxuICAgICAgICB0aGlzLnBhcmVudEVsID0gJ2JvZHknO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5zdGFydERhdGUgPSBtb21lbnQoKS5zdGFydE9mKCdkYXknKTtcclxuICAgICAgICB0aGlzLmVuZERhdGUgPSBtb21lbnQoKS5lbmRPZignZGF5Jyk7XHJcbiAgICAgICAgdGhpcy5taW5EYXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kYXRlTGltaXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF1dG9BcHBseSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2luZ2xlRGF0ZVBpY2tlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3ducyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvd1dlZWtOdW1iZXJzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaG93SVNPV2Vla051bWJlcnMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3dDdXN0b21SYW5nZUxhYmVsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRpbWVQaWNrZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRpbWVQaWNrZXIyNEhvdXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQgPSAxO1xyXG4gICAgICAgIHRoaXMudGltZVBpY2tlclNlY29uZHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxpbmtlZENhbGVuZGFycyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlSW5wdXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWx3YXlzU2hvd0NhbGVuZGFycyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmFuZ2VzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMub3BlbnMgPSAncmlnaHQnO1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ3B1bGwtcmlnaHQnKSlcclxuICAgICAgICAgICAgdGhpcy5vcGVucyA9ICdsZWZ0JztcclxuXHJcbiAgICAgICAgdGhpcy5kcm9wcyA9ICdkb3duJztcclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0NsYXNzKCdkcm9wdXAnKSlcclxuICAgICAgICAgICAgdGhpcy5kcm9wcyA9ICd1cCc7XHJcblxyXG4gICAgICAgIHRoaXMuYnV0dG9uQ2xhc3NlcyA9ICdidG4gYnRuLXNtJztcclxuICAgICAgICB0aGlzLmFwcGx5Q2xhc3MgPSAnYnRuLXN1Y2Nlc3MnO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsQ2xhc3MgPSAnYnRuLWRlZmF1bHQnO1xyXG5cclxuICAgICAgICB0aGlzLmxvY2FsZSA9IHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnbHRyJyxcclxuICAgICAgICAgICAgZm9ybWF0OiBtb21lbnQubG9jYWxlRGF0YSgpLmxvbmdEYXRlRm9ybWF0KCdMJyksXHJcbiAgICAgICAgICAgIHNlcGFyYXRvcjogJyAtICcsXHJcbiAgICAgICAgICAgIGFwcGx5TGFiZWw6ICdBcHBseScsXHJcbiAgICAgICAgICAgIGNhbmNlbExhYmVsOiAnQ2FuY2VsJyxcclxuICAgICAgICAgICAgd2Vla0xhYmVsOiAnVycsXHJcbiAgICAgICAgICAgIGN1c3RvbVJhbmdlTGFiZWw6ICdDdXN0b20gUmFuZ2UnLFxyXG4gICAgICAgICAgICBkYXlzT2ZXZWVrOiBtb21lbnQud2Vla2RheXNNaW4oKSxcclxuICAgICAgICAgICAgbW9udGhOYW1lczogbW9tZW50Lm1vbnRoc1Nob3J0KCksXHJcbiAgICAgICAgICAgIGZpcnN0RGF5OiBtb21lbnQubG9jYWxlRGF0YSgpLmZpcnN0RGF5T2ZXZWVrKClcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24oKSB7IH07XHJcblxyXG4gICAgICAgIC8vc29tZSBzdGF0ZSBpbmZvcm1hdGlvblxyXG4gICAgICAgIHRoaXMuaXNTaG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIgPSB7fTtcclxuICAgICAgICB0aGlzLnJpZ2h0Q2FsZW5kYXIgPSB7fTtcclxuXHJcbiAgICAgICAgLy9jdXN0b20gb3B0aW9ucyBmcm9tIHVzZXJcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuXHJcbiAgICAgICAgLy9hbGxvdyBzZXR0aW5nIG9wdGlvbnMgd2l0aCBkYXRhIGF0dHJpYnV0ZXNcclxuICAgICAgICAvL2RhdGEtYXBpIG9wdGlvbnMgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIGN1c3RvbSBqYXZhc2NyaXB0IG9wdGlvbnNcclxuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQodGhpcy5lbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vaHRtbCB0ZW1wbGF0ZSBmb3IgdGhlIHBpY2tlciBVSVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSAhPT0gJ3N0cmluZycgJiYgIShvcHRpb25zLnRlbXBsYXRlIGluc3RhbmNlb2YgJCkpXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSAnPGRpdiBjbGFzcz1cImRhdGVyYW5nZXBpY2tlciBkcm9wZG93bi1tZW51XCI+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImNhbGVuZGFyIGxlZnRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVyYW5nZXBpY2tlcl9pbnB1dFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cImlucHV0LW1pbmkgZm9ybS1jb250cm9sXCIgdHlwZT1cInRleHRcIiBuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XCIgdmFsdWU9XCJcIiAvPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtY2FsZW5kYXIgZ2x5cGhpY29uIGdseXBoaWNvbi1jYWxlbmRhclwiPjwvaT4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXItdGltZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtY2xvY2stbyBnbHlwaGljb24gZ2x5cGhpY29uLXRpbWVcIj48L2k+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXItdGFibGVcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXIgcmlnaHRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImRhdGVyYW5nZXBpY2tlcl9pbnB1dFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzxpbnB1dCBjbGFzcz1cImlucHV0LW1pbmkgZm9ybS1jb250cm9sXCIgdHlwZT1cInRleHRcIiBuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX2VuZFwiIHZhbHVlPVwiXCIgLz4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNhbGVuZGFyIGdseXBoaWNvbiBnbHlwaGljb24tY2FsZW5kYXJcIj48L2k+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImNhbGVuZGFyLXRpbWVcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXY+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNsb2NrLW8gZ2x5cGhpY29uIGdseXBoaWNvbi10aW1lXCI+PC9pPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImNhbGVuZGFyLXRhYmxlXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJhbmdlc1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmFuZ2VfaW5wdXRzXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8YnV0dG9uIGNsYXNzPVwiYXBwbHlCdG5cIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxidXR0b24gY2xhc3M9XCJjYW5jZWxCdG5cIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JztcclxuXHJcbiAgICAgICAgdGhpcy5wYXJlbnRFbCA9IChvcHRpb25zLnBhcmVudEVsICYmICQob3B0aW9ucy5wYXJlbnRFbCkubGVuZ3RoKSA/ICQob3B0aW9ucy5wYXJlbnRFbCkgOiAkKHRoaXMucGFyZW50RWwpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gJChvcHRpb25zLnRlbXBsYXRlKS5hcHBlbmRUbyh0aGlzLnBhcmVudEVsKTtcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBwb3NzaWJsZSBvcHRpb25zIG92ZXJyaWRpbmcgZGVmYXVsdHNcclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5kaXJlY3Rpb24gPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuZGlyZWN0aW9uID0gb3B0aW9ucy5sb2NhbGUuZGlyZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5mb3JtYXQgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuZm9ybWF0ID0gb3B0aW9ucy5sb2NhbGUuZm9ybWF0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5zZXBhcmF0b3IgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuc2VwYXJhdG9yID0gb3B0aW9ucy5sb2NhbGUuc2VwYXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5kYXlzT2ZXZWVrID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlLmRheXNPZldlZWsgPSBvcHRpb25zLmxvY2FsZS5kYXlzT2ZXZWVrLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLm1vbnRoTmFtZXMgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgIHRoaXMubG9jYWxlLm1vbnRoTmFtZXMgPSBvcHRpb25zLmxvY2FsZS5tb250aE5hbWVzLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLmZpcnN0RGF5ID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICB0aGlzLmxvY2FsZS5maXJzdERheSA9IG9wdGlvbnMubG9jYWxlLmZpcnN0RGF5O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5hcHBseUxhYmVsID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICB0aGlzLmxvY2FsZS5hcHBseUxhYmVsID0gb3B0aW9ucy5sb2NhbGUuYXBwbHlMYWJlbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUuY2FuY2VsTGFiZWwgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgIHRoaXMubG9jYWxlLmNhbmNlbExhYmVsID0gb3B0aW9ucy5sb2NhbGUuY2FuY2VsTGFiZWw7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLndlZWtMYWJlbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUud2Vla0xhYmVsID0gb3B0aW9ucy5sb2NhbGUud2Vla0xhYmVsO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5jdXN0b21SYW5nZUxhYmVsID09PSAnc3RyaW5nJyl7XHJcbiAgICAgICAgICAgICAgICAvL1N1cHBvcnQgdW5pY29kZSBjaGFycyBpbiB0aGUgY3VzdG9tIHJhbmdlIG5hbWUuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XHJcbiAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IG9wdGlvbnMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VIdG1sID0gZWxlbS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWwgPSByYW5nZUh0bWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5sb2NhbGUuZGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0YXJ0RGF0ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gbW9tZW50KG9wdGlvbnMuc3RhcnREYXRlLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZW5kRGF0ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IG1vbWVudChvcHRpb25zLmVuZERhdGUsIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5taW5EYXRlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhpcy5taW5EYXRlID0gbW9tZW50KG9wdGlvbnMubWluRGF0ZSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1heERhdGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aGlzLm1heERhdGUgPSBtb21lbnQob3B0aW9ucy5tYXhEYXRlLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3RhcnREYXRlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSBtb21lbnQob3B0aW9ucy5zdGFydERhdGUpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZW5kRGF0ZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IG1vbWVudChvcHRpb25zLmVuZERhdGUpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWluRGF0ZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHRoaXMubWluRGF0ZSA9IG1vbWVudChvcHRpb25zLm1pbkRhdGUpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4RGF0ZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IG1vbWVudChvcHRpb25zLm1heERhdGUpO1xyXG5cclxuICAgICAgICAvLyBzYW5pdHkgY2hlY2sgZm9yIGJhZCBvcHRpb25zXHJcbiAgICAgICAgaWYgKHRoaXMubWluRGF0ZSAmJiB0aGlzLnN0YXJ0RGF0ZS5pc0JlZm9yZSh0aGlzLm1pbkRhdGUpKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHRoaXMubWluRGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAvLyBzYW5pdHkgY2hlY2sgZm9yIGJhZCBvcHRpb25zXHJcbiAgICAgICAgaWYgKHRoaXMubWF4RGF0ZSAmJiB0aGlzLmVuZERhdGUuaXNBZnRlcih0aGlzLm1heERhdGUpKVxyXG4gICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLm1heERhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmFwcGx5Q2xhc3MgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aGlzLmFwcGx5Q2xhc3MgPSBvcHRpb25zLmFwcGx5Q2xhc3M7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jYW5jZWxDbGFzcyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQ2xhc3MgPSBvcHRpb25zLmNhbmNlbENsYXNzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGF0ZUxpbWl0ID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhpcy5kYXRlTGltaXQgPSBvcHRpb25zLmRhdGVMaW1pdDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9wZW5zID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhpcy5vcGVucyA9IG9wdGlvbnMub3BlbnM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kcm9wcyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMuZHJvcHMgPSBvcHRpb25zLmRyb3BzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2hvd1dlZWtOdW1iZXJzID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1dlZWtOdW1iZXJzID0gb3B0aW9ucy5zaG93V2Vla051bWJlcnM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaG93SVNPV2Vla051bWJlcnMgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy5zaG93SVNPV2Vla051bWJlcnMgPSBvcHRpb25zLnNob3dJU09XZWVrTnVtYmVycztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJ1dHRvbkNsYXNzZXMgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzZXMgPSBvcHRpb25zLmJ1dHRvbkNsYXNzZXM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5idXR0b25DbGFzc2VzID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzc2VzID0gb3B0aW9ucy5idXR0b25DbGFzc2VzLmpvaW4oJyAnKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNob3dEcm9wZG93bnMgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy5zaG93RHJvcGRvd25zID0gb3B0aW9ucy5zaG93RHJvcGRvd25zO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2hvd0N1c3RvbVJhbmdlTGFiZWwgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy5zaG93Q3VzdG9tUmFuZ2VMYWJlbCA9IG9wdGlvbnMuc2hvd0N1c3RvbVJhbmdlTGFiZWw7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGVEYXRlUGlja2VyID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdGhpcy5zaW5nbGVEYXRlUGlja2VyID0gb3B0aW9ucy5zaW5nbGVEYXRlUGlja2VyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW5nbGVEYXRlUGlja2VyKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50aW1lUGlja2VyID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIHRoaXMudGltZVBpY2tlciA9IG9wdGlvbnMudGltZVBpY2tlcjtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVQaWNrZXJTZWNvbmRzID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIHRoaXMudGltZVBpY2tlclNlY29uZHMgPSBvcHRpb25zLnRpbWVQaWNrZXJTZWNvbmRzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGltZVBpY2tlckluY3JlbWVudCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIHRoaXMudGltZVBpY2tlckluY3JlbWVudCA9IG9wdGlvbnMudGltZVBpY2tlckluY3JlbWVudDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVQaWNrZXIyNEhvdXIgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy50aW1lUGlja2VyMjRIb3VyID0gb3B0aW9ucy50aW1lUGlja2VyMjRIb3VyO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYXV0b0FwcGx5ID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIHRoaXMuYXV0b0FwcGx5ID0gb3B0aW9ucy5hdXRvQXBwbHk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdXRvVXBkYXRlSW5wdXQgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy5hdXRvVXBkYXRlSW5wdXQgPSBvcHRpb25zLmF1dG9VcGRhdGVJbnB1dDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmtlZENhbGVuZGFycyA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLmxpbmtlZENhbGVuZGFycyA9IG9wdGlvbnMubGlua2VkQ2FsZW5kYXJzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaXNJbnZhbGlkRGF0ZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgdGhpcy5pc0ludmFsaWREYXRlID0gb3B0aW9ucy5pc0ludmFsaWREYXRlO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaXNDdXN0b21EYXRlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICB0aGlzLmlzQ3VzdG9tRGF0ZSA9IG9wdGlvbnMuaXNDdXN0b21EYXRlO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWx3YXlzU2hvd0NhbGVuZGFycyA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLmFsd2F5c1Nob3dDYWxlbmRhcnMgPSBvcHRpb25zLmFsd2F5c1Nob3dDYWxlbmRhcnM7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBkYXkgbmFtZXMgb3JkZXIgdG8gZmlyc3REYXlcclxuICAgICAgICBpZiAodGhpcy5sb2NhbGUuZmlyc3REYXkgIT0gMCkge1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmxvY2FsZS5maXJzdERheTtcclxuICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuZGF5c09mV2Vlay5wdXNoKHRoaXMubG9jYWxlLmRheXNPZldlZWsuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc3RhcnQsIGVuZCwgcmFuZ2U7XHJcblxyXG4gICAgICAgIC8vaWYgbm8gc3RhcnQvZW5kIGRhdGVzIHNldCwgY2hlY2sgaWYgYW4gaW5wdXQgZWxlbWVudCBjb250YWlucyBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdGFydERhdGUgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRpb25zLmVuZERhdGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlmICgkKHRoaXMuZWxlbWVudCkuaXMoJ2lucHV0W3R5cGU9dGV4dF0nKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9ICQodGhpcy5lbGVtZW50KS52YWwoKSxcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHZhbC5zcGxpdCh0aGlzLmxvY2FsZS5zZXBhcmF0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1vbWVudChzcGxpdFswXSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtb21lbnQoc3BsaXRbMV0sIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2luZ2xlRGF0ZVBpY2tlciAmJiB2YWwgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1vbWVudCh2YWwsIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbW9tZW50KHZhbCwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCAhPT0gbnVsbCAmJiBlbmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXJ0RGF0ZShzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbmREYXRlKGVuZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yYW5nZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZvciAocmFuZ2UgaW4gb3B0aW9ucy5yYW5nZXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmFuZ2VzW3JhbmdlXVswXSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtb21lbnQob3B0aW9ucy5yYW5nZXNbcmFuZ2VdWzBdLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KG9wdGlvbnMucmFuZ2VzW3JhbmdlXVswXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJhbmdlc1tyYW5nZV1bMV0gPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IG1vbWVudChvcHRpb25zLnJhbmdlc1tyYW5nZV1bMV0sIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbW9tZW50KG9wdGlvbnMucmFuZ2VzW3JhbmdlXVsxXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHN0YXJ0IG9yIGVuZCBkYXRlIGV4Y2VlZCB0aG9zZSBhbGxvd2VkIGJ5IHRoZSBtaW5EYXRlIG9yIGRhdGVMaW1pdFxyXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9ucywgc2hvcnRlbiB0aGUgcmFuZ2UgdG8gdGhlIGFsbG93YWJsZSBwZXJpb2QuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5EYXRlICYmIHN0YXJ0LmlzQmVmb3JlKHRoaXMubWluRGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm1pbkRhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4RGF0ZSA9IHRoaXMubWF4RGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGVMaW1pdCAmJiBtYXhEYXRlICYmIHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGF0ZUxpbWl0KS5pc0FmdGVyKG1heERhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIG1heERhdGUgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRhdGVMaW1pdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4RGF0ZSAmJiBlbmQuaXNBZnRlcihtYXhEYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtYXhEYXRlLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVuZCBvZiB0aGUgcmFuZ2UgaXMgYmVmb3JlIHRoZSBtaW5pbXVtIG9yIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgaXNcclxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBtYXhpbXVtLCBkb24ndCBkaXNwbGF5IHRoaXMgcmFuZ2Ugb3B0aW9uIGF0IGFsbC5cclxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5taW5EYXRlICYmIGVuZC5pc0JlZm9yZSh0aGlzLm1pbkRhdGUsIHRoaXMudGltZXBpY2tlciA/ICdtaW51dGUnIDogJ2RheScpKSBcclxuICAgICAgICAgICAgICAgICAgfHwgKG1heERhdGUgJiYgc3RhcnQuaXNBZnRlcihtYXhEYXRlLCB0aGlzLnRpbWVwaWNrZXIgPyAnbWludXRlJyA6ICdkYXknKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9TdXBwb3J0IHVuaWNvZGUgY2hhcnMgaW4gdGhlIHJhbmdlIG5hbWVzLlxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xyXG4gICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPSByYW5nZTtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZUh0bWwgPSBlbGVtLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VzW3JhbmdlSHRtbF0gPSBbc3RhcnQsIGVuZF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gJzx1bD4nO1xyXG4gICAgICAgICAgICBmb3IgKHJhbmdlIGluIHRoaXMucmFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ICs9ICc8bGkgZGF0YS1yYW5nZS1rZXk9XCInICsgcmFuZ2UgKyAnXCI+JyArIHJhbmdlICsgJzwvbGk+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93Q3VzdG9tUmFuZ2VMYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdCArPSAnPGxpIGRhdGEtcmFuZ2Uta2V5PVwiJyArIHRoaXMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWwgKyAnXCI+JyArIHRoaXMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWwgKyAnPC9saT4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3QgKz0gJzwvdWw+JztcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcycpLnByZXBlbmQobGlzdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gdGhpcy5zdGFydERhdGUuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMuZW5kRGF0ZS5lbmRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci10aW1lJykuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jYW4ndCBiZSB1c2VkIHRvZ2V0aGVyIGZvciBub3dcclxuICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyICYmIHRoaXMuYXV0b0FwcGx5KVxyXG4gICAgICAgICAgICB0aGlzLmF1dG9BcHBseSA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hdXRvQXBwbHkgJiYgdHlwZW9mIG9wdGlvbnMucmFuZ2VzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcucmFuZ2VzJykuaGlkZSgpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvQXBwbHkpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmFwcGx5QnRuLCAuY2FuY2VsQnRuJykuYWRkQ2xhc3MoJ2hpZGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZURhdGVQaWNrZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ3NpbmdsZScpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuY2FsZW5kYXIubGVmdCcpLmFkZENsYXNzKCdzaW5nbGUnKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyLmxlZnQnKS5zaG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci5yaWdodCcpLmhpZGUoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmRhdGVyYW5nZXBpY2tlcl9pbnB1dCBpbnB1dCwgLmRhdGVyYW5nZXBpY2tlcl9pbnB1dCA+IGknKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yYW5nZXMgdWwnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcucmFuZ2VzJykuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKHR5cGVvZiBvcHRpb25zLnJhbmdlcyA9PT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc2luZ2xlRGF0ZVBpY2tlcikgfHwgdGhpcy5hbHdheXNTaG93Q2FsZW5kYXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdzaG93LWNhbGVuZGFyJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnb3BlbnMnICsgdGhpcy5vcGVucyk7XHJcblxyXG4gICAgICAgIC8vc3dhcCB0aGUgcG9zaXRpb24gb2YgdGhlIHByZWRlZmluZWQgcmFuZ2VzIGlmIG9wZW5zIHJpZ2h0XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJhbmdlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcGVucyA9PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yYW5nZXMnKS5wcmVwZW5kVG8oIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci5sZWZ0JykucGFyZW50KCkgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYXBwbHkgQ1NTIGNsYXNzZXMgYW5kIGxhYmVscyB0byBidXR0b25zXHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmFwcGx5QnRuLCAuY2FuY2VsQnRuJykuYWRkQ2xhc3ModGhpcy5idXR0b25DbGFzc2VzKTtcclxuICAgICAgICBpZiAodGhpcy5hcHBseUNsYXNzLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmFwcGx5QnRuJykuYWRkQ2xhc3ModGhpcy5hcHBseUNsYXNzKTtcclxuICAgICAgICBpZiAodGhpcy5jYW5jZWxDbGFzcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYW5jZWxCdG4nKS5hZGRDbGFzcyh0aGlzLmNhbmNlbENsYXNzKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuYXBwbHlCdG4nKS5odG1sKHRoaXMubG9jYWxlLmFwcGx5TGFiZWwpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYW5jZWxCdG4nKS5odG1sKHRoaXMubG9jYWxlLmNhbmNlbExhYmVsKTtcclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuY2FsZW5kYXInKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICcucHJldicsICQucHJveHkodGhpcy5jbGlja1ByZXYsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICcubmV4dCcsICQucHJveHkodGhpcy5jbGlja05leHQsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bi5kYXRlcmFuZ2VwaWNrZXInLCAndGQuYXZhaWxhYmxlJywgJC5wcm94eSh0aGlzLmNsaWNrRGF0ZSwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VlbnRlci5kYXRlcmFuZ2VwaWNrZXInLCAndGQuYXZhaWxhYmxlJywgJC5wcm94eSh0aGlzLmhvdmVyRGF0ZSwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZS5kYXRlcmFuZ2VwaWNrZXInLCAndGQuYXZhaWxhYmxlJywgJC5wcm94eSh0aGlzLnVwZGF0ZUZvcm1JbnB1dHMsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2NoYW5nZS5kYXRlcmFuZ2VwaWNrZXInLCAnc2VsZWN0LnllYXJzZWxlY3QnLCAkLnByb3h5KHRoaXMubW9udGhPclllYXJDaGFuZ2VkLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdjaGFuZ2UuZGF0ZXJhbmdlcGlja2VyJywgJ3NlbGVjdC5tb250aHNlbGVjdCcsICQucHJveHkodGhpcy5tb250aE9yWWVhckNoYW5nZWQsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2NoYW5nZS5kYXRlcmFuZ2VwaWNrZXInLCAnc2VsZWN0LmhvdXJzZWxlY3Qsc2VsZWN0Lm1pbnV0ZXNlbGVjdCxzZWxlY3Quc2Vjb25kc2VsZWN0LHNlbGVjdC5hbXBtc2VsZWN0JywgJC5wcm94eSh0aGlzLnRpbWVDaGFuZ2VkLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdjbGljay5kYXRlcmFuZ2VwaWNrZXInLCAnLmRhdGVyYW5nZXBpY2tlcl9pbnB1dCBpbnB1dCcsICQucHJveHkodGhpcy5zaG93Q2FsZW5kYXJzLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdmb2N1cy5kYXRlcmFuZ2VwaWNrZXInLCAnLmRhdGVyYW5nZXBpY2tlcl9pbnB1dCBpbnB1dCcsICQucHJveHkodGhpcy5mb3JtSW5wdXRzRm9jdXNlZCwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignYmx1ci5kYXRlcmFuZ2VwaWNrZXInLCAnLmRhdGVyYW5nZXBpY2tlcl9pbnB1dCBpbnB1dCcsICQucHJveHkodGhpcy5mb3JtSW5wdXRzQmx1cnJlZCwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignY2hhbmdlLmRhdGVyYW5nZXBpY2tlcicsICcuZGF0ZXJhbmdlcGlja2VyX2lucHV0IGlucHV0JywgJC5wcm94eSh0aGlzLmZvcm1JbnB1dHNDaGFuZ2VkLCB0aGlzKSk7XHJcblxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yYW5nZXMnKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICdidXR0b24uYXBwbHlCdG4nLCAkLnByb3h5KHRoaXMuY2xpY2tBcHBseSwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJ2J1dHRvbi5jYW5jZWxCdG4nLCAkLnByb3h5KHRoaXMuY2xpY2tDYW5jZWwsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICdsaScsICQucHJveHkodGhpcy5jbGlja1JhbmdlLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZWVudGVyLmRhdGVyYW5nZXBpY2tlcicsICdsaScsICQucHJveHkodGhpcy5ob3ZlclJhbmdlLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlLmRhdGVyYW5nZXBpY2tlcicsICdsaScsICQucHJveHkodGhpcy51cGRhdGVGb3JtSW5wdXRzLCB0aGlzKSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2lucHV0JykgfHwgdGhpcy5lbGVtZW50LmlzKCdidXR0b24nKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQub24oe1xyXG4gICAgICAgICAgICAgICAgJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcic6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICdmb2N1cy5kYXRlcmFuZ2VwaWNrZXInOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAna2V5dXAuZGF0ZXJhbmdlcGlja2VyJzogJC5wcm94eSh0aGlzLmVsZW1lbnRDaGFuZ2VkLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICdrZXlkb3duLmRhdGVyYW5nZXBpY2tlcic6ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICQucHJveHkodGhpcy50b2dnbGUsIHRoaXMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gaWYgYXR0YWNoZWQgdG8gYSB0ZXh0IGlucHV0LCBzZXQgdGhlIGluaXRpYWwgdmFsdWVcclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpICYmICF0aGlzLnNpbmdsZURhdGVQaWNrZXIgJiYgdGhpcy5hdXRvVXBkYXRlSW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnZhbCh0aGlzLnN0YXJ0RGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSArIHRoaXMubG9jYWxlLnNlcGFyYXRvciArIHRoaXMuZW5kRGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5pcygnaW5wdXQnKSAmJiB0aGlzLmF1dG9VcGRhdGVJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudmFsKHRoaXMuc3RhcnREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIERhdGVSYW5nZVBpY2tlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEYXRlUmFuZ2VQaWNrZXIsXHJcblxyXG4gICAgICAgIHNldFN0YXJ0RGF0ZTogZnVuY3Rpb24oc3RhcnREYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnREYXRlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gbW9tZW50KHN0YXJ0RGF0ZSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnREYXRlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gbW9tZW50KHN0YXJ0RGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcilcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gdGhpcy5zdGFydERhdGUuc3RhcnRPZignZGF5Jyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyICYmIHRoaXMudGltZVBpY2tlckluY3JlbWVudClcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlLm1pbnV0ZShNYXRoLnJvdW5kKHRoaXMuc3RhcnREYXRlLm1pbnV0ZSgpIC8gdGhpcy50aW1lUGlja2VySW5jcmVtZW50KSAqIHRoaXMudGltZVBpY2tlckluY3JlbWVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5taW5EYXRlICYmIHRoaXMuc3RhcnREYXRlLmlzQmVmb3JlKHRoaXMubWluRGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gdGhpcy5taW5EYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyICYmIHRoaXMudGltZVBpY2tlckluY3JlbWVudClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZS5taW51dGUoTWF0aC5yb3VuZCh0aGlzLnN0YXJ0RGF0ZS5taW51dGUoKSAvIHRoaXMudGltZVBpY2tlckluY3JlbWVudCkgKiB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEYXRlICYmIHRoaXMuc3RhcnREYXRlLmlzQWZ0ZXIodGhpcy5tYXhEYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSB0aGlzLm1heERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIgJiYgdGhpcy50aW1lUGlja2VySW5jcmVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlLm1pbnV0ZShNYXRoLmZsb29yKHRoaXMuc3RhcnREYXRlLm1pbnV0ZSgpIC8gdGhpcy50aW1lUGlja2VySW5jcmVtZW50KSAqIHRoaXMudGltZVBpY2tlckluY3JlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Nob3dpbmcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9udGhzSW5WaWV3KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0RW5kRGF0ZTogZnVuY3Rpb24oZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZERhdGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gbW9tZW50KGVuZERhdGUsIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZERhdGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gbW9tZW50KGVuZERhdGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVQaWNrZXIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLmVuZERhdGUuZW5kT2YoJ2RheScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZVBpY2tlciAmJiB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUubWludXRlKE1hdGgucm91bmQodGhpcy5lbmREYXRlLm1pbnV0ZSgpIC8gdGhpcy50aW1lUGlja2VySW5jcmVtZW50KSAqIHRoaXMudGltZVBpY2tlckluY3JlbWVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlLmlzQmVmb3JlKHRoaXMuc3RhcnREYXRlKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEYXRlICYmIHRoaXMuZW5kRGF0ZS5pc0FmdGVyKHRoaXMubWF4RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLm1heERhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGVMaW1pdCAmJiB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpLmFkZCh0aGlzLmRhdGVMaW1pdCkuaXNCZWZvcmUodGhpcy5lbmREYXRlKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCkuYWRkKHRoaXMuZGF0ZUxpbWl0KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNSaWdodFRpbWUgPSB0aGlzLmVuZERhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Nob3dpbmcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9udGhzSW5WaWV3KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNJbnZhbGlkRGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0N1c3RvbURhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlVmlldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGltZVBpY2tlcignbGVmdCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaW1lUGlja2VyKCdyaWdodCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuZERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLmNhbGVuZGFyLXRpbWUgc2VsZWN0JykuYXR0cignZGlzYWJsZWQnLCAnZGlzYWJsZWQnKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLnJpZ2h0IC5jYWxlbmRhci10aW1lIHNlbGVjdCcpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9lbmRcIl0nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XCJdJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9lbmRcIl0nKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XCJdJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9udGhzSW5WaWV3KCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsZW5kYXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUlucHV0cygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZU1vbnRoc0luVmlldzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIGJvdGggZGF0ZXMgYXJlIHZpc2libGUgYWxyZWFkeSwgZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNpbmdsZURhdGVQaWNrZXIgJiYgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGggJiYgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTScpID09IHRoaXMubGVmdENhbGVuZGFyLm1vbnRoLmZvcm1hdCgnWVlZWS1NTScpIHx8IHRoaXMuc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTScpID09IHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5mb3JtYXQoJ1lZWVktTU0nKSlcclxuICAgICAgICAgICAgICAgICAgICAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmVuZERhdGUuZm9ybWF0KCdZWVlZLU1NJykgPT0gdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGguZm9ybWF0KCdZWVlZLU1NJykgfHwgdGhpcy5lbmREYXRlLmZvcm1hdCgnWVlZWS1NTScpID09IHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5mb3JtYXQoJ1lZWVktTU0nKSlcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGggPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpLmRhdGUoMik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGlua2VkQ2FsZW5kYXJzICYmICh0aGlzLmVuZERhdGUubW9udGgoKSAhPSB0aGlzLnN0YXJ0RGF0ZS5tb250aCgpIHx8IHRoaXMuZW5kRGF0ZS55ZWFyKCkgIT0gdGhpcy5zdGFydERhdGUueWVhcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aCA9IHRoaXMuZW5kRGF0ZS5jbG9uZSgpLmRhdGUoMik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aCA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCkuZGF0ZSgyKS5hZGQoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdENhbGVuZGFyLm1vbnRoLmZvcm1hdCgnWVlZWS1NTScpICE9IHRoaXMuc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTScpICYmIHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5mb3JtYXQoJ1lZWVktTU0nKSAhPSB0aGlzLnN0YXJ0RGF0ZS5mb3JtYXQoJ1lZWVktTU0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdENhbGVuZGFyLm1vbnRoID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKS5kYXRlKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aCA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCkuZGF0ZSgyKS5hZGQoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4RGF0ZSAmJiB0aGlzLmxpbmtlZENhbGVuZGFycyAmJiAhdGhpcy5zaW5nbGVEYXRlUGlja2VyICYmIHRoaXMucmlnaHRDYWxlbmRhci5tb250aCA+IHRoaXMubWF4RGF0ZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aCA9IHRoaXMubWF4RGF0ZS5jbG9uZSgpLmRhdGUoMik7XHJcbiAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGggPSB0aGlzLm1heERhdGUuY2xvbmUoKS5kYXRlKDIpLnN1YnRyYWN0KDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlQ2FsZW5kYXJzOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBob3VyLCBtaW51dGUsIHNlY29uZDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3VyID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLmxlZnQgLmhvdXJzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5sZWZ0IC5taW51dGVzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZCA9IHRoaXMudGltZVBpY2tlclNlY29uZHMgPyBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcubGVmdCAuc2Vjb25kc2VsZWN0JykudmFsKCksIDEwKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVQaWNrZXIyNEhvdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtcG0gPSB0aGlzLmNvbnRhaW5lci5maW5kKCcubGVmdCAuYW1wbXNlbGVjdCcpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ1BNJyAmJiBob3VyIDwgMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ0FNJyAmJiBob3VyID09PSAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5yaWdodCAuaG91cnNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWludXRlID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLnJpZ2h0IC5taW51dGVzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZCA9IHRoaXMudGltZVBpY2tlclNlY29uZHMgPyBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLnNlY29uZHNlbGVjdCcpLnZhbCgpLCAxMCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbXBtID0gdGhpcy5jb250YWluZXIuZmluZCgnLnJpZ2h0IC5hbXBtc2VsZWN0JykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnUE0nICYmIGhvdXIgPCAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnQU0nICYmIGhvdXIgPT09IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGguaG91cihob3VyKS5taW51dGUobWludXRlKS5zZWNvbmQoc2Vjb25kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5ob3VyKGhvdXIpLm1pbnV0ZShtaW51dGUpLnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNhbGVuZGFyKCdsZWZ0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FsZW5kYXIoJ3JpZ2h0Jyk7XHJcblxyXG4gICAgICAgICAgICAvL2hpZ2hsaWdodCBhbnkgcHJlZGVmaW5lZCByYW5nZSBtYXRjaGluZyB0aGUgY3VycmVudCBzdGFydCBhbmQgZW5kIGRhdGVzXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yYW5nZXMgbGknKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUgPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVDaG9zZW5MYWJlbCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbmRlckNhbGVuZGFyOiBmdW5jdGlvbihzaWRlKSB7XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgbWF0cml4IG9mIGRhdGVzIHRoYXQgd2lsbCBwb3B1bGF0ZSB0aGUgY2FsZW5kYXJcclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIHZhciBjYWxlbmRhciA9IHNpZGUgPT0gJ2xlZnQnID8gdGhpcy5sZWZ0Q2FsZW5kYXIgOiB0aGlzLnJpZ2h0Q2FsZW5kYXI7XHJcbiAgICAgICAgICAgIHZhciBtb250aCA9IGNhbGVuZGFyLm1vbnRoLm1vbnRoKCk7XHJcbiAgICAgICAgICAgIHZhciB5ZWFyID0gY2FsZW5kYXIubW9udGgueWVhcigpO1xyXG4gICAgICAgICAgICB2YXIgaG91ciA9IGNhbGVuZGFyLm1vbnRoLmhvdXIoKTtcclxuICAgICAgICAgICAgdmFyIG1pbnV0ZSA9IGNhbGVuZGFyLm1vbnRoLm1pbnV0ZSgpO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kID0gY2FsZW5kYXIubW9udGguc2Vjb25kKCk7XHJcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IG1vbWVudChbeWVhciwgbW9udGhdKS5kYXlzSW5Nb250aCgpO1xyXG4gICAgICAgICAgICB2YXIgZmlyc3REYXkgPSBtb21lbnQoW3llYXIsIG1vbnRoLCAxXSk7XHJcbiAgICAgICAgICAgIHZhciBsYXN0RGF5ID0gbW9tZW50KFt5ZWFyLCBtb250aCwgZGF5c0luTW9udGhdKTtcclxuICAgICAgICAgICAgdmFyIGxhc3RNb250aCA9IG1vbWVudChmaXJzdERheSkuc3VidHJhY3QoMSwgJ21vbnRoJykubW9udGgoKTtcclxuICAgICAgICAgICAgdmFyIGxhc3RZZWFyID0gbW9tZW50KGZpcnN0RGF5KS5zdWJ0cmFjdCgxLCAnbW9udGgnKS55ZWFyKCk7XHJcbiAgICAgICAgICAgIHZhciBkYXlzSW5MYXN0TW9udGggPSBtb21lbnQoW2xhc3RZZWFyLCBsYXN0TW9udGhdKS5kYXlzSW5Nb250aCgpO1xyXG4gICAgICAgICAgICB2YXIgZGF5T2ZXZWVrID0gZmlyc3REYXkuZGF5KCk7XHJcblxyXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgYSA2IHJvd3MgeCA3IGNvbHVtbnMgYXJyYXkgZm9yIHRoZSBjYWxlbmRhclxyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSBbXTtcclxuICAgICAgICAgICAgY2FsZW5kYXIuZmlyc3REYXkgPSBmaXJzdERheTtcclxuICAgICAgICAgICAgY2FsZW5kYXIubGFzdERheSA9IGxhc3REYXk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJbaV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9wb3B1bGF0ZSB0aGUgY2FsZW5kYXIgd2l0aCBkYXRlIG9iamVjdHNcclxuICAgICAgICAgICAgdmFyIHN0YXJ0RGF5ID0gZGF5c0luTGFzdE1vbnRoIC0gZGF5T2ZXZWVrICsgdGhpcy5sb2NhbGUuZmlyc3REYXkgKyAxO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnREYXkgPiBkYXlzSW5MYXN0TW9udGgpXHJcbiAgICAgICAgICAgICAgICBzdGFydERheSAtPSA3O1xyXG5cclxuICAgICAgICAgICAgaWYgKGRheU9mV2VlayA9PSB0aGlzLmxvY2FsZS5maXJzdERheSlcclxuICAgICAgICAgICAgICAgIHN0YXJ0RGF5ID0gZGF5c0luTGFzdE1vbnRoIC0gNjtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJEYXRlID0gbW9tZW50KFtsYXN0WWVhciwgbGFzdE1vbnRoLCBzdGFydERheSwgMTIsIG1pbnV0ZSwgc2Vjb25kXSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sLCByb3c7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjb2wgPSAwLCByb3cgPSAwOyBpIDwgNDI7IGkrKywgY29sKyssIGN1ckRhdGUgPSBtb21lbnQoY3VyRGF0ZSkuYWRkKDI0LCAnaG91cicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgY29sICUgNyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxlbmRhcltyb3ddW2NvbF0gPSBjdXJEYXRlLmNsb25lKCkuaG91cihob3VyKS5taW51dGUobWludXRlKS5zZWNvbmQoc2Vjb25kKTtcclxuICAgICAgICAgICAgICAgIGN1ckRhdGUuaG91cigxMik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluRGF0ZSAmJiBjYWxlbmRhcltyb3ddW2NvbF0uZm9ybWF0KCdZWVlZLU1NLUREJykgPT0gdGhpcy5taW5EYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICYmIGNhbGVuZGFyW3Jvd11bY29sXS5pc0JlZm9yZSh0aGlzLm1pbkRhdGUpICYmIHNpZGUgPT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJbcm93XVtjb2xdID0gdGhpcy5taW5EYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4RGF0ZSAmJiBjYWxlbmRhcltyb3ddW2NvbF0uZm9ybWF0KCdZWVlZLU1NLUREJykgPT0gdGhpcy5tYXhEYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICYmIGNhbGVuZGFyW3Jvd11bY29sXS5pc0FmdGVyKHRoaXMubWF4RGF0ZSkgJiYgc2lkZSA9PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJbcm93XVtjb2xdID0gdGhpcy5tYXhEYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL21ha2UgdGhlIGNhbGVuZGFyIG9iamVjdCBhdmFpbGFibGUgdG8gaG92ZXJEYXRlL2NsaWNrRGF0ZVxyXG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdENhbGVuZGFyLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Q2FsZW5kYXIuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgY2FsZW5kYXJcclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIHZhciBtaW5EYXRlID0gc2lkZSA9PSAnbGVmdCcgPyB0aGlzLm1pbkRhdGUgOiB0aGlzLnN0YXJ0RGF0ZTtcclxuICAgICAgICAgICAgdmFyIG1heERhdGUgPSB0aGlzLm1heERhdGU7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IHNpZGUgPT0gJ2xlZnQnID8gdGhpcy5zdGFydERhdGUgOiB0aGlzLmVuZERhdGU7XHJcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IHRoaXMubG9jYWxlLmRpcmVjdGlvbiA9PSAnbHRyJyA/IHtsZWZ0OiAnY2hldnJvbi1sZWZ0JywgcmlnaHQ6ICdjaGV2cm9uLXJpZ2h0J30gOiB7bGVmdDogJ2NoZXZyb24tcmlnaHQnLCByaWdodDogJ2NoZXZyb24tbGVmdCd9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGh0bWwgPSAnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPHRoZWFkPic7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xyXG5cclxuICAgICAgICAgICAgLy8gYWRkIGVtcHR5IGNlbGwgZm9yIHdlZWsgbnVtYmVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dXZWVrTnVtYmVycyB8fCB0aGlzLnNob3dJU09XZWVrTnVtYmVycylcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0aD48L3RoPic7XHJcblxyXG4gICAgICAgICAgICBpZiAoKCFtaW5EYXRlIHx8IG1pbkRhdGUuaXNCZWZvcmUoY2FsZW5kYXIuZmlyc3REYXkpKSAmJiAoIXRoaXMubGlua2VkQ2FsZW5kYXJzIHx8IHNpZGUgPT0gJ2xlZnQnKSkge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRoIGNsYXNzPVwicHJldiBhdmFpbGFibGVcIj48aSBjbGFzcz1cImZhIGZhLScgKyBhcnJvdy5sZWZ0ICsgJyBnbHlwaGljb24gZ2x5cGhpY29uLScgKyBhcnJvdy5sZWZ0ICsgJ1wiPjwvaT48L3RoPic7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dGg+PC90aD4nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0ZUh0bWwgPSB0aGlzLmxvY2FsZS5tb250aE5hbWVzW2NhbGVuZGFyWzFdWzFdLm1vbnRoKCldICsgY2FsZW5kYXJbMV1bMV0uZm9ybWF0KFwiIFlZWVlcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE1vbnRoID0gY2FsZW5kYXJbMV1bMV0ubW9udGgoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50WWVhciA9IGNhbGVuZGFyWzFdWzFdLnllYXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBtYXhZZWFyID0gKG1heERhdGUgJiYgbWF4RGF0ZS55ZWFyKCkpIHx8IChjdXJyZW50WWVhciArIDUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pblllYXIgPSAobWluRGF0ZSAmJiBtaW5EYXRlLnllYXIoKSkgfHwgKGN1cnJlbnRZZWFyIC0gNTApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluTWluWWVhciA9IGN1cnJlbnRZZWFyID09IG1pblllYXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5NYXhZZWFyID0gY3VycmVudFllYXIgPT0gbWF4WWVhcjtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhIdG1sID0gJzxzZWxlY3QgY2xhc3M9XCJtb250aHNlbGVjdFwiPic7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IDEyOyBtKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFpbk1pblllYXIgfHwgbSA+PSBtaW5EYXRlLm1vbnRoKCkpICYmICghaW5NYXhZZWFyIHx8IG0gPD0gbWF4RGF0ZS5tb250aCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aEh0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIG0gKyBcIidcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobSA9PT0gY3VycmVudE1vbnRoID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI+XCIgKyB0aGlzLmxvY2FsZS5tb250aE5hbWVzW21dICsgXCI8L29wdGlvbj5cIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aEh0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIG0gKyBcIidcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobSA9PT0gY3VycmVudE1vbnRoID8gXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1wiIDogXCJcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgZGlzYWJsZWQ9J2Rpc2FibGVkJz5cIiArIHRoaXMubG9jYWxlLm1vbnRoTmFtZXNbbV0gKyBcIjwvb3B0aW9uPlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1vbnRoSHRtbCArPSBcIjwvc2VsZWN0PlwiO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB5ZWFySHRtbCA9ICc8c2VsZWN0IGNsYXNzPVwieWVhcnNlbGVjdFwiPic7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gbWluWWVhcjsgeSA8PSBtYXhZZWFyOyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB5ZWFySHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyB5ICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh5ID09PSBjdXJyZW50WWVhciA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc+JyArIHkgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHllYXJIdG1sICs9ICc8L3NlbGVjdD4nO1xyXG5cclxuICAgICAgICAgICAgICAgIGRhdGVIdG1sID0gbW9udGhIdG1sICsgeWVhckh0bWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzx0aCBjb2xzcGFuPVwiNVwiIGNsYXNzPVwibW9udGhcIj4nICsgZGF0ZUh0bWwgKyAnPC90aD4nO1xyXG4gICAgICAgICAgICBpZiAoKCFtYXhEYXRlIHx8IG1heERhdGUuaXNBZnRlcihjYWxlbmRhci5sYXN0RGF5KSkgJiYgKCF0aGlzLmxpbmtlZENhbGVuZGFycyB8fCBzaWRlID09ICdyaWdodCcgfHwgdGhpcy5zaW5nbGVEYXRlUGlja2VyKSkge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRoIGNsYXNzPVwibmV4dCBhdmFpbGFibGVcIj48aSBjbGFzcz1cImZhIGZhLScgKyBhcnJvdy5yaWdodCArICcgZ2x5cGhpY29uIGdseXBoaWNvbi0nICsgYXJyb3cucmlnaHQgKyAnXCI+PC9pPjwvdGg+JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0aD48L3RoPic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPHRyPic7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgd2VlayBudW1iZXIgbGFiZWxcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1dlZWtOdW1iZXJzIHx8IHRoaXMuc2hvd0lTT1dlZWtOdW1iZXJzKVxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRoIGNsYXNzPVwid2Vla1wiPicgKyB0aGlzLmxvY2FsZS53ZWVrTGFiZWwgKyAnPC90aD4nO1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKHRoaXMubG9jYWxlLmRheXNPZldlZWssIGZ1bmN0aW9uKGluZGV4LCBkYXlPZldlZWspIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0aD4nICsgZGF5T2ZXZWVrICsgJzwvdGg+JztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBodG1sICs9ICc8L3RyPic7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvdGhlYWQ+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPHRib2R5Pic7XHJcblxyXG4gICAgICAgICAgICAvL2FkanVzdCBtYXhEYXRlIHRvIHJlZmxlY3QgdGhlIGRhdGVMaW1pdCBzZXR0aW5nIGluIG9yZGVyIHRvXHJcbiAgICAgICAgICAgIC8vZ3JleSBvdXQgZW5kIGRhdGVzIGJleW9uZCB0aGUgZGF0ZUxpbWl0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUgPT0gbnVsbCAmJiB0aGlzLmRhdGVMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heExpbWl0ID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKS5hZGQodGhpcy5kYXRlTGltaXQpLmVuZE9mKCdkYXknKTtcclxuICAgICAgICAgICAgICAgIGlmICghbWF4RGF0ZSB8fCBtYXhMaW1pdC5pc0JlZm9yZShtYXhEYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERhdGUgPSBtYXhMaW1pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgNjsgcm93KyspIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGFkZCB3ZWVrIG51bWJlclxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1dlZWtOdW1iZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0ZCBjbGFzcz1cIndlZWtcIj4nICsgY2FsZW5kYXJbcm93XVswXS53ZWVrKCkgKyAnPC90ZD4nO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zaG93SVNPV2Vla051bWJlcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwid2Vla1wiPicgKyBjYWxlbmRhcltyb3ddWzBdLmlzb1dlZWsoKSArICc8L3RkPic7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgNzsgY29sKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9oaWdobGlnaHQgdG9kYXkncyBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyW3Jvd11bY29sXS5pc1NhbWUobmV3IERhdGUoKSwgXCJkYXlcIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgndG9kYXknKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9oaWdobGlnaHQgd2Vla2VuZHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJbcm93XVtjb2xdLmlzb1dlZWtkYXkoKSA+IDUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnd2Vla2VuZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dyZXkgb3V0IHRoZSBkYXRlcyBpbiBvdGhlciBtb250aHMgZGlzcGxheWVkIGF0IGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoaXMgY2FsZW5kYXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJbcm93XVtjb2xdLm1vbnRoKCkgIT0gY2FsZW5kYXJbMV1bMV0ubW9udGgoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdvZmYnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgYmVmb3JlIHRoZSBtaW5pbXVtIGRhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5EYXRlICYmIGNhbGVuZGFyW3Jvd11bY29sXS5pc0JlZm9yZSh0aGlzLm1pbkRhdGUsICdkYXknKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdvZmYnLCAnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZXMgYWZ0ZXIgdGhlIG1heGltdW0gZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIGNhbGVuZGFyW3Jvd11bY29sXS5pc0FmdGVyKG1heERhdGUsICdkYXknKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdvZmYnLCAnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBhbGxvdyBzZWxlY3Rpb24gb2YgZGF0ZSBpZiBhIGN1c3RvbSBmdW5jdGlvbiBkZWNpZGVzIGl0J3MgaW52YWxpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW52YWxpZERhdGUoY2FsZW5kYXJbcm93XVtjb2xdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdvZmYnLCAnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9oaWdobGlnaHQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBzdGFydCBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyW3Jvd11bY29sXS5mb3JtYXQoJ1lZWVktTU0tREQnKSA9PSB0aGlzLnN0YXJ0RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhY3RpdmUnLCAnc3RhcnQtZGF0ZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVuZCBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSAhPSBudWxsICYmIGNhbGVuZGFyW3Jvd11bY29sXS5mb3JtYXQoJ1lZWVktTU0tREQnKSA9PSB0aGlzLmVuZERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnYWN0aXZlJywgJ2VuZC1kYXRlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaGlnaGxpZ2h0IGRhdGVzIGluLWJldHdlZW4gdGhlIHNlbGVjdGVkIGRhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSAhPSBudWxsICYmIGNhbGVuZGFyW3Jvd11bY29sXSA+IHRoaXMuc3RhcnREYXRlICYmIGNhbGVuZGFyW3Jvd11bY29sXSA8IHRoaXMuZW5kRGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdpbi1yYW5nZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IGN1c3RvbSBjbGFzc2VzIGZvciB0aGlzIGRhdGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDdXN0b20gPSB0aGlzLmlzQ3VzdG9tRGF0ZShjYWxlbmRhcltyb3ddW2NvbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1c3RvbSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc0N1c3RvbSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goaXNDdXN0b20pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjbGFzc2VzLCBpc0N1c3RvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY25hbWUgPSAnJywgZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY25hbWUgKz0gY2xhc3Nlc1tpXSArICcgJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzZXNbaV0gPT0gJ2Rpc2FibGVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY25hbWUgKz0gJ2F2YWlsYWJsZSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0ZCBjbGFzcz1cIicgKyBjbmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgKyAnXCIgZGF0YS10aXRsZT1cIicgKyAncicgKyByb3cgKyAnYycgKyBjb2wgKyAnXCI+JyArIGNhbGVuZGFyW3Jvd11bY29sXS5kYXRlKCkgKyAnPC90ZD4nO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPC90Ym9keT4nO1xyXG4gICAgICAgICAgICBodG1sICs9ICc8L3RhYmxlPic7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuY2FsZW5kYXIuJyArIHNpZGUgKyAnIC5jYWxlbmRhci10YWJsZScpLmh0bWwoaHRtbCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbmRlclRpbWVQaWNrZXI6IGZ1bmN0aW9uKHNpZGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IGJvdGhlciB1cGRhdGluZyB0aGUgdGltZSBwaWNrZXIgaWYgaXQncyBjdXJyZW50bHkgZGlzYWJsZWRcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBhbiBlbmQgZGF0ZSBoYXNuJ3QgYmVlbiBjbGlja2VkIHlldFxyXG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAncmlnaHQnICYmICF0aGlzLmVuZERhdGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHZhciBodG1sLCBzZWxlY3RlZCwgbWluRGF0ZSwgbWF4RGF0ZSA9IHRoaXMubWF4RGF0ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGVMaW1pdCAmJiAoIXRoaXMubWF4RGF0ZSB8fCB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpLmFkZCh0aGlzLmRhdGVMaW1pdCkuaXNBZnRlcih0aGlzLm1heERhdGUpKSlcclxuICAgICAgICAgICAgICAgIG1heERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpLmFkZCh0aGlzLmRhdGVMaW1pdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIG1pbkRhdGUgPSB0aGlzLm1pbkRhdGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuZW5kRGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgbWluRGF0ZSA9IHRoaXMuc3RhcnREYXRlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vUHJlc2VydmUgdGhlIHRpbWUgYWxyZWFkeSBzZWxlY3RlZFxyXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVTZWxlY3RvciA9IHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci5yaWdodCAuY2FsZW5kYXItdGltZSBkaXYnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU2VsZWN0b3IuaHRtbCgpICE9ICcnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLmhvdXIodGltZVNlbGVjdG9yLmZpbmQoJy5ob3Vyc2VsZWN0IG9wdGlvbjpzZWxlY3RlZCcpLnZhbCgpIHx8IHNlbGVjdGVkLmhvdXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQubWludXRlKHRpbWVTZWxlY3Rvci5maW5kKCcubWludXRlc2VsZWN0IG9wdGlvbjpzZWxlY3RlZCcpLnZhbCgpIHx8IHNlbGVjdGVkLm1pbnV0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5zZWNvbmQodGltZVNlbGVjdG9yLmZpbmQoJy5zZWNvbmRzZWxlY3Qgb3B0aW9uOnNlbGVjdGVkJykudmFsKCkgfHwgc2VsZWN0ZWQuc2Vjb25kKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcjI0SG91cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW1wbSA9IHRpbWVTZWxlY3Rvci5maW5kKCcuYW1wbXNlbGVjdCBvcHRpb246c2VsZWN0ZWQnKS52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdQTScgJiYgc2VsZWN0ZWQuaG91cigpIDwgMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5ob3VyKHNlbGVjdGVkLmhvdXIoKSArIDEyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdBTScgJiYgc2VsZWN0ZWQuaG91cigpID09PSAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLmhvdXIoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQuaXNCZWZvcmUodGhpcy5zdGFydERhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWF4RGF0ZSAmJiBzZWxlY3RlZC5pc0FmdGVyKG1heERhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gbWF4RGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gaG91cnNcclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIGh0bWwgPSAnPHNlbGVjdCBjbGFzcz1cImhvdXJzZWxlY3RcIj4nO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy50aW1lUGlja2VyMjRIb3VyID8gMCA6IDE7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLnRpbWVQaWNrZXIyNEhvdXIgPyAyMyA6IDEyO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaV9pbl8yNCA9IGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcjI0SG91cilcclxuICAgICAgICAgICAgICAgICAgICBpX2luXzI0ID0gc2VsZWN0ZWQuaG91cigpID49IDEyID8gKGkgPT0gMTIgPyAxMiA6IGkgKyAxMikgOiAoaSA9PSAxMiA/IDAgOiBpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IHNlbGVjdGVkLmNsb25lKCkuaG91cihpX2luXzI0KTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbkRhdGUgJiYgdGltZS5taW51dGUoNTkpLmlzQmVmb3JlKG1pbkRhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIHRpbWUubWludXRlKDApLmlzQWZ0ZXIobWF4RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpX2luXzI0ID09IHNlbGVjdGVkLmhvdXIoKSAmJiAhZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPicgKyBpICsgJzwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiIGRpc2FibGVkPVwiZGlzYWJsZWRcIiBjbGFzcz1cImRpc2FibGVkXCI+JyArIGkgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiPicgKyBpICsgJzwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvc2VsZWN0PiAnO1xyXG5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gbWludXRlc1xyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnOiA8c2VsZWN0IGNsYXNzPVwibWludXRlc2VsZWN0XCI+JztcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjA7IGkgKz0gdGhpcy50aW1lUGlja2VySW5jcmVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGVkID0gaSA8IDEwID8gJzAnICsgaSA6IGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IHNlbGVjdGVkLmNsb25lKCkubWludXRlKGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbkRhdGUgJiYgdGltZS5zZWNvbmQoNTkpLmlzQmVmb3JlKG1pbkRhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIHRpbWUuc2Vjb25kKDApLmlzQWZ0ZXIobWF4RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5taW51dGUoKSA9PSBpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIiBzZWxlY3RlZD1cInNlbGVjdGVkXCI+JyArIHBhZGRlZCArICc8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgY2xhc3M9XCJkaXNhYmxlZFwiPicgKyBwYWRkZWQgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiPicgKyBwYWRkZWQgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPC9zZWxlY3Q+ICc7XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBzZWNvbmRzXHJcbiAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyU2Vjb25kcykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnOiA8c2VsZWN0IGNsYXNzPVwic2Vjb25kc2VsZWN0XCI+JztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDYwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGVkID0gaSA8IDEwID8gJzAnICsgaSA6IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBzZWxlY3RlZC5jbG9uZSgpLnNlY29uZChpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkRhdGUgJiYgdGltZS5pc0JlZm9yZShtaW5EYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIHRpbWUuaXNBZnRlcihtYXhEYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQuc2Vjb25kKCkgPT0gaSAmJiAhZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiIHNlbGVjdGVkPVwic2VsZWN0ZWRcIj4nICsgcGFkZGVkICsgJzwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCIgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGNsYXNzPVwiZGlzYWJsZWRcIj4nICsgcGFkZGVkICsgJzwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiPicgKyBwYWRkZWQgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC9zZWxlY3Q+ICc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEFNL1BNXHJcbiAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcjI0SG91cikge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHNlbGVjdCBjbGFzcz1cImFtcG1zZWxlY3RcIj4nO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhbV9odG1sID0gJyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG1faHRtbCA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtaW5EYXRlICYmIHNlbGVjdGVkLmNsb25lKCkuaG91cigxMikubWludXRlKDApLnNlY29uZCgwKS5pc0JlZm9yZShtaW5EYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICBhbV9odG1sID0gJyBkaXNhYmxlZD1cImRpc2FibGVkXCIgY2xhc3M9XCJkaXNhYmxlZFwiJztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWF4RGF0ZSAmJiBzZWxlY3RlZC5jbG9uZSgpLmhvdXIoMCkubWludXRlKDApLnNlY29uZCgwKS5pc0FmdGVyKG1heERhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHBtX2h0bWwgPSAnIGRpc2FibGVkPVwiZGlzYWJsZWRcIiBjbGFzcz1cImRpc2FibGVkXCInO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5ob3VyKCkgPj0gMTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiQU1cIicgKyBhbV9odG1sICsgJz5BTTwvb3B0aW9uPjxvcHRpb24gdmFsdWU9XCJQTVwiIHNlbGVjdGVkPVwic2VsZWN0ZWRcIicgKyBwbV9odG1sICsgJz5QTTwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJBTVwiIHNlbGVjdGVkPVwic2VsZWN0ZWRcIicgKyBhbV9odG1sICsgJz5BTTwvb3B0aW9uPjxvcHRpb24gdmFsdWU9XCJQTVwiJyArIHBtX2h0bWwgKyAnPlBNPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L3NlbGVjdD4nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuY2FsZW5kYXIuJyArIHNpZGUgKyAnIC5jYWxlbmRhci10aW1lIGRpdicpLmh0bWwoaHRtbCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZUZvcm1JbnB1dHM6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgLy9pZ25vcmUgbW91c2UgbW92ZW1lbnRzIHdoaWxlIGFuIGFib3ZlLWNhbGVuZGFyIHRleHQgaW5wdXQgaGFzIGZvY3VzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9zdGFydF0nKS5pcyhcIjpmb2N1c1wiKSB8fCB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9lbmRdJykuaXMoXCI6Zm9jdXNcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9zdGFydF0nKS52YWwodGhpcy5zdGFydERhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfZW5kXScpLnZhbCh0aGlzLmVuZERhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2luZ2xlRGF0ZVBpY2tlciB8fCAodGhpcy5lbmREYXRlICYmICh0aGlzLnN0YXJ0RGF0ZS5pc0JlZm9yZSh0aGlzLmVuZERhdGUpIHx8IHRoaXMuc3RhcnREYXRlLmlzU2FtZSh0aGlzLmVuZERhdGUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2J1dHRvbi5hcHBseUJ0bicpLnJlbW92ZUF0dHIoJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdidXR0b24uYXBwbHlCdG4nKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclRvcDtcclxuICAgICAgICAgICAgdmFyIHBhcmVudFJpZ2h0RWRnZSA9ICQod2luZG93KS53aWR0aCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50RWwuaXMoJ2JvZHknKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy5wYXJlbnRFbC5vZmZzZXQoKS50b3AgLSB0aGlzLnBhcmVudEVsLnNjcm9sbFRvcCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMucGFyZW50RWwub2Zmc2V0KCkubGVmdCAtIHRoaXMucGFyZW50RWwuc2Nyb2xsTGVmdCgpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcGFyZW50UmlnaHRFZGdlID0gdGhpcy5wYXJlbnRFbFswXS5jbGllbnRXaWR0aCArIHRoaXMucGFyZW50RWwub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcHMgPT0gJ3VwJylcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclRvcCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKS50b3AgLSB0aGlzLmNvbnRhaW5lci5vdXRlckhlaWdodCgpIC0gcGFyZW50T2Zmc2V0LnRvcDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyVG9wID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpLnRvcCArIHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIC0gcGFyZW50T2Zmc2V0LnRvcDtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJbdGhpcy5kcm9wcyA9PSAndXAnID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdkcm9wdXAnKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5zID09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IGNvbnRhaW5lclRvcCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogcGFyZW50UmlnaHRFZGdlIC0gdGhpcy5lbGVtZW50Lm9mZnNldCgpLmxlZnQgLSB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICdhdXRvJ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIub2Zmc2V0KCkubGVmdCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiA5XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcGVucyA9PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IGNvbnRhaW5lclRvcCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmVsZW1lbnQub2Zmc2V0KCkubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0ICsgdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSAvIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gdGhpcy5jb250YWluZXIub3V0ZXJXaWR0aCgpIC8gMixcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBjb250YWluZXJUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5lbGVtZW50Lm9mZnNldCgpLmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0ICsgdGhpcy5jb250YWluZXIub3V0ZXJXaWR0aCgpID4gJCh3aW5kb3cpLndpZHRoKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaG93OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2hvd2luZykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2xpY2sgcHJveHkgdGhhdCBpcyBwcml2YXRlIHRvIHRoaXMgaW5zdGFuY2Ugb2YgZGF0ZXBpY2tlciwgZm9yIHVuYmluZGluZ1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRzaWRlQ2xpY2tQcm94eSA9ICQucHJveHkoZnVuY3Rpb24oZSkgeyB0aGlzLm91dHNpZGVDbGljayhlKTsgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBCaW5kIGdsb2JhbCBkYXRlcGlja2VyIG1vdXNlZG93biBmb3IgaGlkaW5nIGFuZFxyXG4gICAgICAgICAgICAkKGRvY3VtZW50KVxyXG4gICAgICAgICAgICAgIC5vbignbW91c2Vkb3duLmRhdGVyYW5nZXBpY2tlcicsIHRoaXMuX291dHNpZGVDbGlja1Byb3h5KVxyXG4gICAgICAgICAgICAgIC8vIGFsc28gc3VwcG9ydCBtb2JpbGUgZGV2aWNlc1xyXG4gICAgICAgICAgICAgIC5vbigndG91Y2hlbmQuZGF0ZXJhbmdlcGlja2VyJywgdGhpcy5fb3V0c2lkZUNsaWNrUHJveHkpXHJcbiAgICAgICAgICAgICAgLy8gYWxzbyBleHBsaWNpdGx5IHBsYXkgbmljZSB3aXRoIEJvb3RzdHJhcCBkcm9wZG93bnMsIHdoaWNoIHN0b3BQcm9wYWdhdGlvbiB3aGVuIGNsaWNraW5nIHRoZW1cclxuICAgICAgICAgICAgICAub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICdbZGF0YS10b2dnbGU9ZHJvcGRvd25dJywgdGhpcy5fb3V0c2lkZUNsaWNrUHJveHkpXHJcbiAgICAgICAgICAgICAgLy8gYW5kIGFsc28gY2xvc2Ugd2hlbiBmb2N1cyBjaGFuZ2VzIHRvIG91dHNpZGUgdGhlIHBpY2tlciAoZWcuIHRhYmJpbmcgYmV0d2VlbiBjb250cm9scylcclxuICAgICAgICAgICAgICAub24oJ2ZvY3VzaW4uZGF0ZXJhbmdlcGlja2VyJywgdGhpcy5fb3V0c2lkZUNsaWNrUHJveHkpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVwb3NpdGlvbiB0aGUgcGlja2VyIGlmIHRoZSB3aW5kb3cgaXMgcmVzaXplZCB3aGlsZSBpdCdzIG9wZW5cclxuICAgICAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuZGF0ZXJhbmdlcGlja2VyJywgJC5wcm94eShmdW5jdGlvbihlKSB7IHRoaXMubW92ZShlKTsgfSwgdGhpcykpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5vbGRTdGFydERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9sZEVuZERhdGUgPSB0aGlzLmVuZERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1JpZ2h0VGltZSA9IHRoaXMuZW5kRGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdzaG93LmRhdGVyYW5nZXBpY2tlcicsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmlzU2hvd2luZyA9IHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTaG93aW5nKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvL2luY29tcGxldGUgZGF0ZSBzZWxlY3Rpb24sIHJldmVydCB0byBsYXN0IHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSB0aGlzLm9sZFN0YXJ0RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdGhpcy5vbGRFbmREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vaWYgYSBuZXcgZGF0ZSByYW5nZSB3YXMgc2VsZWN0ZWQsIGludm9rZSB0aGUgdXNlciBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnREYXRlLmlzU2FtZSh0aGlzLm9sZFN0YXJ0RGF0ZSkgfHwgIXRoaXMuZW5kRGF0ZS5pc1NhbWUodGhpcy5vbGRFbmREYXRlKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5zdGFydERhdGUsIHRoaXMuZW5kRGF0ZSwgdGhpcy5jaG9zZW5MYWJlbCk7XHJcblxyXG4gICAgICAgICAgICAvL2lmIHBpY2tlciBpcyBhdHRhY2hlZCB0byBhIHRleHQgaW5wdXQsIHVwZGF0ZSBpdFxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZignLmRhdGVyYW5nZXBpY2tlcicpO1xyXG4gICAgICAgICAgICAkKHdpbmRvdykub2ZmKCcuZGF0ZXJhbmdlcGlja2VyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmhpZGUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ2hpZGUuZGF0ZXJhbmdlcGlja2VyJywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2hvd2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG91dHNpZGVDbGljazogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYWdlIGlzIGNsaWNrZWQgYW55d2hlcmUgZXhjZXB0IHdpdGhpbiB0aGUgZGF0ZXJhbmdlcnBpY2tlci9idXR0b25cclxuICAgICAgICAgICAgLy8gaXRzZWxmIHRoZW4gY2FsbCB0aGlzLmhpZGUoKVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAvLyBpZSBtb2RhbCBkaWFsb2cgZml4XHJcbiAgICAgICAgICAgICAgICBlLnR5cGUgPT0gXCJmb2N1c2luXCIgfHxcclxuICAgICAgICAgICAgICAgIHRhcmdldC5jbG9zZXN0KHRoaXMuZWxlbWVudCkubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuY2xvc2VzdCh0aGlzLmNvbnRhaW5lcikubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuY2xvc2VzdCgnLmNhbGVuZGFyLXRhYmxlJykubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICApIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdvdXRzaWRlQ2xpY2suZGF0ZXJhbmdlcGlja2VyJywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2hvd0NhbGVuZGFyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdzaG93LWNhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignc2hvd0NhbGVuZGFyLmRhdGVyYW5nZXBpY2tlcicsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhpZGVDYWxlbmRhcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnc2hvdy1jYWxlbmRhcicpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignaGlkZUNhbGVuZGFyLmRhdGVyYW5nZXBpY2tlcicsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhvdmVyUmFuZ2U6IGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vaWdub3JlIG1vdXNlIG1vdmVtZW50cyB3aGlsZSBhbiBhYm92ZS1jYWxlbmRhciB0ZXh0IGlucHV0IGhhcyBmb2N1c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfc3RhcnRdJykuaXMoXCI6Zm9jdXNcIikgfHwgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfZW5kXScpLmlzKFwiOmZvY3VzXCIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXJhbmdlLWtleScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsID09IHRoaXMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGVzID0gdGhpcy5yYW5nZXNbbGFiZWxdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfc3RhcnRdJykudmFsKGRhdGVzWzBdLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX2VuZF0nKS52YWwoZGF0ZXNbMV0uZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsaWNrUmFuZ2U6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXJhbmdlLWtleScpO1xyXG4gICAgICAgICAgICB0aGlzLmNob3NlbkxhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PSB0aGlzLmxvY2FsZS5jdXN0b21SYW5nZUxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dDYWxlbmRhcnMoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlcyA9IHRoaXMucmFuZ2VzW2xhYmVsXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gZGF0ZXNbMF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSBkYXRlc1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlLnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZS5lbmRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFsd2F5c1Nob3dDYWxlbmRhcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlQ2FsZW5kYXJzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQXBwbHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsaWNrUHJldjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgY2FsID0gJChlLnRhcmdldCkucGFyZW50cygnLmNhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgIGlmIChjYWwuaGFzQ2xhc3MoJ2xlZnQnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGguc3VidHJhY3QoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rZWRDYWxlbmRhcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLnN1YnRyYWN0KDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLnN1YnRyYWN0KDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsZW5kYXJzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xpY2tOZXh0OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWwgPSAkKGUudGFyZ2V0KS5wYXJlbnRzKCcuY2FsZW5kYXInKTtcclxuICAgICAgICAgICAgaWYgKGNhbC5oYXNDbGFzcygnbGVmdCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aC5hZGQoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Q2FsZW5kYXIubW9udGguYWRkKDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua2VkQ2FsZW5kYXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdENhbGVuZGFyLm1vbnRoLmFkZCgxLCAnbW9udGgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbGVuZGFycygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhvdmVyRGF0ZTogZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy9pZ25vcmUgbW91c2UgbW92ZW1lbnRzIHdoaWxlIGFuIGFib3ZlLWNhbGVuZGFyIHRleHQgaW5wdXQgaGFzIGZvY3VzXHJcbiAgICAgICAgICAgIC8vaWYgKHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XScpLmlzKFwiOmZvY3VzXCIpIHx8IHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX2VuZF0nKS5pcyhcIjpmb2N1c1wiKSlcclxuICAgICAgICAgICAgLy8gICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy9pZ25vcmUgZGF0ZXMgdGhhdCBjYW4ndCBiZSBzZWxlY3RlZFxyXG4gICAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmhhc0NsYXNzKCdhdmFpbGFibGUnKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy9oYXZlIHRoZSB0ZXh0IGlucHV0cyBhYm92ZSBjYWxlbmRhcnMgcmVmbGVjdCB0aGUgZGF0ZSBiZWluZyBob3ZlcmVkIG92ZXJcclxuICAgICAgICAgICAgdmFyIHRpdGxlID0gJChlLnRhcmdldCkuYXR0cignZGF0YS10aXRsZScpO1xyXG4gICAgICAgICAgICB2YXIgcm93ID0gdGl0bGUuc3Vic3RyKDEsIDEpO1xyXG4gICAgICAgICAgICB2YXIgY29sID0gdGl0bGUuc3Vic3RyKDMsIDEpO1xyXG4gICAgICAgICAgICB2YXIgY2FsID0gJChlLnRhcmdldCkucGFyZW50cygnLmNhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gY2FsLmhhc0NsYXNzKCdsZWZ0JykgPyB0aGlzLmxlZnRDYWxlbmRhci5jYWxlbmRhcltyb3ddW2NvbF0gOiB0aGlzLnJpZ2h0Q2FsZW5kYXIuY2FsZW5kYXJbcm93XVtjb2xdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSAmJiAhdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfc3RhcnRdJykuaXMoXCI6Zm9jdXNcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XScpLnZhbChkYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5lbmREYXRlICYmICF0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9lbmRdJykuaXMoXCI6Zm9jdXNcIikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX2VuZF0nKS52YWwoZGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vaGlnaGxpZ2h0IHRoZSBkYXRlcyBiZXR3ZWVuIHRoZSBzdGFydCBkYXRlIGFuZCB0aGUgZGF0ZSBiZWluZyBob3ZlcmVkIGFzIGEgcG90ZW50aWFsIGVuZCBkYXRlXHJcbiAgICAgICAgICAgIHZhciBsZWZ0Q2FsZW5kYXIgPSB0aGlzLmxlZnRDYWxlbmRhcjtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0Q2FsZW5kYXIgPSB0aGlzLnJpZ2h0Q2FsZW5kYXI7XHJcbiAgICAgICAgICAgIHZhciBzdGFydERhdGUgPSB0aGlzLnN0YXJ0RGF0ZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVuZERhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhciB0Ym9keSB0ZCcpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2tpcCB3ZWVrIG51bWJlcnMsIG9ubHkgbG9vayBhdCBkYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGVsKS5oYXNDbGFzcygnd2VlaycpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9ICQoZWwpLmF0dHIoJ2RhdGEtdGl0bGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gdGl0bGUuc3Vic3RyKDEsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSB0aXRsZS5zdWJzdHIoMywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbCA9ICQoZWwpLnBhcmVudHMoJy5jYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkdCA9IGNhbC5oYXNDbGFzcygnbGVmdCcpID8gbGVmdENhbGVuZGFyLmNhbGVuZGFyW3Jvd11bY29sXSA6IHJpZ2h0Q2FsZW5kYXIuY2FsZW5kYXJbcm93XVtjb2xdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGR0LmlzQWZ0ZXIoc3RhcnREYXRlKSAmJiBkdC5pc0JlZm9yZShkYXRlKSkgfHwgZHQuaXNTYW1lKGRhdGUsICdkYXknKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGVsKS5hZGRDbGFzcygnaW4tcmFuZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGVsKS5yZW1vdmVDbGFzcygnaW4tcmFuZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xpY2tEYXRlOiBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmhhc0NsYXNzKCdhdmFpbGFibGUnKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRpdGxlID0gJChlLnRhcmdldCkuYXR0cignZGF0YS10aXRsZScpO1xyXG4gICAgICAgICAgICB2YXIgcm93ID0gdGl0bGUuc3Vic3RyKDEsIDEpO1xyXG4gICAgICAgICAgICB2YXIgY29sID0gdGl0bGUuc3Vic3RyKDMsIDEpO1xyXG4gICAgICAgICAgICB2YXIgY2FsID0gJChlLnRhcmdldCkucGFyZW50cygnLmNhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gY2FsLmhhc0NsYXNzKCdsZWZ0JykgPyB0aGlzLmxlZnRDYWxlbmRhci5jYWxlbmRhcltyb3ddW2NvbF0gOiB0aGlzLnJpZ2h0Q2FsZW5kYXIuY2FsZW5kYXJbcm93XVtjb2xdO1xyXG5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBkbyBhIGZldyB0aGluZ3M6XHJcbiAgICAgICAgICAgIC8vICogYWx0ZXJuYXRlIGJldHdlZW4gc2VsZWN0aW5nIGEgc3RhcnQgYW5kIGVuZCBkYXRlIGZvciB0aGUgcmFuZ2UsXHJcbiAgICAgICAgICAgIC8vICogaWYgdGhlIHRpbWUgcGlja2VyIGlzIGVuYWJsZWQsIGFwcGx5IHRoZSBob3VyL21pbnV0ZS9zZWNvbmQgZnJvbSB0aGUgc2VsZWN0IGJveGVzIHRvIHRoZSBjbGlja2VkIGRhdGVcclxuICAgICAgICAgICAgLy8gKiBpZiBhdXRvYXBwbHkgaXMgZW5hYmxlZCwgYW5kIGFuIGVuZCBkYXRlIHdhcyBjaG9zZW4sIGFwcGx5IHRoZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgLy8gKiBpZiBzaW5nbGUgZGF0ZSBwaWNrZXIgbW9kZSwgYW5kIHRpbWUgcGlja2VyIGlzbid0IGVuYWJsZWQsIGFwcGx5IHRoZSBzZWxlY3Rpb24gaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgLy8gKiBpZiBvbmUgb2YgdGhlIGlucHV0cyBhYm92ZSB0aGUgY2FsZW5kYXJzIHdhcyBmb2N1c2VkLCBjYW5jZWwgdGhhdCBtYW51YWwgaW5wdXRcclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUgfHwgZGF0ZS5pc0JlZm9yZSh0aGlzLnN0YXJ0RGF0ZSwgJ2RheScpKSB7IC8vcGlja2luZyBzdGFydFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3VyID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLmxlZnQgLmhvdXJzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbXBtID0gdGhpcy5jb250YWluZXIuZmluZCgnLmxlZnQgLmFtcG1zZWxlY3QnKS52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdQTScgJiYgaG91ciA8IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArPSAxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdBTScgJiYgaG91ciA9PT0gMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbnV0ZSA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5sZWZ0IC5taW51dGVzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnRpbWVQaWNrZXJTZWNvbmRzID8gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLmxlZnQgLnNlY29uZHNlbGVjdCcpLnZhbCgpLCAxMCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBkYXRlLmNsb25lKCkuaG91cihob3VyKS5taW51dGUobWludXRlKS5zZWNvbmQoc2Vjb25kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXJ0RGF0ZShkYXRlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmVuZERhdGUgJiYgZGF0ZS5pc0JlZm9yZSh0aGlzLnN0YXJ0RGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlOiBjbGlja2luZyB0aGUgc2FtZSBkYXRlIGZvciBzdGFydC9lbmQsXHJcbiAgICAgICAgICAgICAgICAvL2J1dCB0aGUgdGltZSBvZiB0aGUgZW5kIGRhdGUgaXMgYmVmb3JlIHRoZSBzdGFydCBkYXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVuZERhdGUodGhpcy5zdGFydERhdGUuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHBpY2tpbmcgZW5kXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvdXIgPSBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLmhvdXJzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbXBtID0gdGhpcy5jb250YWluZXIuZmluZCgnLnJpZ2h0IC5hbXBtc2VsZWN0JykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnUE0nICYmIGhvdXIgPCAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnQU0nICYmIGhvdXIgPT09IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW51dGUgPSBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLm1pbnV0ZXNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZCA9IHRoaXMudGltZVBpY2tlclNlY29uZHMgPyBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLnNlY29uZHNlbGVjdCcpLnZhbCgpLCAxMCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBkYXRlLmNsb25lKCkuaG91cihob3VyKS5taW51dGUobWludXRlKS5zZWNvbmQoc2Vjb25kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZShkYXRlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0FwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQ2hvc2VuTGFiZWwoKTtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5jbGlja0FwcGx5KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZURhdGVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZSh0aGlzLnN0YXJ0RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQXBwbHkoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcblxyXG4gICAgICAgICAgICAvL1RoaXMgaXMgdG8gY2FuY2VsIHRoZSBibHVyIGV2ZW50IGhhbmRsZXIgaWYgdGhlIG1vdXNlIHdhcyBpbiBvbmUgb2YgdGhlIGlucHV0c1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjYWxjdWxhdGVDaG9zZW5MYWJlbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY3VzdG9tUmFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJhbmdlIGluIHRoaXMucmFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnREYXRlLmlzU2FtZSh0aGlzLnJhbmdlc1tyYW5nZV1bMF0pICYmIHRoaXMuZW5kRGF0ZS5pc1NhbWUodGhpcy5yYW5nZXNbcmFuZ2VdWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNob3NlbkxhYmVsID0gdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcyBsaTplcSgnICsgaSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpLmh0bWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lnbm9yZSB0aW1lcyB3aGVuIGNvbXBhcmluZyBkYXRlcyBpZiB0aW1lIHBpY2tlciBpcyBub3QgZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSA9PSB0aGlzLnJhbmdlc1tyYW5nZV1bMF0uZm9ybWF0KCdZWVlZLU1NLUREJykgJiYgdGhpcy5lbmREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpID09IHRoaXMucmFuZ2VzW3JhbmdlXVsxXS5mb3JtYXQoJ1lZWVktTU0tREQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21SYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNob3NlbkxhYmVsID0gdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcyBsaTplcSgnICsgaSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpLmh0bWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0N1c3RvbVJhbmdlTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNob3NlbkxhYmVsID0gdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcyBsaTpsYXN0JykuYWRkQ2xhc3MoJ2FjdGl2ZScpLmh0bWwoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaG9zZW5MYWJlbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dDYWxlbmRhcnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsaWNrQXBwbHk6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdhcHBseS5kYXRlcmFuZ2VwaWNrZXInLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGlja0NhbmNlbDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHRoaXMub2xkU3RhcnREYXRlO1xyXG4gICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLm9sZEVuZERhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignY2FuY2VsLmRhdGVyYW5nZXBpY2tlcicsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1vbnRoT3JZZWFyQ2hhbmdlZDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNMZWZ0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLmNhbGVuZGFyJykuaGFzQ2xhc3MoJ2xlZnQnKSxcclxuICAgICAgICAgICAgICAgIGxlZnRPclJpZ2h0ID0gaXNMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JyxcclxuICAgICAgICAgICAgICAgIGNhbCA9IHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci4nK2xlZnRPclJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vbnRoIG11c3QgYmUgTnVtYmVyIGZvciBuZXcgbW9tZW50IHZlcnNpb25zXHJcbiAgICAgICAgICAgIHZhciBtb250aCA9IHBhcnNlSW50KGNhbC5maW5kKCcubW9udGhzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgeWVhciA9IGNhbC5maW5kKCcueWVhcnNlbGVjdCcpLnZhbCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc0xlZnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5ZWFyIDwgdGhpcy5zdGFydERhdGUueWVhcigpIHx8ICh5ZWFyID09IHRoaXMuc3RhcnREYXRlLnllYXIoKSAmJiBtb250aCA8IHRoaXMuc3RhcnREYXRlLm1vbnRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSB0aGlzLnN0YXJ0RGF0ZS5tb250aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXIgPSB0aGlzLnN0YXJ0RGF0ZS55ZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1pbkRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5ZWFyIDwgdGhpcy5taW5EYXRlLnllYXIoKSB8fCAoeWVhciA9PSB0aGlzLm1pbkRhdGUueWVhcigpICYmIG1vbnRoIDwgdGhpcy5taW5EYXRlLm1vbnRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSB0aGlzLm1pbkRhdGUubW9udGgoKTtcclxuICAgICAgICAgICAgICAgICAgICB5ZWFyID0gdGhpcy5taW5EYXRlLnllYXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHllYXIgPiB0aGlzLm1heERhdGUueWVhcigpIHx8ICh5ZWFyID09IHRoaXMubWF4RGF0ZS55ZWFyKCkgJiYgbW9udGggPiB0aGlzLm1heERhdGUubW9udGgoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb250aCA9IHRoaXMubWF4RGF0ZS5tb250aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXIgPSB0aGlzLm1heERhdGUueWVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aC5tb250aChtb250aCkueWVhcih5ZWFyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmtlZENhbGVuZGFycylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Q2FsZW5kYXIubW9udGggPSB0aGlzLmxlZnRDYWxlbmRhci5tb250aC5jbG9uZSgpLmFkZCgxLCAnbW9udGgnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5tb250aChtb250aCkueWVhcih5ZWFyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmtlZENhbGVuZGFycylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aCA9IHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5jbG9uZSgpLnN1YnRyYWN0KDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsZW5kYXJzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdGltZUNoYW5nZWQ6IGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjYWwgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuY2FsZW5kYXInKSxcclxuICAgICAgICAgICAgICAgIGlzTGVmdCA9IGNhbC5oYXNDbGFzcygnbGVmdCcpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGhvdXIgPSBwYXJzZUludChjYWwuZmluZCgnLmhvdXJzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgbWludXRlID0gcGFyc2VJbnQoY2FsLmZpbmQoJy5taW51dGVzZWxlY3QnKS52YWwoKSwgMTApO1xyXG4gICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy50aW1lUGlja2VyU2Vjb25kcyA/IHBhcnNlSW50KGNhbC5maW5kKCcuc2Vjb25kc2VsZWN0JykudmFsKCksIDEwKSA6IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcjI0SG91cikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFtcG0gPSBjYWwuZmluZCgnLmFtcG1zZWxlY3QnKS52YWwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnUE0nICYmIGhvdXIgPCAxMilcclxuICAgICAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdBTScgJiYgaG91ciA9PT0gMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc0xlZnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5ob3VyKGhvdXIpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQubWludXRlKG1pbnV0ZSk7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zZWNvbmQoc2Vjb25kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnREYXRlKHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZURhdGVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVuZERhdGUgJiYgdGhpcy5lbmREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpID09IHN0YXJ0LmZvcm1hdCgnWVlZWS1NTS1ERCcpICYmIHRoaXMuZW5kRGF0ZS5pc0JlZm9yZShzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVuZERhdGUoc3RhcnQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lbmREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBlbmQuaG91cihob3VyKTtcclxuICAgICAgICAgICAgICAgIGVuZC5taW51dGUobWludXRlKTtcclxuICAgICAgICAgICAgICAgIGVuZC5zZWNvbmQoc2Vjb25kKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgY2FsZW5kYXJzIHNvIGFsbCBjbGlja2FibGUgZGF0ZXMgcmVmbGVjdCB0aGUgbmV3IHRpbWUgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsZW5kYXJzKCk7XHJcblxyXG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgZm9ybSBpbnB1dHMgYWJvdmUgdGhlIGNhbGVuZGFycyB3aXRoIHRoZSBuZXcgdGltZVxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1JbnB1dHMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vcmUtcmVuZGVyIHRoZSB0aW1lIHBpY2tlcnMgYmVjYXVzZSBjaGFuZ2luZyBvbmUgc2VsZWN0aW9uIGNhbiBhZmZlY3Qgd2hhdCdzIGVuYWJsZWQgaW4gYW5vdGhlclxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVQaWNrZXIoJ2xlZnQnKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUaW1lUGlja2VyKCdyaWdodCcpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmb3JtSW5wdXRzQ2hhbmdlZDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNSaWdodCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jYWxlbmRhcicpLmhhc0NsYXNzKCdyaWdodCcpO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBtb21lbnQodGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9zdGFydFwiXScpLnZhbCgpLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gbW9tZW50KHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfZW5kXCJdJykudmFsKCksIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RhcnQuaXNWYWxpZCgpICYmIGVuZC5pc1ZhbGlkKCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSaWdodCAmJiBlbmQuaXNCZWZvcmUoc3RhcnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGFydERhdGUoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmREYXRlKGVuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XCJdJykudmFsKHRoaXMuc3RhcnREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9lbmRcIl0nKS52YWwodGhpcy5lbmREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZvcm1JbnB1dHNGb2N1c2VkOiBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIGZvY3VzZWQgaW5wdXRcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9zdGFydFwiXSwgaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9lbmRcIl0nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICQoZS50YXJnZXQpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgc3RhdGUgc3VjaCB0aGF0IGlmIHRoZSB1c2VyIGdvZXMgYmFjayB0byB1c2luZyBhIG1vdXNlLCBcclxuICAgICAgICAgICAgLy8gdGhlIGNhbGVuZGFycyBhcmUgYXdhcmUgd2UncmUgc2VsZWN0aW5nIHRoZSBlbmQgb2YgdGhlIHJhbmdlLCBub3RcclxuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0LiBUaGlzIGFsbG93cyBzb21lb25lIHRvIGVkaXQgdGhlIGVuZCBvZiBhIGRhdGUgcmFuZ2Ugd2l0aG91dFxyXG4gICAgICAgICAgICAvLyByZS1zZWxlY3RpbmcgdGhlIGJlZ2lubmluZywgYnkgY2xpY2tpbmcgb24gdGhlIGVuZCBkYXRlIGlucHV0IHRoZW5cclxuICAgICAgICAgICAgLy8gdXNpbmcgdGhlIGNhbGVuZGFyLlxyXG4gICAgICAgICAgICB2YXIgaXNSaWdodCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jYWxlbmRhcicpLmhhc0NsYXNzKCdyaWdodCcpO1xyXG4gICAgICAgICAgICBpZiAoaXNSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnREYXRlKHRoaXMuc3RhcnREYXRlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZm9ybUlucHV0c0JsdXJyZWQ6IGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gaGFzIG9uZSBwdXJwb3NlIHJpZ2h0IG5vdzogaWYgeW91IHRhYiBmcm9tIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyB0ZXh0IGlucHV0IHRvIHRoZSBzZWNvbmQgaW4gdGhlIFVJLCB0aGUgZW5kRGF0ZSBpcyBudWxsZWQgc28gdGhhdFxyXG4gICAgICAgICAgICAvLyB5b3UgY2FuIGNsaWNrIGFub3RoZXIsIGJ1dCBpZiB5b3UgdGFiIG91dCB3aXRob3V0IGNsaWNraW5nIGFueXRoaW5nXHJcbiAgICAgICAgICAgIC8vIG9yIGNoYW5naW5nIHRoZSBpbnB1dCB2YWx1ZSwgdGhlIG9sZCBlbmREYXRlIHNob3VsZCBiZSByZXRhaW5lZFxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVuZERhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX2VuZFwiXScpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IG1vbWVudCh2YWwsIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZShlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVsZW1lbnRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuaXMoJ2lucHV0JykpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQudmFsKCkubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQudmFsKCkubGVuZ3RoIDwgdGhpcy5sb2NhbGUuZm9ybWF0Lmxlbmd0aCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGVTdHJpbmcgPSB0aGlzLmVsZW1lbnQudmFsKCkuc3BsaXQodGhpcy5sb2NhbGUuc2VwYXJhdG9yKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbnVsbCxcclxuICAgICAgICAgICAgICAgIGVuZCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0ZVN0cmluZy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KGRhdGVTdHJpbmdbMF0sIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBtb21lbnQoZGF0ZVN0cmluZ1sxXSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2luZ2xlRGF0ZVBpY2tlciB8fCBzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KHRoaXMuZWxlbWVudC52YWwoKSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSB8fCAhZW5kLmlzVmFsaWQoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRTdGFydERhdGUoc3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEVuZERhdGUoZW5kKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAvL2hpZGUgb24gdGFiIG9yIGVudGVyXHJcbiAgICAgICAgICAgIGlmICgoZS5rZXlDb2RlID09PSA5KSB8fCAoZS5rZXlDb2RlID09PSAxMykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlRWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2lucHV0JykgJiYgIXRoaXMuc2luZ2xlRGF0ZVBpY2tlciAmJiB0aGlzLmF1dG9VcGRhdGVJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnZhbCh0aGlzLnN0YXJ0RGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSArIHRoaXMubG9jYWxlLnNlcGFyYXRvciArIHRoaXMuZW5kRGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpICYmIHRoaXMuYXV0b1VwZGF0ZUlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudmFsKHRoaXMuc3RhcnREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQub2ZmKCcuZGF0ZXJhbmdlcGlja2VyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVEYXRhKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgJC5mbi5kYXRlcmFuZ2VwaWNrZXIgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gJCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGVsLmRhdGEoJ2RhdGVyYW5nZXBpY2tlcicpKVxyXG4gICAgICAgICAgICAgICAgZWwuZGF0YSgnZGF0ZXJhbmdlcGlja2VyJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGVsLmRhdGEoJ2RhdGVyYW5nZXBpY2tlcicsIG5ldyBEYXRlUmFuZ2VQaWNrZXIoZWwsIG9wdGlvbnMsIGNhbGxiYWNrKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBEYXRlUmFuZ2VQaWNrZXI7XHJcblxyXG59KSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGVyYW5nZXBpY2tlci9kYXRlcmFuZ2VwaWNrZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2RhdGVyYW5nZXBpY2tlci9kYXRlcmFuZ2VwaWNrZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSwgcmVxdWlyZShcIm1vbWVudFwiKSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcblx0XHRkZWZpbmUoW1wianF1ZXJ5XCIsIFwibW9tZW50XCJdLCBmYWN0b3J5KTtcclxuXHRlbHNlIHtcclxuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwianF1ZXJ5XCIpLCByZXF1aXJlKFwibW9tZW50XCIpKSA6IGZhY3Rvcnkocm9vdFtcImpRdWVyeVwiXSwgcm9vdFtcIm1vbWVudFwiXSk7XHJcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XHJcblx0fVxyXG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XHJcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcclxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXHJcbi8qKioqKiovIFx0XHRcdH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xyXG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNzIpO1xyXG4vKioqKioqLyB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqLyAoW1xyXG4vKiAwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblxyXG4vKlxyXG5kZXJpdmVkIGZyb206XHJcbmh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvdHNsaWIvYmxvYi92MS42LjAvdHNsaWIuanNcclxuXHJcbm9ubHkgaW5jbHVkZSB0aGUgaGVscGVycyB3ZSBuZWVkLCB0byBrZWVwIGRvd24gZmlsZXNpemVcclxuKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID1cclxuXHQvKiBOT1RFOiB0c2xpYidzIGFzLWlzIG1ldGhvZCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGhvdyBDb2ZmZWVTY3JpcHQgZG9lcyBzdWJjbGFzc2VzLlxyXG5cdCAqIFdoZW4gQ29mZmVlU2NyaXB0IGlzIHN0cmlwcGVkIG91dCwgY2FuIHJldmVydC5cclxuXHQgKlxyXG5cdCAqIE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG5cdCAqICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuXHQgKi9cclxuXHRmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydHMuX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuXHRleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG5cdGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG5cdGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgRE9NIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gR2l2ZW4gdGhlIHNjcm9sbGJhciB3aWR0aHMgb2Ygc29tZSBvdGhlciBjb250YWluZXIsIGNyZWF0ZSBib3JkZXJzL21hcmdpbnMgb24gcm93RWxzIGluIG9yZGVyIHRvIG1hdGNoIHRoZSBsZWZ0XHJcbi8vIGFuZCByaWdodCBzcGFjZSB0aGF0IHdhcyBvZmZzZXQgYnkgdGhlIHNjcm9sbGJhcnMuIEEgMS1waXhlbCBib3JkZXIgZmlyc3QsIHRoZW4gbWFyZ2luIGJleW9uZCB0aGF0LlxyXG5mdW5jdGlvbiBjb21wZW5zYXRlU2Nyb2xsKHJvd0Vscywgc2Nyb2xsYmFyV2lkdGhzKSB7XHJcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQpIHtcclxuICAgICAgICByb3dFbHMuY3NzKHtcclxuICAgICAgICAgICAgJ2JvcmRlci1sZWZ0LXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ21hcmdpbi1sZWZ0Jzogc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgcm93RWxzLmNzcyh7XHJcbiAgICAgICAgICAgICdib3JkZXItcmlnaHQtd2lkdGgnOiAxLFxyXG4gICAgICAgICAgICAnbWFyZ2luLXJpZ2h0Jzogc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IC0gMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29tcGVuc2F0ZVNjcm9sbCA9IGNvbXBlbnNhdGVTY3JvbGw7XHJcbi8vIFVuZG9lcyBjb21wZW5zYXRlU2Nyb2xsIGFuZCByZXN0b3JlcyBhbGwgYm9yZGVycy9tYXJnaW5zXHJcbmZ1bmN0aW9uIHVuY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMpIHtcclxuICAgIHJvd0Vscy5jc3Moe1xyXG4gICAgICAgICdtYXJnaW4tbGVmdCc6ICcnLFxyXG4gICAgICAgICdtYXJnaW4tcmlnaHQnOiAnJyxcclxuICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnOiAnJyxcclxuICAgICAgICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogJydcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMudW5jb21wZW5zYXRlU2Nyb2xsID0gdW5jb21wZW5zYXRlU2Nyb2xsO1xyXG4vLyBNYWtlIHRoZSBtb3VzZSBjdXJzb3IgZXhwcmVzcyB0aGF0IGFuIGV2ZW50IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBjdXJyZW50IGFyZWFcclxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcclxuICAgICQoJ2JvZHknKS5hZGRDbGFzcygnZmMtbm90LWFsbG93ZWQnKTtcclxufVxyXG5leHBvcnRzLmRpc2FibGVDdXJzb3IgPSBkaXNhYmxlQ3Vyc29yO1xyXG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcclxuZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xyXG4gICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xyXG59XHJcbmV4cG9ydHMuZW5hYmxlQ3Vyc29yID0gZW5hYmxlQ3Vyc29yO1xyXG4vLyBHaXZlbiBhIHRvdGFsIGF2YWlsYWJsZSBoZWlnaHQgdG8gZmlsbCwgaGF2ZSBgZWxzYCAoZXNzZW50aWFsbHkgY2hpbGQgcm93cykgZXhwYW5kIHRvIGFjY29tb2RhdGUuXHJcbi8vIEJ5IGRlZmF1bHQsIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBzaG9ydGVyIHRoYW4gdGhlIHJlY29tbWVuZGVkIGhlaWdodCBhcmUgZXhwYW5kZWQgdW5pZm9ybWx5LCBub3QgY29uc2lkZXJpbmdcclxuLy8gYW55IG90aGVyIGVscyB0aGF0IGFyZSBhbHJlYWR5IHRvbyB0YWxsLiBpZiBgc2hvdWxkUmVkaXN0cmlidXRlYCBpcyBvbiwgaXQgY29uc2lkZXJzIHRoZXNlIHRhbGwgcm93cyBhbmRcclxuLy8gcmVkdWNlcyB0aGUgYXZhaWxhYmxlIGhlaWdodC5cclxuZnVuY3Rpb24gZGlzdHJpYnV0ZUhlaWdodChlbHMsIGF2YWlsYWJsZUhlaWdodCwgc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAvLyAqRkxPT1JJTkcgTk9URSo6IHdlIGZsb29yIGluIGNlcnRhaW4gcGxhY2VzIGJlY2F1c2Ugem9vbSBjYW4gZ2l2ZSBpbmFjY3VyYXRlIGZsb2F0aW5nLXBvaW50IGRpbWVuc2lvbnMsXHJcbiAgICAvLyBhbmQgaXQgaXMgYmV0dGVyIHRvIGJlIHNob3J0ZXIgdGhhbiB0YWxsZXIsIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IHNjcm9sbGJhcnMuXHJcbiAgICB2YXIgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZWxzLmxlbmd0aCk7IC8vIGZvciBub24tbGFzdCBlbGVtZW50XHJcbiAgICB2YXIgbWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChlbHMubGVuZ3RoIC0gMSkpOyAvLyBmb3IgbGFzdCBlbGVtZW50ICpGTE9PUklORyBOT1RFKlxyXG4gICAgdmFyIGZsZXhFbHMgPSBbXTsgLy8gZWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBleHBhbmQuIGFycmF5IG9mIERPTSBub2Rlc1xyXG4gICAgdmFyIGZsZXhPZmZzZXRzID0gW107IC8vIGFtb3VudCBvZiB2ZXJ0aWNhbCBzcGFjZSBpdCB0YWtlcyB1cFxyXG4gICAgdmFyIGZsZXhIZWlnaHRzID0gW107IC8vIGFjdHVhbCBjc3MgaGVpZ2h0XHJcbiAgICB2YXIgdXNlZEhlaWdodCA9IDA7XHJcbiAgICB1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKTsgLy8gZ2l2ZSBhbGwgZWxlbWVudHMgdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuICAgIC8vIGZpbmQgZWxlbWVudHMgdGhhdCBhcmUgYmVsb3cgdGhlIHJlY29tbWVuZGVkIGhlaWdodCAoZXhwYW5kYWJsZSkuXHJcbiAgICAvLyBpbXBvcnRhbnQgdG8gcXVlcnkgZm9yIGhlaWdodHMgaW4gYSBzaW5nbGUgZmlyc3QgcGFzcyAodG8gYXZvaWQgcmVmbG93IG9zY2lsbGF0aW9uKS5cclxuICAgIGVscy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgIHZhciBtaW5PZmZzZXQgPSBpID09PSBlbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gJChlbCkub3V0ZXJIZWlnaHQodHJ1ZSk7XHJcbiAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgZmxleEVscy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgZmxleE9mZnNldHMucHVzaChuYXR1cmFsT2Zmc2V0KTtcclxuICAgICAgICAgICAgZmxleEhlaWdodHMucHVzaCgkKGVsKS5oZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgc3RyZXRjaGVzIHBhc3QgcmVjb21tZW5kZWQgaGVpZ2h0IChub24tZXhwYW5kYWJsZSkuIG1hcmsgdGhlIHNwYWNlIGFzIG9jY3VwaWVkLlxyXG4gICAgICAgICAgICB1c2VkSGVpZ2h0ICs9IG5hdHVyYWxPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyByZWFkanVzdCB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IHRvIG9ubHkgY29uc2lkZXIgdGhlIGhlaWdodCBhdmFpbGFibGUgdG8gbm9uLW1heGVkLW91dCByb3dzLlxyXG4gICAgaWYgKHNob3VsZFJlZGlzdHJpYnV0ZSkge1xyXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCAtPSB1c2VkSGVpZ2h0O1xyXG4gICAgICAgIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGZsZXhFbHMubGVuZ3RoKTtcclxuICAgICAgICBtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGZsZXhFbHMubGVuZ3RoIC0gMSkpOyAvLyAqRkxPT1JJTkcgTk9URSpcclxuICAgIH1cclxuICAgIC8vIGFzc2lnbiBoZWlnaHRzIHRvIGFsbCBleHBhbmRhYmxlIGVsZW1lbnRzXHJcbiAgICAkKGZsZXhFbHMpLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgdmFyIG1pbk9mZnNldCA9IGkgPT09IGZsZXhFbHMubGVuZ3RoIC0gMSA/IG1pbk9mZnNldDIgOiBtaW5PZmZzZXQxO1xyXG4gICAgICAgIHZhciBuYXR1cmFsT2Zmc2V0ID0gZmxleE9mZnNldHNbaV07XHJcbiAgICAgICAgdmFyIG5hdHVyYWxIZWlnaHQgPSBmbGV4SGVpZ2h0c1tpXTtcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gbWluT2Zmc2V0IC0gKG5hdHVyYWxPZmZzZXQgLSBuYXR1cmFsSGVpZ2h0KTsgLy8gc3VidHJhY3QgdGhlIG1hcmdpbi9wYWRkaW5nXHJcbiAgICAgICAgaWYgKG5hdHVyYWxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgJChlbCkuaGVpZ2h0KG5ld0hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kaXN0cmlidXRlSGVpZ2h0ID0gZGlzdHJpYnV0ZUhlaWdodDtcclxuLy8gVW5kb2VzIGRpc3RydWJ1dGVIZWlnaHQsIHJlc3RvcmluZyBhbGwgZWxzIHRvIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XHJcbmZ1bmN0aW9uIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpIHtcclxuICAgIGVscy5oZWlnaHQoJycpO1xyXG59XHJcbmV4cG9ydHMudW5kaXN0cmlidXRlSGVpZ2h0ID0gdW5kaXN0cmlidXRlSGVpZ2h0O1xyXG4vLyBHaXZlbiBgZWxzYCwgYSBqUXVlcnkgc2V0IG9mIDx0ZD4gY2VsbHMsIGZpbmQgdGhlIGNlbGwgd2l0aCB0aGUgbGFyZ2VzdCBuYXR1cmFsIHdpZHRoIGFuZCBzZXQgdGhlIHdpZHRocyBvZiBhbGwgdGhlXHJcbi8vIGNlbGxzIHRvIGJlIHRoYXQgd2lkdGguXHJcbi8vIFBSRVJFUVVJU0lURTogaWYgeW91IHdhbnQgYSBjZWxsIHRvIHRha2UgdXAgd2lkdGgsIGl0IG5lZWRzIHRvIGhhdmUgYSBzaW5nbGUgaW5uZXIgZWxlbWVudCB3LyBkaXNwbGF5OmlubGluZVxyXG5mdW5jdGlvbiBtYXRjaENlbGxXaWR0aHMoZWxzKSB7XHJcbiAgICB2YXIgbWF4SW5uZXJXaWR0aCA9IDA7XHJcbiAgICBlbHMuZmluZCgnPiAqJykuZWFjaChmdW5jdGlvbiAoaSwgaW5uZXJFbCkge1xyXG4gICAgICAgIHZhciBpbm5lcldpZHRoID0gJChpbm5lckVsKS5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgaWYgKGlubmVyV2lkdGggPiBtYXhJbm5lcldpZHRoKSB7XHJcbiAgICAgICAgICAgIG1heElubmVyV2lkdGggPSBpbm5lcldpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgbWF4SW5uZXJXaWR0aCsrOyAvLyBzb21ldGltZXMgbm90IGFjY3VyYXRlIG9mIHdpZHRoIHRoZSB0ZXh0IG5lZWRzIHRvIHN0YXkgb24gb25lIGxpbmUuIGluc3VyYW5jZVxyXG4gICAgZWxzLndpZHRoKG1heElubmVyV2lkdGgpO1xyXG4gICAgcmV0dXJuIG1heElubmVyV2lkdGg7XHJcbn1cclxuZXhwb3J0cy5tYXRjaENlbGxXaWR0aHMgPSBtYXRjaENlbGxXaWR0aHM7XHJcbi8vIEdpdmVuIG9uZSBlbGVtZW50IHRoYXQgcmVzaWRlcyBpbnNpZGUgYW5vdGhlcixcclxuLy8gU3VidHJhY3RzIHRoZSBoZWlnaHQgb2YgdGhlIGlubmVyIGVsZW1lbnQgZnJvbSB0aGUgb3V0ZXIgZWxlbWVudC5cclxuZnVuY3Rpb24gc3VidHJhY3RJbm5lckVsSGVpZ2h0KG91dGVyRWwsIGlubmVyRWwpIHtcclxuICAgIHZhciBib3RoID0gb3V0ZXJFbC5hZGQoaW5uZXJFbCk7XHJcbiAgICB2YXIgZGlmZjtcclxuICAgIC8vIGVmZmluJyBJRTgvOS8xMC8xMSBzb21ldGltZXMgcmV0dXJucyAwIGZvciBkaW1lbnNpb25zLiB0aGlzIHdlaXJkIGhhY2sgd2FzIHRoZSBvbmx5IHRoaW5nIHRoYXQgd29ya2VkXHJcbiAgICBib3RoLmNzcyh7XHJcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgbGVmdDogLTEgLy8gZW5zdXJlIHJlZmxvdyBpbiBjYXNlIHRoZSBlbCB3YXMgYWxyZWFkeSByZWxhdGl2ZS4gbmVnYXRpdmUgaXMgbGVzcyBsaWtlbHkgdG8gY2F1c2UgbmV3IHNjcm9sbFxyXG4gICAgfSk7XHJcbiAgICBkaWZmID0gb3V0ZXJFbC5vdXRlckhlaWdodCgpIC0gaW5uZXJFbC5vdXRlckhlaWdodCgpOyAvLyBncmFiIHRoZSBkaW1lbnNpb25zXHJcbiAgICBib3RoLmNzcyh7IHBvc2l0aW9uOiAnJywgbGVmdDogJycgfSk7IC8vIHVuZG8gaGFja1xyXG4gICAgcmV0dXJuIGRpZmY7XHJcbn1cclxuZXhwb3J0cy5zdWJ0cmFjdElubmVyRWxIZWlnaHQgPSBzdWJ0cmFjdElubmVyRWxIZWlnaHQ7XHJcbi8qIEVsZW1lbnQgR2VvbSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi8xLjExLjAvdWkvY29yZS5qcyNMNTFcclxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsKSB7XHJcbiAgICB2YXIgcG9zaXRpb24gPSBlbC5jc3MoJ3Bvc2l0aW9uJyksIHNjcm9sbFBhcmVudCA9IGVsLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSAkKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KHBhcmVudC5jc3MoJ292ZXJmbG93JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy15JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy14JykpO1xyXG4gICAgfSkuZXEoMCk7XHJcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICdmaXhlZCcgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggPyAkKGVsWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpIDogc2Nyb2xsUGFyZW50O1xyXG59XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50O1xyXG4vLyBRdWVyaWVzIHRoZSBvdXRlciBib3VuZGluZyBhcmVhIG9mIGEgalF1ZXJ5IGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxyXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXHJcbmZ1bmN0aW9uIGdldE91dGVyUmVjdChlbCwgb3JpZ2luKSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7XHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0IC0gKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyBlbC5vdXRlcldpZHRoKCksXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgYm90dG9tOiB0b3AgKyBlbC5vdXRlckhlaWdodCgpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0T3V0ZXJSZWN0ID0gZ2V0T3V0ZXJSZWN0O1xyXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9zY3JvbGxiYXJzIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIERvZXMgbm90IGdvIHdpdGhpbiB0aGUgcGFkZGluZy5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnNcclxuLy8gTk9URTogc2hvdWxkIHVzZSBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IHZlcnkgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyLlxyXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcclxuICAgIHZhciBzY3JvbGxiYXJXaWR0aHMgPSBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpO1xyXG4gICAgdmFyIGxlZnQgPSBvZmZzZXQubGVmdCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSArIHNjcm9sbGJhcldpZHRocy5sZWZ0IC0gKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyBlbFswXS5jbGllbnRXaWR0aCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsWzBdLmNsaWVudEhlaWdodCAvLyBjbGllbnRIZWlnaHQgaW5jbHVkZXMgcGFkZGluZyBidXQgTk9UIHNjcm9sbGJhcnNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdDtcclxuLy8gUXVlcmllcyB0aGUgYXJlYSB3aXRoaW4gdGhlIG1hcmdpbi9ib3JkZXIvcGFkZGluZyBvZiBhIGpRdWVyeSBlbGVtZW50LiBBc3N1bWVkIG5vdCB0byBoYXZlIHNjcm9sbGJhcnMuXHJcbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxyXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXHJcbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTsgLy8ganVzdCBvdXRzaWRlIG9mIGJvcmRlciwgbWFyZ2luIG5vdCBpbmNsdWRlZFxyXG4gICAgdmFyIGxlZnQgPSBvZmZzZXQubGVmdCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSArIGdldENzc0Zsb2F0KGVsLCAncGFkZGluZy1sZWZ0JykgLVxyXG4gICAgICAgIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xyXG4gICAgdmFyIHRvcCA9IG9mZnNldC50b3AgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci10b3Atd2lkdGgnKSArIGdldENzc0Zsb2F0KGVsLCAncGFkZGluZy10b3AnKSAtXHJcbiAgICAgICAgKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsLndpZHRoKCksXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgYm90dG9tOiB0b3AgKyBlbC5oZWlnaHQoKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldENvbnRlbnRSZWN0ID0gZ2V0Q29udGVudFJlY3Q7XHJcbi8vIFJldHVybnMgdGhlIGNvbXB1dGVkIGxlZnQvcmlnaHQvdG9wL2JvdHRvbSBzY3JvbGxiYXIgd2lkdGhzIGZvciB0aGUgZ2l2ZW4galF1ZXJ5IGVsZW1lbnQuXHJcbi8vIFdBUk5JTkc6IGdpdmVuIGVsZW1lbnQgY2FuJ3QgaGF2ZSBib3JkZXJzICh3aGljaCB3aWxsIGNhdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB0byBiZSBsYXJnZXIpLlxyXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXHJcbmZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocyhlbCkge1xyXG4gICAgdmFyIGxlZnRSaWdodFdpZHRoID0gZWxbMF0ub2Zmc2V0V2lkdGggLSBlbFswXS5jbGllbnRXaWR0aDtcclxuICAgIHZhciBib3R0b21XaWR0aCA9IGVsWzBdLm9mZnNldEhlaWdodCAtIGVsWzBdLmNsaWVudEhlaWdodDtcclxuICAgIHZhciB3aWR0aHM7XHJcbiAgICBsZWZ0UmlnaHRXaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgobGVmdFJpZ2h0V2lkdGgpO1xyXG4gICAgYm90dG9tV2lkdGggPSBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKGJvdHRvbVdpZHRoKTtcclxuICAgIHdpZHRocyA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiBib3R0b21XaWR0aCB9O1xyXG4gICAgaWYgKGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSAmJiBlbC5jc3MoJ2RpcmVjdGlvbicpID09ICdydGwnKSB7XHJcbiAgICAgICAgd2lkdGhzLmxlZnQgPSBsZWZ0UmlnaHRXaWR0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpZHRocy5yaWdodCA9IGxlZnRSaWdodFdpZHRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpZHRocztcclxufVxyXG5leHBvcnRzLmdldFNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocztcclxuLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gZ2V0U2Nyb2xsYmFyV2lkdGhzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cclxuLy8gcmV0aW5hIGRpc3BsYXlzLCByb3VuZGluZywgYW5kIElFMTEuIE1hc3NhZ2UgdGhlbSBpbnRvIGEgdXNhYmxlIHZhbHVlLlxyXG5mdW5jdGlvbiBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKHdpZHRoKSB7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXHJcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59XHJcbi8vIExvZ2ljIGZvciBkZXRlcm1pbmluZyBpZiwgd2hlbiB0aGUgZWxlbWVudCBpcyByaWdodC10by1sZWZ0LCB0aGUgc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgc2lkZVxyXG52YXIgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgaWYgKF9pc0xlZnRSdGxTY3JvbGxiYXJzID09PSBudWxsKSB7XHJcbiAgICAgICAgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBjb21wdXRlSXNMZWZ0UnRsU2Nyb2xsYmFycygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc0xlZnRSdGxTY3JvbGxiYXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgdmFyIGVsID0gJCgnPGRpdj48ZGl2Lz48L2Rpdj4nKVxyXG4gICAgICAgIC5jc3Moe1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogLTEwMDAsXHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgcGFkZGluZzogMCxcclxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXHJcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJ1xyXG4gICAgfSlcclxuICAgICAgICAuYXBwZW5kVG8oJ2JvZHknKTtcclxuICAgIHZhciBpbm5lckVsID0gZWwuY2hpbGRyZW4oKTtcclxuICAgIHZhciByZXMgPSBpbm5lckVsLm9mZnNldCgpLmxlZnQgPiBlbC5vZmZzZXQoKS5sZWZ0OyAvLyBpcyB0aGUgaW5uZXIgZGl2IHNoaWZ0ZWQgdG8gYWNjb21tb2RhdGUgYSBsZWZ0IHNjcm9sbGJhcj9cclxuICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vLyBSZXRyaWV2ZXMgYSBqUXVlcnkgZWxlbWVudCdzIGNvbXB1dGVkIENTUyB2YWx1ZSBhcyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cclxuLy8gSWYgdGhlIHF1ZXJpZWQgdmFsdWUgaXMgbm9uLW51bWVyaWMgKGV4OiBJRSBjYW4gcmV0dXJuIFwibWVkaXVtXCIgZm9yIGJvcmRlciB3aWR0aCksIHdpbGwganVzdCByZXR1cm4gemVyby5cclxuZnVuY3Rpb24gZ2V0Q3NzRmxvYXQoZWwsIHByb3ApIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KGVsLmNzcyhwcm9wKSkgfHwgMDtcclxufVxyXG4vKiBNb3VzZSAvIFRvdWNoIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXHJcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSB7XHJcbiAgICByZXR1cm4gZXYud2hpY2ggPT0gMSAmJiAhZXYuY3RybEtleTtcclxufVxyXG5leHBvcnRzLmlzUHJpbWFyeU1vdXNlQnV0dG9uID0gaXNQcmltYXJ5TW91c2VCdXR0b247XHJcbmZ1bmN0aW9uIGdldEV2WChldikge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldi5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XHJcbiAgICAvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcclxuICAgIC8vIHNvLCBsb29rIGF0IHRvdWNoIGNvb3JkaW5hdGVzIGZpcnN0LlxyXG4gICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdG91Y2hlc1swXS5wYWdlWDtcclxuICAgIH1cclxuICAgIHJldHVybiBldi5wYWdlWDtcclxufVxyXG5leHBvcnRzLmdldEV2WCA9IGdldEV2WDtcclxuZnVuY3Rpb24gZ2V0RXZZKGV2KSB7XHJcbiAgICB2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcclxuICAgIC8vIG9uIG1vYmlsZSBGRiwgcGFnZVggZm9yIHRvdWNoIGV2ZW50cyBpcyBwcmVzZW50LCBidXQgaW5jb3JyZWN0LFxyXG4gICAgLy8gc28sIGxvb2sgYXQgdG91Y2ggY29vcmRpbmF0ZXMgZmlyc3QuXHJcbiAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2LnBhZ2VZO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZZID0gZ2V0RXZZO1xyXG5mdW5jdGlvbiBnZXRFdklzVG91Y2goZXYpIHtcclxuICAgIHJldHVybiAvXnRvdWNoLy50ZXN0KGV2LnR5cGUpO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZJc1RvdWNoID0gZ2V0RXZJc1RvdWNoO1xyXG5mdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XHJcbiAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcclxuICAgICAgICAub24oJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG59XHJcbmV4cG9ydHMucHJldmVudFNlbGVjdGlvbiA9IHByZXZlbnRTZWxlY3Rpb247XHJcbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XHJcbiAgICBlbC5yZW1vdmVDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcclxuICAgICAgICAub2ZmKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5leHBvcnRzLmFsbG93U2VsZWN0aW9uID0gYWxsb3dTZWxlY3Rpb247XHJcbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxyXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XHJcbi8qIEdlbmVyYWwgR2VvbWV0cnkgVXRpbHNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXHJcbmZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xyXG4gICAgdmFyIHJlcyA9IHtcclxuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcclxuICAgICAgICByaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcclxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcclxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxyXG4gICAgfTtcclxuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IGludGVyc2VjdFJlY3RzO1xyXG4vLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXHJcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxyXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNvbnN0cmFpblBvaW50ID0gY29uc3RyYWluUG9pbnQ7XHJcbi8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMixcclxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDJcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gZ2V0UmVjdENlbnRlcjtcclxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXHJcbmZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcclxuICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGlmZlBvaW50cyA9IGRpZmZQb2ludHM7XHJcbi8qIE9iamVjdCBPcmRlcmluZyBieSBGaWVsZFxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XHJcbiAgICB2YXIgc3BlY3MgPSBbXTtcclxuICAgIHZhciB0b2tlbnMgPSBbXTtcclxuICAgIHZhciBpLCB0b2tlbjtcclxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICB0b2tlbnMgPSBpbnB1dDtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PSAnLScgP1xyXG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XHJcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNwZWNzO1xyXG59XHJcbmV4cG9ydHMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xyXG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajEsIG9iajIsIGZpZWxkU3BlY3MpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGNtcDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajEsIG9iajIsIGZpZWxkU3BlY3NbaV0pO1xyXG4gICAgICAgIGlmIChjbXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSBjb21wYXJlQnlGaWVsZFNwZWNzO1xyXG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMSwgb2JqMiwgZmllbGRTcGVjKSB7XHJcbiAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMSwgb2JqMik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKG9iajFbZmllbGRTcGVjLmZpZWxkXSwgb2JqMltmaWVsZFNwZWMuZmllbGRdKSAqXHJcbiAgICAgICAgKGZpZWxkU3BlYy5vcmRlciB8fCAxKTtcclxufVxyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IGNvbXBhcmVCeUZpZWxkU3BlYztcclxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcclxuICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGlmICgkLnR5cGUoYSkgPT09ICdzdHJpbmcnIHx8ICQudHlwZShiKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IGZsZXhpYmxlQ29tcGFyZTtcclxuLyogRGF0ZSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbmV4cG9ydHMuZGF5SURzID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcclxuZXhwb3J0cy51bml0c0Rlc2MgPSBbJ3llYXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107IC8vIGRlc2NlbmRpbmdcclxuLy8gRGlmZnMgdGhlIHR3byBtb21lbnRzIGludG8gYSBEdXJhdGlvbiB3aGVyZSBmdWxsLWRheXMgYXJlIHJlY29yZGVkIGZpcnN0LCB0aGVuIHRoZSByZW1haW5pbmcgdGltZS5cclxuLy8gTW9tZW50cyB3aWxsIGhhdmUgdGhlaXIgdGltZXpvbmVzIG5vcm1hbGl6ZWQuXHJcbmZ1bmN0aW9uIGRpZmZEYXlUaW1lKGEsIGIpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xyXG4gICAgICAgIGRheXM6IGEuY2xvbmUoKS5zdHJpcFRpbWUoKS5kaWZmKGIuY2xvbmUoKS5zdHJpcFRpbWUoKSwgJ2RheXMnKSxcclxuICAgICAgICBtczogYS50aW1lKCkgLSBiLnRpbWUoKSAvLyB0aW1lLW9mLWRheSBmcm9tIGRheSBzdGFydC4gZGlzcmVnYXJkcyB0aW1lem9uZVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kaWZmRGF5VGltZSA9IGRpZmZEYXlUaW1lO1xyXG4vLyBEaWZmcyB0aGUgdHdvIG1vbWVudHMgdmlhIHRoZWlyIHN0YXJ0LW9mLWRheSAocmVnYXJkbGVzcyBvZiB0aW1lem9uZSkuIFByb2R1Y2VzIHdob2xlLWRheSBkdXJhdGlvbnMuXHJcbmZ1bmN0aW9uIGRpZmZEYXkoYSwgYikge1xyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpZmZEYXkgPSBkaWZmRGF5O1xyXG4vLyBEaWZmcyB0d28gbW9tZW50cywgcHJvZHVjaW5nIGEgZHVyYXRpb24sIG1hZGUgb2YgYSB3aG9sZS11bml0LWluY3JlbWVudCBvZiB0aGUgZ2l2ZW4gdW5pdC4gVXNlcyByb3VuZGluZy5cclxuZnVuY3Rpb24gZGlmZkJ5VW5pdChhLCBiLCB1bml0KSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKE1hdGgucm91bmQoYS5kaWZmKGIsIHVuaXQsIHRydWUpKSwgLy8gcmV0dXJuRmxvYXQ9dHJ1ZVxyXG4gICAgdW5pdCk7XHJcbn1cclxuZXhwb3J0cy5kaWZmQnlVbml0ID0gZGlmZkJ5VW5pdDtcclxuLy8gQ29tcHV0ZXMgdGhlIHVuaXQgbmFtZSBvZiB0aGUgbGFyZ2VzdCB3aG9sZS11bml0IHBlcmlvZCBvZiB0aW1lLlxyXG4vLyBGb3IgZXhhbXBsZSwgNDggaG91cnMgd2lsbCBiZSBcImRheXNcIiB3aGVyZWFzIDQ5IGhvdXJzIHdpbGwgYmUgXCJob3Vyc1wiLlxyXG4vLyBBY2NlcHRzIHN0YXJ0L2VuZCwgYSByYW5nZSBvYmplY3QsIG9yIGFuIG9yaWdpbmFsIGR1cmF0aW9uIG9iamVjdC5cclxuZnVuY3Rpb24gY29tcHV0ZUdyZWF0ZXN0VW5pdChzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgaSwgdW5pdDtcclxuICAgIHZhciB2YWw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy51bml0c0Rlc2MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB1bml0ID0gZXhwb3J0cy51bml0c0Rlc2NbaV07XHJcbiAgICAgICAgdmFsID0gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgaWYgKHZhbCA+PSAxICYmIGlzSW50KHZhbCkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXQ7IC8vIHdpbGwgYmUgXCJtaWxsaXNlY29uZHNcIiBpZiBub3RoaW5nIGVsc2UgbWF0Y2hlc1xyXG59XHJcbmV4cG9ydHMuY29tcHV0ZUdyZWF0ZXN0VW5pdCA9IGNvbXB1dGVHcmVhdGVzdFVuaXQ7XHJcbi8vIGxpa2UgY29tcHV0ZUdyZWF0ZXN0VW5pdCwgYnV0IGhhcyBzcGVjaWFsIGFiaWxpdGllcyB0byBpbnRlcnByZXQgdGhlIHNvdXJjZSBpbnB1dCBmb3IgY2x1ZXNcclxuZnVuY3Rpb24gY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0KGR1cmF0aW9uLCBkdXJhdGlvbklucHV0KSB7XHJcbiAgICB2YXIgdW5pdCA9IGNvbXB1dGVHcmVhdGVzdFVuaXQoZHVyYXRpb24pO1xyXG4gICAgLy8gcHJldmVudCBkYXlzOjcgZnJvbSBiZWluZyBpbnRlcnByZXRlZCBhcyBhIHdlZWtcclxuICAgIGlmICh1bml0ID09PSAnd2VlaycgJiYgdHlwZW9mIGR1cmF0aW9uSW5wdXQgPT09ICdvYmplY3QnICYmIGR1cmF0aW9uSW5wdXQuZGF5cykge1xyXG4gICAgICAgIHVuaXQgPSAnZGF5JztcclxuICAgIH1cclxuICAgIHJldHVybiB1bml0O1xyXG59XHJcbmV4cG9ydHMuY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0ID0gY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0O1xyXG4vLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIHVuaXRzIChsaWtlIFwiaG91cnNcIikgaW4gdGhlIGdpdmVuIHJhbmdlLlxyXG4vLyBSYW5nZSBjYW4gYmUgYSB7c3RhcnQsZW5kfSBvYmplY3QsIHNlcGFyYXRlIHN0YXJ0L2VuZCBhcmdzLCBvciBhIER1cmF0aW9uLlxyXG4vLyBSZXN1bHRzIGFyZSBiYXNlZCBvbiBNb21lbnQncyAuYXMoKSBhbmQgLmRpZmYoKSBtZXRob2RzLCBzbyByZXN1bHRzIGNhbiBkZXBlbmQgb24gaW50ZXJuYWwgaGFuZGxpbmdcclxuLy8gb2YgbW9udGgtZGlmZmluZyBsb2dpYyAod2hpY2ggdGVuZHMgdG8gdmFyeSBmcm9tIHZlcnNpb24gdG8gdmVyc2lvbikuXHJcbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZUFzKHVuaXQsIHN0YXJ0LCBlbmQpIHtcclxuICAgIGlmIChlbmQgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtb21lbnQuaXNEdXJhdGlvbihzdGFydCkpIHtcclxuICAgICAgICByZXR1cm4gc3RhcnQuYXModW5pdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc3RhcnQuZW5kLmRpZmYoc3RhcnQuc3RhcnQsIHVuaXQsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8vIEludGVsbGlnZW50bHkgZGl2aWRlcyBhIHJhbmdlIChzcGVjaWZpZWQgYnkgYSBzdGFydC9lbmQgcGFyYW1zKSBieSBhIGR1cmF0aW9uXHJcbmZ1bmN0aW9uIGRpdmlkZVJhbmdlQnlEdXJhdGlvbihzdGFydCwgZW5kLCBkdXIpIHtcclxuICAgIHZhciBtb250aHM7XHJcbiAgICBpZiAoZHVyYXRpb25IYXNUaW1lKGR1cikpIHtcclxuICAgICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cjtcclxuICAgIH1cclxuICAgIG1vbnRocyA9IGR1ci5hc01vbnRocygpO1xyXG4gICAgaWYgKE1hdGguYWJzKG1vbnRocykgPj0gMSAmJiBpc0ludChtb250aHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnbW9udGhzJywgdHJ1ZSkgLyBtb250aHM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsICdkYXlzJywgdHJ1ZSkgLyBkdXIuYXNEYXlzKCk7XHJcbn1cclxuZXhwb3J0cy5kaXZpZGVSYW5nZUJ5RHVyYXRpb24gPSBkaXZpZGVSYW5nZUJ5RHVyYXRpb247XHJcbi8vIEludGVsbGlnZW50bHkgZGl2aWRlcyBvbmUgZHVyYXRpb24gYnkgYW5vdGhlclxyXG5mdW5jdGlvbiBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24oZHVyMSwgZHVyMikge1xyXG4gICAgdmFyIG1vbnRoczEsIG1vbnRoczI7XHJcbiAgICBpZiAoZHVyYXRpb25IYXNUaW1lKGR1cjEpIHx8IGR1cmF0aW9uSGFzVGltZShkdXIyKSkge1xyXG4gICAgICAgIHJldHVybiBkdXIxIC8gZHVyMjtcclxuICAgIH1cclxuICAgIG1vbnRoczEgPSBkdXIxLmFzTW9udGhzKCk7XHJcbiAgICBtb250aHMyID0gZHVyMi5hc01vbnRocygpO1xyXG4gICAgaWYgKE1hdGguYWJzKG1vbnRoczEpID49IDEgJiYgaXNJbnQobW9udGhzMSkgJiZcclxuICAgICAgICBNYXRoLmFicyhtb250aHMyKSA+PSAxICYmIGlzSW50KG1vbnRoczIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbnRoczEgLyBtb250aHMyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGR1cjEuYXNEYXlzKCkgLyBkdXIyLmFzRGF5cygpO1xyXG59XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uO1xyXG4vLyBJbnRlbGxpZ2VudGx5IG11bHRpcGxpZXMgYSBkdXJhdGlvbiBieSBhIG51bWJlclxyXG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGR1ciwgbikge1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZHVyICogbik7XHJcbiAgICB9XHJcbiAgICBtb250aHMgPSBkdXIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBtb250aHM6IG1vbnRocyAqIG4gfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogZHVyLmFzRGF5cygpICogbiB9KTtcclxufVxyXG5leHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBkdXJhdGlvbiBoYXMgYW55IHRpbWUgcGFydHMgKGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcylcclxuZnVuY3Rpb24gZHVyYXRpb25IYXNUaW1lKGR1cikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZHVyLmhvdXJzKCkgfHwgZHVyLm1pbnV0ZXMoKSB8fCBkdXIuc2Vjb25kcygpIHx8IGR1ci5taWxsaXNlY29uZHMoKSk7XHJcbn1cclxuZXhwb3J0cy5kdXJhdGlvbkhhc1RpbWUgPSBkdXJhdGlvbkhhc1RpbWU7XHJcbmZ1bmN0aW9uIGlzTmF0aXZlRGF0ZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJyB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XHJcbn1cclxuZXhwb3J0cy5pc05hdGl2ZURhdGUgPSBpc05hdGl2ZURhdGU7XHJcbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgdGltZSBzdHJpbmcsIGxpa2UgXCIwNjo0MDowMFwiIG9yIFwiMDY6MDBcIlxyXG5mdW5jdGlvbiBpc1RpbWVTdHJpbmcoc3RyKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAvXlxcZCtcXDpcXGQrKD86XFw6XFxkK1xcLj8oPzpcXGR7M30pPyk/JC8udGVzdChzdHIpO1xyXG59XHJcbmV4cG9ydHMuaXNUaW1lU3RyaW5nID0gaXNUaW1lU3RyaW5nO1xyXG4vKiBMb2dnaW5nIGFuZCBEZWJ1Z1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gbG9nKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubG9nID0gbG9nO1xyXG5mdW5jdGlvbiB3YXJuKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9nLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMud2FybiA9IHdhcm47XHJcbi8qIEdlbmVyYWwgVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgaGFzT3duUHJvcE1ldGhvZCA9IHt9Lmhhc093blByb3BlcnR5O1xyXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cclxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wcykge1xyXG4gICAgdmFyIGRlc3QgPSB7fTtcclxuICAgIHZhciBpLCBuYW1lO1xyXG4gICAgdmFyIGNvbXBsZXhPYmpzO1xyXG4gICAgdmFyIGosIHZhbDtcclxuICAgIHZhciBwcm9wcztcclxuICAgIGlmIChjb21wbGV4UHJvcHMpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tcGxleFByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBjb21wbGV4UHJvcHNbaV07XHJcbiAgICAgICAgICAgIGNvbXBsZXhPYmpzID0gW107XHJcbiAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIHRyYWlsaW5nIG9iamVjdCB2YWx1ZXMsIHN0b3BwaW5nIHdoZW4gYSBub24tb2JqZWN0IGlzIGRpc2NvdmVyZWRcclxuICAgICAgICAgICAgZm9yIChqID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IHByb3BPYmpzW2pdW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gdmFsOyAvLyBpZiB0aGVyZSB3ZXJlIG5vIG9iamVjdHMsIHRoaXMgdmFsdWUgd2lsbCBiZSB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXHJcbiAgICAgICAgICAgIGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBtZXJnZVByb3BzKGNvbXBsZXhPYmpzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGNvcHkgdmFsdWVzIGludG8gdGhlIGRlc3RpbmF0aW9uLCBnb2luZyBmcm9tIGxhc3QgdG8gZmlyc3RcclxuICAgIGZvciAoaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZXN0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3Q7XHJcbn1cclxuZXhwb3J0cy5tZXJnZVByb3BzID0gbWVyZ2VQcm9wcztcclxuZnVuY3Rpb24gY29weU93blByb3BzKHNyYywgZGVzdCkge1xyXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzcmMpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcChzcmMsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBzcmNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY29weU93blByb3BzID0gY29weU93blByb3BzO1xyXG5mdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwgbmFtZSkge1xyXG4gICAgcmV0dXJuIGhhc093blByb3BNZXRob2QuY2FsbChvYmosIG5hbWUpO1xyXG59XHJcbmV4cG9ydHMuaGFzT3duUHJvcCA9IGhhc093blByb3A7XHJcbmZ1bmN0aW9uIGFwcGx5QWxsKGZ1bmN0aW9ucywgdGhpc09iaiwgYXJncykge1xyXG4gICAgaWYgKCQuaXNGdW5jdGlvbihmdW5jdGlvbnMpKSB7XHJcbiAgICAgICAgZnVuY3Rpb25zID0gW2Z1bmN0aW9uc107XHJcbiAgICB9XHJcbiAgICBpZiAoZnVuY3Rpb25zKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHJldDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldCA9IGZ1bmN0aW9uc1tpXS5hcHBseSh0aGlzT2JqLCBhcmdzKSB8fCByZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBseUFsbCA9IGFwcGx5QWxsO1xyXG5mdW5jdGlvbiByZW1vdmVNYXRjaGluZyhhcnJheSwgdGVzdEZ1bmMpIHtcclxuICAgIHZhciByZW1vdmVDbnQgPSAwO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAodGVzdEZ1bmMoYXJyYXlbaV0pKSB7XHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmVtb3ZlQ250Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZUNudDtcclxufVxyXG5leHBvcnRzLnJlbW92ZU1hdGNoaW5nID0gcmVtb3ZlTWF0Y2hpbmc7XHJcbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xyXG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcclxuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICByZW1vdmVDbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG59XHJcbmV4cG9ydHMucmVtb3ZlRXhhY3QgPSByZW1vdmVFeGFjdDtcclxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEpIHtcclxuICAgIHZhciBsZW4gPSBhMC5sZW5ndGg7XHJcbiAgICB2YXIgaTtcclxuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gIT09IGExLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChhMFtpXSAhPT0gYTFbaV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmV4cG9ydHMuaXNBcnJheXNFcXVhbCA9IGlzQXJyYXlzRXF1YWw7XHJcbmZ1bmN0aW9uIGZpcnN0RGVmaW5lZCgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhcmdzW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZmlyc3REZWZpbmVkID0gZmlyc3REZWZpbmVkO1xyXG5mdW5jdGlvbiBodG1sRXNjYXBlKHMpIHtcclxuICAgIHJldHVybiAocyArICcnKS5yZXBsYWNlKC8mL2csICcmYW1wOycpXHJcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcclxuICAgICAgICAucmVwbGFjZSgvJy9nLCAnJiMwMzk7JylcclxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnPGJyIC8+Jyk7XHJcbn1cclxuZXhwb3J0cy5odG1sRXNjYXBlID0gaHRtbEVzY2FwZTtcclxuZnVuY3Rpb24gc3RyaXBIdG1sRW50aXRpZXModGV4dCkge1xyXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvJi4qPzsvZywgJycpO1xyXG59XHJcbmV4cG9ydHMuc3RyaXBIdG1sRW50aXRpZXMgPSBzdHJpcEh0bWxFbnRpdGllcztcclxuLy8gR2l2ZW4gYSBoYXNoIG9mIENTUyBwcm9wZXJ0aWVzLCByZXR1cm5zIGEgc3RyaW5nIG9mIENTUy5cclxuLy8gVXNlcyBwcm9wZXJ0eSBuYW1lcyBhcy1pcyAobm8gY2FtZWwtY2FzZSBjb252ZXJzaW9uKS4gV2lsbCBub3QgbWFrZSBzdGF0ZW1lbnRzIGZvciBudWxsL3VuZGVmaW5lZCB2YWx1ZXMuXHJcbmZ1bmN0aW9uIGNzc1RvU3RyKGNzc1Byb3BzKSB7XHJcbiAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xyXG4gICAgJC5lYWNoKGNzc1Byb3BzLCBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuYW1lICsgJzonICsgdmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdGF0ZW1lbnRzLmpvaW4oJzsnKTtcclxufVxyXG5leHBvcnRzLmNzc1RvU3RyID0gY3NzVG9TdHI7XHJcbi8vIEdpdmVuIGFuIG9iamVjdCBoYXNoIG9mIEhUTUwgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcyxcclxuLy8gZ2VuZXJhdGVzIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGluamVjdGVkIGJldHdlZW4gPCA+IGluIEhUTUxcclxuZnVuY3Rpb24gYXR0cnNUb1N0cihhdHRycykge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICAkLmVhY2goYXR0cnMsIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChuYW1lICsgJz1cIicgKyBodG1sRXNjYXBlKHZhbCkgKyAnXCInKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcgJyk7XHJcbn1cclxuZXhwb3J0cy5hdHRyc1RvU3RyID0gYXR0cnNUb1N0cjtcclxuZnVuY3Rpb24gY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxufVxyXG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IGNhcGl0YWxpc2VGaXJzdExldHRlcjtcclxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZU51bWJlcnMgPSBjb21wYXJlTnVtYmVycztcclxuZnVuY3Rpb24gaXNJbnQobikge1xyXG4gICAgcmV0dXJuIG4gJSAxID09PSAwO1xyXG59XHJcbmV4cG9ydHMuaXNJbnQgPSBpc0ludDtcclxuLy8gUmV0dXJucyBhIG1ldGhvZCBib3VuZCB0byB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnRleHQuXHJcbi8vIEp1c3QgbGlrZSBvbmUgb2YgdGhlIGpRdWVyeS5wcm94eSBzaWduYXR1cmVzLCBidXQgd2l0aG91dCB0aGUgdW5kZXNpcmVkIGJlaGF2aW9yIG9mIHRyZWF0aW5nIHRoZSBzYW1lIG1ldGhvZCB3aXRoXHJcbi8vIGRpZmZlcmVudCBjb250ZXh0cyBhcyBpZGVudGljYWwgd2hlbiBiaW5kaW5nL3VuYmluZGluZyBldmVudHMuXHJcbmZ1bmN0aW9uIHByb3h5KG9iaiwgbWV0aG9kTmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucHJveHkgPSBwcm94eTtcclxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxyXG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXHJcbi8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxyXG4vLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvYmxvYi8xLjYuMC91bmRlcnNjb3JlLmpzI0w3MTRcclxuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XHJcbiAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cclxuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcclxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGFzdCA9ICtuZXcgRGF0ZSgpIC0gdGltZXN0YW1wO1xyXG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICB0aW1lc3RhbXAgPSArbmV3IERhdGUoKTtcclxuICAgICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgICBpZiAoIXRpbWVvdXQpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbE5vdykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBVbnpvbmVkUmFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVbnpvbmVkUmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoZXNlIGludG8gZm9vdHByaW50LlxyXG4gICAgICAgIC8vIEVzcGVjaWFsbHksIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgbnVsbCBzdGFydE1zL2VuZE1zLlxyXG4gICAgICAgIHRoaXMuaXNTdGFydCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0VuZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChzdGFydElucHV0KSkge1xyXG4gICAgICAgICAgICBzdGFydElucHV0ID0gc3RhcnRJbnB1dC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGVuZElucHV0KSkge1xyXG4gICAgICAgICAgICBlbmRJbnB1dCA9IGVuZElucHV0LmNsb25lKCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydElucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRNcyA9IHN0YXJ0SW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kSW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRNcyA9IGVuZElucHV0LnZhbHVlT2YoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0TXMgPSB0aGlzLnN0YXJ0TXM7XHJcbiAgICAgICAgdmFyIGVuZE1zID0gdGhpcy5lbmRNcztcclxuICAgICAgICB2YXIgbmV3UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRNcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1zID0gb3RoZXJSYW5nZS5zdGFydE1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNcyA9IE1hdGgubWF4KHN0YXJ0TXMsIG90aGVyUmFuZ2Uuc3RhcnRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2UuZW5kTXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kTXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kTXMgPSBvdGhlclJhbmdlLmVuZE1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW5kTXMgPSBNYXRoLm1pbihlbmRNcywgb3RoZXJSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0TXMgPT0gbnVsbCB8fCBlbmRNcyA9PSBudWxsIHx8IHN0YXJ0TXMgPCBlbmRNcykge1xyXG4gICAgICAgICAgICBuZXdSYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgZW5kTXMpO1xyXG4gICAgICAgICAgICBuZXdSYW5nZS5pc1N0YXJ0ID0gdGhpcy5pc1N0YXJ0ICYmIHN0YXJ0TXMgPT09IHRoaXMuc3RhcnRNcztcclxuICAgICAgICAgICAgbmV3UmFuZ2UuaXNFbmQgPSB0aGlzLmlzRW5kICYmIGVuZE1zID09PSB0aGlzLmVuZE1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzV2l0aCA9IGZ1bmN0aW9uIChvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmVuZE1zID09IG51bGwgfHwgb3RoZXJSYW5nZS5zdGFydE1zID09IG51bGwgfHwgdGhpcy5lbmRNcyA+IG90aGVyUmFuZ2Uuc3RhcnRNcykgJiZcclxuICAgICAgICAgICAgKHRoaXMuc3RhcnRNcyA9PSBudWxsIHx8IG90aGVyUmFuZ2UuZW5kTXMgPT0gbnVsbCB8fCB0aGlzLnN0YXJ0TXMgPCBvdGhlclJhbmdlLmVuZE1zKTtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zUmFuZ2UgPSBmdW5jdGlvbiAoaW5uZXJSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydE1zID09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnRNcyAhPSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnRNcyA+PSB0aGlzLnN0YXJ0TXMpKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5lbmRNcyA9PSBudWxsIHx8IChpbm5lclJhbmdlLmVuZE1zICE9IG51bGwgJiYgaW5uZXJSYW5nZS5lbmRNcyA8PSB0aGlzLmVuZE1zKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gYGRhdGVgIGNhbiBiZSBhIG1vbWVudCwgYSBEYXRlLCBvciBhIG1pbGxpc2Vjb25kIHRpbWUuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIG1zID0gZGF0ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0TXMgPT0gbnVsbCB8fCBtcyA+PSB0aGlzLnN0YXJ0TXMpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmVuZE1zID09IG51bGwgfHwgbXMgPCB0aGlzLmVuZE1zKTtcclxuICAgIH07XHJcbiAgICAvLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXHJcbiAgICAvLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cclxuICAgIC8vIGBkYXRlYCBjYW4gYmUgYSBtb21lbnQsIGEgRGF0ZSwgb3IgYSBtaWxsaXNlY29uZCB0aW1lLlxyXG4gICAgLy8gUmV0dXJucyBhIE1TLXRpbWUuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNvbnN0cmFpbkRhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBtcyA9IGRhdGUudmFsdWVPZigpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0TXMgIT0gbnVsbCAmJiBtcyA8IHRoaXMuc3RhcnRNcykge1xyXG4gICAgICAgICAgICBtcyA9IHRoaXMuc3RhcnRNcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTXMgIT0gbnVsbCAmJiBtcyA+PSB0aGlzLmVuZE1zKSB7XHJcbiAgICAgICAgICAgIG1zID0gdGhpcy5lbmRNcyAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtcztcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRNcyA9PT0gb3RoZXJSYW5nZS5zdGFydE1zICYmIHRoaXMuZW5kTXMgPT09IG90aGVyUmFuZ2UuZW5kTXM7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlKHRoaXMuc3RhcnRNcywgdGhpcy5lbmRNcyk7XHJcbiAgICAgICAgcmFuZ2UuaXNTdGFydCA9IHRoaXMuaXNTdGFydDtcclxuICAgICAgICByYW5nZS5pc0VuZCA9IHRoaXMuaXNFbmQ7XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYW4gYW1iaWctem9uZWQgbW9tZW50IGZyb20gc3RhcnRNcy5cclxuICAgIC8vIEJFV0FSRTogcmV0dXJuZWQgbW9tZW50IGlzIG5vdCBsb2NhbGl6ZWQuXHJcbiAgICAvLyBGb3JtYXR0aW5nIGFuZCBzdGFydC1vZi13ZWVrIHdpbGwgYmUgZGVmYXVsdC5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuZ2V0U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGModGhpcy5zdGFydE1zKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhbiBhbWJpZy16b25lZCBtb21lbnQgZnJvbSBzdGFydE1zLlxyXG4gICAgLy8gQkVXQVJFOiByZXR1cm5lZCBtb21lbnQgaXMgbm90IGxvY2FsaXplZC5cclxuICAgIC8vIEZvcm1hdHRpbmcgYW5kIHN0YXJ0LW9mLXdlZWsgd2lsbCBiZSBkZWZhdWx0LlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5nZXRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKHRoaXMuZW5kTXMpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmFzID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LnV0Yyh0aGlzLmVuZE1zKS5kaWZmKG1vbWVudC51dGModGhpcy5zdGFydE1zKSwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFNJREVFRkZFQ1Q6IHdpbGwgbXV0YXRlIGV2ZW50UmFuZ2VzLlxyXG4gICAgV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxyXG4gICAgT25seSB3b3JrcyBmb3Igbm9uLW9wZW4tZW5kZWQgcmFuZ2VzLlxyXG4gICAgKi9cclxuICAgIFVuem9uZWRSYW5nZS5pbnZlcnRSYW5nZXMgPSBmdW5jdGlvbiAocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IGNvbnN0cmFpbnRSYW5nZS5zdGFydE1zOyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZGF0ZVJhbmdlO1xyXG4gICAgICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cclxuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlVW56b25lZFJhbmdlcyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydE1zID4gc3RhcnRNcykge1xyXG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaChuZXcgVW56b25lZFJhbmdlKHN0YXJ0TXMsIGRhdGVSYW5nZS5zdGFydE1zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmRNcyA+IHN0YXJ0TXMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TXMgPSBkYXRlUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcclxuICAgICAgICBpZiAoc3RhcnRNcyA8IGNvbnN0cmFpbnRSYW5nZS5lbmRNcykge1xyXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgY29uc3RyYWludFJhbmdlLmVuZE1zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVW56b25lZFJhbmdlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVbnpvbmVkUmFuZ2U7XHJcbi8qXHJcbk9ubHkgd29ya3MgZm9yIG5vbi1vcGVuLWVuZGVkIHJhbmdlcy5cclxuKi9cclxuZnVuY3Rpb24gY29tcGFyZVVuem9uZWRSYW5nZXMocmFuZ2UxLCByYW5nZTIpIHtcclxuICAgIHJldHVybiByYW5nZTEuc3RhcnRNcyAtIHJhbmdlMi5zdGFydE1zOyAvLyBlYXJsaWVyIHJhbmdlcyBnbyBmaXJzdFxyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XHJcbnZhciBDbGFzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBFdmVudERlZlBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbnZhciBFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgLy8gY2FuIHdlIGRvIGF3YXkgd2l0aCBjYWxlbmRhcj8gYXQgbGVhc3QgZm9yIHRoZSBhYnN0cmFjdD9cclxuICAgIC8vIHVzZWZ1bCBmb3IgYnVpbGRFdmVudERlZlxyXG4gICAgZnVuY3Rpb24gRXZlbnRTb3VyY2UoY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMuY2xhc3NOYW1lID0gW107XHJcbiAgICAgICAgX3RoaXMudWlkID0gU3RyaW5nKEV2ZW50U291cmNlLnV1aWQrKyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudC4gbXVzdCByZXR1cm4gYSBwcm9taXNlLlxyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICAvLyBvcHRpb25hbCBmb3Igc3ViY2xhc3NlcyB0byBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIG9wdGlvbmFsIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBGb3IgY29tcGFpcmluZy9tYXRjaGluZ1xyXG4gICAgKi9cclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAob3RoZXJTb3VyY2UpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnBhcnNlRXZlbnREZWZzID0gZnVuY3Rpb24gKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhd0V2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudERlZiA9IHRoaXMucGFyc2VFdmVudERlZihyYXdFdmVudERlZnNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGVmcy5wdXNoKGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnREZWZzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5wYXJzZUV2ZW50RGVmID0gZnVuY3Rpb24gKHJhd0lucHV0KSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyVHJhbnNmb3JtID0gdGhpcy5jYWxlbmRhci5vcHQoJ2V2ZW50RGF0YVRyYW5zZm9ybScpO1xyXG4gICAgICAgIHZhciBzb3VyY2VUcmFuc2Zvcm0gPSB0aGlzLmV2ZW50RGF0YVRyYW5zZm9ybTtcclxuICAgICAgICBpZiAoY2FsZW5kYXJUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmF3SW5wdXQgPSBjYWxlbmRhclRyYW5zZm9ybShyYXdJbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzb3VyY2VUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmF3SW5wdXQgPSBzb3VyY2VUcmFuc2Zvcm0ocmF3SW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKHJhd0lucHV0LCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzLmlkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IEV2ZW50U291cmNlLm5vcm1hbGl6ZUlkKHJhd1Byb3BzLmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogY29udmVyZ2Ugd2l0aCBFdmVudERlZlxyXG4gICAgICAgIGlmICgkLmlzQXJyYXkocmF3UHJvcHMuY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhd1Byb3BzLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIHJhd0lucHV0IGNhbiBiZSBhbnkgZGF0YSB0eXBlIVxyXG4gICAgKi9cclxuICAgIEV2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBuZXcgdGhpcyhjYWxlbmRhcik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXdJbnB1dCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5hcHBseVByb3BzKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2Uubm9ybWFsaXplSWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudFNvdXJjZS5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgLy8gSURzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gVE9ETzogY29udmVyZ2Ugd2l0aCBFdmVudERlZlxyXG4gICAgRXZlbnRTb3VyY2UudXVpZCA9IDA7XHJcbiAgICByZXR1cm4gRXZlbnRTb3VyY2U7XHJcbn0oQ2xhc3NfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50U291cmNlO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnRTb3VyY2UpO1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5FdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIC8vIG1hbnVhbGx5IHByb2Nlc3MuLi5cclxuICAgIGlkOiBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogZmFsc2UsXHJcbiAgICAvLyBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyLi4uXHJcbiAgICBjb2xvcjogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcclxuICAgIGJvcmRlckNvbG9yOiB0cnVlLFxyXG4gICAgdGV4dENvbG9yOiB0cnVlLFxyXG4gICAgZWRpdGFibGU6IHRydWUsXHJcbiAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxyXG4gICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcclxuICAgIHJlbmRlcmluZzogdHJ1ZSxcclxuICAgIG92ZXJsYXA6IHRydWUsXHJcbiAgICBjb25zdHJhaW50OiB0cnVlLFxyXG4gICAgYWxsRGF5RGVmYXVsdDogdHJ1ZSxcclxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vKlxyXG5VdGlsaXR5IG1ldGhvZHMgZm9yIGVhc2lseSBsaXN0ZW5pbmcgdG8gZXZlbnRzIG9uIGFub3RoZXIgb2JqZWN0LFxyXG5hbmQgbW9yZSBpbXBvcnRhbnRseSwgZWFzaWx5IHVubGlzdGVuaW5nIGZyb20gdGhlbS5cclxuXHJcblVTQUdFOlxyXG4gICAgaW1wb3J0IHsgZGVmYXVsdCBhcyBMaXN0ZW5lck1peGluLCBMaXN0ZW5lckludGVyZmFjZSB9IGZyb20gJy4vTGlzdGVuZXJNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgICBsaXN0ZW5UbzogTGlzdGVuZXJJbnRlcmZhY2VbJ2xpc3RlblRvJ11cclxuICAgIHN0b3BMaXN0ZW5pbmdUbzogTGlzdGVuZXJJbnRlcmZhY2VbJ3N0b3BMaXN0ZW5pbmdUbyddXHJcbmFmdGVyIGNsYXNzOlxyXG4gICAgTGlzdGVuZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgZ3VpZCA9IDA7XHJcbnZhciBMaXN0ZW5lck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdGVuZXJNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RlbmVyTWl4aW4oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGlzdGVuZXJJZCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEdpdmVuIGFuIGBvdGhlcmAgb2JqZWN0IHRoYXQgaGFzIG9uL29mZiBtZXRob2RzLCBiaW5kIHRoZSBnaXZlbiBgY2FsbGJhY2tgIHRvIGFuIGV2ZW50IGJ5IHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgVGhlIGBjYWxsYmFja2Agd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIG9iamVjdCB0aGF0IC5saXN0ZW5UbyBpcyBiZWluZyBjYWxsZWQgb24uXHJcbiAgICBDYW4gYmUgY2FsbGVkOlxyXG4gICAgICAgIC5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBjYWxsYmFjaylcclxuICAgIE9SXHJcbiAgICAgICAgLmxpc3RlblRvKG90aGVyLCB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZTE6IGNhbGxiYWNrMSxcclxuICAgICAgICAgICAgZXZlbnROYW1lMjogY2FsbGJhY2syXHJcbiAgICAgICAgfSlcclxuICAgICovXHJcbiAgICBMaXN0ZW5lck1peGluLnByb3RvdHlwZS5saXN0ZW5UbyA9IGZ1bmN0aW9uIChvdGhlciwgYXJnLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGFyZ1tldmVudE5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvdGhlci5vbihhcmcgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCksIC8vIHVzZSBldmVudCBuYW1lc3BhY2luZyB0byBpZGVudGlmeSB0aGlzIG9iamVjdFxyXG4gICAgICAgICAgICAkLnByb3h5KGNhbGxiYWNrLCB0aGlzKSAvLyBhbHdheXMgdXNlIGB0aGlzYCBjb250ZXh0XHJcbiAgICAgICAgICAgIC8vIHRoZSB1c3VhbGx5LXVuZGVzaXJlZCBqUXVlcnkgZ3VpZCBiZWhhdmlvciBkb2Vzbid0IG1hdHRlcixcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhbHdheXMgdW5iaW5kIHZpYSBuYW1lc3BhY2VcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIENhdXNlcyB0aGUgY3VycmVudCBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8gZXZlbnRzIG9uIHRoZSBgb3RoZXJgIG9iamVjdC5cclxuICAgIGBldmVudE5hbWVgIGlzIG9wdGlvbmFsLiBJZiBvbWl0dGVkLCB3aWxsIHN0b3AgbGlzdGVuaW5nIHRvIEFMTCBldmVudHMgb24gYG90aGVyYC5cclxuICAgICovXHJcbiAgICBMaXN0ZW5lck1peGluLnByb3RvdHlwZS5zdG9wTGlzdGVuaW5nVG8gPSBmdW5jdGlvbiAob3RoZXIsIGV2ZW50TmFtZSkge1xyXG4gICAgICAgIG90aGVyLm9mZigoZXZlbnROYW1lIHx8ICcnKSArICcuJyArIHRoaXMuZ2V0TGlzdGVuZXJOYW1lc3BhY2UoKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFJldHVybnMgYSBzdHJpbmcsIHVuaXF1ZSB0byB0aGlzIG9iamVjdCwgdG8gYmUgdXNlZCBmb3IgZXZlbnQgbmFtZXNwYWNpbmdcclxuICAgICovXHJcbiAgICBMaXN0ZW5lck1peGluLnByb3RvdHlwZS5nZXRMaXN0ZW5lck5hbWVzcGFjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcklkID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcklkID0gZ3VpZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ19saXN0ZW5lcicgKyB0aGlzLmxpc3RlbmVySWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RlbmVyTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RlbmVyTWl4aW47XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICB2ZXJzaW9uOiBcIjwlPSB2ZXJzaW9uICU+XCIsXHJcbiAgICAvLyBXaGVuIGludHJvZHVjaW5nIGludGVybmFsIEFQSSBpbmNvbXBhdGliaWxpdGllcyAod2hlcmUgZnVsbGNhbGVuZGFyIHBsdWdpbnMgd291bGQgYnJlYWspLFxyXG4gICAgLy8gdGhlIG1pbm9yIHZlcnNpb24gb2YgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSB1cHBlZCAoZXg6IDIuNy4yIC0+IDIuOC4wKVxyXG4gICAgLy8gYW5kIHRoZSBiZWxvdyBpbnRlZ2VyIHNob3VsZCBiZSBpbmNyZW1lbnRlZC5cclxuICAgIGludGVybmFsQXBpVmVyc2lvbjogMTIsXHJcbiAgICAvLyBmb3IgR2xvYmFsRW1pdHRlclxyXG4gICAgdG91Y2hNb3VzZUlnbm9yZVdhaXQ6IDUwMCxcclxuICAgIC8vIGZvciBFeHRlcm5hbERyb3BwaW5nXHJcbiAgICAvLyBSZXF1aXJlIGFsbCBIVE1MNSBkYXRhLSogYXR0cmlidXRlcyB1c2VkIGJ5IEZ1bGxDYWxlbmRhciB0byBoYXZlIHRoaXMgcHJlZml4LlxyXG4gICAgLy8gQSB2YWx1ZSBvZiAnJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWV2ZW50LiBBIHZhbHVlIG9mICdmYycgd2lsbCBxdWVyeSBhdHRyaWJ1dGVzIGxpa2UgZGF0YS1mYy1ldmVudC5cclxuICAgIGRhdGFBdHRyUHJlZml4OiAnJyxcclxuICAgIHZpZXdzOiB7fSxcclxuICAgIGxvY2FsZXM6IHt9XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLypcclxuVVNBR0U6XHJcbiAgICBpbXBvcnQgeyBkZWZhdWx0IGFzIEVtaXR0ZXJNaXhpbiwgRW1pdHRlckludGVyZmFjZSB9IGZyb20gJy4vRW1pdHRlck1peGluJ1xyXG5pbiBjbGFzczpcclxuICAgIG9uOiBFbWl0dGVySW50ZXJmYWNlWydvbiddXHJcbiAgICBvbmU6IEVtaXR0ZXJJbnRlcmZhY2VbJ29uZSddXHJcbiAgICBvZmY6IEVtaXR0ZXJJbnRlcmZhY2VbJ29mZiddXHJcbiAgICB0cmlnZ2VyOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyJ11cclxuICAgIHRyaWdnZXJXaXRoOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyV2l0aCddXHJcbiAgICBoYXNIYW5kbGVyczogRW1pdHRlckludGVyZmFjZVsnaGFzSGFuZGxlcnMnXVxyXG5hZnRlciBjbGFzczpcclxuICAgIEVtaXR0ZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgRW1pdHRlck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRW1pdHRlck1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW1pdHRlck1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIGpRdWVyeS1pZmljYXRpb24gdmlhICQodGhpcykgYWxsb3dzIGEgbm9uLURPTSBvYmplY3QgdG8gaGF2ZVxyXG4gICAgLy8gdGhlIHNhbWUgZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzIChpbmNsdWRpbmcgbmFtZXNwYWNlcykuXHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbih0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbmUodHlwZXMsIHRoaXMuX3ByZXBhcmVJbnRlcmNlcHQoaGFuZGxlcikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLl9wcmVwYXJlSW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgYWx3YXlzIGNhbGxlZCB3aXRoIGFuIFwiZXZlbnRcIiBvYmplY3QgYXMgdGhlaXIgZmlyc3QgcGFyYW0uXHJcbiAgICAgICAgLy8gc25lYWsgdGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhcmd1bWVudHMgaW50byB0aGUgZXh0cmEgcGFyYW1ldGVyIG9iamVjdFxyXG4gICAgICAgIC8vIGFuZCBmb3J3YXJkIHRoZW0gb24gdG8gdGhlIG9yaWdpbmFsIGhhbmRsZXIuXHJcbiAgICAgICAgdmFyIGludGVyY2VwdCA9IGZ1bmN0aW9uIChldiwgZXh0cmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuYXBwbHkoZXh0cmEuY29udGV4dCB8fCB0aGlzLCBleHRyYS5hcmdzIHx8IFtdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG1pbWljayBqUXVlcnkncyBpbnRlcm5hbCBcInByb3h5XCIgc3lzdGVtIChyaXNreSwgSSBrbm93KVxyXG4gICAgICAgIC8vIGNhdXNpbmcgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIC5ndWlkIHRvIGFwcGVhciB0byBiZSB0aGUgc2FtZS5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMi40L3NyYy9jb3JlLmpzI0w0NDhcclxuICAgICAgICAvLyB0aGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyAub2ZmIHdpdGggdGhlIG9yaWdpbmFsIG5vbi1pbnRlcmNlcHQgaGFuZGxlci5cclxuICAgICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSAkLmd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaW50ZXJjZXB0Lmd1aWQgPSBoYW5kbGVyLmd1aWQ7XHJcbiAgICAgICAgcmV0dXJuIGludGVyY2VwdDtcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlcywgaGFuZGxlcikge1xyXG4gICAgICAgICQodGhpcykub2ZmKHR5cGVzLCBoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGVzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHRcclxuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUudHJpZ2dlcldpdGggPSBmdW5jdGlvbiAodHlwZXMsIGNvbnRleHQsIGFyZ3MpIHtcclxuICAgICAgICAvLyBgdHJpZ2dlckhhbmRsZXJgIGlzIGxlc3MgcmVsaWFudCBvbiB0aGUgRE9NIGNvbXBhcmVkIHRvIGB0cmlnZ2VyYC5cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHQuXHJcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBjb250ZXh0OiBjb250ZXh0LCBhcmdzOiBhcmdzIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgaGFzaCA9ICQuX2RhdGEodGhpcywgJ2V2ZW50cycpOyAvLyBodHRwOi8vYmxvZy5qcXVlcnkuY29tLzIwMTIvMDgvMDkvanF1ZXJ5LTEtOC1yZWxlYXNlZC9cclxuICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoW3R5cGVdICYmIGhhc2hbdHlwZV0ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1pdHRlck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyTWl4aW47XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuLypcclxuR0VORVJBTCBOT1RFIG9uIG1vbWVudHMgdGhyb3VnaG91dCB0aGUgKmVudGlyZSByZXN0KiBvZiB0aGUgY29kZWJhc2U6XHJcbkFsbCBtb21lbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGFtYmlndW91c2x5LXpvbmVkIHVubGVzcyBvdGhlcndpc2Ugbm90ZWQsXHJcbndpdGggdGhlIE5PVEFCTEUgRVhDRU9QVElPTiBvZiBzdGFydC9lbmQgZGF0ZXMgdGhhdCBsaXZlIG9uICpFdmVudCBPYmplY3RzKi5cclxuQW1iaWd1b3VzbHktVElNRUQgbW9tZW50cyBhcmUgYXNzdW1lZCB0byBiZSBhbWJpZ3VvdXNseS16b25lZCBieSBuYXR1cmUuXHJcbiovXHJcbnZhciBhbWJpZ0RhdGVPZk1vbnRoUmVnZXggPSAvXlxccypcXGR7NH0tXFxkXFxkJC87XHJcbnZhciBhbWJpZ1RpbWVPclpvbmVSZWdleCA9IC9eXFxzKlxcZHs0fS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyk/JC87XHJcbnZhciBuZXdNb21lbnRQcm90byA9IG1vbWVudC5mbjsgLy8gd2hlcmUgd2Ugd2lsbCBhdHRhY2ggb3VyIG5ldyBtZXRob2RzXHJcbmV4cG9ydHMubmV3TW9tZW50UHJvdG8gPSBuZXdNb21lbnRQcm90bztcclxudmFyIG9sZE1vbWVudFByb3RvID0gJC5leHRlbmQoe30sIG5ld01vbWVudFByb3RvKTsgLy8gY29weSBvZiBvcmlnaW5hbCBtb21lbnQgbWV0aG9kc1xyXG5leHBvcnRzLm9sZE1vbWVudFByb3RvID0gb2xkTW9tZW50UHJvdG87XHJcbi8vIHRlbGwgbW9tZW50anMgdG8gdHJhbnNmZXIgdGhlc2UgcHJvcGVydGllcyB1cG9uIGNsb25lXHJcbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50Lm1vbWVudFByb3BlcnRpZXM7XHJcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2Z1bGxDYWxlbmRhcicpO1xyXG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1RpbWUnKTtcclxubW9tZW50UHJvcGVydGllcy5wdXNoKCdfYW1iaWdab25lJyk7XHJcbi8qXHJcbkNhbGwgdGhpcyBpZiB5b3Ugd2FudCBNb21lbnQncyBvcmlnaW5hbCBmb3JtYXQgbWV0aG9kIHRvIGJlIHVzZWRcclxuKi9cclxuZnVuY3Rpb24gb2xkTW9tZW50Rm9ybWF0KG1vbSwgZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmNhbGwobW9tLCBmb3JtYXRTdHIpOyAvLyBvbGRNb21lbnRQcm90byBkZWZpbmVkIGluIG1vbWVudC1leHQuanNcclxufVxyXG5leHBvcnRzLm9sZE1vbWVudEZvcm1hdCA9IG9sZE1vbWVudEZvcm1hdDtcclxuLy8gQ3JlYXRpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDcmVhdGVzIGEgbmV3IG1vbWVudCwgc2ltaWxhciB0byB0aGUgdmFuaWxsYSBtb21lbnQoLi4uKSBjb25zdHJ1Y3RvciwgYnV0IHdpdGhcclxuLy8gZXh0cmEgZmVhdHVyZXMgKGFtYmlndW91cyB0aW1lLCBlbmhhbmNlZCBmb3JtYXR0aW5nKS4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsXHJcbi8vIGl0IHdpbGwgZnVuY3Rpb24gYXMgYSBjbG9uZSAoYW5kIHJldGFpbiB0aGUgem9uZSBvZiB0aGUgbW9tZW50KS4gQW55dGhpbmcgZWxzZSB3aWxsXHJcbi8vIHJlc3VsdCBpbiBhIG1vbWVudCBpbiB0aGUgbG9jYWwgem9uZS5cclxudmFyIG1vbWVudEV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cyk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1vbWVudEV4dDtcclxuLy8gU2FtZXMgYXMgbW9tZW50RXh0LCBidXQgZm9yY2VzIHRoZSByZXN1bHRpbmcgbW9tZW50IHRvIGJlIGluIHRoZSBVVEMgdGltZXpvbmUuXHJcbm1vbWVudEV4dC51dGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbW9tID0gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUpO1xyXG4gICAgLy8gRm9yY2UgaXQgaW50byBVVEMgYmVjYXVzZSBtYWtlTW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0XHJcbiAgICAvLyAoaWYgZ2l2ZW4gYSBwcmUtZXhpc3RpbmcgbW9tZW50IGZvciBleGFtcGxlKVxyXG4gICAgaWYgKG1vbS5oYXNUaW1lKCkpIHtcclxuICAgICAgICBtb20udXRjKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tO1xyXG59O1xyXG4vLyBTYW1lIGFzIG1vbWVudEV4dCwgYnV0IHdoZW4gZ2l2ZW4gYW4gSVNPODYwMSBzdHJpbmcsIHRoZSB0aW1lem9uZSBvZmZzZXQgaXMgcHJlc2VydmVkLlxyXG4vLyBJU084NjAxIHN0cmluZ3Mgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgd2lsbCBiZWNvbWUgYW1iaWd1b3VzbHkgem9uZWQuXHJcbm1vbWVudEV4dC5wYXJzZVpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUsIHRydWUpO1xyXG59O1xyXG4vLyBCdWlsZHMgYW4gZW5oYW5jZWQgbW9tZW50IGZyb20gYXJncy4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsIGl0IGNsb25lcy4gV2hlbiBnaXZlbiBhXHJcbi8vIG5hdGl2ZSBEYXRlLCBvciBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgKHRoZSBjdXJyZW50IHRpbWUpLCB0aGUgcmVzdWx0aW5nIG1vbWVudCB3aWxsIGJlIGxvY2FsLlxyXG4vLyBBbnl0aGluZyBlbHNlIG5lZWRzIHRvIGJlIFwicGFyc2VkXCIgKGEgc3RyaW5nIG9yIGFuIGFycmF5KSwgYW5kIHdpbGwgYmUgYWZmZWN0ZWQgYnk6XHJcbi8vICAgIHBhcnNlQXNVVEMgLSBpZiB0aGVyZSBpcyBubyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgcGFyc2UgdGhlIGlucHV0IGluIFVUQz9cclxuLy8gICAgcGFyc2Vab25lIC0gaWYgdGhlcmUgaXMgem9uZSBpbmZvcm1hdGlvbiwgc2hvdWxkIHdlIGZvcmNlIHRoZSB6b25lIG9mIHRoZSBtb21lbnQ/XHJcbmZ1bmN0aW9uIG1ha2VNb21lbnQoYXJncywgcGFyc2VBc1VUQywgcGFyc2Vab25lKSB7XHJcbiAgICBpZiAocGFyc2VBc1VUQyA9PT0gdm9pZCAwKSB7IHBhcnNlQXNVVEMgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhcnNlWm9uZSA9PT0gdm9pZCAwKSB7IHBhcnNlWm9uZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgaW5wdXQgPSBhcmdzWzBdO1xyXG4gICAgdmFyIGlzU2luZ2xlU3RyaW5nID0gYXJncy5sZW5ndGggPT0gMSAmJiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnO1xyXG4gICAgdmFyIGlzQW1iaWdUaW1lO1xyXG4gICAgdmFyIGlzQW1iaWdab25lO1xyXG4gICAgdmFyIGFtYmlnTWF0Y2g7XHJcbiAgICB2YXIgbW9tO1xyXG4gICAgaWYgKG1vbWVudC5pc01vbWVudChpbnB1dCkgfHwgdXRpbF8xLmlzTmF0aXZlRGF0ZShpbnB1dCkgfHwgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG1vbSA9IG1vbWVudC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlzQW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgaXNBbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoaXNTaW5nbGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKGFtYmlnRGF0ZU9mTW9udGhSZWdleC50ZXN0KGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYWNjZXB0IHN0cmluZ3MgbGlrZSAnMjAxNC0wNScsIGJ1dCBjb252ZXJ0IHRvIHRoZSBmaXJzdCBvZiB0aGUgbW9udGhcclxuICAgICAgICAgICAgICAgIGlucHV0ICs9ICctMDEnO1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IFtpbnB1dF07IC8vIGZvciB3aGVuIHdlIHBhc3MgaXQgb24gdG8gbW9tZW50J3MgY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdUaW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoYW1iaWdNYXRjaCA9IGFtYmlnVGltZU9yWm9uZVJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xyXG4gICAgICAgICAgICAgICAgaXNBbWJpZ1RpbWUgPSAhYW1iaWdNYXRjaFs1XTsgLy8gbm8gdGltZSBwYXJ0P1xyXG4gICAgICAgICAgICAgICAgaXNBbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgLy8gYXJyYXlzIGhhdmUgbm8gdGltZXpvbmUgaW5mb3JtYXRpb24sIHNvIGFzc3VtZSBhbWJpZ3VvdXMgem9uZVxyXG4gICAgICAgICAgICBpc0FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSwgcHJvYmFibHkgYSBzdHJpbmcgd2l0aCBhIGZvcm1hdFxyXG4gICAgICAgIGlmIChwYXJzZUFzVVRDIHx8IGlzQW1iaWdUaW1lKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudC51dGMuYXBwbHkobW9tZW50LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQW1iaWdUaW1lKSB7XHJcbiAgICAgICAgICAgIG1vbS5fYW1iaWdUaW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgbW9tLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBhbWJpZ3VvdXMgdGltZSBhbHdheXMgbWVhbnMgYW1iaWd1b3VzIHpvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyc2Vab25lKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FtYmlnWm9uZSkge1xyXG4gICAgICAgICAgICAgICAgbW9tLl9hbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2luZ2xlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBtb20udXRjT2Zmc2V0KGlucHV0KTsgLy8gaWYgbm90IGEgdmFsaWQgem9uZSwgd2lsbCBhc3NpZ24gVVRDXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtb20uX2Z1bGxDYWxlbmRhciA9IHRydWU7IC8vIGZsYWcgZm9yIGV4dGVuZGVkIGZ1bmN0aW9uYWxpdHlcclxuICAgIHJldHVybiBtb207XHJcbn1cclxuLy8gV2VlayBOdW1iZXJcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBSZXR1cm5zIHRoZSB3ZWVrIG51bWJlciwgY29uc2lkZXJpbmcgdGhlIGxvY2FsZSdzIGN1c3RvbSB3ZWVrIG51bWJlciBjYWxjdWF0aW9uXHJcbi8vIGB3ZWVrc2AgaXMgYW4gYWxpYXMgZm9yIGB3ZWVrYFxyXG5uZXdNb21lbnRQcm90by53ZWVrID0gbmV3TW9tZW50UHJvdG8ud2Vla3MgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHZhciB3ZWVrQ2FsYyA9IHRoaXMuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjO1xyXG4gICAgaWYgKGlucHV0ID09IG51bGwgJiYgdHlwZW9mIHdlZWtDYWxjID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIHdlZWtDYWxjKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2Vla0NhbGMgPT09ICdJU08nKSB7XHJcbiAgICAgICAgcmV0dXJuIG9sZE1vbWVudFByb3RvLmlzb1dlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gSVNPIGdldHRlci9zZXR0ZXJcclxuICAgIH1cclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by53ZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGxvY2FsIGdldHRlci9zZXR0ZXJcclxufTtcclxuLy8gVGltZS1vZi1kYXlcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBHRVRURVJcclxuLy8gUmV0dXJucyBhIER1cmF0aW9uIHdpdGggdGhlIGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcyB2YWx1ZXMgb2YgdGhlIG1vbWVudC5cclxuLy8gSWYgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGEgZHVyYXRpb24gb2YgMDA6MDAgd2lsbCBiZSByZXR1cm5lZC5cclxuLy9cclxuLy8gU0VUVEVSXHJcbi8vIFlvdSBjYW4gc3VwcGx5IGEgRHVyYXRpb24sIGEgTW9tZW50LCBvciBhIER1cmF0aW9uLWxpa2UgYXJndW1lbnQuXHJcbi8vIFdoZW4gc2V0dGluZyB0aGUgdGltZSwgYW5kIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBpdCB0aGVuIGJlY29tZXMgdW5hbWJpZ3VvdXMuXHJcbm5ld01vbWVudFByb3RvLnRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgLy8gRmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZCAoaWYgdGhlcmUgaXMgb25lKSBpZiB0aGlzIG1vbWVudCB3YXNuJ3QgY3JlYXRlZCB2aWEgRnVsbENhbGVuZGFyLlxyXG4gICAgLy8gYHRpbWVgIGlzIGEgZ2VuZXJpYyBlbm91Z2ggbWV0aG9kIG5hbWUgd2hlcmUgdGhpcyBwcmVjYXV0aW9uIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBjb2xsaXNpb25zIHcvIG90aGVyIHBsdWdpbnMuXHJcbiAgICBpZiAoIXRoaXMuX2Z1bGxDYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBvbGRNb21lbnRQcm90by50aW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgICAgIGhvdXJzOiB0aGlzLmhvdXJzKCksXHJcbiAgICAgICAgICAgIG1pbnV0ZXM6IHRoaXMubWludXRlcygpLFxyXG4gICAgICAgICAgICBzZWNvbmRzOiB0aGlzLnNlY29uZHMoKSxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiB0aGlzLm1pbGxpc2Vjb25kcygpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTsgLy8gbWFyayB0aGF0IHRoZSBtb21lbnQgbm93IGhhcyBhIHRpbWVcclxuICAgICAgICBpZiAoIW1vbWVudC5pc0R1cmF0aW9uKHRpbWUpICYmICFtb21lbnQuaXNNb21lbnQodGltZSkpIHtcclxuICAgICAgICAgICAgdGltZSA9IG1vbWVudC5kdXJhdGlvbih0aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlIGRheSB2YWx1ZSBzaG91bGQgY2F1c2Ugb3ZlcmZsb3cgKHNvIDI0IGhvdXJzIGJlY29tZXMgMDA6MDA6MDAgb2YgbmV4dCBkYXkpLlxyXG4gICAgICAgIC8vIE9ubHkgZm9yIER1cmF0aW9uIHRpbWVzLCBub3QgTW9tZW50IHRpbWVzLlxyXG4gICAgICAgIHZhciBkYXlIb3VycyA9IDA7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHRpbWUpKSB7XHJcbiAgICAgICAgICAgIGRheUhvdXJzID0gTWF0aC5mbG9vcih0aW1lLmFzRGF5cygpKSAqIDI0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHNldCB0aGUgaW5kaXZpZHVhbCBmaWVsZHMuXHJcbiAgICAgICAgLy8gQ2FuJ3QgdXNlIHN0YXJ0T2YoJ2RheScpIHRoZW4gYWRkIGR1cmF0aW9uLiBJbiBjYXNlIG9mIERTVCBhdCBzdGFydCBvZiBkYXkuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoZGF5SG91cnMgKyB0aW1lLmhvdXJzKCkpXHJcbiAgICAgICAgICAgIC5taW51dGVzKHRpbWUubWludXRlcygpKVxyXG4gICAgICAgICAgICAuc2Vjb25kcyh0aW1lLnNlY29uZHMoKSlcclxuICAgICAgICAgICAgLm1pbGxpc2Vjb25kcyh0aW1lLm1pbGxpc2Vjb25kcygpKTtcclxuICAgIH1cclxufTtcclxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWUtb2YtZGF5IGFuZCB0aW1lem9uZSBvZmZzZXQsXHJcbi8vIGJ1dCBwcmVzZXJ2aW5nIGl0cyBZTUQuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lIHdpbGwgZGlzcGxheSBubyB0aW1lXHJcbi8vIG5vciB0aW1lem9uZSBvZmZzZXQgd2hlbiAuZm9ybWF0KCkgaXMgY2FsbGVkLlxyXG5uZXdNb21lbnRQcm90by5zdHJpcFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2FtYmlnVGltZSkge1xyXG4gICAgICAgIHRoaXMudXRjKHRydWUpOyAvLyBrZWVwTG9jYWxUaW1lPXRydWUgKGZvciBrZWVwaW5nICpkYXRlKiB2YWx1ZSlcclxuICAgICAgICAvLyBzZXQgdGltZSB0byB6ZXJvXHJcbiAgICAgICAgdGhpcy5zZXQoe1xyXG4gICAgICAgICAgICBob3VyczogMCxcclxuICAgICAgICAgICAgbWludXRlczogMCxcclxuICAgICAgICAgICAgc2Vjb25kczogMCxcclxuICAgICAgICAgICAgbXM6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBNYXJrIHRoZSB0aW1lIGFzIGFtYmlndW91cy4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIC51dGMoKSBjYWxsLCB3aGljaCBtaWdodCBjYWxsIC51dGNPZmZzZXQoKSxcclxuICAgICAgICAvLyB3aGljaCBjbGVhcnMgYWxsIGFtYmlnIGZsYWdzLlxyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fYW1iaWdab25lID0gdHJ1ZTsgLy8gaWYgYW1iaWd1b3VzIHRpbWUsIGFsc28gYW1iaWd1b3VzIHRpbWV6b25lIG9mZnNldFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG59O1xyXG4vLyBSZXR1cm5zIGlmIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lIChib29sZWFuKVxyXG5uZXdNb21lbnRQcm90by5oYXNUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLl9hbWJpZ1RpbWU7XHJcbn07XHJcbi8vIFRpbWV6b25lXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gQ29udmVydHMgdGhlIG1vbWVudCB0byBVVEMsIHN0cmlwcGluZyBvdXQgaXRzIHRpbWV6b25lIG9mZnNldCwgYnV0IHByZXNlcnZpbmcgaXRzXHJcbi8vIFlNRCBhbmQgdGltZS1vZi1kYXkuIEEgbW9tZW50IHdpdGggYSBzdHJpcHBlZCB0aW1lem9uZSBvZmZzZXQgd2lsbCBkaXNwbGF5IG5vXHJcbi8vIHRpbWV6b25lIG9mZnNldCB3aGVuIC5mb3JtYXQoKSBpcyBjYWxsZWQuXHJcbm5ld01vbWVudFByb3RvLnN0cmlwWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB3YXNBbWJpZ1RpbWU7XHJcbiAgICBpZiAoIXRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHdhc0FtYmlnVGltZSA9IHRoaXMuX2FtYmlnVGltZTtcclxuICAgICAgICB0aGlzLnV0Yyh0cnVlKTsgLy8ga2VlcExvY2FsVGltZT10cnVlIChmb3Iga2VlcGluZyBkYXRlIGFuZCB0aW1lIHZhbHVlcylcclxuICAgICAgICAvLyB0aGUgYWJvdmUgY2FsbCB0byAudXRjKCkvLnV0Y09mZnNldCgpIHVuZm9ydHVuYXRlbHkgbWlnaHQgY2xlYXIgdGhlIGFtYmlnIGZsYWdzLCBzbyByZXN0b3JlXHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gd2FzQW1iaWdUaW1lIHx8IGZhbHNlO1xyXG4gICAgICAgIC8vIE1hcmsgdGhlIHpvbmUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxyXG4gICAgICAgIC8vIHdoaWNoIGNsZWFycyB0aGUgYW1iaWcgZmxhZ3MuXHJcbiAgICAgICAgdGhpcy5fYW1iaWdab25lID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxufTtcclxuLy8gUmV0dXJucyBvZiB0aGUgbW9tZW50IGhhcyBhIG5vbi1hbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0IChib29sZWFuKVxyXG5uZXdNb21lbnRQcm90by5oYXNab25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLl9hbWJpZ1pvbmU7XHJcbn07XHJcbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXHJcbm5ld01vbWVudFByb3RvLmxvY2FsID0gZnVuY3Rpb24gKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgIC8vIGZvciB3aGVuIGNvbnZlcnRpbmcgZnJvbSBhbWJpZ3VvdXNseS16b25lZCB0byBsb2NhbCxcclxuICAgIC8vIGtlZXAgdGhlIHRpbWUgdmFsdWVzIHdoZW4gY29udmVydGluZyBmcm9tIFVUQyAtPiBsb2NhbFxyXG4gICAgb2xkTW9tZW50UHJvdG8ubG9jYWwuY2FsbCh0aGlzLCB0aGlzLl9hbWJpZ1pvbmUgfHwga2VlcExvY2FsVGltZSk7XHJcbiAgICAvLyBlbnN1cmUgbm9uLWFtYmlndW91c1xyXG4gICAgLy8gdGhpcyBwcm9iYWJseSBhbHJlYWR5IGhhcHBlbmVkIHZpYSBsb2NhbCgpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcclxuICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYW1iaWdab25lID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbn07XHJcbi8vIGltcGxpY2l0bHkgbWFya3MgYSB6b25lXHJcbm5ld01vbWVudFByb3RvLnV0YyA9IGZ1bmN0aW9uIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICBvbGRNb21lbnRQcm90by51dGMuY2FsbCh0aGlzLCBrZWVwTG9jYWxUaW1lKTtcclxuICAgIC8vIGVuc3VyZSBub24tYW1iaWd1b3VzXHJcbiAgICAvLyB0aGlzIHByb2JhYmx5IGFscmVhZHkgaGFwcGVuZWQgdmlhIHV0YygpIC0+IHV0Y09mZnNldCgpLCBidXQgZG9uJ3QgcmVseSBvbiBNb21lbnQncyBpbnRlcm5hbHNcclxuICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5fYW1iaWdab25lID0gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmUgKHdpbGwgcHJvYmFibHkgZ2V0IGNhbGxlZCB1cG9uIC51dGMoKSBhbmQgLmxvY2FsKCkpXHJcbm5ld01vbWVudFByb3RvLnV0Y09mZnNldCA9IGZ1bmN0aW9uICh0em8pIHtcclxuICAgIGlmICh0em8gIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHRoZXNlIGFzc2lnbm1lbnRzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIG9yaWdpbmFsIHpvbmUgbWV0aG9kIGlzIGNhbGxlZC5cclxuICAgICAgICAvLyBJIGZvcmdldCB3aHksIHNvbWV0aGluZyB0byBkbyB3aXRoIGEgYnJvd3NlciBjcmFzaC5cclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKlxyXG5NZWFudCB0byBiZSBpbW11dGFibGVcclxuKi9cclxudmFyIENvbXBvbmVudEZvb3RwcmludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZvb3RwcmludCh1bnpvbmVkUmFuZ2UsIGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdGhpcy5pc0FsbERheSA9IGZhbHNlOyAvLyBjb21wb25lbnQgY2FuIGNob29zZSB0byBpZ25vcmUgdGhpc1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdW56b25lZFJhbmdlO1xyXG4gICAgICAgIHRoaXMuaXNBbGxEYXkgPSBpc0FsbERheTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBPbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgQ29tcG9uZW50Rm9vdHByaW50LnByb3RvdHlwZS50b0xlZ2FjeSA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBjYWxlbmRhci5tc1RvTW9tZW50KHRoaXMudW56b25lZFJhbmdlLnN0YXJ0TXMsIHRoaXMuaXNBbGxEYXkpLFxyXG4gICAgICAgICAgICBlbmQ6IGNhbGVuZGFyLm1zVG9Nb21lbnQodGhpcy51bnpvbmVkUmFuZ2UuZW5kTXMsIHRoaXMuaXNBbGxEYXkpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50Rm9vdHByaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb25lbnRGb290cHJpbnQ7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgRXZlbnRJbnN0YW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MSk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2luZ2xlRXZlbnREZWYsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTaW5nbGVFdmVudERlZigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgV2lsbCByZWNlaXZlIHN0YXJ0L2VuZCBwYXJhbXMsIGJ1dCB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAqL1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmJ1aWxkSW5zdGFuY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5idWlsZEluc3RhbmNlKCldO1xyXG4gICAgfTtcclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5idWlsZEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRJbnN0YW5jZV8xLmRlZmF1bHQodGhpcywgLy8gZGVmaW5pdGlvblxyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUpO1xyXG4gICAgfTtcclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5pc0FsbERheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRlUHJvZmlsZS5pc0FsbERheSgpO1xyXG4gICAgfTtcclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmID0gX3N1cGVyLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGRlZi5kYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUucmV6b25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuc291cmNlLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChjYWxlbmRhci5tb21lbnQoZGF0ZVByb2ZpbGUuc3RhcnQpLCBkYXRlUHJvZmlsZS5lbmQgPyBjYWxlbmRhci5tb21lbnQoZGF0ZVByb2ZpbGUuZW5kKSA6IG51bGwsIGNhbGVuZGFyKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTk9URTogaWYgc3VwZXItbWV0aG9kIGZhaWxzLCBzaG91bGQgc3RpbGwgYXR0ZW1wdCB0byBhcHBseVxyXG4gICAgKi9cclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB2YXIgc3VwZXJTdWNjZXNzID0gX3N1cGVyLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMuY2FsbCh0aGlzLCByYXdQcm9wcyk7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQucGFyc2UocmF3UHJvcHMsIHRoaXMuc291cmNlKTsgLy8gcmV0dXJucyBudWxsIG9uIGZhaWx1cmVcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYGRhdGVgIHNob3dzIHVwIGluIHRoZSBsZWdhY3kgZXZlbnQgb2JqZWN0cyBhcy1pc1xyXG4gICAgICAgICAgICBpZiAocmF3UHJvcHMuZGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pc2NQcm9wcy5kYXRlID0gcmF3UHJvcHMuZGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU2luZ2xlRXZlbnREZWY7XHJcbn0oRXZlbnREZWZfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNpbmdsZUV2ZW50RGVmO1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5TaW5nbGVFdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIHN0YXJ0OiBmYWxzZSxcclxuICAgIGRhdGU6IGZhbHNlLFxyXG4gICAgZW5kOiBmYWxzZSxcclxuICAgIGFsbERheTogZmFsc2VcclxufSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWl4aW4oKSB7XHJcbiAgICB9XHJcbiAgICBNaXhpbi5taXhJbnRvID0gZnVuY3Rpb24gKGRlc3RDbGFzcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCFkZXN0Q2xhc3MucHJvdG90eXBlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0Q2xhc3MucHJvdG90eXBlW25hbWVdID0gX3RoaXMucHJvdG90eXBlW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmcgbWV0aG9kc1xyXG4gICAgKi9cclxuICAgIE1peGluLm1peE92ZXIgPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBkZXN0Q2xhc3MucHJvdG90eXBlW25hbWVdID0gX3RoaXMucHJvdG90eXBlW25hbWVdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNaXhpbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTWl4aW47XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEludGVyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnRlcmFjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJhY3Rpb247XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgbmFtZXNwYWNlX2hvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIGdsb2JhbEVtaXR0ZXIgPSBudWxsO1xyXG52YXIgbmVlZGVkQ291bnQgPSAwO1xyXG4vKlxyXG5MaXN0ZW5zIHRvIGRvY3VtZW50IGFuZCB3aW5kb3ctbGV2ZWwgdXNlci1pbnRlcmFjdGlvbiBldmVudHMsIGxpa2UgdG91Y2ggZXZlbnRzIGFuZCBtb3VzZSBldmVudHMsXHJcbmFuZCBmaXJlcyB0aGVzZSBldmVudHMgYXMtaXMgdG8gd2hvZXZlciBpcyBvYnNlcnZpbmcgYSBHbG9iYWxFbWl0dGVyLlxyXG5CZXN0IHdoZW4gdXNlZCBhcyBhIHNpbmdsZXRvbiB2aWEgR2xvYmFsRW1pdHRlci5nZXQoKVxyXG5cclxuTm9ybWFsaXplcyBtb3VzZS90b3VjaCBldmVudHMuIEZvciBleGFtcGxlczpcclxuLSBpZ25vcmVzIHRoZSB0aGUgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB0aGF0IGhhcHBlbiBhZnRlciBhIHF1aWNrIHRhcDogbW91c2Vtb3ZlK21vdXNlZG93bittb3VzZXVwK2NsaWNrXHJcbi0gY29tcGVuc2F0ZXMgZm9yIHZhcmlvdXMgYnVnZ3kgc2NlbmFyaW9zIHdoZXJlIGEgdG91Y2hlbmQgZG9lcyBub3QgZmlyZVxyXG4qL1xyXG52YXIgR2xvYmFsRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdsb2JhbEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZUlnbm9yZURlcHRoID0gMDtcclxuICAgIH1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XHJcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcclxuICAgICAgICAgICAgdG91Y2hjYW5jZWw6IHRoaXMuaGFuZGxlVG91Y2hDYW5jZWwsXHJcbiAgICAgICAgICAgIHRvdWNoZW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kLFxyXG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxyXG4gICAgICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxyXG4gICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmhhbmRsZU1vdXNlVXAsXHJcbiAgICAgICAgICAgIGNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLFxyXG4gICAgICAgICAgICBzZWxlY3RzdGFydDogdGhpcy5oYW5kbGVTZWxlY3RTdGFydCxcclxuICAgICAgICAgICAgY29udGV4dG1lbnU6IHRoaXMuaGFuZGxlQ29udGV4dE1lbnVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCBwcmV2ZW50RGVmYXVsdFxyXG4gICAgICAgIC8vIGJlY2F1c2UgaHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlcy81MDkzNTY2MDA3MjE0MDgwXHJcbiAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgcGVyZm9ybWFuY2UgYmVjYXVzZSB0aGlzIGlzIGEgZ2xvYmFsIGhhbmRsZXJcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmVQcm94eSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVUb3VjaE1vdmUoJC5FdmVudChldikpO1xyXG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSAvLyBhbGxvd3MgcHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cclxuICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsUHJveHkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsKCQuRXZlbnQoZXYpKTtcclxuICAgICAgICB9LCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHkpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbFByb3h5LCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIC8vIFRvdWNoIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIGlmIGEgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24gbmV2ZXIgZW5kZWQgd2l0aCBhIHRvdWNoZW5kLCB0aGVuIGltcGxpY2l0bHkgZW5kIGl0LFxyXG4gICAgICAgIC8vIGJ1dCBzaW5jZSBhIG5ldyB0b3VjaCBpbnRlcmFjdGlvbiBpcyBhYm91dCB0byBiZWdpbiwgZG9uJ3Qgc3RhcnQgdGhlIG1vdXNlIGlnbm9yZSBwZXJpb2QuXHJcbiAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYsIHRydWUpOyAvLyBza2lwTW91c2VJZ25vcmU9dHJ1ZVxyXG4gICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaHN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaG1vdmUnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoQ2FuY2VsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RvdWNoY2FuY2VsJywgZXYpO1xyXG4gICAgICAgICAgICAvLyBIYXZlIHRvdWNoY2FuY2VsIGZpcmUgYW4gYXJ0aWZpY2lhbCB0b3VjaGVuZC4gVGhhdCB3YXksIGhhbmRsZXJzIHdvbid0IG5lZWQgdG8gbGlzdGVuIHRvIGJvdGguXHJcbiAgICAgICAgICAgIC8vIElmIHRvdWNoZW5kIGZpcmVzIGxhdGVyLCBpdCB3b24ndCBoYXZlIGFueSBlZmZlY3QgYi9jIGlzVG91Y2hpbmcgd2lsbCBiZSBmYWxzZS5cclxuICAgICAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaEVuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBNb3VzZSBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vkb3duJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2V1cCcsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NsaWNrJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBNaXNjIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlU2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdHN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250ZXh0bWVudScsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Njcm9sbCcsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnN0b3BUb3VjaCA9IGZ1bmN0aW9uIChldiwgc2tpcE1vdXNlSWdub3JlKSB7XHJcbiAgICAgICAgaWYgKHNraXBNb3VzZUlnbm9yZSA9PT0gdm9pZCAwKSB7IHNraXBNb3VzZUlnbm9yZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaGVuZCcsIGV2KTtcclxuICAgICAgICAgICAgaWYgKCFza2lwTW91c2VJZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUb3VjaE1vdXNlSWdub3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc3RhcnRUb3VjaE1vdXNlSWdub3JlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHdhaXQgPSBuYW1lc3BhY2VfaG9va3NfMS5kZWZhdWx0LnRvdWNoTW91c2VJZ25vcmVXYWl0O1xyXG4gICAgICAgIGlmICh3YWl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VJZ25vcmVEZXB0aCsrO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLm1vdXNlSWdub3JlRGVwdGgtLTtcclxuICAgICAgICAgICAgfSwgd2FpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnNob3VsZElnbm9yZU1vdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVG91Y2hpbmcgfHwgQm9vbGVhbih0aGlzLm1vdXNlSWdub3JlRGVwdGgpO1xyXG4gICAgfTtcclxuICAgIC8vIFNpbmdsZXRvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGdldHMgdGhlIHNpbmdsZXRvblxyXG4gICAgR2xvYmFsRW1pdHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFnbG9iYWxFbWl0dGVyKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIgPSBuZXcgR2xvYmFsRW1pdHRlcigpO1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbEVtaXR0ZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gY2FsbGVkIHdoZW4gYW4gb2JqZWN0IGtub3dzIGl0IHdpbGwgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgaW4gdGhlIG5lYXIgZnV0dXJlLlxyXG4gICAgR2xvYmFsRW1pdHRlci5uZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgR2xvYmFsRW1pdHRlci5nZXQoKTsgLy8gZW5zdXJlcyBnbG9iYWxFbWl0dGVyXHJcbiAgICAgICAgbmVlZGVkQ291bnQrKztcclxuICAgIH07XHJcbiAgICAvLyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IHRoYXQgb3JpZ2luYWxseSBjYWxsZWQgbmVlZGVkKCkgZG9lc24ndCBuZWVkIGEgR2xvYmFsRW1pdHRlciBhbnltb3JlLlxyXG4gICAgR2xvYmFsRW1pdHRlci51bm5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBuZWVkZWRDb3VudC0tO1xyXG4gICAgICAgIGlmICghbmVlZGVkQ291bnQpIHtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlci51bmJpbmQoKTtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBHbG9iYWxFbWl0dGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBHbG9iYWxFbWl0dGVyO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEdsb2JhbEVtaXR0ZXIpO1xyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oR2xvYmFsRW1pdHRlcik7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLypcclxuTWVhbnQgdG8gYmUgaW1tdXRhYmxlXHJcbiovXHJcbnZhciBFdmVudERhdGVQcm9maWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnREYXRlUHJvZmlsZShzdGFydCwgZW5kLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZCB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdGhpcy5idWlsZFVuem9uZWRSYW5nZShjYWxlbmRhcik7XHJcbiAgICB9XHJcbiAgICBFdmVudERhdGVQcm9maWxlLnByb3RvdHlwZS5pc0FsbERheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISh0aGlzLnN0YXJ0Lmhhc1RpbWUoKSB8fCAodGhpcy5lbmQgJiYgdGhpcy5lbmQuaGFzVGltZSgpKSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGEgQ2FsZW5kYXIgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wcm90b3R5cGUuYnVpbGRVbnpvbmVkUmFuZ2UgPSBmdW5jdGlvbiAoY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IHRoaXMuc3RhcnQuY2xvbmUoKS5zdHJpcFpvbmUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgdmFyIGVuZE1zID0gdGhpcy5nZXRFbmQoY2FsZW5kYXIpLnN0cmlwWm9uZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnRNcywgZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOZWVkcyBhIENhbGVuZGFyIG9iamVjdFxyXG4gICAgKi9cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucHJvdG90eXBlLmdldEVuZCA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZCA/XHJcbiAgICAgICAgICAgIHRoaXMuZW5kLmNsb25lKCkgOlxyXG4gICAgICAgICAgICAvLyBkZXJpdmUgdGhlIGVuZCBmcm9tIHRoZSBzdGFydCBhbmQgYWxsRGF5LiBjb21wdXRlIGFsbERheSBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKHRoaXMuaXNBbGxEYXkoKSwgdGhpcy5zdGFydCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5pc1N0YW5kYXJkUHJvcCA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9wTmFtZSA9PT0gJ3N0YXJ0JyB8fCBwcm9wTmFtZSA9PT0gJ2RhdGUnIHx8IHByb3BOYW1lID09PSAnZW5kJyB8fCBwcm9wTmFtZSA9PT0gJ2FsbERheSc7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGFuIEV2ZW50U291cmNlIG9iamVjdFxyXG4gICAgKi9cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucGFyc2UgPSBmdW5jdGlvbiAocmF3UHJvcHMsIHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBzdGFydElucHV0ID0gcmF3UHJvcHMuc3RhcnQgfHwgcmF3UHJvcHMuZGF0ZTtcclxuICAgICAgICB2YXIgZW5kSW5wdXQgPSByYXdQcm9wcy5lbmQ7XHJcbiAgICAgICAgaWYgKCFzdGFydElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gc291cmNlLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBzdGFydCA9IGNhbGVuZGFyLm1vbWVudChzdGFydElucHV0KTtcclxuICAgICAgICB2YXIgZW5kID0gZW5kSW5wdXQgPyBjYWxlbmRhci5tb21lbnQoZW5kSW5wdXQpIDogbnVsbDtcclxuICAgICAgICB2YXIgZm9yY2VkQWxsRGF5ID0gcmF3UHJvcHMuYWxsRGF5O1xyXG4gICAgICAgIHZhciBmb3JjZUV2ZW50RHVyYXRpb24gPSBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpO1xyXG4gICAgICAgIGlmICghc3RhcnQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCAmJiAoIWVuZC5pc1ZhbGlkKCkgfHwgIWVuZC5pc0FmdGVyKHN0YXJ0KSkpIHtcclxuICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcmNlZEFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcmNlZEFsbERheSA9IHNvdXJjZS5hbGxEYXlEZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VkQWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlZEFsbERheSA9IGNhbGVuZGFyLm9wdCgnYWxsRGF5RGVmYXVsdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JjZWRBbGxEYXkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmb3JjZWRBbGxEYXkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC50aW1lKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZW5kICYmIGZvcmNlRXZlbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoIXN0YXJ0Lmhhc1RpbWUoKSwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGUoc3RhcnQsIGVuZCwgY2FsZW5kYXIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudERhdGVQcm9maWxlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERhdGVQcm9maWxlO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIFByb21pc2VTdHViID0ge1xyXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLnJlc29sdmUodmFsKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZWplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVqZWN0KCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQcm9taXNlU3R1YjtcclxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZXNvbHZpbmdUaGVuKHByb21pc2UsIHZhbCkge1xyXG4gICAgcHJvbWlzZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlU3R1Yi5yZXNvbHZlKG9uUmVzb2x2ZSh2YWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKSB7XHJcbiAgICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbi8qXHJcbkl0J3MgZXhwZWN0ZWQgdGhhdCB0aGVyZSB3aWxsIGJlIGF0IGxlYXN0IG9uZSBFdmVudEluc3RhbmNlLFxyXG5PUiB0aGF0IGFuIGV4cGxpY2l0RXZlbnREZWYgaXMgYXNzaWduZWQuXHJcbiovXHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEluc3RhbmNlR3JvdXAoZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2VzID0gZXZlbnRJbnN0YW5jZXMgfHwgW107XHJcbiAgICB9XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmdldEFsbEV2ZW50UmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VOb3JtYWxSZW5kZXJSYW5nZXMoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuc2xpY2VSZW5kZXJSYW5nZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbnZlcnNlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VJbnZlcnNlUmVuZGVyUmFuZ2VzKGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZU5vcm1hbFJlbmRlclJhbmdlcyhjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlTm9ybWFsUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcyA9IHRoaXMuZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgdmFyIGksIGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIHNsaWNlZFJhbmdlO1xyXG4gICAgICAgIHZhciBzbGljZWRFdmVudFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlID0gZXZlbnRJbnN0YW5jZXNbaV07XHJcbiAgICAgICAgICAgIHNsaWNlZFJhbmdlID0gZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2xpY2VkRXZlbnRSYW5nZXMucHVzaChuZXcgRXZlbnRSYW5nZV8xLmRlZmF1bHQoc2xpY2VkUmFuZ2UsIGV2ZW50SW5zdGFuY2UuZGVmLCBldmVudEluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsaWNlZEV2ZW50UmFuZ2VzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuc2xpY2VJbnZlcnNlUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2VzID0gdGhpcy5ldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIG93bmVyRGVmID0gdGhpcy5nZXRFdmVudERlZigpO1xyXG4gICAgICAgIHVuem9uZWRSYW5nZXMgPSBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0LmludmVydFJhbmdlcyh1bnpvbmVkUmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIHJldHVybiB1bnpvbmVkUmFuZ2VzLm1hcChmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRSYW5nZV8xLmRlZmF1bHQodW56b25lZFJhbmdlLCBvd25lckRlZik7IC8vIGRvbid0IGdpdmUgYW4gRXZlbnRJbnN0YW5jZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuaXNJbnZlcnNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEV2ZW50RGVmKCkuaGFzSW52ZXJzZVJlbmRlcmluZygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuZ2V0RXZlbnREZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwbGljaXRFdmVudERlZiB8fCB0aGlzLmV2ZW50SW5zdGFuY2VzWzBdLmRlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEluc3RhbmNlR3JvdXA7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbi8qIFRyYWNrcyBtb3VzZSBtb3ZlbWVudHMgb3ZlciBhIGNvbXBvbmVudCBhbmQgcmFpc2VzIGV2ZW50cyBhYm91dCB3aGljaCBoaXQgdGhlIG1vdXNlIGlzIG92ZXIuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5vcHRpb25zOlxyXG4tIHN1YmplY3RFbFxyXG4tIHN1YmplY3RDZW50ZXJcclxuKi9cclxudmFyIEhpdERyYWdMaXN0ZW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEhpdERyYWdMaXN0ZW5lciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEhpdERyYWdMaXN0ZW5lcihjb21wb25lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBkcmFnIGxpc3RlbmluZyBzdGFydHMgKGJ1dCBhIHJlYWwgZHJhZyBoYXMgbm90IG5lY2Vzc2FyaWx5IGJlZ2FuKS5cclxuICAgIC8vIGV2IG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiBkcmFnZ2luZyB3YXMgc3RhcnRlZCBtYW51YWxseS5cclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBzdWJqZWN0RWwgPSB0aGlzLnN1YmplY3RFbDtcclxuICAgICAgICB2YXIgc3ViamVjdFJlY3Q7XHJcbiAgICAgICAgdmFyIG9yaWdQb2ludDtcclxuICAgICAgICB2YXIgcG9pbnQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaGl0c05lZWRlZCgpO1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZVNjcm9sbEJvdW5kcygpOyAvLyBmb3IgYXV0b3Njcm9sbFxyXG4gICAgICAgIGlmIChldikge1xyXG4gICAgICAgICAgICBvcmlnUG9pbnQgPSB7IGxlZnQ6IHV0aWxfMS5nZXRFdlgoZXYpLCB0b3A6IHV0aWxfMS5nZXRFdlkoZXYpIH07XHJcbiAgICAgICAgICAgIHBvaW50ID0gb3JpZ1BvaW50O1xyXG4gICAgICAgICAgICAvLyBjb25zdHJhaW4gdGhlIHBvaW50IHRvIGJvdW5kcyBvZiB0aGUgZWxlbWVudCBiZWluZyBkcmFnZ2VkXHJcbiAgICAgICAgICAgIGlmIChzdWJqZWN0RWwpIHtcclxuICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gdXRpbF8xLmdldE91dGVyUmVjdChzdWJqZWN0RWwpOyAvLyB1c2VkIGZvciBjZW50ZXJpbmcgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSB1dGlsXzEuY29uc3RyYWluUG9pbnQocG9pbnQsIHN1YmplY3RSZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9yaWdIaXQgPSB0aGlzLnF1ZXJ5SGl0KHBvaW50LmxlZnQsIHBvaW50LnRvcCk7XHJcbiAgICAgICAgICAgIC8vIHRyZWF0IHRoZSBjZW50ZXIgb2YgdGhlIHN1YmplY3QgYXMgdGhlIGNvbGxpc2lvbiBwb2ludD9cclxuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCAmJiB0aGlzLm9wdGlvbnMuc3ViamVjdENlbnRlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBjb25zaWRlciB0aGUgYXJlYSB0aGUgc3ViamVjdCBvdmVybGFwcyB0aGUgaGl0LiBiZXN0IGZvciBsYXJnZSBzdWJqZWN0cy5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNraXAgdGhpcyBpZiBoaXQgZGlkbid0IHN1cHBseSBsZWZ0L3JpZ2h0L3RvcC9ib3R0b21cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0UmVjdCA9IHV0aWxfMS5pbnRlcnNlY3RSZWN0cyh0aGlzLm9yaWdIaXQsIHN1YmplY3RSZWN0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0UmVjdDsgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvaW50ID0gdXRpbF8xLmdldFJlY3RDZW50ZXIoc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSB1dGlsXzEuZGlmZlBvaW50cyhwb2ludCwgb3JpZ1BvaW50KTsgLy8gcG9pbnQgLSBvcmlnUG9pbnRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxsIHRoZSBzdXBlci1tZXRob2QuIGRvIGl0IGFmdGVyIG9yaWdIaXQgaGFzIGJlZW4gY29tcHV0ZWRcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQuY2FsbCh0aGlzLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGFjdHVhbCBkcmFnIGhhcyBzdGFydGVkXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnU3RhcnQuY2FsbCh0aGlzLCBldik7XHJcbiAgICAgICAgLy8gbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gdGhpcy5vcmlnSGl0IGlmIHRoZSBtaW4tZGlzdGFuY2UgaXMgbGFyZ2VcclxuICAgICAgICBoaXQgPSB0aGlzLnF1ZXJ5SGl0KHV0aWxfMS5nZXRFdlgoZXYpLCB1dGlsXzEuZ2V0RXZZKGV2KSk7XHJcbiAgICAgICAgLy8gcmVwb3J0IHRoZSBpbml0aWFsIGhpdCB0aGUgbW91c2UgaXMgb3ZlclxyXG4gICAgICAgIC8vIGVzcGVjaWFsbHkgaW1wb3J0YW50IGlmIG5vIG1pbi1kaXN0YW5jZSBhbmQgZHJhZyBzdGFydHMgaW1tZWRpYXRlbHlcclxuICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0T3ZlcihoaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZyBtb3Zlc1xyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnID0gZnVuY3Rpb24gKGR4LCBkeSwgZXYpIHtcclxuICAgICAgICB2YXIgaGl0O1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlRHJhZy5jYWxsKHRoaXMsIGR4LCBkeSwgZXYpO1xyXG4gICAgICAgIGhpdCA9IHRoaXMucXVlcnlIaXQodXRpbF8xLmdldEV2WChldiksIHV0aWxfMS5nZXRFdlkoZXYpKTtcclxuICAgICAgICBpZiAoIWlzSGl0c0VxdWFsKGhpdCwgdGhpcy5oaXQpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhpdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUhpdE92ZXIoaGl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBkcmFnZ2luZyBoYXMgYmVlbiBzdG9wcGVkXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUhpdERvbmUoKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZURyYWdFbmQuY2FsbCh0aGlzLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3ZlciBhIG5ldyBoaXRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSGl0T3ZlciA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgaXNPcmlnID0gaXNIaXRzRXF1YWwoaGl0LCB0aGlzLm9yaWdIaXQpO1xyXG4gICAgICAgIHRoaXMuaGl0ID0gaGl0O1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignaGl0T3ZlcicsIHRoaXMuaGl0LCBpc09yaWcsIHRoaXMub3JpZ0hpdCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG91dCBvZiBhIGhpdFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVIaXRPdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaGl0T3V0JywgdGhpcy5oaXQpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUhpdERvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5oaXQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYWZ0ZXIgYSBoaXRPdXQuIEFsc28gY2FsbGVkIGJlZm9yZSBhIGRyYWdTdG9wXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUhpdERvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaGl0RG9uZScsIHRoaXMuaGl0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGludGVyYWN0aW9uIGVuZHMsIHdoZXRoZXIgdGhlcmUgd2FzIGEgcmVhbCBkcmFnIG9yIG5vdFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZCA9IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uRW5kLmNhbGwodGhpcywgZXYsIGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICB0aGlzLm9yaWdIaXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGl0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5oaXRzTm90TmVlZGVkKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gc2Nyb2xsaW5nIGhhcyBzdG9wcGVkLCB3aGV0aGVyIHRocm91Z2ggYXV0byBzY3JvbGwsIG9yIHRoZSB1c2VyIHNjcm9sbGluZ1xyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVTY3JvbGxFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVTY3JvbGxFbmQuY2FsbCh0aGlzKTtcclxuICAgICAgICAvLyBoaXRzJyBhYnNvbHV0ZSBwb3NpdGlvbnMgd2lsbCBiZSBpbiBuZXcgcGxhY2VzIGFmdGVyIGEgdXNlcidzIHNjcm9sbC5cclxuICAgICAgICAvLyBIQUNLIGZvciByZWNvbXB1dGluZy5cclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlbGVhc2VIaXRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGhpdCB1bmRlcm5lYXRoIHRoZSBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIG1vdXNlIGV2ZW50XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnQsIHRvcCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvb3JkQWRqdXN0KSB7XHJcbiAgICAgICAgICAgIGxlZnQgKz0gdGhpcy5jb29yZEFkanVzdC5sZWZ0O1xyXG4gICAgICAgICAgICB0b3AgKz0gdGhpcy5jb29yZEFkanVzdC50b3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5xdWVyeUhpdChsZWZ0LCB0b3ApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIaXREcmFnTGlzdGVuZXI7XHJcbn0oRHJhZ0xpc3RlbmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBIaXREcmFnTGlzdGVuZXI7XHJcbi8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBoaXRzIGFyZSBpZGVudGljYWxseSBlcXVhbC4gYGZhbHNlYCBvdGhlcndpc2UuIE11c3QgYmUgZnJvbSB0aGUgc2FtZSBjb21wb25lbnQuXHJcbi8vIFR3byBudWxsIHZhbHVlcyB3aWxsIGJlIGNvbnNpZGVyZWQgZXF1YWwsIGFzIHR3byBcIm91dCBvZiB0aGUgY29tcG9uZW50XCIgc3RhdGVzIGFyZSB0aGUgc2FtZS5cclxuZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xyXG4gICAgaWYgKCFoaXQwICYmICFoaXQxKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaGl0MCAmJiBoaXQxKSB7XHJcbiAgICAgICAgcmV0dXJuIGhpdDAuY29tcG9uZW50ID09PSBoaXQxLmNvbXBvbmVudCAmJlxyXG4gICAgICAgICAgICBpc0hpdFByb3BzV2l0aGluKGhpdDAsIGhpdDEpICYmXHJcbiAgICAgICAgICAgIGlzSGl0UHJvcHNXaXRoaW4oaGl0MSwgaGl0MCk7IC8vIGVuc3VyZXMgYWxsIHByb3BzIGFyZSBpZGVudGljYWxcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBSZXR1cm5zIHRydWUgaWYgYWxsIG9mIHN1YkhpdCdzIG5vbi1zdGFuZGFyZCBwcm9wZXJ0aWVzIGFyZSB3aXRoaW4gc3VwZXJIaXRcclxuZnVuY3Rpb24gaXNIaXRQcm9wc1dpdGhpbihzdWJIaXQsIHN1cGVySGl0KSB7XHJcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzdWJIaXQpIHtcclxuICAgICAgICBpZiAoIS9eKGNvbXBvbmVudHxsZWZ0fHJpZ2h0fHRvcHxib3R0b20pJC8udGVzdChwcm9wTmFtZSkpIHtcclxuICAgICAgICAgICAgaWYgKHN1YkhpdFtwcm9wTmFtZV0gIT09IHN1cGVySGl0W3Byb3BOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuZXhwb3J0cy5nbG9iYWxEZWZhdWx0cyA9IHtcclxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxyXG4gICAgbW9udGhZZWFyRm9ybWF0OiAnTU1NTSBZWVlZJyxcclxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMjowMDowMCcsXHJcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXlzOiAxIH0sXHJcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxyXG4gICAgbmV4dERheVRocmVzaG9sZDogJzA5OjAwOjAwJyxcclxuICAgIC8vIGRpc3BsYXlcclxuICAgIGNvbHVtbkhlYWRlcjogdHJ1ZSxcclxuICAgIGRlZmF1bHRWaWV3OiAnbW9udGgnLFxyXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAndGl0bGUnLFxyXG4gICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgcmlnaHQ6ICd0b2RheSBwcmV2LG5leHQnXHJcbiAgICB9LFxyXG4gICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXHJcbiAgICB3ZWVrTnVtYmVyVGl0bGU6ICdXJyxcclxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgIC8vZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgLy9ub3dJbmRpY2F0b3I6IGZhbHNlLFxyXG4gICAgc2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcclxuICAgIG1pblRpbWU6ICcwMDowMDowMCcsXHJcbiAgICBtYXhUaW1lOiAnMjQ6MDA6MDAnLFxyXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcclxuICAgIC8vIGV2ZW50IGFqYXhcclxuICAgIGxhenlGZXRjaGluZzogdHJ1ZSxcclxuICAgIHN0YXJ0UGFyYW06ICdzdGFydCcsXHJcbiAgICBlbmRQYXJhbTogJ2VuZCcsXHJcbiAgICB0aW1lem9uZVBhcmFtOiAndGltZXpvbmUnLFxyXG4gICAgdGltZXpvbmU6IGZhbHNlLFxyXG4gICAgLy9hbGxEYXlEZWZhdWx0OiB1bmRlZmluZWQsXHJcbiAgICAvLyBsb2NhbGVcclxuICAgIGxvY2FsZTogbnVsbCxcclxuICAgIGlzUlRMOiBmYWxzZSxcclxuICAgIGJ1dHRvblRleHQ6IHtcclxuICAgICAgICBwcmV2OiBcInByZXZcIixcclxuICAgICAgICBuZXh0OiBcIm5leHRcIixcclxuICAgICAgICBwcmV2WWVhcjogXCJwcmV2IHllYXJcIixcclxuICAgICAgICBuZXh0WWVhcjogXCJuZXh0IHllYXJcIixcclxuICAgICAgICB5ZWFyOiAneWVhcicsXHJcbiAgICAgICAgdG9kYXk6ICd0b2RheScsXHJcbiAgICAgICAgbW9udGg6ICdtb250aCcsXHJcbiAgICAgICAgd2VlazogJ3dlZWsnLFxyXG4gICAgICAgIGRheTogJ2RheSdcclxuICAgIH0sXHJcbiAgICAvL2J1dHRvbkljb25zOiBudWxsLFxyXG4gICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxyXG4gICAgLy8gYWxsb3dzIHNldHRpbmcgYSBtaW4taGVpZ2h0IHRvIHRoZSBldmVudCBzZWdtZW50IHRvIHByZXZlbnQgc2hvcnQgZXZlbnRzIG92ZXJsYXBwaW5nIGVhY2ggb3RoZXJcclxuICAgIGFnZW5kYUV2ZW50TWluSGVpZ2h0OiAwLFxyXG4gICAgLy8ganF1ZXJ5LXVpIHRoZW1pbmdcclxuICAgIHRoZW1lOiBmYWxzZSxcclxuICAgIC8vdGhlbWVCdXR0b25JY29uczogbnVsbCxcclxuICAgIC8vZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IGZhbHNlLFxyXG4gICAgZHJhZ09wYWNpdHk6IC43NSxcclxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxyXG4gICAgZHJhZ1Njcm9sbDogdHJ1ZSxcclxuICAgIC8vc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICB1bnNlbGVjdEF1dG86IHRydWUsXHJcbiAgICAvL3NlbGVjdE1pbkRpc3RhbmNlOiAwLFxyXG4gICAgZHJvcEFjY2VwdDogJyonLFxyXG4gICAgZXZlbnRPcmRlcjogJ3RpdGxlJyxcclxuICAgIC8vZXZlbnRSZW5kZXJXYWl0OiBudWxsLFxyXG4gICAgZXZlbnRMaW1pdDogZmFsc2UsXHJcbiAgICBldmVudExpbWl0VGV4dDogJ21vcmUnLFxyXG4gICAgZXZlbnRMaW1pdENsaWNrOiAncG9wb3ZlcicsXHJcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiAnTEwnLFxyXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxyXG4gICAgd2luZG93UmVzaXplRGVsYXk6IDEwMCxcclxuICAgIGxvbmdQcmVzc0RlbGF5OiAxMDAwXHJcbn07XHJcbmV4cG9ydHMuZW5nbGlzaERlZmF1bHRzID0ge1xyXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogJ2RkZGQsIE1NTU0gRCdcclxufTtcclxuZXhwb3J0cy5ydGxEZWZhdWx0cyA9IHtcclxuICAgIGhlYWRlcjoge1xyXG4gICAgICAgIGxlZnQ6ICduZXh0LHByZXYgdG9kYXknLFxyXG4gICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgcmlnaHQ6ICd0aXRsZSdcclxuICAgIH0sXHJcbiAgICBidXR0b25JY29uczoge1xyXG4gICAgICAgIHByZXY6ICdyaWdodC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgICAgIG5leHQ6ICdsZWZ0LXNpbmdsZS1hcnJvdycsXHJcbiAgICAgICAgcHJldlllYXI6ICdyaWdodC1kb3VibGUtYXJyb3cnLFxyXG4gICAgICAgIG5leHRZZWFyOiAnbGVmdC1kb3VibGUtYXJyb3cnXHJcbiAgICB9LFxyXG4gICAgdGhlbWVCdXR0b25JY29uczoge1xyXG4gICAgICAgIHByZXY6ICdjaXJjbGUtdHJpYW5nbGUtZScsXHJcbiAgICAgICAgbmV4dDogJ2NpcmNsZS10cmlhbmdsZS13JyxcclxuICAgICAgICBuZXh0WWVhcjogJ3NlZWstcHJldicsXHJcbiAgICAgICAgcHJldlllYXI6ICdzZWVrLW5leHQnXHJcbiAgICB9XHJcbn07XHJcbnZhciBjb21wbGV4T3B0aW9ucyA9IFtcclxuICAgICdoZWFkZXInLFxyXG4gICAgJ2Zvb3RlcicsXHJcbiAgICAnYnV0dG9uVGV4dCcsXHJcbiAgICAnYnV0dG9uSWNvbnMnLFxyXG4gICAgJ3RoZW1lQnV0dG9uSWNvbnMnXHJcbl07XHJcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdFxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMob3B0aW9uT2Jqcykge1xyXG4gICAgcmV0dXJuIHV0aWxfMS5tZXJnZVByb3BzKG9wdGlvbk9ianMsIGNvbXBsZXhPcHRpb25zKTtcclxufVxyXG5leHBvcnRzLm1lcmdlT3B0aW9ucyA9IG1lcmdlT3B0aW9ucztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbmFtZXNwYWNlX2hvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgb3B0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgbG9jYWxlT3B0aW9uSGFzaCA9IG5hbWVzcGFjZV9ob29rc18xLmRlZmF1bHQubG9jYWxlcztcclxuZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoID0gbG9jYWxlT3B0aW9uSGFzaDtcclxuLy8gSW5pdGlhbGl6ZSBqUXVlcnkgVUkgZGF0ZXBpY2tlciB0cmFuc2xhdGlvbnMgd2hpbGUgdXNpbmcgc29tZSBvZiB0aGUgdHJhbnNsYXRpb25zXHJcbi8vIFdpbGwgc2V0IHRoaXMgYXMgdGhlIGRlZmF1bHQgbG9jYWxlcyBmb3IgZGF0ZXBpY2tlci5cclxuZnVuY3Rpb24gZGF0ZXBpY2tlckxvY2FsZShsb2NhbGVDb2RlLCBkcExvY2FsZUNvZGUsIGRwT3B0aW9ucykge1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICB2YXIgZmNPcHRpb25zID0gbG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSB8fCAobG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcclxuICAgIC8vIHRyYW5zZmVyIHNvbWUgc2ltcGxlIG9wdGlvbnMgZnJvbSBkYXRlcGlja2VyIHRvIGZjXHJcbiAgICBmY09wdGlvbnMuaXNSVEwgPSBkcE9wdGlvbnMuaXNSVEw7XHJcbiAgICBmY09wdGlvbnMud2Vla051bWJlclRpdGxlID0gZHBPcHRpb25zLndlZWtIZWFkZXI7XHJcbiAgICAvLyBjb21wdXRlIHNvbWUgbW9yZSBjb21wbGV4IG9wdGlvbnMgZnJvbSBkYXRlcGlja2VyXHJcbiAgICAkLmVhY2goZHBDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBmY09wdGlvbnNbbmFtZV0gPSBmdW5jKGRwT3B0aW9ucyk7XHJcbiAgICB9KTtcclxuICAgIHZhciBqcURhdGVQaWNrZXIgPSAkLmRhdGVwaWNrZXI7XHJcbiAgICAvLyBpcyBqUXVlcnkgVUkgRGF0ZXBpY2tlciBpcyBvbiB0aGUgcGFnZT9cclxuICAgIGlmIChqcURhdGVQaWNrZXIpIHtcclxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgbG9jYWxlIGRhdGEuXHJcbiAgICAgICAgLy8gRnVsbENhbGVuZGFyIGFuZCBNb21lbnRKUyB1c2UgbG9jYWxlIGNvZGVzIGxpa2UgXCJwdC1iclwiIGJ1dCBEYXRlcGlja2VyXHJcbiAgICAgICAgLy8gZG9lcyBpdCBsaWtlIFwicHQtQlJcIiBvciBpZiBpdCBkb2Vzbid0IGhhdmUgdGhlIGxvY2FsZSwgbWF5YmUganVzdCBcInB0XCIuXHJcbiAgICAgICAgLy8gTWFrZSBhbiBhbGlhcyBzbyB0aGUgbG9jYWxlIGNhbiBiZSByZWZlcmVuY2VkIGVpdGhlciB3YXkuXHJcbiAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsW2RwTG9jYWxlQ29kZV0gPVxyXG4gICAgICAgICAgICBqcURhdGVQaWNrZXIucmVnaW9uYWxbbG9jYWxlQ29kZV0gPSAvLyBhbGlhc1xyXG4gICAgICAgICAgICAgICAgZHBPcHRpb25zO1xyXG4gICAgICAgIC8vIEFsaWFzICdlbicgdG8gdGhlIGRlZmF1bHQgbG9jYWxlIGRhdGEuIERvIHRoaXMgZXZlcnkgdGltZS5cclxuICAgICAgICBqcURhdGVQaWNrZXIucmVnaW9uYWwuZW4gPSBqcURhdGVQaWNrZXIucmVnaW9uYWxbJyddO1xyXG4gICAgICAgIC8vIFNldCBhcyBEYXRlcGlja2VyJ3MgZ2xvYmFsIGRlZmF1bHRzLlxyXG4gICAgICAgIGpxRGF0ZVBpY2tlci5zZXREZWZhdWx0cyhkcE9wdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGF0ZXBpY2tlckxvY2FsZSA9IGRhdGVwaWNrZXJMb2NhbGU7XHJcbi8vIFNldHMgRnVsbENhbGVuZGFyLXNwZWNpZmljIHRyYW5zbGF0aW9ucy4gV2lsbCBzZXQgdGhlIGxvY2FsZXMgYXMgdGhlIGdsb2JhbCBkZWZhdWx0LlxyXG5mdW5jdGlvbiBsb2NhbGUobG9jYWxlQ29kZSwgbmV3RmNPcHRpb25zKSB7XHJcbiAgICB2YXIgZmNPcHRpb25zO1xyXG4gICAgdmFyIG1vbU9wdGlvbnM7XHJcbiAgICAvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3NhcnlcclxuICAgIGZjT3B0aW9ucyA9IGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSB7fSk7XHJcbiAgICAvLyBwcm92aWRlZCBuZXcgb3B0aW9ucyBmb3IgdGhpcyBsb2NhbGVzPyBtZXJnZSB0aGVtIGluXHJcbiAgICBpZiAobmV3RmNPcHRpb25zKSB7XHJcbiAgICAgICAgZmNPcHRpb25zID0gbG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW2ZjT3B0aW9ucywgbmV3RmNPcHRpb25zXSk7XHJcbiAgICB9XHJcbiAgICAvLyBjb21wdXRlIGxvY2FsZSBvcHRpb25zIHRoYXQgd2VyZW4ndCBkZWZpbmVkLlxyXG4gICAgLy8gYWx3YXlzIGRvIHRoaXMuIG5ld0ZjT3B0aW9ucyBjYW4gYmUgdW5kZWZpbmVkIHdoZW4gaW5pdGlhbGl6aW5nIGZyb20gaTE4biBmaWxlLFxyXG4gICAgLy8gc28gbm8gd2F5IHRvIHRlbGwgaWYgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBvciBhIGRlZmF1bHQtc2V0dGluZy5cclxuICAgIG1vbU9wdGlvbnMgPSBnZXRNb21lbnRMb2NhbGVEYXRhKGxvY2FsZUNvZGUpOyAvLyB3aWxsIGZhbGwgYmFjayB0byBlblxyXG4gICAgJC5lYWNoKG1vbUNvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xyXG4gICAgICAgIGlmIChmY09wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmY09wdGlvbnNbbmFtZV0gPSBmdW5jKG1vbU9wdGlvbnMsIGZjT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBzZXQgaXQgYXMgdGhlIGRlZmF1bHQgbG9jYWxlIGZvciBGdWxsQ2FsZW5kYXJcclxuICAgIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGUgPSBsb2NhbGVDb2RlO1xyXG59XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlO1xyXG47XHJcbi8vIE5PVEU6IGNhbid0IGd1YXJhbnRlZSBhbnkgb2YgdGhlc2UgY29tcHV0YXRpb25zIHdpbGwgcnVuIGJlY2F1c2Ugbm90IGV2ZXJ5IGxvY2FsZSBoYXMgZGF0ZXBpY2tlclxyXG4vLyBjb25maWdzLCBzbyBtYWtlIHN1cmUgdGhlcmUgYXJlIEVuZ2xpc2ggZmFsbGJhY2tzIGZvciB0aGVzZSBpbiB0aGUgZGVmYXVsdHMgZmlsZS5cclxudmFyIGRwQ29tcHV0YWJsZU9wdGlvbnMgPSB7XHJcbiAgICBidXR0b25UZXh0OiBmdW5jdGlvbiAoZHBPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gdGhlIHRyYW5zbGF0aW9ucyBzb21ldGltZXMgd3JvbmdseSBjb250YWluIEhUTUwgZW50aXRpZXNcclxuICAgICAgICAgICAgcHJldjogdXRpbF8xLnN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5wcmV2VGV4dCksXHJcbiAgICAgICAgICAgIG5leHQ6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMubmV4dFRleHQpLFxyXG4gICAgICAgICAgICB0b2RheTogdXRpbF8xLnN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5jdXJyZW50VGV4dClcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJNTU1NIFlZWVlcIiAtPiBcIlNlcHRlbWJlciAyMDE0XCJcclxuICAgIG1vbnRoWWVhckZvcm1hdDogZnVuY3Rpb24gKGRwT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBkcE9wdGlvbnMuc2hvd01vbnRoQWZ0ZXJZZWFyID9cclxuICAgICAgICAgICAgJ1lZWVlbJyArIGRwT3B0aW9ucy55ZWFyU3VmZml4ICsgJ10gTU1NTScgOlxyXG4gICAgICAgICAgICAnTU1NTSBZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddJztcclxuICAgIH1cclxufTtcclxudmFyIG1vbUNvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImRkZCBNL0RcIiAtPiBcIkZyaSA5LzE1XCJcclxuICAgIGRheU9mTW9udGhGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zLCBmY09wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZm9ybWF0ID0gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnbCcpOyAvLyBmb3IgdGhlIGZvcm1hdCBsaWtlIFwiTS9EL1lZWVlcIlxyXG4gICAgICAgIC8vIHN0cmlwIHRoZSB5ZWFyIG9mZiB0aGUgZWRnZSwgYXMgd2VsbCBhcyBvdGhlciBtaXNjIG5vbi13aGl0ZXNwYWNlIGNoYXJzXHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoL15ZK1teXFx3XFxzXSp8W15cXHdcXHNdKlkrJC9nLCAnJyk7XHJcbiAgICAgICAgaWYgKGZjT3B0aW9ucy5pc1JUTCkge1xyXG4gICAgICAgICAgICBmb3JtYXQgKz0gJyBkZGQnOyAvLyBmb3IgUlRMLCBhZGQgZGF5LW9mLXdlZWsgdG8gZW5kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3JtYXQgPSAnZGRkICcgKyBmb3JtYXQ7IC8vIGZvciBMVFIsIGFkZCBkYXktb2Ytd2VlayB0byBiZWdpbm5pbmdcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbWFcIiAtPiBcIjY6MDBwbVwiXHJcbiAgICBtZWRpdW1UaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaCg6bW0pYVwiIC0+IFwiNnBtXCIgLyBcIjY6MzBwbVwiXHJcbiAgICBzbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcoOm1tKScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxXbW0pJC8sICcoJDEpJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoKDptbSl0XCIgLT4gXCI2cFwiIC8gXCI2OjMwcFwiXHJcbiAgICBleHRyYVNtYWxsVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgnOm1tJywgJyg6bW0pJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXFdtbSkkLywgJygkMSknKSAvLyBsaWtlIGFib3ZlLCBidXQgZm9yIGZvcmVpZ24gbG9jYWxlc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICd0Jyk7IC8vIGNvbnZlcnQgdG8gQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlIG9uZS1sZXR0ZXIuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaGFcIiAvIFwiSFwiIC0+IFwiNnBtXCIgLyBcIjE4XCJcclxuICAgIGhvdXJGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcV21tKSQvLCAnJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoOm1tXCIgLT4gXCI2OjMwXCIgKHdpdGggbm8gQU0vUE0pXHJcbiAgICBub01lcmlkaWVtVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIEFNL1BNXHJcbiAgICB9XHJcbn07XHJcbi8vIG9wdGlvbnMgdGhhdCBzaG91bGQgYmUgY29tcHV0ZWQgb2ZmIGxpdmUgY2FsZW5kYXIgb3B0aW9ucyAoY29uc2lkZXJzIG92ZXJyaWRlIG9wdGlvbnMpXHJcbi8vIFRPRE86IGJlc3QgcGxhY2UgZm9yIHRoaXM/IHJlbGF0ZWQgdG8gbG9jYWxlP1xyXG4vLyBUT0RPOiBmbGlwcGluZyB0ZXh0IGJhc2VkIG9uIGlzUlRMIGlzIGEgYmFkIGlkZWEgYmVjYXVzZSB0aGUgQ1NTIGBkaXJlY3Rpb25gIG1pZ2h0IHdhbnQgdG8gaGFuZGxlIGl0XHJcbnZhciBpbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIk1vIDE2XCJcclxuICAgIHNtYWxsRGF5RGF0ZUZvcm1hdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5pc1JUTCA/XHJcbiAgICAgICAgICAgICdEIGRkJyA6XHJcbiAgICAgICAgICAgICdkZCBEJztcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2sgNVwiXHJcbiAgICB3ZWVrRm9ybWF0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmlzUlRMID9cclxuICAgICAgICAgICAgJ3dbICcgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICddJyA6XHJcbiAgICAgICAgICAgICdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJyBddyc7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIldrNVwiXHJcbiAgICBzbWFsbFdlZWtGb3JtYXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xyXG4gICAgICAgICAgICAnd1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxyXG4gICAgICAgICAgICAnWycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICdddyc7XHJcbiAgICB9XHJcbn07XHJcbi8vIFRPRE86IG1ha2UgdGhlc2UgY29tcHV0YWJsZSBwcm9wZXJ0aWVzIGluIG9wdGlvbnNNYW5hZ2VyXHJcbmZ1bmN0aW9uIHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAkLmVhY2goaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBmdW5jKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMucG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zID0gcG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zO1xyXG4vLyBSZXR1cm5zIG1vbWVudCdzIGludGVybmFsIGxvY2FsZSBkYXRhLiBJZiBkb2Vzbid0IGV4aXN0LCByZXR1cm5zIEVuZ2xpc2guXHJcbmZ1bmN0aW9uIGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSkge1xyXG4gICAgcmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGxvY2FsZUNvZGUpIHx8IG1vbWVudC5sb2NhbGVEYXRhKCdlbicpO1xyXG59XHJcbmV4cG9ydHMuZ2V0TW9tZW50TG9jYWxlRGF0YSA9IGdldE1vbWVudExvY2FsZURhdGE7XHJcbi8vIEluaXRpYWxpemUgRW5nbGlzaCBieSBmb3JjaW5nIGNvbXB1dGF0aW9uIG9mIG1vbWVudC1kZXJpdmVkIG9wdGlvbnMuXHJcbi8vIEFsc28sIHNldHMgaXQgYXMgdGhlIGRlZmF1bHQuXHJcbmxvY2FsZSgnZW4nLCBvcHRpb25zXzEuZW5nbGlzaERlZmF1bHRzKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG4vLyBDbGFzcyB0aGF0IGFsbCBvdGhlciBjbGFzc2VzIHdpbGwgaW5oZXJpdCBmcm9tXHJcbnZhciBDbGFzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENsYXNzKCkge1xyXG4gICAgfVxyXG4gICAgLy8gQ2FsbGVkIG9uIGEgY2xhc3MgdG8gY3JlYXRlIGEgc3ViY2xhc3MuXHJcbiAgICAvLyBMSU1JVEFUSU9OOiBjYW5ub3QgcHJvdmlkZSBhIGNvbnN0cnVjdG9yIVxyXG4gICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24gKG1lbWJlcnMpIHtcclxuICAgICAgICB2YXIgU3ViQ2xhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIHRzbGliXzEuX19leHRlbmRzKFN1YkNsYXNzLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICAgICAgfSh0aGlzKSk7XHJcbiAgICAgICAgO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMobWVtYmVycywgU3ViQ2xhc3MucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQWRkcyBuZXcgbWVtYmVyIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBjbGFzcydzIHByb3RvdHlwZS5cclxuICAgIC8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbm90aGVyIGNsYXNzLCBvciBhIHBsYWluIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgbmV3IG1lbWJlcnMuXHJcbiAgICBDbGFzcy5taXhpbiA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhtZW1iZXJzLCB0aGlzLnByb3RvdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENsYXNzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDbGFzcztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xyXG52YXIgRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZihzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWlzY1Byb3BzID0ge307XHJcbiAgICB9XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgY29weS5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgY29weS5yYXdJZCA9IHRoaXMucmF3SWQ7XHJcbiAgICAgICAgY29weS51aWQgPSB0aGlzLnVpZDsgLy8gbm90IHJlYWxseSB1bmlxdWUgYW55bW9yZSA6KFxyXG4gICAgICAgIEV2ZW50RGVmLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHModGhpcywgY29weSk7XHJcbiAgICAgICAgY29weS5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5zbGljZSgpOyAvLyBjb3B5XHJcbiAgICAgICAgY29weS5taXNjUHJvcHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5oYXNJbnZlcnNlUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmluZygpID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaGFzQmdSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmluZyA9IHRoaXMuZ2V0UmVuZGVyaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmluZyA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcgfHwgcmVuZGVyaW5nID09PSAnYmFja2dyb3VuZCc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldFJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZW5kZXJpbmc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldENvbnN0cmFpbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZS5jb25zdHJhaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNvbnN0cmFpbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jYWxlbmRhci5vcHQoJ2V2ZW50Q29uc3RyYWludCcpOyAvLyB3aGF0IGFib3V0IFZpZXcgb3B0aW9uP1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5nZXRPdmVybGFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXAgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zb3VyY2Uub3ZlcmxhcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5vdmVybGFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY2FsZW5kYXIub3B0KCdldmVudE92ZXJsYXAnKTsgLy8gd2hhdCBhYm91dCBWaWV3IG9wdGlvbj9cclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaXNTdGFydEV4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydEVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRFZGl0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN0YXJ0RWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmlzRHVyYXRpb25FeHBsaWNpdGx5RWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5kdXJhdGlvbkVkaXRhYmxlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5pc0V4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLnRvTGVnYWN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvYmogPSAkLmV4dGVuZCh7fSwgdGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIG9iai5faWQgPSB0aGlzLnVpZDtcclxuICAgICAgICBvYmouc291cmNlID0gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgb2JqLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnNsaWNlKCk7IC8vIGNvcHlcclxuICAgICAgICBvYmouYWxsRGF5ID0gdGhpcy5pc0FsbERheSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnJhd0lkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgb2JqLmlkID0gdGhpcy5yYXdJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnREZWYuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLCBvYmopO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIGlmIChyYXdQcm9wcy5pZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudERlZi5ub3JtYWxpemVJZCgodGhpcy5yYXdJZCA9IHJhd1Byb3BzLmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnREZWYuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMuX2lkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBTdHJpbmcocmF3UHJvcHMuX2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudWlkID0gRXZlbnREZWYuZ2VuZXJhdGVJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50U291cmNlXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWUuc3BsaXQoL1xccysvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWlzY1Byb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgJC5leHRlbmQodGhpcy5taXNjUHJvcHMsIHJhd1Byb3BzKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IG5ldyB0aGlzKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGRlZi5hcHBseVByb3BzKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYubm9ybWFsaXplSWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnX2ZjJyArIChFdmVudERlZi51dWlkKyspO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudERlZi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgLy8gSURzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFRPRE86IGNvbnZlcmdlIHdpdGggRXZlbnRTb3VyY2VcclxuICAgIEV2ZW50RGVmLnV1aWQgPSAwO1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZjtcclxuUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50RGVmKTtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBub3QgYXV0b21hdGljYWxseSBhc3NpZ25lZCAoYGZhbHNlYClcclxuICAgIF9pZDogZmFsc2UsXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IGZhbHNlLFxyXG4gICAgc291cmNlOiBmYWxzZSxcclxuICAgIC8vIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgKGB0cnVlYClcclxuICAgIHRpdGxlOiB0cnVlLFxyXG4gICAgdXJsOiB0cnVlLFxyXG4gICAgcmVuZGVyaW5nOiB0cnVlLFxyXG4gICAgY29uc3RyYWludDogdHJ1ZSxcclxuICAgIG92ZXJsYXA6IHRydWUsXHJcbiAgICBlZGl0YWJsZTogdHJ1ZSxcclxuICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXHJcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiB0cnVlLFxyXG4gICAgY29sb3I6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZSxcclxuICAgIHRleHRDb2xvcjogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5mdW5jdGlvbiBldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzKGV2ZW50RGVmcywgdW56b25lZFJhbmdlKSB7XHJcbiAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VzLnB1c2guYXBwbHkoZXZlbnRJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgIGV2ZW50RGVmc1tpXS5idWlsZEluc3RhbmNlcyh1bnpvbmVkUmFuZ2UpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudEluc3RhbmNlcztcclxufVxyXG5leHBvcnRzLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMgPSBldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzO1xyXG5mdW5jdGlvbiBldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBuZXcgRXZlbnRSYW5nZV8xLmRlZmF1bHQoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS51bnpvbmVkUmFuZ2UsIGV2ZW50SW5zdGFuY2UuZGVmLCBldmVudEluc3RhbmNlKTtcclxufVxyXG5leHBvcnRzLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UgPSBldmVudEluc3RhbmNlVG9FdmVudFJhbmdlO1xyXG5mdW5jdGlvbiBldmVudFJhbmdlVG9FdmVudEZvb3RwcmludChldmVudFJhbmdlKSB7XHJcbiAgICByZXR1cm4gbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChldmVudFJhbmdlLnVuem9uZWRSYW5nZSwgZXZlbnRSYW5nZS5ldmVudERlZi5pc0FsbERheSgpKSwgZXZlbnRSYW5nZS5ldmVudERlZiwgZXZlbnRSYW5nZS5ldmVudEluc3RhbmNlIC8vIG1pZ2h0IG5vdCBleGlzdFxyXG4gICAgKTtcclxufVxyXG5leHBvcnRzLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50ID0gZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQ7XHJcbmZ1bmN0aW9uIGV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZShldmVudEluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS51bnpvbmVkUmFuZ2U7XHJcbn1cclxuZXhwb3J0cy5ldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UgPSBldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2U7XHJcbmZ1bmN0aW9uIGV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQoZXZlbnRGb290cHJpbnQpIHtcclxuICAgIHJldHVybiBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbn1cclxuZXhwb3J0cy5ldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50ID0gZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRGb290cHJpbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRGb290cHJpbnQgPSBjb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZiA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgRXZlbnRGb290cHJpbnQucHJvdG90eXBlLmdldEV2ZW50TGVnYWN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ldmVudEluc3RhbmNlIHx8IHRoaXMuZXZlbnREZWYpLnRvTGVnYWN5KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50Rm9vdHByaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEZvb3RwcmludDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBzb3VyY2VDbGFzc2VzOiBbXSxcclxuICAgIHJlZ2lzdGVyQ2xhc3M6IGZ1bmN0aW9uIChFdmVudFNvdXJjZUNsYXNzKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VDbGFzc2VzLnVuc2hpZnQoRXZlbnRTb3VyY2VDbGFzcyk7IC8vIGdpdmUgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgfSxcclxuICAgIHBhcnNlOiBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZUNsYXNzZXMgPSB0aGlzLnNvdXJjZUNsYXNzZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50U291cmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQ2xhc3Nlc1tpXS5wYXJzZShyYXdJbnB1dCwgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVmTXV0YXRpb24oKSB7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgZXZlbnREZWYgYXNzdW1lZCB0byBiZSBhIFNpbmdsZUV2ZW50RGVmLlxyXG4gICAgcmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50RGVmTXV0YXRpb24ucHJvdG90eXBlLm11dGF0ZVNpbmdsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvcmlnRGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIG9yaWdEYXRlUHJvZmlsZSA9IGV2ZW50RGVmLmRhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICBldmVudERlZi5kYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZU11dGF0aW9uLmJ1aWxkTmV3RGF0ZVByb2ZpbGUob3JpZ0RhdGVQcm9maWxlLCBldmVudERlZi5zb3VyY2UuY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBFdmVudERlZjo6YXBwbHlNYW51YWxTdGFuZGFyZFByb3BzXHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREZWZJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmlkID0gRXZlbnREZWZfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKChldmVudERlZi5yYXdJZCA9IHRoaXMuZXZlbnREZWZJZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBFdmVudERlZjo6YXBwbHlNYW51YWxTdGFuZGFyZFByb3BzXHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgaWYgKHRoaXMudmVyYmF0aW1TdGFuZGFyZFByb3BzKSB7XHJcbiAgICAgICAgICAgIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzKHRoaXMudmVyYmF0aW1TdGFuZGFyZFByb3BzLCAvLyBzcmNcclxuICAgICAgICAgICAgZXZlbnREZWYgLy8gZGVzdFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4ndCB1bmRvXHJcbiAgICAgICAgaWYgKHRoaXMubWlzY1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmFwcGx5TWlzY1Byb3BzKHRoaXMubWlzY1Byb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9yaWdEYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWYuZGF0ZVByb2ZpbGUgPSBvcmlnRGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZk11dGF0aW9uLnByb3RvdHlwZS5zZXREYXRlTXV0YXRpb24gPSBmdW5jdGlvbiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRhdGVNdXRhdGlvbiAmJiAhZGF0ZU11dGF0aW9uLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVNdXRhdGlvbiA9IGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZGF0ZU11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmTXV0YXRpb24uY3JlYXRlRnJvbVJhd1Byb3BzID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIHJhd1Byb3BzLCBsYXJnZVVuaXQpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBldmVudEluc3RhbmNlLmRlZjtcclxuICAgICAgICB2YXIgZGF0ZVByb3BzID0ge307XHJcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbWlzY1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIHZlcmJhdGltU3RhbmRhcmRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBldmVudERlZklkID0gbnVsbDtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgcHJvcE5hbWU7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgdmFyIGRlZk11dGF0aW9uO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0LmlzU3RhbmRhcmRQcm9wKHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudERlZi5pc1N0YW5kYXJkUHJvcChwcm9wTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50RGVmLm1pc2NQcm9wc1twcm9wTmFtZV0gIT09IHJhd1Byb3BzW3Byb3BOYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgbWlzY1Byb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlUHJvZmlsZSA9IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0LnBhcnNlKGRhdGVQcm9wcywgZXZlbnREZWYuc291cmNlKTtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uID0gRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0LmNyZWF0ZUZyb21EaWZmKGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlLCBsYXJnZVVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhbmRhcmRQcm9wcy5pZCAhPT0gZXZlbnREZWYuaWQpIHtcclxuICAgICAgICAgICAgZXZlbnREZWZJZCA9IHN0YW5kYXJkUHJvcHMuaWQ7IC8vIG9ubHkgYXBwbHkgaWYgdGhlcmUncyBhIGNoYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXV0aWxfMS5pc0FycmF5c0VxdWFsKHN0YW5kYXJkUHJvcHMuY2xhc3NOYW1lLCBldmVudERlZi5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHN0YW5kYXJkUHJvcHMuY2xhc3NOYW1lOyAvLyBvbmx5IGFwcGx5IGlmIHRoZXJlJ3MgYSBjaGFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnREZWZfMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMoc3RhbmRhcmRQcm9wcywgLy8gc3JjXHJcbiAgICAgICAgdmVyYmF0aW1TdGFuZGFyZFByb3BzIC8vIGRlc3RcclxuICAgICAgICApO1xyXG4gICAgICAgIGRlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb24oKTtcclxuICAgICAgICBkZWZNdXRhdGlvbi5ldmVudERlZklkID0gZXZlbnREZWZJZDtcclxuICAgICAgICBkZWZNdXRhdGlvbi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgZGVmTXV0YXRpb24udmVyYmF0aW1TdGFuZGFyZFByb3BzID0gdmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLm1pc2NQcm9wcyA9IG1pc2NQcm9wcztcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGRlZk11dGF0aW9uLmRhdGVNdXRhdGlvbiA9IGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZk11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudERlZk11dGF0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZk11dGF0aW9uO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGhlbWUob3B0aW9uc01hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gb3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzSWNvbk92ZXJyaWRlKCk7XHJcbiAgICB9XHJcbiAgICBUaGVtZS5wcm90b3R5cGUucHJvY2Vzc0ljb25PdmVycmlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUodGhpcy5vcHRpb25zTWFuYWdlci5nZXQodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLnNldEljb25PdmVycmlkZSA9IGZ1bmN0aW9uIChpY29uT3ZlcnJpZGVIYXNoKSB7XHJcbiAgICAgICAgdmFyIGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICB2YXIgYnV0dG9uTmFtZTtcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGljb25PdmVycmlkZUhhc2gpKSB7XHJcbiAgICAgICAgICAgIGljb25DbGFzc2VzQ29weSA9ICQuZXh0ZW5kKHt9LCB0aGlzLmljb25DbGFzc2VzKTtcclxuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWNvbk92ZXJyaWRlSGFzaCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXggPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4O1xyXG4gICAgICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVmaXggKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWU7XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcclxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzID0gZnVuY3Rpb24gKGN1c3RvbUJ1dHRvblByb3BzKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGhlbWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRoZW1lO1xyXG5UaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xyXG5UaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7fTtcclxuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcclxuVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIENsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuLypcclxuRW1ib2RpZXMgYSBkaXYgdGhhdCBoYXMgcG90ZW50aWFsIHNjcm9sbGJhcnNcclxuKi9cclxudmFyIFNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Nyb2xsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTY3JvbGxlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBfdGhpcy5vdmVyZmxvd1ggPSBvcHRpb25zLm92ZXJmbG93WCB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcclxuICAgICAgICBfdGhpcy5vdmVyZmxvd1kgPSBvcHRpb25zLm92ZXJmbG93WSB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLnJlbmRlckVsKCk7XHJcbiAgICAgICAgdGhpcy5hcHBseU92ZXJmbG93KCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlckVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zY3JvbGxFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1zY3JvbGxlclwiPjwvZGl2PicpKTtcclxuICAgIH07XHJcbiAgICAvLyBzZXRzIHRvIG5hdHVyYWwgaGVpZ2h0LCB1bmxvY2tzIG92ZXJmbG93XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoJ2F1dG8nKTtcclxuICAgICAgICB0aGlzLmFwcGx5T3ZlcmZsb3coKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIE92ZXJmbG93XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmFwcGx5T3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5jc3Moe1xyXG4gICAgICAgICAgICAnb3ZlcmZsb3cteCc6IHRoaXMub3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAnb3ZlcmZsb3cteSc6IHRoaXMub3ZlcmZsb3dZXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2F1c2VzIGFueSAnYXV0bycgb3ZlcmZsb3cgdmFsdWVzIHRvIHJlc29sdmVzIHRvICdzY3JvbGwnIG9yICdoaWRkZW4nLlxyXG4gICAgLy8gVXNlZnVsIGZvciBwcmVzZXJ2aW5nIHNjcm9sbGJhciB3aWR0aHMgcmVnYXJkbGVzcyBvZiBmdXR1cmUgcmVzaXplcy5cclxuICAgIC8vIENhbiBwYXNzIGluIHNjcm9sbGJhcldpZHRocyBmb3Igb3B0aW1pemF0aW9uLlxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmxvY2tPdmVyZmxvdyA9IGZ1bmN0aW9uIChzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3dYID0gdGhpcy5vdmVyZmxvd1g7XHJcbiAgICAgICAgdmFyIG92ZXJmbG93WSA9IHRoaXMub3ZlcmZsb3dZO1xyXG4gICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHNjcm9sbGJhcldpZHRocyB8fCB0aGlzLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgIGlmIChvdmVyZmxvd1ggPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICBvdmVyZmxvd1ggPSAoc2Nyb2xsYmFyV2lkdGhzLnRvcCB8fCBzY3JvbGxiYXJXaWR0aHMuYm90dG9tIHx8IC8vIGhvcml6b250YWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsV2lkdGggLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aCkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3ZlcmZsb3dZID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dZID0gKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCB8fCAvLyB2ZXJ0aWNhbCBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgLy8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbFswXS5zY3JvbGxIZWlnaHQgLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRIZWlnaHQpID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5jc3MoeyAnb3ZlcmZsb3cteCc6IG92ZXJmbG93WCwgJ292ZXJmbG93LXknOiBvdmVyZmxvd1kgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0dGVycyAvIFNldHRlcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuaGVpZ2h0KGhlaWdodCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AoKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsRWwuc2Nyb2xsVG9wKHRvcCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldENsaWVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRDbGllbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0O1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxiYXJXaWR0aHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRTY3JvbGxiYXJXaWR0aHModGhpcy5zY3JvbGxFbCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNjcm9sbGVyO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50KF92aWV3LCBfb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF92aWV3LCBfb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICAvLyBzZWxmLWNvbmZpZywgb3ZlcnJpZGFibGUgYnkgc3ViY2xhc3Nlc1xyXG4gICAgICAgIF90aGlzLnNlZ1NlbGVjdG9yID0gJy5mYy1ldmVudC1jb250YWluZXIgPiAqJzsgLy8gd2hhdCBjb25zdGl0dXRlcyBhbiBldmVudCBlbGVtZW50P1xyXG4gICAgICAgIGlmIChfdGhpcy5kYXRlU2VsZWN0aW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZGF0ZUNsaWNraW5nID0gbmV3IF90aGlzLmRhdGVDbGlja2luZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRlU2VsZWN0aW5nID0gbmV3IF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudFBvaW50aW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IG5ldyBfdGhpcy5ldmVudFBvaW50aW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnREcmFnZ2luZ0NsYXNzICYmIF90aGlzLmV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnREcmFnZ2luZyA9IG5ldyBfdGhpcy5ldmVudERyYWdnaW5nQ2xhc3MoX3RoaXMsIF90aGlzLmV2ZW50UG9pbnRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnRSZXNpemluZ0NsYXNzICYmIF90aGlzLmV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRSZXNpemluZyA9IG5ldyBfdGhpcy5ldmVudFJlc2l6aW5nQ2xhc3MoX3RoaXMsIF90aGlzLmV2ZW50UG9pbnRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4dGVybmFsRHJvcHBpbmcgPSBuZXcgX3RoaXMuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gU2V0cyB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgdmlldyBzaG91bGQgcmVuZGVyIGluc2lkZSBvZiwgZG9lcyBnbG9iYWwgRE9NLXJlbGF0ZWQgaW5pdGlhbGl6YXRpb25zLFxyXG4gICAgLy8gYW5kIHJlbmRlcnMgYWxsIHRoZSBub24tZGF0ZS1yZWxhdGVkIGNvbnRlbnQgaW5zaWRlLlxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRFbGVtZW50LmNhbGwodGhpcywgZWwpO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGVDbGlja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVDbGlja2luZy5iaW5kVG9FbChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGVTZWxlY3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlU2VsZWN0aW5nLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iaW5kQWxsU2VnSGFuZGxlcnNUb0VsKGVsKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbnMoKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb25zKCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWxEcm9wcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRHJvcHBpbmcuYmluZFRvRG9jdW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWxEcm9wcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRHJvcHBpbmcudW5iaW5kRnJvbURvY3VtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZERhdGVIYW5kbGVyVG9FbCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byB0aGUgZ3JpZCdzIHJvb3QgZWxlbWVudC5cclxuICAgICAgICAvLyBqUXVlcnkgd2lsbCB0YWtlIGNhcmUgb2YgdW5yZWdpc3RlcmluZyB0aGVtIHdoZW4gcmVtb3ZlRWxlbWVudCBnZXRzIGNhbGxlZC5cclxuICAgICAgICB0aGlzLmVsLm9uKG5hbWUsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoISQoZXYudGFyZ2V0KS5pcyhfdGhpcy5zZWdTZWxlY3RvciArICcsJyArIC8vIGRpcmVjdGx5IG9uIGFuIGV2ZW50IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1NlbGVjdG9yICsgJyAqLCcgKyAvLyB3aXRoaW4gYW4gZXZlbnQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgJy5mYy1tb3JlLCcgKyAvLyBhIFwibW9yZS4uXCIgbGlua1xyXG4gICAgICAgICAgICAgICAgJ2FbZGF0YS1nb3RvXScgLy8gYSBjbGlja2FibGUgbmF2IGxpbmtcclxuICAgICAgICAgICAgKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kQWxsU2VnSGFuZGxlcnNUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UG9pbnRpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREcmFnZ2luZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlc2l6aW5nXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudEludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudEludGVyYWN0aW9uLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZFNlZ0hhbmRsZXJUb0VsID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBlbC5vbihuYW1lLCB0aGlzLnNlZ1NlbGVjdG9yLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIHNlZyA9ICQoZXYuY3VycmVudFRhcmdldCkuZGF0YSgnZmMtc2VnJyk7IC8vIGdyYWIgc2VnbWVudCBkYXRhLiBwdXQgdGhlcmUgYnkgVmlldzo6cmVuZGVyRXZlbnRzUGF5bG9hZFxyXG4gICAgICAgICAgICBpZiAoc2VnICYmICFfdGhpcy5zaG91bGRJZ25vcmVFdmVudFBvaW50aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwoX3RoaXMsIHNlZywgZXYpOyAvLyBjb250ZXh0IHdpbGwgYmUgdGhlIEdyaWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSEFDS1xyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBzdGlsbCB3b3JrIGV2ZW4gdGhvdWdoIGJpbmREYXRlSGFuZGxlclRvRWwgZG9lc24ndCB1c2UgR2xvYmFsRW1pdHRlci5cclxuICAgICAgICByZXR1cm4gR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZElnbm9yZVRvdWNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIC8vIE9uIGlPUyAoYW5kIEFuZHJvaWQ/KSB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBpbml0aWF0ZWQgb3ZlcnRvcCBhbm90aGVyIHNlbGVjdGlvbixcclxuICAgICAgICAvLyB0aGUgdG91Y2hlbmQgbmV2ZXIgZmlyZXMgYmVjYXVzZSB0aGUgZWxlbWVudHMgZ2V0cyByZW1vdmVkIG1pZC10b3VjaC1pbnRlcmFjdGlvbiAobXkgdGhlb3J5KS5cclxuICAgICAgICAvLyBIQUNLOiBzaW1wbHkgZG9uJ3QgYWxsb3cgdGhpcyB0byBoYXBwZW4uXHJcbiAgICAgICAgLy8gQUxTTzogcHJldmVudCBzZWxlY3Rpb24gd2hlbiBhbiAqZXZlbnQqIGlzIGFscmVhZHkgcmFpc2VkLlxyXG4gICAgICAgIHJldHVybiB2aWV3LmlzU2VsZWN0ZWQgfHwgdmlldy5zZWxlY3RlZEV2ZW50O1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlRXZlbnRQb2ludGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBvbmx5IGNhbGwgdGhlIGhhbmRsZXJzIGlmIHRoZXJlIGlzIG5vdCBhIGRyYWcvcmVzaXplIGluIHByb2dyZXNzXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmV2ZW50RHJhZ2dpbmcgJiYgdGhpcy5ldmVudERyYWdnaW5nLmlzRHJhZ2dpbmcpIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmV2ZW50UmVzaXppbmcgJiYgdGhpcy5ldmVudFJlc2l6aW5nLmlzUmVzaXppbmcpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSAmJlxyXG4gICAgICAgICAgICAodGhpcy5pc0V2ZW50RGVmRHJhZ2dhYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnREcmFnID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2FuU3RhcnRSZXNpemUoc2VnLCBldikgJiZcclxuICAgICAgICAgICAgdGhpcy5pc0V2ZW50RGVmRHJhZ2dhYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FuU3RhcnRSZXNpemUgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgcmV0dXJuICghdXRpbF8xLmdldEV2SXNUb3VjaChldikgfHwgdmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoZXZlbnREZWYpKSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoZXZlbnREZWYpICYmXHJcbiAgICAgICAgICAgICQoZXYudGFyZ2V0KS5pcygnLmZjLXJlc2l6ZXInKTtcclxuICAgIH07XHJcbiAgICAvLyBLaWxscyBhbGwgaW4tcHJvZ3Jlc3MgZHJhZ2dpbmcuXHJcbiAgICAvLyBVc2VmdWwgZm9yIHdoZW4gcHVibGljIEFQSSBtZXRob2RzIHRoYXQgcmVzdWx0IGluIHJlLXJlbmRlcmluZyBhcmUgaW52b2tlZCBkdXJpbmcgYSBkcmFnLlxyXG4gICAgLy8gQWxzbyB1c2VmdWwgZm9yIHdoZW4gdG91Y2ggZGV2aWNlcyBtaXNiZWhhdmUgYW5kIGRvbid0IGZpcmUgdGhlaXIgdG91Y2hlbmQuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmVuZEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNsaWNraW5nLFxyXG4gICAgICAgICAgICB0aGlzLmRhdGVTZWxlY3RpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRQb2ludGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudERyYWdnaW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVzaXppbmdcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uZW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEcmFnLW4tRHJvcFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSBkcmFnZ2VkIGJ5IHRoZSB1c2VyXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZEcmFnZ2FibGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0V2ZW50RGVmU3RhcnRFZGl0YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmU3RhcnRFZGl0YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gZXZlbnREZWYuaXNTdGFydEV4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc0VkaXRhYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMub3B0KCdldmVudFN0YXJ0RWRpdGFibGUnKTtcclxuICAgICAgICAgICAgaWYgKGlzRWRpdGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMuaXNFdmVudERlZkdlbmVyYWxseUVkaXRhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZHZW5lcmFsbHlFZGl0YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc0VkaXRhYmxlID0gZXZlbnREZWYuaXNFeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNFZGl0YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzRWRpdGFibGUgPSB0aGlzLm9wdCgnZWRpdGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBzdGFydGluZyBlZGdlXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2V2ZW50UmVzaXphYmxlRnJvbVN0YXJ0JykgJiYgdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIGVuZGluZyBlZGdlXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBieSB0aGUgdXNlciBhdCBhbGxcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZSA9IGV2ZW50RGVmLmlzRHVyYXRpb25FeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNSZXNpemFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc1Jlc2l6YWJsZSA9IHRoaXMub3B0KCdldmVudER1cmF0aW9uRWRpdGFibGUnKTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXphYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVzaXphYmxlID0gdGhpcy5pc0V2ZW50RGVmR2VuZXJhbGx5RWRpdGFibGUoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc1Jlc2l6YWJsZTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBNdXRhdGlvbiAvIENvbnN0cmFpbnRzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIERpZmZzIHRoZSB0d28gZGF0ZXMsIHJldHVybmluZyBhIGR1cmF0aW9uLCBiYXNlZCBvbiBncmFudWxhcml0eSBvZiB0aGUgZ3JpZFxyXG4gICAgLy8gVE9ETzogcG9ydCBpc1RpbWVTY2FsZSBpbnRvIHRoaXMgc3lzdGVtP1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5kaWZmRGF0ZXMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGlmICh0aGlzLmxhcmdlVW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZCeVVuaXQoYSwgYiwgdGhpcy5sYXJnZVVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5VGltZShhLCBiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gaXMgaXQgYWxsb3dlZCwgaW4gcmVsYXRpb24gdG8gdGhlIHZpZXcncyB2YWxpZFJhbmdlP1xyXG4gICAgLy8gTk9URTogdmVyeSBzaW1pbGFyIHRvIGlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRBbGxFdmVudFJhbmdlcygpKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGp1c3QgdXNlIGdldEFsbEV2ZW50UmFuZ2VzIGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmICghZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQoZXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgIH07XHJcbiAgICAvLyBOT1RFOiB2ZXJ5IHNpbWlsYXIgdG8gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAvLyB3aGVuIGl0J3MgYSBjb21wbGV0ZWx5IGFub255bW91cyBleHRlcm5hbCBkcmFnLCBubyBldmVudC5cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGVQcm9maWxlLnZhbGlkVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBwYXNzIGluIGV2ZW50SW5zdGFuY2VHcm91cCBpbnN0ZWFkXHJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIHdlIGRvbid0IHdhbnQgY2FsZW5kYXIncyBjb25zdHJhaW50IHN5c3RlbSB0byBkZXBlbmQgb24gYSBjb21wb25lbnQnc1xyXG4gICAgICAgICAgICAvLyAgZGV0ZXJtaW5hdGlvbiBvZiBmb290cHJpbnRzLlxyXG4gICAgICAgICAgICBpZiAoIXZpZXcuY2FsZW5kYXIuY29uc3RyYWludHMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudDtcclxufShEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQ7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZnJvbSB3aGljaCBvdGhlciB2aWV3cyBpbmhlcml0IGZyb21cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFZpZXcoY2FsZW5kYXIsIHZpZXdTcGVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgdmlld1NwZWMub3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5iYXRjaFJlbmRlckRlcHRoID0gMDtcclxuICAgICAgICBfdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7IC8vIGJvb2xlYW4gd2hldGhlciBhIHJhbmdlIG9mIHRpbWUgaXMgdXNlci1zZWxlY3RlZCBvciBub3RcclxuICAgICAgICBfdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLnZpZXdTcGVjID0gdmlld1NwZWM7XHJcbiAgICAgICAgLy8gc2hvcnRjdXRzXHJcbiAgICAgICAgX3RoaXMudHlwZSA9IHZpZXdTcGVjLnR5cGU7XHJcbiAgICAgICAgLy8gLm5hbWUgaXMgZGVwcmVjYXRlZFxyXG4gICAgICAgIF90aGlzLm5hbWUgPSBfdGhpcy50eXBlO1xyXG4gICAgICAgIF90aGlzLmluaXRSZW5kZXJRdWV1ZSgpO1xyXG4gICAgICAgIF90aGlzLmluaXRIaWRkZW5EYXlzKCk7XHJcbiAgICAgICAgX3RoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBuZXcgX3RoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMuYmluZEJhc2VSZW5kZXJIYW5kbGVycygpO1xyXG4gICAgICAgIF90aGlzLmV2ZW50T3JkZXJTcGVjcyA9IHV0aWxfMS5wYXJzZUZpZWxkU3BlY3MoX3RoaXMub3B0KCdldmVudE9yZGVyJykpO1xyXG4gICAgICAgIC8vIGxlZ2FjeVxyXG4gICAgICAgIGlmIChfdGhpc1snaW5pdGlhbGl6ZSddKSB7XHJcbiAgICAgICAgICAgIF90aGlzWydpbml0aWFsaXplJ10oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgVmlldy5wcm90b3R5cGUuX2dldFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0cmlldmVzIGFuIG9wdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lXHJcbiAgICBWaWV3LnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgLyogUmVuZGVyIFF1ZXVlXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuaW5pdFJlbmRlclF1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyUXVldWUgPSBuZXcgUmVuZGVyUXVldWVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZXZlbnQ6IHRoaXMub3B0KCdldmVudFJlbmRlcldhaXQnKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVuZGVyUXVldWUub24oJ3N0YXJ0JywgdGhpcy5vblJlbmRlclF1ZXVlU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5vbignc3RvcCcsIHRoaXMub25SZW5kZXJRdWV1ZVN0b3AuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vbignYmVmb3JlOmNoYW5nZScsIHRoaXMuc3RhcnRCYXRjaFJlbmRlcik7XHJcbiAgICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5zdG9wQmF0Y2hSZW5kZXIpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLm9uUmVuZGVyUXVldWVTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGVuZGFyLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLmFkZFNjcm9sbCh0aGlzLnF1ZXJ5U2Nyb2xsKCkpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLm9uUmVuZGVyUXVldWVTdG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGVuZGFyLnVwZGF0ZVZpZXdTaXplKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BTY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhci50aGF3Q29udGVudEhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnN0YXJ0QmF0Y2hSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5iYXRjaFJlbmRlckRlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUucGF1c2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RvcEJhdGNoUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKC0tdGhpcy5iYXRjaFJlbmRlckRlcHRoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0UmVuZGVyID0gZnVuY3Rpb24gKGZ1bmMsIG5hbWVzcGFjZSwgYWN0aW9uVHlwZSkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyUXVldWUucXVldWUoZnVuYywgbmFtZXNwYWNlLCBhY3Rpb25UeXBlKTtcclxuICAgIH07XHJcbiAgICAvLyBnaXZlbiBmdW5jIHdpbGwgYXV0by1iaW5kIHRvIGB0aGlzYFxyXG4gICAgVmlldy5wcm90b3R5cGUud2hlblNpemVVcGRhdGVkID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJRdWV1ZS5pc1J1bm5pbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5vbmUoJ3N0b3AnLCBmdW5jLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBUaXRsZSBhbmQgRGF0ZSBGb3JtYXR0aW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcclxuICAgIFZpZXcucHJvdG90eXBlLmNvbXB1dGVUaXRsZSA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgLy8gZm9yIHZpZXdzIHRoYXQgc3BhbiBhIGxhcmdlIHVuaXQgb2YgdGltZSwgc2hvdyB0aGUgcHJvcGVyIGludGVydmFsLCBpZ25vcmluZyBzdHJheSBkYXlzIGJlZm9yZSBhbmQgYWZ0ZXJcclxuICAgICAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKSB7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFJhbmdlKHtcclxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuY2FsZW5kYXIubXNUb01vbWVudCh1bnpvbmVkUmFuZ2Uuc3RhcnRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSksXHJcbiAgICAgICAgICAgIGVuZDogdGhpcy5jYWxlbmRhci5tc1RvTW9tZW50KHVuem9uZWRSYW5nZS5lbmRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSlcclxuICAgICAgICB9LCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5LCB0aGlzLm9wdCgndGl0bGVGb3JtYXQnKSB8fCB0aGlzLmNvbXB1dGVUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSksIHRoaXMub3B0KCd0aXRsZVJhbmdlU2VwYXJhdG9yJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cclxuICAgIC8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5jb21wdXRlVGl0bGVGb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgY3VycmVudFJhbmdlVW5pdCA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQ7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnWVlZWSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ21vbnRoWWVhckZvcm1hdCcpOyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmFzKCdkYXlzJykgPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbGwnOyAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdMTCc7IC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEYXRlIFNldHRpbmcvVW5zZXR0aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUuc2V0RGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnREYXRlUHJvZmlsZSA9IHRoaXMuZ2V0KCdkYXRlUHJvZmlsZScpO1xyXG4gICAgICAgIHZhciBuZXdEYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoZGF0ZSwgdW5kZWZpbmVkLCB0cnVlKTsgLy8gZm9yY2VUb1ZhbGlkPXRydWVcclxuICAgICAgICBpZiAoIWN1cnJlbnREYXRlUHJvZmlsZSB8fFxyXG4gICAgICAgICAgICAhY3VycmVudERhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lcXVhbHMobmV3RGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldCgnZGF0ZVByb2ZpbGUnLCBuZXdEYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnVuc2V0RGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdkYXRlUHJvZmlsZScpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERhdGFcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5mZXRjaEluaXRpYWxFdmVudHMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkgJiYgIXRoaXMudXNlc01pbk1heFRpbWU7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnJlcXVlc3RFdmVudHMoY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZm9yY2VBbGxEYXkpLCBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lbmRNcywgZm9yY2VBbGxEYXkpKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kRXZlbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5jYWxlbmRhciwgJ2V2ZW50c1Jlc2V0JywgdGhpcy5yZXNldEV2ZW50cyk7IC8vIFRPRE86IG1ha2UgdGhpcyBhIHJlYWwgZXZlbnRcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bmJpbmRFdmVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5jYWxlbmRhciwgJ2V2ZW50c1Jlc2V0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc2V0RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB0aGlzLnNldCgnY3VycmVudEV2ZW50cycsIGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIHRoaXMuc2V0KCdoYXNFdmVudHMnLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNldEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdjdXJyZW50RXZlbnRzJyk7XHJcbiAgICAgICAgdGhpcy51bnNldCgnaGFzRXZlbnRzJyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVzZXRFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaFJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMudW5zZXRFdmVudHMoKTtcclxuICAgICAgICB0aGlzLnNldEV2ZW50cyhldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB0aGlzLnN0b3BCYXRjaFJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8vIERhdGUgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZURhdGVSZW5kZXIoZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIH0sICdkYXRlJywgJ2luaXQnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RGF0ZVVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZURhdGVVbnJlbmRlcigpO1xyXG4gICAgICAgIH0sICdkYXRlJywgJ2Rlc3Ryb3knKTtcclxuICAgIH07XHJcbiAgICAvLyBpZiBkYXRlUHJvZmlsZSBub3Qgc3BlY2lmaWVkLCB1c2VzIGN1cnJlbnRcclxuICAgIFZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlci5jYWxsKHRoaXMsIGRhdGVQcm9maWxlKTtcclxuICAgICAgICBpZiAodGhpc1sncmVuZGVyJ10pIHtcclxuICAgICAgICAgICAgdGhpc1sncmVuZGVyJ10oKTsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0ZXNSZW5kZXJlZCcpO1xyXG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKHsgaXNEYXRlSW5pdDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLnN0YXJ0Tm93SW5kaWNhdG9yKCk7IC8vIHNob3VsZG4ndCByZW5kZXIgeWV0IGJlY2F1c2UgdXBkYXRlU2l6ZSB3aWxsIGJlIGNhbGxlZCBzb29uXHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuZXhlY3V0ZURhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgdGhpcy5zdG9wTm93SW5kaWNhdG9yKCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6ZGF0ZXNVbnJlbmRlcmVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXNbJ2Rlc3Ryb3knXSkge1xyXG4gICAgICAgICAgICB0aGlzWydkZXN0cm95J10oKTsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVVbnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8vIFwiQmFzZVwiIHJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLmJpbmRCYXNlUmVuZGVySGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLm9uKCdkYXRlc1JlbmRlcmVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy53aGVuU2l6ZVVwZGF0ZWQoX3RoaXMudHJpZ2dlclZpZXdSZW5kZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub24oJ2JlZm9yZTpkYXRlc1VucmVuZGVyZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJWaWV3RGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJWaWV3UmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyVmlld0Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdEZXN0cm95Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RFdmVudHNSZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZUV2ZW50UmVuZGVyKGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgICAgICBfdGhpcy53aGVuU2l6ZVVwZGF0ZWQoX3RoaXMudHJpZ2dlckFmdGVyRXZlbnRzUmVuZGVyZWQpO1xyXG4gICAgICAgIH0sICdldmVudCcsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEV2ZW50c1VucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlckJlZm9yZUV2ZW50c0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgICAgICBfdGhpcy5leGVjdXRlRXZlbnRVbnJlbmRlcigpO1xyXG4gICAgICAgIH0sICdldmVudCcsICdkZXN0cm95Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVzaW5lc3MgSG91ciBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RCdXNpbmVzc0hvdXJzUmVuZGVyID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyQnVzaW5lc3NIb3VycyhidXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgIH0sICdidXNpbmVzc0hvdXJzJywgJ2luaXQnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1VucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5yZW5kZXJCdXNpbmVzc0hvdXJzKCk7XHJcbiAgICAgICAgfSwgJ2J1c2luZXNzSG91cnMnLCAnZGVzdHJveScpO1xyXG4gICAgfTtcclxuICAgIC8vIE1pc2MgdmlldyByZW5kZXJpbmcgdXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBCaW5kcyBET00gaGFuZGxlcnMgdG8gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgdmlldyBjb250YWluZXIsIHN1Y2ggYXMgdGhlIGRvY3VtZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLCB7XHJcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMucHJvY2Vzc1Vuc2VsZWN0LFxyXG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd25cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBVbmJpbmRzIERPTSBoYW5kbGVycyBmcm9tIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyXHJcbiAgICBWaWV3LnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkpO1xyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBJbW1lZGlhdGVseSByZW5kZXIgdGhlIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYW5kIGJlZ2lucyByZS1yZW5kZXJpbmcgaXQgYXQgYW4gaW50ZXJ2YWwsXHJcbiAgICAvLyB3aGljaCBpcyBkZWZpbmVkIGJ5IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpLlxyXG4gICAgLy8gVE9ETzogc29tZWhvdyBkbyB0aGlzIGZvciB0aGUgY3VycmVudCB3aG9sZSBkYXkncyBiYWNrZ3JvdW5kIHRvb1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RhcnROb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdW5pdDtcclxuICAgICAgICB2YXIgdXBkYXRlO1xyXG4gICAgICAgIHZhciBkZWxheTsgLy8gbXMgd2FpdCB2YWx1ZVxyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnbm93SW5kaWNhdG9yJykpIHtcclxuICAgICAgICAgICAgdW5pdCA9IHRoaXMuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xyXG4gICAgICAgICAgICBpZiAodW5pdCkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlID0gdXRpbF8xLnByb3h5KHRoaXMsICd1cGRhdGVOb3dJbmRpY2F0b3InKTsgLy8gYmluZCB0byBgdGhpc2BcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSB0aGlzLmNhbGVuZGFyLmdldE5vdygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gK25ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgaW50ZXJ2YWxcclxuICAgICAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5pbml0aWFsTm93RGF0ZS5jbG9uZSgpLnN0YXJ0T2YodW5pdCkuYWRkKDEsIHVuaXQpIC0gdGhpcy5pbml0aWFsTm93RGF0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9ICttb21lbnQuZHVyYXRpb24oMSwgdW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1heCgxMDAsIGRlbGF5KTsgLy8gcHJldmVudCB0b28gZnJlcXVlbnRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwodXBkYXRlLCBkZWxheSk7IC8vIHVwZGF0ZSBldmVyeSBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbmRlcmluZyB3aWxsIGJlIGluaXRpYXRlZCBpbiB1cGRhdGVTaXplXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHJlcmVuZGVycyB0aGUgbm93IGluZGljYXRvciwgY29tcHV0aW5nIHRoZSBuZXcgY3VycmVudCB0aW1lIGZyb20gdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZFxyXG4gICAgLy8gc2luY2UgdGhlIGluaXRpYWwgZ2V0Tm93IGNhbGwuXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgLy8gYWN0aXZhdGVkIGJlZm9yZT9cclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpOyAvLyB3b24ndCB1bnJlbmRlciBpZiB1bm5lY2Vzc2FyeVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vd0luZGljYXRvcih0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuYWRkKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSAvLyBhZGQgbXNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgdW5yZW5kZXJzIHRoZSB2aWV3J3MgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgc3RvcHMgYW55IHJlLXJlbmRlcmluZyB0aW1lcnMuXHJcbiAgICAvLyBXb24ndCBjYXVzZSBzaWRlIGVmZmVjdHMgaWYgaW5kaWNhdG9yIGlzbid0IHJlbmRlcmVkLlxyXG4gICAgVmlldy5wcm90b3R5cGUuc3RvcE5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3NldEhlaWdodCddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3NldEhlaWdodCddKHRvdGFsSGVpZ2h0LCBpc0F1dG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU5vd0luZGljYXRvcigpO1xyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbGVyXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuYWRkU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIHZhciBxdWV1ZWRTY3JvbGwgPSB0aGlzLnF1ZXVlZFNjcm9sbCB8fCAodGhpcy5xdWV1ZWRTY3JvbGwgPSB7fSk7XHJcbiAgICAgICAgJC5leHRlbmQocXVldWVkU2Nyb2xsLCBzY3JvbGwpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnBvcFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFwcGx5UXVldWVkU2Nyb2xsKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZWRTY3JvbGwgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5UXVldWVkU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZFNjcm9sbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U2Nyb2xsKHRoaXMucXVldWVkU2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucXVlcnlTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbCA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMucXVlcnlEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Nyb2xsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5U2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwuaXNEYXRlSW5pdCAmJiB0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBseURhdGVTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgOyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZy1uLURyb3BcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFdmVudERyb3AgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbiwgZWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB1bmRvRnVuYyA9IGV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnRJbnN0YW5jZS5kZWYuaWQsIGV2ZW50TXV0YXRpb24sIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb24gPSBldmVudE11dGF0aW9uLmRhdGVNdXRhdGlvbjtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIEV2ZW50SW5zdGFuY2UsIGZvciBoYW5kbGVyc1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSA9IGRhdGVNdXRhdGlvbi5idWlsZE5ld0RhdGVQcm9maWxlKGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUsIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudERyb3AoZXZlbnRJbnN0YW5jZSwgXHJcbiAgICAgICAgLy8gYSBkcm9wIGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiBhIGRhdGUgbXV0YXRpb24gKGV4OiByZXNvdXJjZSBjaGFuZ2UpXHJcbiAgICAgICAgKGRhdGVNdXRhdGlvbiAmJiBkYXRlTXV0YXRpb24uZGF0ZURlbHRhKSB8fCBtb21lbnQuZHVyYXRpb24oKSwgdW5kb0Z1bmMsIGVsLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgZXZlbnQtZHJvcCBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckV2ZW50RHJvcCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBkYXRlRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcm9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBlbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZURlbHRhLFxyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmMsXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogRXh0ZXJuYWwgRWxlbWVudCBEcmFnLW4tRHJvcFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXh0ZXJuYWwgZWxlbWVudCwgdmlhIGpRdWVyeSBVSSwgaGFzIGJlZW4gZHJvcHBlZCBvbnRvIHRoZSBjYWxlbmRhci5cclxuICAgIC8vIGBtZXRhYCBpcyB0aGUgcGFyc2VkIGRhdGEgdGhhdCBoYXMgYmVlbiBlbWJlZGRlZCBpbnRvIHRoZSBkcmFnZ2luZyBldmVudC5cclxuICAgIC8vIGBkcm9wTG9jYXRpb25gIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgem9uZWQgc3RhcnQvZW5kL2FsbERheSB2YWx1ZXMgZm9yIHRoZSBldmVudC5cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydEV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChzaW5nbGVFdmVudERlZiwgaXNFdmVudCwgaXNTdGlja3ksIGVsLCBldiwgdWkpIHtcclxuICAgICAgICBpZiAoaXNFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLmV2ZW50TWFuYWdlci5hZGRFdmVudERlZihzaW5nbGVFdmVudERlZiwgaXNTdGlja3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXJFeHRlcm5hbERyb3Aoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGVsLCBldiwgdWkpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV4dGVybmFsLWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJFeHRlcm5hbERyb3AgPSBmdW5jdGlvbiAoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGVsLCBldiwgdWkpIHtcclxuICAgICAgICAvLyB0cmlnZ2VyICdkcm9wJyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgZWxlbWVudCByZXByZXNlbnRzIGFuIGV2ZW50XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2Ryb3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZi5kYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB1aSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpc0V2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHNpZ25hbCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYuYnVpbGRJbnN0YW5jZSgpLnRvTGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVzaXppbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGluIHRoZSB2aWV3IGhhcyBiZWVuIHJlc2l6ZWQgdG8gYSBuZXcgbGVuZ3RoXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBldmVudE11dGF0aW9uLCBlbCwgZXYpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5jYWxlbmRhci5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHVuZG9GdW5jID0gZXZlbnRNYW5hZ2VyLm11dGF0ZUV2ZW50c1dpdGhJZChldmVudEluc3RhbmNlLmRlZi5pZCwgZXZlbnRNdXRhdGlvbiwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBFdmVudEluc3RhbmNlLCBmb3IgaGFuZGxlcnNcclxuICAgICAgICBldmVudEluc3RhbmNlLmRhdGVQcm9maWxlID0gZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudFJlc2l6ZShldmVudEluc3RhbmNlLCBldmVudE11dGF0aW9uLmRhdGVNdXRhdGlvbi5lbmREZWx0YSwgdW5kb0Z1bmMsIGVsLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgZXZlbnQtcmVzaXplIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZHVyYXRpb25EZWx0YSwgdW5kb0Z1bmMsIGVsLCBldikge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uRGVsdGEsXHJcbiAgICAgICAgICAgICAgICB1bmRvRnVuYyxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiBTZWxlY3Rpb24gKHRpbWUgcmFuZ2UpXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gU2VsZWN0cyBhIGRhdGUgc3BhbiBvbiB0aGUgdmlldy4gYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIGJvdGggTW9tZW50cy5cclxuICAgIC8vIGBldmAgaXMgdGhlIG5hdGl2ZSBtb3VzZSBldmVudCB0aGF0IGJlZ2luIHRoZSBpbnRlcmFjdGlvbi5cclxuICAgIFZpZXcucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGV2KSB7XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdChldik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoZm9vdHByaW50KTtcclxuICAgICAgICB0aGlzLnJlcG9ydFNlbGVjdGlvbihmb290cHJpbnQsIGV2KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoZm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3JlbmRlclNlbGVjdGlvbiddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlclNlbGVjdGlvbiddKGZvb3RwcmludC50b0xlZ2FjeSh0aGlzLmNhbGVuZGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludC5jYWxsKHRoaXMsIGZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBtYWRlLiBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJTZWxlY3QoZm9vdHByaW50LCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgaGFuZGxlcnMgdG8gJ3NlbGVjdCdcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJTZWxlY3QgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY2FsZW5kYXIuZm9vdHByaW50VG9EYXRlUHJvZmlsZShmb290cHJpbnQpOyAvLyBhYnVzZSBvZiBcIkV2ZW50XCJEYXRlUHJvZmlsZT9cclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignc2VsZWN0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZS5zdGFydCxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLmVuZCxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5kb2VzIGEgc2VsZWN0aW9uLiB1cGRhdGVzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXHJcbiAgICAvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdhbiB0aGUgaW50ZXJhY3Rpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmIChldiA9PT0gdm9pZCAwKSB7IGV2ID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzWydkZXN0cm95U2VsZWN0aW9uJ10pIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbJ2Rlc3Ryb3lTZWxlY3Rpb24nXSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVucmVuZGVyU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd1bnNlbGVjdCcsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbZXYsIHRoaXNdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZWxlY3RFdmVudEluc3RhbmNlID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlICE9PSBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RFdmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlID09PSBldmVudEluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlID0gZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZWxlY3RFdmVudEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuaXNFdmVudERlZlNlbGVjdGVkID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgLy8gZXZlbnQgcmVmZXJlbmNlcyBtaWdodCBjaGFuZ2Ugb24gcmVmZXRjaEV2ZW50cygpLCB3aGlsZSBzZWxlY3RlZEV2ZW50SW5zdGFuY2UgZG9lc24ndCxcclxuICAgICAgICAvLyBzbyBjb21wYXJlIElEc1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSAmJiB0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZS5kZWYuaWQgPT09IGV2ZW50RGVmLmlkO1xyXG4gICAgfTtcclxuICAgIC8qIE1vdXNlIC8gVG91Y2ggVW5zZWxlY3RpbmcgKHRpbWUgcmFuZ2UgJiBldmVudCB1bnNlbGVjdGlvbilcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBUT0RPOiBtb3ZlIGNvbnNpc3RlbnRseSB0byBkb3duL3N0YXJ0IG9yIHVwL2VuZD9cclxuICAgIC8vIFRPRE86IGRvbid0IGtpbGwgcHJldmlvdXMgc2VsZWN0aW9uIGlmIHRvdWNoIHNjcm9sbGluZ1xyXG4gICAgVmlldy5wcm90b3R5cGUuaGFuZGxlRG9jdW1lbnRNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodXRpbF8xLmlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NVbnNlbGVjdChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnByb2Nlc3NVbnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1JhbmdlVW5zZWxlY3QoZXYpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50VW5zZWxlY3QoZXYpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnByb2Nlc3NSYW5nZVVuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGlnbm9yZTtcclxuICAgICAgICAvLyBpcyB0aGVyZSBhIHRpbWUtcmFuZ2Ugc2VsZWN0aW9uP1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQgJiYgdGhpcy5vcHQoJ3Vuc2VsZWN0QXV0bycpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgdW5zZWxlY3QgaWYgdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBub3QgaWRlbnRpY2FsIHRvIG9yIGluc2lkZSBvZiBhbiAndW5zZWxlY3RDYW5jZWwnIGVsZW1lbnRcclxuICAgICAgICAgICAgaWdub3JlID0gdGhpcy5vcHQoJ3Vuc2VsZWN0Q2FuY2VsJyk7XHJcbiAgICAgICAgICAgIGlmICghaWdub3JlIHx8ICEkKGV2LnRhcmdldCkuY2xvc2VzdChpZ25vcmUpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bnNlbGVjdChldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucHJvY2Vzc0V2ZW50VW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnLmZjLXNlbGVjdGVkJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0RXZlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFRyaWdnZXJzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckJhc2VSZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1JlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckJhc2VVbnJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3RGVzdHJveScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgaGFuZGxlcnMgdG8gJ2RheUNsaWNrJ1xyXG4gICAgLy8gU3BhbiBoYXMgc3RhcnQvZW5kIG9mIHRoZSBjbGlja2VkIGFyZWEuIE9ubHkgdGhlIHN0YXJ0IGlzIHVzZWZ1bC5cclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJEYXlDbGljayA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGRheUVsLCBldikge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY2FsZW5kYXIuZm9vdHByaW50VG9EYXRlUHJvZmlsZShmb290cHJpbnQpOyAvLyBhYnVzZSBvZiBcIkV2ZW50XCJEYXRlUHJvZmlsZT9cclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5Q2xpY2snLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGRheUVsLFxyXG4gICAgICAgICAgICBhcmdzOiBbZGF0ZVByb2ZpbGUuc3RhcnQsIGV2LCB0aGlzXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgVXRpbHNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBGb3IgRGF0ZUNvbXBvbmVudDo6Z2V0RGF5Q2xhc3Nlc1xyXG4gICAgVmlldy5wcm90b3R5cGUuaXNEYXRlSW5PdGhlck1vbnRoID0gZnVuY3Rpb24gKGRhdGUsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIEFyZ3VtZW50cyBhZnRlciBuYW1lIHdpbGwgYmUgZm9yd2FyZGVkIHRvIGEgaHlwb3RoZXRpY2FsIGZ1bmN0aW9uIHZhbHVlXHJcbiAgICAvLyBXQVJOSU5HOiBwYXNzZWQtaW4gYXJndW1lbnRzIHdpbGwgYmUgZ2l2ZW4gdG8gZ2VuZXJhdG9yIGZ1bmN0aW9ucyBhcy1pcyBhbmQgY2FuIGNhdXNlIHNpZGUtZWZmZWN0cy5cclxuICAgIC8vIEFsd2F5cyBjbG9uZSB5b3VyIG9iamVjdHMgaWYgeW91IGZlYXIgbXV0YXRpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS5nZXRVbnpvbmVkUmFuZ2VPcHRpb24gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLm9wdChuYW1lKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YWwgPSB2YWwuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIucGFyc2VVbnpvbmVkUmFuZ2UodmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogSGlkZGVuIERheXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pbml0SGlkZGVuRGF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGlkZGVuRGF5cyA9IHRoaXMub3B0KCdoaWRkZW5EYXlzJykgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXHJcbiAgICAgICAgdmFyIGlzSGlkZGVuRGF5SGFzaCA9IFtdOyAvLyBpcyB0aGUgZGF5LW9mLXdlZWsgaGlkZGVuPyAoaGFzaCB3aXRoIGRheS1vZi13ZWVrLWluZGV4IC0+IGJvb2wpXHJcbiAgICAgICAgdmFyIGRheUNudCA9IDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCd3ZWVrZW5kcycpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBoaWRkZW5EYXlzLnB1c2goMCwgNik7IC8vIDA9c3VuZGF5LCA2PXNhdHVyZGF5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCEoaXNIaWRkZW5EYXlIYXNoW2ldID0gJC5pbkFycmF5KGksIGhpZGRlbkRheXMpICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIGRheUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZGF5Q250KSB7XHJcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGhpZGRlbkRheXMnOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaDtcclxuICAgIH07XHJcbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxyXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKGlucHV0VW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5wdXRVbnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgZW5kID0gaW5wdXRVbnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5za2lwSGlkZGVuRGF5cyhlbmQsIC0xLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XHJcbiAgICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIE1vbWVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuaXNIaWRkZW5EYXkgPSBmdW5jdGlvbiAoZGF5KSB7XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChkYXkpKSB7XHJcbiAgICAgICAgICAgIGRheSA9IGRheS5kYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XHJcbiAgICB9O1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxyXG4gICAgLy8gRE9FUyBOT1QgQ09OU0lERVIgdmFsaWRVbnpvbmVkUmFuZ2UhXHJcbiAgICAvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxyXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcclxuICAgIFZpZXcucHJvdG90eXBlLnNraXBIaWRkZW5EYXlzID0gZnVuY3Rpb24gKGRhdGUsIGluYywgaXNFeGNsdXNpdmUpIHtcclxuICAgICAgICBpZiAoaW5jID09PSB2b2lkIDApIHsgaW5jID0gMTsgfVxyXG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdm9pZCAwKSB7IGlzRXhjbHVzaXZlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgb3V0ID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsob3V0LmRheSgpICsgKGlzRXhjbHVzaXZlID8gaW5jIDogMCkgKyA3KSAlIDddKSB7XHJcbiAgICAgICAgICAgIG91dC5hZGQoaW5jLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3O1xyXG59KEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVmlldztcclxuVmlldy5wcm90b3R5cGUudXNlc01pbk1heFRpbWUgPSBmYWxzZTtcclxuVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IERhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0RhdGVzJywgWydpc0luRG9tJywgJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnJlcXVlc3REYXRlUmVuZGVyKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3REYXRlVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2Rpc3BsYXlpbmdCdXNpbmVzc0hvdXJzJywgWydkaXNwbGF5aW5nRGF0ZXMnLCAnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RCdXNpbmVzc0hvdXJzUmVuZGVyKGRlcHMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1VucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdpbml0aWFsRXZlbnRzJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hJbml0aWFsRXZlbnRzKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG59KTtcclxuVmlldy53YXRjaCgnYmluZGluZ0V2ZW50cycsIFsnaW5pdGlhbEV2ZW50cyddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgdGhpcy5zZXRFdmVudHMoZGVwcy5pbml0aWFsRXZlbnRzKTtcclxuICAgIHRoaXMuYmluZEV2ZW50Q2hhbmdlcygpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnVuYmluZEV2ZW50Q2hhbmdlcygpO1xyXG4gICAgdGhpcy51bnNldEV2ZW50cygpO1xyXG59KTtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0V2ZW50cycsIFsnZGlzcGxheWluZ0RhdGVzJywgJ2hhc0V2ZW50cyddLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RFdmVudHNSZW5kZXIodGhpcy5nZXQoJ2N1cnJlbnRFdmVudHMnKSk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdEV2ZW50c1VucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCd0aXRsZScsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHJldHVybiAodGhpcy50aXRsZSA9IHRoaXMuY29tcHV0ZVRpdGxlKGRlcHMuZGF0ZVByb2ZpbGUpKTsgLy8gYXNzaWduIHRvIFZpZXcgZm9yIGxlZ2FjeSByZWFzb25zXHJcbn0pO1xyXG5WaWV3LndhdGNoKCdsZWdhY3lEYXRlUHJvcHMnLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgdmFyIGRhdGVQcm9maWxlID0gZGVwcy5kYXRlUHJvZmlsZTtcclxuICAgIC8vIERFUFJFQ0FURUQsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXQgdXBkYXRlZC4uLlxyXG4gICAgdGhpcy5zdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLnN0YXJ0TXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgdGhpcy5lbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5lbmRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmludGVydmFsU3RhcnQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmludGVydmFsRW5kID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxufSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudFJlbmRlcmVyKGNvbXBvbmVudCwgZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIgPSBmaWxsUmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcub3B0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdmFsdWVzIHRoYXQgcmVseSBvbiBvcHRpb25zIGFuZCBhbHNvIHJlbGF0ZSB0byByYW5nZVxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmFuZ2VVcGRhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaXNwbGF5RXZlbnRUaW1lO1xyXG4gICAgICAgIHZhciBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgdGhpcy5ldmVudFRpbWVGb3JtYXQgPVxyXG4gICAgICAgICAgICB0aGlzLm9wdCgnZXZlbnRUaW1lRm9ybWF0JykgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0KCd0aW1lRm9ybWF0JykgfHwgLy8gZGVwcmVjYXRlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRXZlbnRUaW1lRm9ybWF0KCk7XHJcbiAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IHRoaXMub3B0KCdkaXNwbGF5RXZlbnRUaW1lJyk7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50VGltZSgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gdGhpcy5vcHQoJ2Rpc3BsYXlFdmVudEVuZCcpO1xyXG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlzcGxheUV2ZW50VGltZSA9IGRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5RXZlbnRFbmQgPSBkaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmNvbXBvbmVudC5fZ2V0RGF0ZVByb2ZpbGUoKTtcclxuICAgICAgICB2YXIgZXZlbnREZWZJZDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VHcm91cDtcclxuICAgICAgICB2YXIgZXZlbnRSYW5nZXM7XHJcbiAgICAgICAgdmFyIGJnUmFuZ2VzID0gW107XHJcbiAgICAgICAgdmFyIGZnUmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChldmVudERlZklkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2VHcm91cCA9IGV2ZW50c1BheWxvYWRbZXZlbnREZWZJZF07XHJcbiAgICAgICAgICAgIGV2ZW50UmFuZ2VzID0gaW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpLmhhc0JnUmVuZGVyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgIGJnUmFuZ2VzLnB1c2guYXBwbHkoYmdSYW5nZXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZnUmFuZ2VzLnB1c2guYXBwbHkoZmdSYW5nZXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckJnUmFuZ2VzKGJnUmFuZ2VzKTtcclxuICAgICAgICB0aGlzLnJlbmRlckZnUmFuZ2VzKGZnUmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQmdSYW5nZXMoKTtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRmdSYW5nZXMoKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1JhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIC8vIHJlbmRlciBhbiBgLmVsYCBvbiBlYWNoIHNlZ1xyXG4gICAgICAgIC8vIHJldHVybnMgYSBzdWJzZXQgb2YgdGhlIHNlZ3MuIHNlZ3MgdGhhdCB3ZXJlIGFjdHVhbGx5IHJlbmRlcmVkXHJcbiAgICAgICAgc2VncyA9IHRoaXMucmVuZGVyRmdTZWdFbHMoc2Vncyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyRmdTZWdzKHNlZ3MpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZnU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckZnU2Vncyh0aGlzLmZnU2VncyB8fCBbXSk7XHJcbiAgICAgICAgdGhpcy5mZ1NlZ3MgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyQmdTZWdzKHNlZ3MpICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJnU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyQmdSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckJnU2VncygpO1xyXG4gICAgICAgIHRoaXMuYmdTZWdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iZ1NlZ3MgfHwgW10pLmNvbmNhdCh0aGlzLmZnU2VncyB8fCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIHNlZ3MgYWxyZWFkeSBoYXMgcmVuZGVyZWQgZWxzLCBhbmQgaGFzIGJlZW4gZmlsdGVyZWQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaWduYWwgZmFpbHVyZSBpZiBub3QgaW1wbGVtZW50ZWRcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYWxsIGN1cnJlbnRseSByZW5kZXJlZCBmb3JlZ3JvdW5kIHNlZ21lbnRzXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYmdFdmVudCcsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0QmdDbGFzc2VzKHNlZy5mb290cHJpbnQuZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldENzczogZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogX3RoaXMuZ2V0QmdDb2xvcihzZWcuZm9vdHByaW50LmV2ZW50RGVmKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyRWw6IGZ1bmN0aW9uIChzZWcsIGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbHRlckV2ZW50UmVuZGVyRWwoc2VnLmZvb3RwcmludCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gc2lnbmFsIGZhaWx1cmUgaWYgbm8gZmlsbFJlbmRlcmVyXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyQmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignYmdFdmVudCcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LlxyXG4gICAgLy8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdFbHMgPSBmdW5jdGlvbiAoc2VncywgZGlzYWJsZVJlc2l6aW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZGlzYWJsZVJlc2l6aW5nID09PSB2b2lkIDApIHsgZGlzYWJsZVJlc2l6aW5nID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgaGFzRXZlbnRSZW5kZXJIYW5kbGVycyA9IHRoaXMudmlldy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRSZW5kZXInKTtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIGV2ZW50IHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iZWZvcmVGZ1NlZ0h0bWwoc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRoaXMuZmdTZWdIdG1sKHNlZ3NbaV0sIGRpc2FibGVSZXNpemluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC4gQW4gZWwgbWlnaHQgYmUgbnVsbCBpZiB0aGUgZXZlbnRSZW5kZXIgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UuXHJcbiAgICAgICAgICAgICQoaHRtbCkuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0V2ZW50UmVuZGVySGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9IF90aGlzLmZpbHRlckV2ZW50UmVuZGVyRWwoc2VnLmZvb3RwcmludCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuZGF0YSgnZmMtc2VnJywgc2VnKTsgLy8gdXNlZCBieSBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRTZWdzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJlZm9yZUZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBkZWZhdWx0IHJlbmRlcmluZyBvZiBhIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudC4gVXNlZCBieSByZW5kZXJGZ1NlZ0VscygpXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmljIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgdGhlIEhUTUwgY2xhc3NOYW1lcyBmb3IgYW4gZXZlbnQgc2VnbWVudCdzIGVsZW1lbnRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ0NsYXNzZXMgPSBmdW5jdGlvbiAoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGUpIHtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLWV2ZW50JyxcclxuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPyAnZmMtc3RhcnQnIDogJ2ZjLW5vdC1zdGFydCcsXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCA/ICdmYy1lbmQnIDogJ2ZjLW5vdC1lbmQnXHJcbiAgICAgICAgXS5jb25jYXQodGhpcy5nZXRDbGFzc2VzKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKTtcclxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1kcmFnZ2FibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmVzaXphYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV2ZW50IGlzIGN1cnJlbnRseSBzZWxlY3RlZD8gYXR0YWNoIGEgY2xhc3NOYW1lLlxyXG4gICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlNlbGVjdGVkKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQgYW5kIHRoZSBkZWZhdWx0IGVsZW1lbnQgdXNlZCBmb3IgcmVuZGVyaW5nLCByZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGFjdHVhbGx5IGJlIHVzZWQuXHJcbiAgICAvLyBCYXNpY2FsbHkgcnVucyBldmVudHMgYW5kIGVsZW1lbnRzIHRocm91Z2ggdGhlIGV2ZW50UmVuZGVyIGhvb2suXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5maWx0ZXJFdmVudFJlbmRlckVsID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50LCBlbCkge1xyXG4gICAgICAgIHZhciBsZWdhY3kgPSBldmVudEZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpO1xyXG4gICAgICAgIHZhciBjdXN0b20gPSB0aGlzLnZpZXcucHVibGljbHlUcmlnZ2VyKCdldmVudFJlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogbGVnYWN5LFxyXG4gICAgICAgICAgICBhcmdzOiBbbGVnYWN5LCBlbCwgdGhpcy52aWV3XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjdXN0b20gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VzdG9tICYmIGN1c3RvbSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBlbCA9ICQoY3VzdG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIG9uIGFuIGV2ZW50J3MgZWxlbWVudC5cclxuICAgIC8vIGByYW5nZWAgY2FuIGJlIHRoZSBFdmVudCBvYmplY3QgaXRzZWxmLCBvciBzb21ldGhpbmcgcmFuZ2UtbGlrZSwgd2l0aCBhdCBsZWFzdCBhIGBzdGFydGAuXHJcbiAgICAvLyBJZiBldmVudCB0aW1lcyBhcmUgZGlzYWJsZWQsIG9yIHRoZSBldmVudCBoYXMgbm8gdGltZSwgd2lsbCByZXR1cm4gYSBibGFuayBzdHJpbmcuXHJcbiAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBmb3JtYXRTdHIgd2lsbCBkZWZhdWx0IHRvIHRoZSBldmVudFRpbWVGb3JtYXQgc2V0dGluZyxcclxuICAgIC8vIGFuZCBkaXNwbGF5RW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgZGlzcGxheUV2ZW50RW5kIHNldHRpbmcuXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaW1lVGV4dCA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludCwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRpbWVUZXh0KGV2ZW50Rm9vdHByaW50LmV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUuc3RhcnQsIGV2ZW50Rm9vdHByaW50LmV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUuZW5kLCBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXksIGZvcm1hdFN0ciwgZGlzcGxheUVuZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuX2dldFRpbWVUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGlzQWxsRGF5LCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcclxuICAgICAgICBpZiAoZm9ybWF0U3RyID09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9ybWF0U3RyID0gdGhpcy5ldmVudFRpbWVGb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUVuZCA9IHRoaXMuZGlzcGxheUV2ZW50RW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5RXZlbnRUaW1lICYmICFpc0FsbERheSkge1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUVuZCAmJiBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXcuZm9ybWF0UmFuZ2UoeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0sIGZhbHNlLCAvLyBhbGxEYXlcclxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQuZm9ybWF0KGZvcm1hdFN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50VGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJnQ2xhc3NlcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5nZXRDbGFzc2VzKGV2ZW50RGVmKTtcclxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWJnZXZlbnQnKTtcclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRDbGFzc2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaC5hcHBseSgvLyBhcHBlbmRcclxuICAgICAgICAgICAgY2xhc3NOYW1lcywgb2Jqc1tpXS5ldmVudENsYXNzTmFtZSB8fCBvYmpzW2ldLmNsYXNzTmFtZSB8fCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgZXZlbnQgc2tpbi1yZWxhdGVkIENTUyBwcm9wZXJ0aWVzXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTa2luQ3NzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiB0aGlzLmdldEJnQ29sb3IoZXZlbnREZWYpLFxyXG4gICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogdGhpcy5nZXRCb3JkZXJDb2xvcihldmVudERlZiksXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmdldFRleHRDb2xvcihldmVudERlZilcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRCZ0NvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudEJhY2tncm91bmRDb2xvciB8fCBvYmpzW2ldLmV2ZW50Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0uYmFja2dyb3VuZENvbG9yIHx8IG9ianNbaV0uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudEJhY2tncm91bmRDb2xvcicpIHx8IHRoaXMub3B0KCdldmVudENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJvcmRlckNvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudEJvcmRlckNvbG9yIHx8IG9ianNbaV0uZXZlbnRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS5ib3JkZXJDb2xvciB8fCBvYmpzW2ldLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRCb3JkZXJDb2xvcicpIHx8IHRoaXMub3B0KCdldmVudENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFRleHRDb2xvciA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGggJiYgIXZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG9ianNbaV0uZXZlbnRUZXh0Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0udGV4dENvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRUZXh0Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRTdHlsaW5nT2JqcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRGYWxsYmFja1N0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICBvYmpzLnVuc2hpZnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHJldHVybiBvYmpzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEZhbGxiYWNrU3R5bGluZ09ianMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gW2V2ZW50RGVmLnNvdXJjZV07XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuc29ydEV2ZW50U2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgc2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUV2ZW50U2VncycpKTtcclxuICAgIH07XHJcbiAgICAvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggc2VnbWVudHMgc2hvdWxkIHRha2UgdmlzdWFsIHByaW9yaXR5XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRXZlbnRTZWdzID0gZnVuY3Rpb24gKHNlZzEsIHNlZzIpIHtcclxuICAgICAgICB2YXIgZjEgPSBzZWcxLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIHIxID0gZjEudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBmMiA9IHNlZzIuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgcjIgPSBmMi51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgcmV0dXJuIHIxLnN0YXJ0TXMgLSByMi5zdGFydE1zIHx8IC8vIGVhcmxpZXIgZXZlbnRzIGdvIGZpcnN0XHJcbiAgICAgICAgICAgIChyMi5lbmRNcyAtIHIyLnN0YXJ0TXMpIC0gKHIxLmVuZE1zIC0gcjEuc3RhcnRNcykgfHwgLy8gdGllPyBsb25nZXIgZXZlbnRzIGdvIGZpcnN0XHJcbiAgICAgICAgICAgIGYyLmlzQWxsRGF5IC0gZjEuaXNBbGxEYXkgfHwgLy8gdGllPyBwdXQgYWxsLWRheSBldmVudHMgZmlyc3QgKGJvb2xlYW5zIGNhc3QgdG8gMC8xKVxyXG4gICAgICAgICAgICB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcyhzZWcxLmZvb3RwcmludC5ldmVudERlZiwgc2VnMi5mb290cHJpbnQuZXZlbnREZWYsIHRoaXMudmlldy5ldmVudE9yZGVyU3BlY3MpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJlbmRlcmVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIENsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1vZGVsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9kZWwoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fd2F0Y2hlcnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5fcHJvcHMgPSB7fTtcclxuICAgICAgICBfdGhpcy5hcHBseUdsb2JhbFdhdGNoZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuY29uc3RydWN0ZWQoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyB1c2VmdWwgZm9yIG1vbmtleXBhdGNoaW5nLiBUT0RPOiBCYXNlQ2xhc3M/XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFwcGx5R2xvYmFsV2F0Y2hlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX2dsb2JhbFdhdGNoQXJncztcclxuICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gbWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2F0Y2guYXBwbHkodGhpcywgW25hbWVdLmNvbmNhdChtYXBbbmFtZV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGhpcy5fcHJvcHM7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIHZhciBuZXdQcm9wcztcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW25hbWVdID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmV3UHJvcHMgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFByb3BzKG5ld1Byb3BzKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAobmV3UHJvcHMpIHtcclxuICAgICAgICB2YXIgb2xkUHJvcHMgPSB0aGlzLl9wcm9wcztcclxuICAgICAgICB2YXIgY2hhbmdlc2V0ID0ge307IC8vIHdpbGwgaGF2ZSB1bmRlZmluZWQncyB0byBzaWduYWwgdW5zZXRzXHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZXNldFtuYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZXNldFtuYW1lXSA9IG5ld1Byb3BzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFByb3BzKGNoYW5nZXNldCk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbmFtZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBuYW1lcyA9IFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5hbWVzID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW25hbWVzW2ldXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhuZXdQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIGNoYW5nZWRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBjaGFuZ2VkQ250ID0gMDtcclxuICAgICAgICB2YXIgbmFtZSwgdmFsO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICB2YWwgPSBuZXdQcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgLy8gYSBjaGFuZ2UgaW4gdmFsdWU/XHJcbiAgICAgICAgICAgIC8vIGlmIGFuIG9iamVjdCwgZG9uJ3QgY2hlY2sgZXF1YWxpdHksIGJlY2F1c2UgbWlnaHQgaGF2ZSBiZWVuIG11dGF0ZWQgaW50ZXJuYWxseS5cclxuICAgICAgICAgICAgLy8gVE9ETzogZXZlbnR1YWxseSBlbmZvcmNlIGltbXV0YWJpbGl0eS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgICAgICAgICB2YWwgIT09IHRoaXMuX3Byb3BzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUHJvcHNbbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZWRDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6YmF0Y2hDaGFuZ2UnLCBjaGFuZ2VkUHJvcHMpO1xyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gY2hhbmdlZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZTpjaGFuZ2UnLCBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlOicgKyBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBjaGFuZ2VkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGNoYW5nZWRQcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW25hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6JyArIG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiYXRjaENoYW5nZScsIGNoYW5nZWRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChuYW1lLCBkZXBMaXN0LCBzdGFydEZ1bmMsIHN0b3BGdW5jKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnVud2F0Y2gobmFtZSk7XHJcbiAgICAgICAgdGhpcy5fd2F0Y2hlcnNbbmFtZV0gPSB0aGlzLl93YXRjaERlcHMoZGVwTGlzdCwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgdmFyIHJlcyA9IHN0YXJ0RnVuYy5jYWxsKF90aGlzLCBkZXBzKTtcclxuICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMudGhlbikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudW5zZXQobmFtZSk7IC8vIHB1dCBpbiBhbiB1bnNldCBzdGF0ZSB3aGlsZSByZXNvbHZpbmdcclxuICAgICAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXQobmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0KG5hbWUsIHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBfdGhpcy51bnNldChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHN0b3BGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICBzdG9wRnVuYy5jYWxsKF90aGlzLCBkZXBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXJzW25hbWVdO1xyXG4gICAgICAgIGlmICh3YXRjaGVyKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuX3dhdGNoRGVwcyA9IGZ1bmN0aW9uIChkZXBMaXN0LCBzdGFydEZ1bmMsIHN0b3BGdW5jKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcXVldWVkQ2hhbmdlQ250ID0gMDtcclxuICAgICAgICB2YXIgZGVwQ250ID0gZGVwTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHNhdGlzZnlDbnQgPSAwO1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSB7fTsgLy8gd2hhdCdzIHBhc3NlZCBhcyB0aGUgYGRlcHNgIGFyZ3VtZW50c1xyXG4gICAgICAgIHZhciBiaW5kVHVwbGVzID0gW107IC8vIGFycmF5IG9mIFsgZXZlbnROYW1lLCBoYW5kbGVyRnVuYyBdIGFycmF5c1xyXG4gICAgICAgIHZhciBpc0NhbGxpbmdTdG9wID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG9uQmVmb3JlRGVwQ2hhbmdlID0gZnVuY3Rpb24gKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICBxdWV1ZWRDaGFuZ2VDbnQrKztcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZENoYW5nZUNudCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FsbGluZ1N0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgb25EZXBDaGFuZ2UgPSBmdW5jdGlvbiAoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHNldD9cclxuICAgICAgICAgICAgICAgIGlmICghaXNPcHRpb25hbCAmJiB2YWx1ZXNbZGVwTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNbZGVwTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBkZXBlbmRlbmN5IHRoYXQgd2FzIHByZXZpb3VzbHkgdW5zZXQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3B0aW9uYWwgJiYgdmFsdWVzW2RlcE5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzYXRpc2Z5Q250Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbZGVwTmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcXVldWVkQ2hhbmdlQ250LS07XHJcbiAgICAgICAgICAgIGlmICghcXVldWVkQ2hhbmdlQ250KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3cgZmluYWxseSBzYXRpc2ZpZWQgb3Igc2F0aXNmaWVkIGFsbCBhbG9uZz9cclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RvcEZ1bmMgaW5pdGlhdGVkIGFub3RoZXIgdmFsdWUgY2hhbmdlLCBpZ25vcmUgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2lsbCBiZSBwcm9jZXNzZWQgYnkgYW5vdGhlciBjaGFuZ2UgZXZlbnQgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDYWxsaW5nU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEZ1bmModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGludGVyY2VwdCBmb3IgLm9uKCkgdGhhdCByZW1lbWJlcnMgaGFuZGxlcnNcclxuICAgICAgICB2YXIgYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgYmluZFR1cGxlcy5wdXNoKFtldmVudE5hbWUsIGhhbmRsZXJdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGxpc3RlbiB0byBkZXBlbmRlbmN5IGNoYW5nZXNcclxuICAgICAgICBkZXBMaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlcE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGRlcE5hbWUuY2hhckF0KDApID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBkZXBOYW1lLnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJpbmQoJ2JlZm9yZTpjaGFuZ2U6JyArIGRlcE5hbWUsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIG9uQmVmb3JlRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBiaW5kKCdjaGFuZ2U6JyArIGRlcE5hbWUsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIG9uRGVwQ2hhbmdlKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHByb2Nlc3MgY3VycmVudCBkZXBlbmRlbmN5IHZhbHVlc1xyXG4gICAgICAgIGRlcExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVwTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZGVwTmFtZS5jaGFyQXQoMCkgPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IGRlcE5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKF90aGlzLmhhcyhkZXBOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzW2RlcE5hbWVdID0gX3RoaXMuZ2V0KGRlcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGluaXRpYWxseSBzYXRpc2ZpZWRcclxuICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0RnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0ZWFyZG93bjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5kVHVwbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGJpbmRUdXBsZXNbaV1bMF0sIGJpbmRUdXBsZXNbaV1bMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYmluZFR1cGxlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyB3YXMgc2F0aXNmaWVkLCBzbyBjYWxsIHN0b3BGdW5jXHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEZ1bmMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmxhc2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZmxhc2ggPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlcnNbbmFtZV07XHJcbiAgICAgICAgaWYgKHdhdGNoZXIpIHtcclxuICAgICAgICAgICAgd2F0Y2hlci5mbGFzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBtYWtlIGEgbWFza2VkLWNvcHkgb2YgdGhlIHN1cGVyY2xhc3MncyBtYXBcclxuICAgICAgICAvLyBUT0RPOiB3cml0ZSB0ZXN0XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX2dsb2JhbFdhdGNoQXJncycpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fZ2xvYmFsV2F0Y2hBcmdzW25hbWVdID0gYXJncztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9kZWw7XHJcbn0oQ2xhc3NfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGVsO1xyXG5Nb2RlbC5wcm90b3R5cGUuX2dsb2JhbFdhdGNoQXJncyA9IHt9OyAvLyBtdXRhdGlvbiBwcm90ZWN0aW9uIGluIE1vZGVsLndhdGNoXHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhNb2RlbCk7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW9kZWwpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChldmVudElucHV0LCBzb3VyY2UpIHtcclxuICAgICAgICBpZiAodXRpbF8xLmlzVGltZVN0cmluZyhldmVudElucHV0LnN0YXJ0KSB8fCBtb21lbnQuaXNEdXJhdGlvbihldmVudElucHV0LnN0YXJ0KSB8fFxyXG4gICAgICAgICAgICB1dGlsXzEuaXNUaW1lU3RyaW5nKGV2ZW50SW5wdXQuZW5kKSB8fCBtb21lbnQuaXNEdXJhdGlvbihldmVudElucHV0LmVuZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlY3VycmluZ0V2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZShldmVudElucHV0LCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZShldmVudElucHV0LCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEFycmF5RXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBcnJheUV2ZW50U291cmNlKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXZlbnREZWZzID0gW107IC8vIGZvciBpZiBzZXRSYXdFdmVudERlZnMgaXMgbmV2ZXIgY2FsbGVkXHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuc2V0UmF3RXZlbnREZWZzID0gZnVuY3Rpb24gKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgIHRoaXMucmF3RXZlbnREZWZzID0gcmF3RXZlbnREZWZzO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzID0gdGhpcy5wYXJzZUV2ZW50RGVmcyhyYXdFdmVudERlZnMpO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuZXZlbnREZWZzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lem9uZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWV6b25lICE9PSB0aW1lem9uZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZzW2ldIGluc3RhbmNlb2YgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZzW2ldLnJlem9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWV6b25lID0gdGltZXpvbmU7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LnJlc29sdmUoZXZlbnREZWZzKTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5hZGRFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBldmVudERlZklkIGFscmVhZHkgbm9ybWFsaXplZCB0byBhIHN0cmluZ1xyXG4gICAgKi9cclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEucmVtb3ZlTWF0Y2hpbmcodGhpcy5ldmVudERlZnMsIGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZWYuaWQgPT09IGV2ZW50RGVmSWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzID0gW107XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJpbWl0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJhd0V2ZW50RGVmcztcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB2YXIgc3VwZXJTdWNjZXNzID0gX3N1cGVyLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMuY2FsbCh0aGlzLCByYXdQcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zZXRSYXdFdmVudERlZnMocmF3UHJvcHMuZXZlbnRzKTtcclxuICAgICAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd0lucHV0LmV2ZW50cykpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgZXZlbnRzOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXJyYXlFdmVudFNvdXJjZTtcclxufShFdmVudFNvdXJjZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXJyYXlFdmVudFNvdXJjZTtcclxuQXJyYXlFdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIGV2ZW50czogZmFsc2UgLy8gZG9uJ3QgYXV0b21hdGljYWxseSB0cmFuc2ZlclxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZkRhdGVNdXRhdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNsZWFyRW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JjZVRpbWVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JjZUFsbERheSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIHJldHVybnMgYW4gdW5kbyBmdW5jdGlvbi5cclxuICAgICovXHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuYnVpbGROZXdEYXRlUHJvZmlsZSA9IGZ1bmN0aW9uIChldmVudERhdGVQcm9maWxlLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzdGFydCA9IGV2ZW50RGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKTtcclxuICAgICAgICB2YXIgZW5kID0gbnVsbDtcclxuICAgICAgICB2YXIgc2hvdWxkUmV6b25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0ZVByb2ZpbGUuZW5kICYmICF0aGlzLmNsZWFyRW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGV2ZW50RGF0ZVByb2ZpbGUuZW5kLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5kRGVsdGEgJiYgIWVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREYXRlUHJvZmlsZS5pc0FsbERheSgpLCBzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlVGltZWQpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCAmJiAhZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5mb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmIGVuZC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXRlRGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhcnQuYWRkKHRoaXMuZGF0ZURlbHRhKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmRhdGVEZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG8gdGhpcyBiZWZvcmUgYWRkaW5nIHN0YXJ0RGVsdGEgdG8gc3RhcnQsIHNvIHdlIGNhbiB3b3JrIG9mZiBvZiBzdGFydFxyXG4gICAgICAgIGlmICh0aGlzLmVuZERlbHRhKSB7XHJcbiAgICAgICAgICAgIHNob3VsZFJlem9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGVuZC5hZGQodGhpcy5lbmREZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RhcnQuYWRkKHRoaXMuc3RhcnREZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZXpvbmUpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKHN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IG9rYXkgdG8gYWNjZXNzIGNhbGVuZGFyIG9wdGlvbj9cclxuICAgICAgICBpZiAoIWVuZCAmJiBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChldmVudERhdGVQcm9maWxlLmlzQWxsRGF5KCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChzdGFydCwgZW5kLCBjYWxlbmRhcik7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldERhdGVEZWx0YSA9IGZ1bmN0aW9uIChkYXRlRGVsdGEpIHtcclxuICAgICAgICBpZiAoZGF0ZURlbHRhICYmIGRhdGVEZWx0YS52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlRGVsdGEgPSBkYXRlRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVEZWx0YSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLnByb3RvdHlwZS5zZXRTdGFydERlbHRhID0gZnVuY3Rpb24gKHN0YXJ0RGVsdGEpIHtcclxuICAgICAgICBpZiAoc3RhcnREZWx0YSAmJiBzdGFydERlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsdGEgPSBzdGFydERlbHRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldEVuZERlbHRhID0gZnVuY3Rpb24gKGVuZERlbHRhKSB7XHJcbiAgICAgICAgaWYgKGVuZERlbHRhICYmIGVuZERlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERlbHRhID0gZW5kRGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVuZERlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmNsZWFyRW5kICYmICF0aGlzLmZvcmNlVGltZWQgJiYgIXRoaXMuZm9yY2VBbGxEYXkgJiZcclxuICAgICAgICAgICAgIXRoaXMuZGF0ZURlbHRhICYmICF0aGlzLnN0YXJ0RGVsdGEgJiYgIXRoaXMuZW5kRGVsdGE7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24uY3JlYXRlRnJvbURpZmYgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUwLCBkYXRlUHJvZmlsZTEsIGxhcmdlVW5pdCkge1xyXG4gICAgICAgIHZhciBjbGVhckVuZCA9IGRhdGVQcm9maWxlMC5lbmQgJiYgIWRhdGVQcm9maWxlMS5lbmQ7XHJcbiAgICAgICAgdmFyIGZvcmNlVGltZWQgPSBkYXRlUHJvZmlsZTAuaXNBbGxEYXkoKSAmJiAhZGF0ZVByb2ZpbGUxLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgdmFyIGZvcmNlQWxsRGF5ID0gIWRhdGVQcm9maWxlMC5pc0FsbERheSgpICYmIGRhdGVQcm9maWxlMS5pc0FsbERheSgpO1xyXG4gICAgICAgIHZhciBkYXRlRGVsdGE7XHJcbiAgICAgICAgdmFyIGVuZERpZmY7XHJcbiAgICAgICAgdmFyIGVuZERlbHRhO1xyXG4gICAgICAgIHZhciBtdXRhdGlvbjtcclxuICAgICAgICAvLyBzdWJ0cmFjdHMgdGhlIGRhdGVzIGluIHRoZSBhcHByb3ByaWF0ZSB3YXksIHJldHVybmluZyBhIGR1cmF0aW9uXHJcbiAgICAgICAgZnVuY3Rpb24gc3VidHJhY3REYXRlcyhkYXRlMSwgZGF0ZTApIHtcclxuICAgICAgICAgICAgaWYgKGxhcmdlVW5pdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmQnlVbml0KGRhdGUxLCBkYXRlMCwgbGFyZ2VVbml0KTsgLy8gcG9vcmx5IG5hbWVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZVByb2ZpbGUxLmlzQWxsRGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkRheShkYXRlMSwgZGF0ZTApOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkRheVRpbWUoZGF0ZTEsIGRhdGUwKTsgLy8gcG9vcmx5IG5hbWVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZURlbHRhID0gc3VidHJhY3REYXRlcyhkYXRlUHJvZmlsZTEuc3RhcnQsIGRhdGVQcm9maWxlMC5zdGFydCk7XHJcbiAgICAgICAgaWYgKGRhdGVQcm9maWxlMS5lbmQpIHtcclxuICAgICAgICAgICAgLy8gdXNlIHVuem9uZWRSYW5nZXMgYmVjYXVzZSBkYXRlUHJvZmlsZTAuZW5kIG1pZ2h0IGJlIG51bGxcclxuICAgICAgICAgICAgZW5kRGlmZiA9IHN1YnRyYWN0RGF0ZXMoZGF0ZVByb2ZpbGUxLnVuem9uZWRSYW5nZS5nZXRFbmQoKSwgZGF0ZVByb2ZpbGUwLnVuem9uZWRSYW5nZS5nZXRFbmQoKSk7XHJcbiAgICAgICAgICAgIGVuZERlbHRhID0gZW5kRGlmZi5zdWJ0cmFjdChkYXRlRGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbigpO1xyXG4gICAgICAgIG11dGF0aW9uLmNsZWFyRW5kID0gY2xlYXJFbmQ7XHJcbiAgICAgICAgbXV0YXRpb24uZm9yY2VUaW1lZCA9IGZvcmNlVGltZWQ7XHJcbiAgICAgICAgbXV0YXRpb24uZm9yY2VBbGxEYXkgPSBmb3JjZUFsbERheTtcclxuICAgICAgICBtdXRhdGlvbi5zZXREYXRlRGVsdGEoZGF0ZURlbHRhKTtcclxuICAgICAgICBtdXRhdGlvbi5zZXRFbmREZWx0YShlbmREZWx0YSk7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudERlZkRhdGVNdXRhdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREZWZEYXRlTXV0YXRpb247XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFN0YW5kYXJkVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIHRoZW1lQ2xhc3NIYXNoOiB7fSxcclxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAodGhlbWVOYW1lLCB0aGVtZUNsYXNzKSB7XHJcbiAgICAgICAgdGhpcy50aGVtZUNsYXNzSGFzaFt0aGVtZU5hbWVdID0gdGhlbWVDbGFzcztcclxuICAgIH0sXHJcbiAgICBnZXRUaGVtZUNsYXNzOiBmdW5jdGlvbiAodGhlbWVTZXR0aW5nKSB7XHJcbiAgICAgICAgaWYgKCF0aGVtZVNldHRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0YW5kYXJkVGhlbWVfMS5kZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGVtZVNldHRpbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpxdWVyeVVpVGhlbWVfMS5kZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbWVDbGFzc0hhc2hbdGhlbWVTZXR0aW5nXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbi8vIFBsdWdpblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbm1vbWVudF9leHRfMS5uZXdNb21lbnRQcm90by5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyICYmIGFyZ3VtZW50c1swXSkge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlKHRoaXMsIGFyZ3VtZW50c1swXSk7IC8vIG91ciBleHRlbmRlZCBmb3JtYXR0aW5nXHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tREQnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7XHJcbiAgICAgICAgLy8gbW9tZW50LmZvcm1hdCgpIGRvZXNuJ3QgZW5zdXJlIGVuZ2xpc2gsIGJ1dCB3ZSB3YW50IHRvLlxyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRQcm90by5mb3JtYXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxubW9tZW50X2V4dF8xLm5ld01vbWVudFByb3RvLnRvSVNPU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuX2FtYmlnVGltZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fYW1iaWdab25lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcycpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2Z1bGxDYWxlbmRhcikge1xyXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiBicm93c2VyLCBtb21lbnQgbWlnaHQgbm90IG91dHB1dCBlbmdsaXNoLiBlbnN1cmUgZW5nbGlzaC5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9ibG9iLzIuMTguMS9zcmMvbGliL21vbWVudC9mb3JtYXQuanMjTDIyXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRQcm90by50b0lTT1N0cmluZy5hcHBseShlbmdsaXNoTW9tZW50KHRoaXMpLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRQcm90by50b0lTT1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5mdW5jdGlvbiBlbmdsaXNoTW9tZW50KG1vbSkge1xyXG4gICAgaWYgKG1vbS5sb2NhbGUoKSAhPT0gJ2VuJykge1xyXG4gICAgICAgIHJldHVybiBtb20uY2xvbmUoKS5sb2NhbGUoJ2VuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tO1xyXG59XHJcbi8vIENvbmZpZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuSW5zZXJ0ZWQgYmV0d2VlbiBjaHVua3MgaW4gdGhlIGZha2UgKFwiaW50ZXJtZWRpYXRlXCIpIGZvcm1hdHRpbmcgc3RyaW5nLlxyXG5JbXBvcnRhbnQgdGhhdCBpdCBwYXNzZXMgYXMgd2hpdGVzcGFjZSAoXFxzKSBiZWNhdXNlIG1vbWVudCBvZnRlbiBpZGVudGlmaWVzIG5vbi1zdGFuZGFsb25lIG1vbnRoc1xyXG52aWEgYSByZWdleHAgd2l0aCBhbiBcXHMuXHJcbiovXHJcbnZhciBQQVJUX1NFUEFSQVRPUiA9ICdcXHUwMDBiJzsgLy8gdmVydGljYWwgdGFiXHJcbi8qXHJcbkluc2VydGVkIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBsaXRlcmFsLXRleHQgY2h1bmsgdG8gaW5kaWNhdGUgdGhhdCB0aGUgbGl0ZXJhbCB0ZXh0IGlzIG5vdCBhY3R1YWxseSBsaXRlcmFsIHRleHQsXHJcbmJ1dCByYXRoZXIsIGEgXCJzcGVjaWFsXCIgdG9rZW4gdGhhdCBoYXMgY3VzdG9tIHJlbmRlcmluZyAoc2VlIHNwZWNpYWxUb2tlbnMgbWFwKS5cclxuKi9cclxudmFyIFNQRUNJQUxfVE9LRU5fTUFSS0VSID0gJ1xcdTAwMWYnOyAvLyBpbmZvcm1hdGlvbiBzZXBhcmF0b3IgMVxyXG4vKlxyXG5JbnNlcnRlZCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzcGFuIG9mIHRleHQgdGhhdCBtdXN0IGhhdmUgbm9uLXplcm8gbnVtZXJpYyBjaGFyYWN0ZXJzLlxyXG5IYW5kbGluZyBvZiB0aGVzZSBtYXJrZXJzIGlzIGRvbmUgaW4gYSBwb3N0LXByb2Nlc3Npbmcgc3RlcCBhdCB0aGUgdmVyeSBlbmQgb2YgdGV4dCByZW5kZXJpbmcuXHJcbiovXHJcbnZhciBNQVlCRV9NQVJLRVIgPSAnXFx1MDAxZSc7IC8vIGluZm9ybWF0aW9uIHNlcGFyYXRvciAyXHJcbnZhciBNQVlCRV9SRUdFWFAgPSBuZXcgUmVnRXhwKE1BWUJFX01BUktFUiArICcoW14nICsgTUFZQkVfTUFSS0VSICsgJ10qKScgKyBNQVlCRV9NQVJLRVIsICdnJyk7IC8vIG11c3QgYmUgZ2xvYmFsXHJcbi8qXHJcbkFkZGl0aW9uIGZvcm1hdHRpbmcgdG9rZW5zIHdlIHdhbnQgcmVjb2duaXplZFxyXG4qL1xyXG52YXIgc3BlY2lhbFRva2VucyA9IHtcclxuICAgIHQ6IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZGF0ZSwgJ2EnKS5jaGFyQXQoMCk7XHJcbiAgICB9LFxyXG4gICAgVDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChkYXRlLCAnQScpLmNoYXJBdCgwKTtcclxuICAgIH1cclxufTtcclxuLypcclxuVGhlIGZpcnN0IGNoYXJhY3RlcnMgb2YgZm9ybWF0dGluZyB0b2tlbnMgZm9yIHVuaXRzIHRoYXQgYXJlIDEgZGF5IG9yIGxhcmdlci5cclxuYHZhbHVlYCBpcyBmb3IgcmFua2luZyByZWxhdGl2ZSBzaXplIChsb3dlciBtZWFucyBiaWdnZXIpLlxyXG5gdW5pdGAgaXMgYSBub3JtYWxpemVkIHVuaXQsIHVzZWQgZm9yIGNvbXBhcmluZyBtb21lbnRzLlxyXG4qL1xyXG52YXIgbGFyZ2VUb2tlbk1hcCA9IHtcclxuICAgIFk6IHsgdmFsdWU6IDEsIHVuaXQ6ICd5ZWFyJyB9LFxyXG4gICAgTTogeyB2YWx1ZTogMiwgdW5pdDogJ21vbnRoJyB9LFxyXG4gICAgVzogeyB2YWx1ZTogMywgdW5pdDogJ3dlZWsnIH0sXHJcbiAgICB3OiB7IHZhbHVlOiAzLCB1bml0OiAnd2VlaycgfSxcclxuICAgIEQ6IHsgdmFsdWU6IDQsIHVuaXQ6ICdkYXknIH0sXHJcbiAgICBkOiB7IHZhbHVlOiA0LCB1bml0OiAnZGF5JyB9IC8vIGRheSBvZiB3ZWVrXHJcbn07XHJcbi8vIFNpbmdsZSBEYXRlIEZvcm1hdHRpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qXHJcbkZvcm1hdHMgYGRhdGVgIHdpdGggYSBNb21lbnQgZm9ybWF0dGluZyBzdHJpbmcsIGJ1dCBhbGxvdyBvdXIgbm9uLXplcm8gYXJlYXMgYW5kIHNwZWNpYWwgdG9rZW5cclxuKi9cclxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXRTdHIpIHtcclxuICAgIHJldHVybiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nKGdldFBhcnNlZEZvcm1hdFN0cmluZyhmb3JtYXRTdHIpLmZha2VGb3JtYXRTdHJpbmcsIGRhdGUpO1xyXG59XHJcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XHJcbi8vIERhdGUgUmFuZ2UgRm9ybWF0dGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFRPRE86IG1ha2UgaXQgd29yayB3aXRoIHRpbWV6b25lIG9mZnNldFxyXG4vKlxyXG5Vc2luZyBhIGZvcm1hdHRpbmcgc3RyaW5nIG1lYW50IGZvciBhIHNpbmdsZSBkYXRlLCBnZW5lcmF0ZSBhIHJhbmdlIHN0cmluZywgbGlrZVxyXG5cIlNlcCAyIC0gOSAyMDEzXCIsIHRoYXQgaW50ZWxsaWdlbnRseSBpbnNlcnRzIGEgc2VwYXJhdG9yIHdoZXJlIHRoZSBkYXRlcyBkaWZmZXIuXHJcbklmIHRoZSBkYXRlcyBhcmUgdGhlIHNhbWUgYXMgZmFyIGFzIHRoZSBmb3JtYXQgc3RyaW5nIGlzIGNvbmNlcm5lZCwganVzdCByZXR1cm4gYSBzaW5nbGVcclxucmVuZGVyaW5nIG9mIG9uZSBkYXRlLCB3aXRob3V0IGFueSBzZXBhcmF0b3IuXHJcbiovXHJcbmZ1bmN0aW9uIGZvcm1hdFJhbmdlKGRhdGUxLCBkYXRlMiwgZm9ybWF0U3RyLCBzZXBhcmF0b3IsIGlzUlRMKSB7XHJcbiAgICB2YXIgbG9jYWxlRGF0YTtcclxuICAgIGRhdGUxID0gbW9tZW50X2V4dF8xLmRlZmF1bHQucGFyc2Vab25lKGRhdGUxKTtcclxuICAgIGRhdGUyID0gbW9tZW50X2V4dF8xLmRlZmF1bHQucGFyc2Vab25lKGRhdGUyKTtcclxuICAgIGxvY2FsZURhdGEgPSBkYXRlMS5sb2NhbGVEYXRhKCk7XHJcbiAgICAvLyBFeHBhbmQgbG9jYWxpemVkIGZvcm1hdCBzdHJpbmdzLCBsaWtlIFwiTExcIiAtPiBcIk1NTU0gRCBZWVlZXCIuXHJcbiAgICAvLyBCVFcsIHRoaXMgaXMgbm90IGltcG9ydGFudCBmb3IgYGZvcm1hdERhdGVgIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSB0byBwdXQgY3VzdG9tIHRva2Vuc1xyXG4gICAgLy8gb3Igbm9uLXplcm8gYXJlYXMgaW4gTW9tZW50J3MgbG9jYWxpemVkIGZvcm1hdCBzdHJpbmdzLlxyXG4gICAgZm9ybWF0U3RyID0gbG9jYWxlRGF0YS5sb25nRGF0ZUZvcm1hdChmb3JtYXRTdHIpIHx8IGZvcm1hdFN0cjtcclxuICAgIHJldHVybiByZW5kZXJQYXJzZWRGb3JtYXQoZ2V0UGFyc2VkRm9ybWF0U3RyaW5nKGZvcm1hdFN0ciksIGRhdGUxLCBkYXRlMiwgc2VwYXJhdG9yIHx8ICcgLSAnLCBpc1JUTCk7XHJcbn1cclxuZXhwb3J0cy5mb3JtYXRSYW5nZSA9IGZvcm1hdFJhbmdlO1xyXG4vKlxyXG5SZW5kZXJzIGEgcmFuZ2Ugd2l0aCBhbiBhbHJlYWR5LXBhcnNlZCBmb3JtYXQgc3RyaW5nLlxyXG4qL1xyXG5mdW5jdGlvbiByZW5kZXJQYXJzZWRGb3JtYXQocGFyc2VkRm9ybWF0LCBkYXRlMSwgZGF0ZTIsIHNlcGFyYXRvciwgaXNSVEwpIHtcclxuICAgIHZhciBzYW1lVW5pdHMgPSBwYXJzZWRGb3JtYXQuc2FtZVVuaXRzO1xyXG4gICAgdmFyIHVuem9uZWREYXRlMSA9IGRhdGUxLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIGZvciBzYW1lLXVuaXQgY29tcGFyaXNvbnNcclxuICAgIHZhciB1bnpvbmVkRGF0ZTIgPSBkYXRlMi5jbG9uZSgpLnN0cmlwWm9uZSgpOyAvLyBcIlxyXG4gICAgdmFyIHJlbmRlcmVkUGFydHMxID0gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKHBhcnNlZEZvcm1hdC5mYWtlRm9ybWF0U3RyaW5nLCBkYXRlMSk7XHJcbiAgICB2YXIgcmVuZGVyZWRQYXJ0czIgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUyKTtcclxuICAgIHZhciBsZWZ0STtcclxuICAgIHZhciBsZWZ0U3RyID0gJyc7XHJcbiAgICB2YXIgcmlnaHRJO1xyXG4gICAgdmFyIHJpZ2h0U3RyID0gJyc7XHJcbiAgICB2YXIgbWlkZGxlSTtcclxuICAgIHZhciBtaWRkbGVTdHIxID0gJyc7XHJcbiAgICB2YXIgbWlkZGxlU3RyMiA9ICcnO1xyXG4gICAgdmFyIG1pZGRsZVN0ciA9ICcnO1xyXG4gICAgLy8gU3RhcnQgYXQgdGhlIGxlZnRtb3N0IHNpZGUgb2YgdGhlIGZvcm1hdHRpbmcgc3RyaW5nIGFuZCBjb250aW51ZSB1bnRpbCB5b3UgaGl0IGEgdG9rZW5cclxuICAgIC8vIHRoYXQgaXMgbm90IHRoZSBzYW1lIGJldHdlZW4gZGF0ZXMuXHJcbiAgICBmb3IgKGxlZnRJID0gMDsgbGVmdEkgPCBzYW1lVW5pdHMubGVuZ3RoICYmICghc2FtZVVuaXRzW2xlZnRJXSB8fCB1bnpvbmVkRGF0ZTEuaXNTYW1lKHVuem9uZWREYXRlMiwgc2FtZVVuaXRzW2xlZnRJXSkpOyBsZWZ0SSsrKSB7XHJcbiAgICAgICAgbGVmdFN0ciArPSByZW5kZXJlZFBhcnRzMVtsZWZ0SV07XHJcbiAgICB9XHJcbiAgICAvLyBTaW1pbGFybHksIHN0YXJ0IGF0IHRoZSByaWdodG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIG1vdmUgbGVmdFxyXG4gICAgZm9yIChyaWdodEkgPSBzYW1lVW5pdHMubGVuZ3RoIC0gMTsgcmlnaHRJID4gbGVmdEkgJiYgKCFzYW1lVW5pdHNbcmlnaHRJXSB8fCB1bnpvbmVkRGF0ZTEuaXNTYW1lKHVuem9uZWREYXRlMiwgc2FtZVVuaXRzW3JpZ2h0SV0pKTsgcmlnaHRJLS0pIHtcclxuICAgICAgICAvLyBJZiBjdXJyZW50IGNodW5rIGlzIG9uIHRoZSBib3VuZGFyeSBvZiB1bmlxdWUgZGF0ZS1jb250ZW50LCBhbmQgaXMgYSBzcGVjaWFsLWNhc2VcclxuICAgICAgICAvLyBkYXRlLWZvcm1hdHRpbmcgcG9zdGZpeCBjaGFyYWN0ZXIsIHRoZW4gZG9uJ3QgY29uc3VtZSBpdC4gQ29uc2lkZXIgaXQgdW5pcXVlIGRhdGUtY29udGVudC5cclxuICAgICAgICAvLyBUT0RPOiBtYWtlIGNvbmZpZ3VyYWJsZVxyXG4gICAgICAgIGlmIChyaWdodEkgLSAxID09PSBsZWZ0SSAmJiByZW5kZXJlZFBhcnRzMVtyaWdodEldID09PSAnLicpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJpZ2h0U3RyID0gcmVuZGVyZWRQYXJ0czFbcmlnaHRJXSArIHJpZ2h0U3RyO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIGFyZWEgaW4gdGhlIG1pZGRsZSBpcyBkaWZmZXJlbnQgZm9yIGJvdGggb2YgdGhlIGRhdGVzLlxyXG4gICAgLy8gQ29sbGVjdCB0aGVtIGRpc3RpbmN0bHkgc28gd2UgY2FuIGphbSB0aGVtIHRvZ2V0aGVyIGxhdGVyLlxyXG4gICAgZm9yIChtaWRkbGVJID0gbGVmdEk7IG1pZGRsZUkgPD0gcmlnaHRJOyBtaWRkbGVJKyspIHtcclxuICAgICAgICBtaWRkbGVTdHIxICs9IHJlbmRlcmVkUGFydHMxW21pZGRsZUldO1xyXG4gICAgICAgIG1pZGRsZVN0cjIgKz0gcmVuZGVyZWRQYXJ0czJbbWlkZGxlSV07XHJcbiAgICB9XHJcbiAgICBpZiAobWlkZGxlU3RyMSB8fCBtaWRkbGVTdHIyKSB7XHJcbiAgICAgICAgaWYgKGlzUlRMKSB7XHJcbiAgICAgICAgICAgIG1pZGRsZVN0ciA9IG1pZGRsZVN0cjIgKyBzZXBhcmF0b3IgKyBtaWRkbGVTdHIxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWlkZGxlU3RyID0gbWlkZGxlU3RyMSArIHNlcGFyYXRvciArIG1pZGRsZVN0cjI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2Nlc3NNYXliZU1hcmtlcnMobGVmdFN0ciArIG1pZGRsZVN0ciArIHJpZ2h0U3RyKTtcclxufVxyXG4vLyBGb3JtYXQgU3RyaW5nIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbnZhciBwYXJzZWRGb3JtYXRTdHJDYWNoZSA9IHt9O1xyXG4vKlxyXG5SZXR1cm5zIGEgcGFyc2VkIGZvcm1hdCBzdHJpbmcsIGxldmVyYWdpbmcgYSBjYWNoZS5cclxuKi9cclxuZnVuY3Rpb24gZ2V0UGFyc2VkRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikge1xyXG4gICAgcmV0dXJuIHBhcnNlZEZvcm1hdFN0ckNhY2hlW2Zvcm1hdFN0cl0gfHxcclxuICAgICAgICAocGFyc2VkRm9ybWF0U3RyQ2FjaGVbZm9ybWF0U3RyXSA9IHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikpO1xyXG59XHJcbi8qXHJcblBhcnNlcyBhIGZvcm1hdCBzdHJpbmcgaW50byB0aGUgZm9sbG93aW5nOlxyXG4tIGZha2VGb3JtYXRTdHJpbmc6IGEgbW9tZW50SlMgZm9ybWF0dGluZyBzdHJpbmcsIGxpdHRlcmVkIHdpdGggc3BlY2lhbCBjb250cm9sIGNoYXJhY3RlcnMgdGhhdCBnZXQgcG9zdC1wcm9jZXNzZWQuXHJcbi0gc2FtZVVuaXRzOiBmb3IgZXZlcnkgcGFydCBpbiBmYWtlRm9ybWF0U3RyaW5nLCBpZiB0aGUgcGFydCBpcyBhIHRva2VuLCB0aGUgdmFsdWUgd2lsbCBiZSBhIHVuaXQgc3RyaW5nIChsaWtlIFwiZGF5XCIpLFxyXG4gIHRoYXQgaW5kaWNhdGVzIGhvdyBzaW1pbGFyIGEgcmFuZ2UncyBzdGFydCAmIGVuZCBtdXN0IGJlIGluIG9yZGVyIHRvIHNoYXJlIHRoZSBzYW1lIGZvcm1hdHRlZCB0ZXh0LlxyXG4gIElmIG5vdCBhIHRva2VuLCB0aGVuIHRoZSB2YWx1ZSBpcyBudWxsLlxyXG4gIEFsd2F5cyBhIGZsYXQgYXJyYXkgKG5vdCBuZXN0ZWQgbGlrZWQgXCJjaHVua3NcIikuXHJcbiovXHJcbmZ1bmN0aW9uIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikge1xyXG4gICAgdmFyIGNodW5rcyA9IGNodW5rRm9ybWF0U3RyaW5nKGZvcm1hdFN0cik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZha2VGb3JtYXRTdHJpbmc6IGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVua3MpLFxyXG4gICAgICAgIHNhbWVVbml0czogYnVpbGRTYW1lVW5pdHMoY2h1bmtzKVxyXG4gICAgfTtcclxufVxyXG4vKlxyXG5CcmVhayB0aGUgZm9ybWF0dGluZyBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBjaHVua3MuXHJcbkEgJ21heWJlJyBjaHVuayB3aWxsIGhhdmUgbmVzdGVkIGNodW5rcy5cclxuKi9cclxuZnVuY3Rpb24gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gW107XHJcbiAgICB2YXIgbWF0Y2g7XHJcbiAgICAvLyBUT0RPOiBtb3JlIGRlc2NyaW1pbmF0aW9uXHJcbiAgICAvLyBcXDQgaXMgYSBiYWNrcmVmZXJlbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBtdWx0aS1jaGFyYWN0ZXIgc2V0LlxyXG4gICAgdmFyIGNodW5rZXIgPSAvXFxbKFteXFxdXSopXFxdfFxcKChbXlxcKV0qKVxcKXwoTFRTfExUfChcXHcpXFw0Km8/KXwoW15cXHdcXFtcXChdKykvZztcclxuICAgIHdoaWxlICgobWF0Y2ggPSBjaHVua2VyLmV4ZWMoZm9ybWF0U3RyKSkpIHtcclxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2guYXBwbHkoY2h1bmtzLCAvLyBhcHBlbmRcclxuICAgICAgICAgICAgc3BsaXRTdHJpbmdMaXRlcmFsKG1hdGNoWzFdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHsgbWF5YmU6IGNodW5rRm9ybWF0U3RyaW5nKG1hdGNoWzJdKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbM10pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2goeyB0b2tlbjogbWF0Y2hbM10gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzVdKSB7XHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoLmFwcGx5KGNodW5rcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIHNwbGl0U3RyaW5nTGl0ZXJhbChtYXRjaFs1XSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaHVua3M7XHJcbn1cclxuLypcclxuUG90ZW50aWFsbHkgc3BsaXRzIGEgbGl0ZXJhbC10ZXh0IHN0cmluZyBpbnRvIG11bHRpcGxlIHBhcnRzLiBGb3Igc3BlY2lhbCBjYXNlcy5cclxuKi9cclxuZnVuY3Rpb24gc3BsaXRTdHJpbmdMaXRlcmFsKHMpIHtcclxuICAgIGlmIChzID09PSAnLiAnKSB7XHJcbiAgICAgICAgcmV0dXJuIFsnLicsICcgJ107IC8vIGZvciBsb2NhbGVzIHdpdGggcGVyaW9kcyBib3VuZCB0byB0aGUgZW5kIG9mIGVhY2ggeWVhci9tb250aC9kYXRlXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW3NdO1xyXG4gICAgfVxyXG59XHJcbi8qXHJcbkdpdmVuIGNodW5rcyBwYXJzZWQgZnJvbSBhIHJlYWwgZm9ybWF0IHN0cmluZywgZ2VuZXJhdGUgYSBmYWtlIChha2EgXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0IHN0cmluZyB3aXRoIHNwZWNpYWwgY29udHJvbFxyXG5jaGFyYWN0ZXJzIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIGdpdmVuIHRvIG1vbWVudCBmb3IgZm9ybWF0dGluZywgYW5kIHRoZW4gcG9zdC1wcm9jZXNzZWQuXHJcbiovXHJcbmZ1bmN0aW9uIGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVua3MpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgdmFyIGksIGNodW5rO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ1snICsgY2h1bmsgKyAnXScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuay50b2tlbikge1xyXG4gICAgICAgICAgICBpZiAoY2h1bmsudG9rZW4gaW4gc3BlY2lhbFRva2Vucykge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChTUEVDSUFMX1RPS0VOX01BUktFUiArIC8vIHVzZWZ1bCBkdXJpbmcgcG9zdC1wcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgY2h1bmsudG9rZW4gKyAnXScgLy8gcHJlc2VydmUgYXMgbGl0ZXJhbCB0ZXh0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjaHVuay50b2tlbik7IC8vIHVucHJvdGVjdGVkIHRleHQgaW1wbGllcyBhIGZvcm1hdCBzdHJpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuay5tYXliZSkge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKE1BWUJFX01BUktFUiArIC8vIHVzZWZ1bCBkdXJpbmcgcG9zdC1wcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICBidWlsZEZha2VGb3JtYXRTdHJpbmcoY2h1bmsubWF5YmUpICtcclxuICAgICAgICAgICAgICAgIE1BWUJFX01BUktFUik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oUEFSVF9TRVBBUkFUT1IpO1xyXG59XHJcbi8qXHJcbkdpdmVuIHBhcnNlZCBjaHVua3MgZnJvbSBhIHJlYWwgZm9ybWF0dGluZyBzdHJpbmcsIGdlbmVyYXRlcyBhbiBhcnJheSBvZiB1bml0IHN0cmluZ3MgKGxpa2UgXCJkYXlcIikgdGhhdCBpbmRpY2F0ZVxyXG5pbiB3aGljaCByZWdhcmQgdHdvIGRhdGVzIG11c3QgYmUgc2ltaWxhciBpbiBvcmRlciB0byBzaGFyZSByYW5nZSBmb3JtYXR0aW5nIHRleHQuXHJcblRoZSBgY2h1bmtzYCBjYW4gYmUgbmVzdGVkIChiZWNhdXNlIG9mIFwibWF5YmVcIiBjaHVua3MpLCBob3dldmVyLCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBiZSBmbGF0LlxyXG4qL1xyXG5mdW5jdGlvbiBidWlsZFNhbWVVbml0cyhjaHVua3MpIHtcclxuICAgIHZhciB1bml0cyA9IFtdO1xyXG4gICAgdmFyIGksIGNodW5rO1xyXG4gICAgdmFyIHRva2VuSW5mbztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgdG9rZW5JbmZvID0gbGFyZ2VUb2tlbk1hcFtjaHVuay50b2tlbi5jaGFyQXQoMCldO1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoKHRva2VuSW5mbyA/IHRva2VuSW5mby51bml0IDogJ3NlY29uZCcpOyAvLyBkZWZhdWx0IHRvIGEgdmVyeSBzdHJpY3Qgc2FtZS1zZWNvbmRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2h1bmsubWF5YmUpIHtcclxuICAgICAgICAgICAgdW5pdHMucHVzaC5hcHBseSh1bml0cywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGJ1aWxkU2FtZVVuaXRzKGNodW5rLm1heWJlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bml0cztcclxufVxyXG4vLyBSZW5kZXJpbmcgdG8gdGV4dFxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBhIGRhdGUgd2l0aCBhIGZha2UgZm9ybWF0IHN0cmluZywgcG9zdC1wcm9jZXNzZXMgdGhlIGNvbnRyb2wgY2hhcmFjdGVycywgdGhlbiByZXR1cm5zLlxyXG4qL1xyXG5mdW5jdGlvbiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcclxuICAgIHJldHVybiBwcm9jZXNzTWF5YmVNYXJrZXJzKHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKS5qb2luKCcnKSk7XHJcbn1cclxuLypcclxuRm9ybWF0cyBhIGRhdGUgaW50byBwYXJ0cyB0aGF0IHdpbGwgaGF2ZSBiZWVuIHBvc3QtcHJvY2Vzc2VkLCBFWENFUFQgZm9yIHRoZSBcIm1heWJlXCIgbWFya2Vycy5cclxuKi9cclxuZnVuY3Rpb24gcmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgdmFyIGZha2VSZW5kZXIgPSBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsIGZha2VGb3JtYXRTdHJpbmcpO1xyXG4gICAgdmFyIGZha2VQYXJ0cyA9IGZha2VSZW5kZXIuc3BsaXQoUEFSVF9TRVBBUkFUT1IpO1xyXG4gICAgdmFyIGksIGZha2VQYXJ0O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZha2VQYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZha2VQYXJ0ID0gZmFrZVBhcnRzW2ldO1xyXG4gICAgICAgIGlmIChmYWtlUGFydC5jaGFyQXQoMCkgPT09IFNQRUNJQUxfVE9LRU5fTUFSS0VSKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXHJcbiAgICAgICAgICAgIC8vIHRoZSBsaXRlcmFsIHN0cmluZyBJUyB0aGUgdG9rZW4ncyBuYW1lLlxyXG4gICAgICAgICAgICAvLyBjYWxsIHNwZWNpYWwgdG9rZW4ncyByZWdpc3RlcmVkIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICBzcGVjaWFsVG9rZW5zW2Zha2VQYXJ0LnN1YnN0cmluZygxKV0oZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChmYWtlUGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRzO1xyXG59XHJcbi8qXHJcbkFjY2VwdHMgYW4gYWxtb3N0LWZpbmFsbHktZm9ybWF0dGVkIHN0cmluZyBhbmQgcHJvY2Vzc2VzIHRoZSBcIm1heWJlXCIgY29udHJvbCBjaGFyYWN0ZXJzLCByZXR1cm5pbmcgYSBuZXcgc3RyaW5nLlxyXG4qL1xyXG5mdW5jdGlvbiBwcm9jZXNzTWF5YmVNYXJrZXJzKHMpIHtcclxuICAgIHJldHVybiBzLnJlcGxhY2UoTUFZQkVfUkVHRVhQLCBmdW5jdGlvbiAobTAsIG0xKSB7XHJcbiAgICAgICAgaWYgKG0xLm1hdGNoKC9bMS05XS8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vLyBNaXNjIFV0aWxzXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuUmV0dXJucyBhIHVuaXQgc3RyaW5nLCBlaXRoZXIgJ3llYXInLCAnbW9udGgnLCAnZGF5Jywgb3IgbnVsbCBmb3IgdGhlIG1vc3QgZ3JhbnVsYXIgZm9ybWF0dGluZyB0b2tlbiBpbiB0aGUgc3RyaW5nLlxyXG4qL1xyXG5mdW5jdGlvbiBxdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcclxuICAgIHZhciBpLCBjaHVuaztcclxuICAgIHZhciBjYW5kaWRhdGU7XHJcbiAgICB2YXIgYmVzdDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjaHVuayA9IGNodW5rc1tpXTtcclxuICAgICAgICBpZiAoY2h1bmsudG9rZW4pIHtcclxuICAgICAgICAgICAgY2FuZGlkYXRlID0gbGFyZ2VUb2tlbk1hcFtjaHVuay50b2tlbi5jaGFyQXQoMCldO1xyXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJlc3QgfHwgY2FuZGlkYXRlLnZhbHVlID4gYmVzdC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3QgPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYmVzdCkge1xyXG4gICAgICAgIHJldHVybiBiZXN0LnVuaXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5leHBvcnRzLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdCA9IHF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG4vKlxyXG5BIGNhY2hlIGZvciB0aGUgbGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCB2YWx1ZXMgZm9yIG9uZSBvciBtb3JlIGVsZW1lbnRzLlxyXG5Xb3JrcyB3aXRoIGJvdGggb2Zmc2V0IChmcm9tIHRvcGxlZnQgZG9jdW1lbnQpIGFuZCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQpLlxyXG5cclxub3B0aW9uczpcclxuLSBlbHNcclxuLSBpc0hvcml6b250YWxcclxuLSBpc1ZlcnRpY2FsXHJcbiovXHJcbnZhciBDb29yZENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29vcmRDYWNoZShvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0hvcml6b250YWwgPSBmYWxzZTsgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgbGVmdC9yaWdodC93aWR0aFxyXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IGZhbHNlOyAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciB0b3AvYm90dG9tL2hlaWdodFxyXG4gICAgICAgIHRoaXMuZWxzID0gJChvcHRpb25zLmVscyk7XHJcbiAgICAgICAgdGhpcy5pc0hvcml6b250YWwgPSBvcHRpb25zLmlzSG9yaXpvbnRhbDtcclxuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBvcHRpb25zLmlzVmVydGljYWw7XHJcbiAgICAgICAgdGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbCA9IG9wdGlvbnMub2Zmc2V0UGFyZW50ID8gJChvcHRpb25zLm9mZnNldFBhcmVudCkgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gUXVlcmllcyB0aGUgZWxzIGZvciBjb29yZGluYXRlcyBhbmQgc3RvcmVzIHRoZW0uXHJcbiAgICAvLyBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSB1c2luZyBhbmQgb2YgdGhlIGdldCogbWV0aG9kcyBiZWxvdy5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnRFbCA9IHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWw7XHJcbiAgICAgICAgaWYgKCFvZmZzZXRQYXJlbnRFbCAmJiB0aGlzLmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG9mZnNldFBhcmVudEVsID0gdGhpcy5lbHMuZXEoMCkub2Zmc2V0UGFyZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3JpZ2luID0gb2Zmc2V0UGFyZW50RWwgP1xyXG4gICAgICAgICAgICBvZmZzZXRQYXJlbnRFbC5vZmZzZXQoKSA6XHJcbiAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JlY3QgPSB0aGlzLnF1ZXJ5Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEVsVmVydGljYWxzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIERlc3Ryb3lzIGFsbCBpbnRlcm5hbCBkYXRhIGFib3V0IGNvb3JkaW5hdGVzLCBmcmVlaW5nIG1lbW9yeVxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxlZnRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b3BzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJvdHRvbXMgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIFdoZW4gY2FsbGVkLCBpZiBjb29yZCBjYWNoZXMgYXJlbid0IGJ1aWx0LCBidWlsZHMgdGhlbVxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZW5zdXJlQnVpbHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9yaWdpbikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGRFbEhvcml6b250YWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0cyA9IFtdO1xyXG4gICAgICAgIHZhciByaWdodHMgPSBbXTtcclxuICAgICAgICB0aGlzLmVscy5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZWwub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gZWwub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgICAgICBsZWZ0cy5wdXNoKGxlZnQpO1xyXG4gICAgICAgICAgICByaWdodHMucHVzaChsZWZ0ICsgd2lkdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubGVmdHMgPSBsZWZ0cztcclxuICAgICAgICB0aGlzLnJpZ2h0cyA9IHJpZ2h0cztcclxuICAgIH07XHJcbiAgICAvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRvcHMgPSBbXTtcclxuICAgICAgICB2YXIgYm90dG9tcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWxzLmVhY2goZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gJChub2RlKTtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IGVsLm9mZnNldCgpLnRvcDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGVsLm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHRvcHMucHVzaCh0b3ApO1xyXG4gICAgICAgICAgICBib3R0b21zLnB1c2godG9wICsgaGVpZ2h0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnRvcHMgPSB0b3BzO1xyXG4gICAgICAgIHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXHJcbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRIb3Jpem9udGFsSW5kZXggPSBmdW5jdGlvbiAobGVmdE9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICB2YXIgbGVmdHMgPSB0aGlzLmxlZnRzO1xyXG4gICAgICAgIHZhciByaWdodHMgPSB0aGlzLnJpZ2h0cztcclxuICAgICAgICB2YXIgbGVuID0gbGVmdHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGVmdE9mZnNldCA+PSBsZWZ0c1tpXSAmJiBsZWZ0T2Zmc2V0IDwgcmlnaHRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxyXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0VmVydGljYWxJbmRleCA9IGZ1bmN0aW9uICh0b3BPZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgdmFyIHRvcHMgPSB0aGlzLnRvcHM7XHJcbiAgICAgICAgdmFyIGJvdHRvbXMgPSB0aGlzLmJvdHRvbXM7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRvcHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodG9wT2Zmc2V0ID49IHRvcHNbaV0gJiYgdG9wT2Zmc2V0IDwgYm90dG9tc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRMZWZ0T2Zmc2V0ID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGxlZnQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0TGVmdFBvc2l0aW9uID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdIC0gdGhpcy5vcmlnaW4ubGVmdDtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSByaWdodCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50J3MgcmlnaHQgZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJyaWdodFwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0UmlnaHRPZmZzZXQgPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHJpZ2h0IHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgcmlnaHQgZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJyaWdodFwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0UmlnaHRQb3NpdGlvbiA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5sZWZ0c1tsZWZ0SW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFRvcE9mZnNldCA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50b3BzW3RvcEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSB0b3AgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRUb3BQb3NpdGlvbiA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy50b3BzW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBib3R0b20gb2Zmc2V0IChmcm9tIHRoZSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyBib3R0b20gZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJib3R0b21cIiB3b3VsZCBiZS5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldEJvdHRvbU9mZnNldCA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBib3R0b20gcG9zaXRpb24gKGZyb20gdGhlIG9mZnNldFBhcmVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyBib3R0b20gZWRnZSwgbGlrZSB0aGUgQ1NTIGNvbmNlcHQgb2YgXCJib3R0b21cIiB3b3VsZCBiZS5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldEJvdHRvbVBvc2l0aW9uID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gQm91bmRpbmcgUmVjdFxyXG4gICAgLy8gVE9ETzogZGVjb3VwbGUgdGhpcyBmcm9tIENvb3JkQ2FjaGVcclxuICAgIC8vIENvbXB1dGUgYW5kIHJldHVybiB3aGF0IHRoZSBlbGVtZW50cycgYm91bmRpbmcgcmVjdGFuZ2xlIGlzLCBmcm9tIHRoZSB1c2VyJ3MgcGVyc3BlY3RpdmUuXHJcbiAgICAvLyBSaWdodCBub3csIG9ubHkgcmV0dXJucyBhIHJlY3RhbmdsZSBpZiBjb25zdHJhaW5lZCBieSBhbiBvdmVyZmxvdzpzY3JvbGwgZWxlbWVudC5cclxuICAgIC8vIFJldHVybnMgbnVsbCBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHNcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLnF1ZXJ5Qm91bmRpbmdSZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY3JvbGxQYXJlbnRFbDtcclxuICAgICAgICBpZiAodGhpcy5lbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBzY3JvbGxQYXJlbnRFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQodGhpcy5lbHMuZXEoMCkpO1xyXG4gICAgICAgICAgICBpZiAoIXNjcm9sbFBhcmVudEVsLmlzKGRvY3VtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRDbGllbnRSZWN0KHNjcm9sbFBhcmVudEVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5pc1BvaW50SW5Cb3VuZHMgPSBmdW5jdGlvbiAobGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgdGhpcy5pc1RvcEluQm91bmRzKHRvcE9mZnNldCk7XHJcbiAgICB9O1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuaXNMZWZ0SW5Cb3VuZHMgPSBmdW5jdGlvbiAobGVmdE9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5ib3VuZGluZ1JlY3QgfHwgKGxlZnRPZmZzZXQgPj0gdGhpcy5ib3VuZGluZ1JlY3QubGVmdCAmJiBsZWZ0T2Zmc2V0IDwgdGhpcy5ib3VuZGluZ1JlY3QucmlnaHQpO1xyXG4gICAgfTtcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmlzVG9wSW5Cb3VuZHMgPSBmdW5jdGlvbiAodG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAodG9wT2Zmc2V0ID49IHRoaXMuYm91bmRpbmdSZWN0LnRvcCAmJiB0b3BPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5ib3R0b20pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb29yZENhY2hlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb29yZENhY2hlO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbi8qIFRyYWNrcyBhIGRyYWcncyBtb3VzZSBtb3ZlbWVudCwgZmlyaW5nIHZhcmlvdXMgaGFuZGxlcnNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFRPRE86IHVzZSBFbWl0dGVyXHJcbnZhciBEcmFnTGlzdGVuZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmFnTGlzdGVuZXIob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1RvdWNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0dlbmVyaWMgPSBmYWxzZTsgLy8gaW5pdGlhdGVkIGJ5ICdkcmFnc3RhcnQnIChqcXVpKVxyXG4gICAgICAgIHRoaXMuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsQWx3YXlzS2lsbHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzQXV0b1Njcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy5zY3JvbGxTZW5zaXRpdml0eSA9IDMwOyAvLyBwaXhlbHMgZnJvbSBlZGdlIGZvciBzY3JvbGxpbmcgdG8gc3RhcnRcclxuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0gMjAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZCwgYXQgbWF4aW11bSBzcGVlZFxyXG4gICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyA9IDUwOyAvLyBtaWxsaXNlY29uZCB3YWl0IGJldHdlZW4gc2Nyb2xsIGluY3JlbWVudFxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB9XHJcbiAgICAvLyBJbnRlcmFjdGlvbiAoaGlnaC1sZXZlbClcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0SW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZXYsIGV4dHJhT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgPT09IHZvaWQgMCkgeyBleHRyYU9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChldi50eXBlID09PSAnbW91c2Vkb3duJykge1xyXG4gICAgICAgICAgICBpZiAoR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsXzEuaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50cyBuYXRpdmUgc2VsZWN0aW9uIGluIG1vc3QgYnJvd3NlcnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmFjdGluZykge1xyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIG9wdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5kZWxheSA9IHV0aWxfMS5maXJzdERlZmluZWQoZXh0cmFPcHRpb25zLmRlbGF5LCB0aGlzLm9wdGlvbnMuZGVsYXksIDApO1xyXG4gICAgICAgICAgICB0aGlzLm1pbkRpc3RhbmNlID0gdXRpbF8xLmZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGlzdGFuY2UsIHRoaXMub3B0aW9ucy5kaXN0YW5jZSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gdGhpcy5vcHRpb25zLnN1YmplY3RFbDtcclxuICAgICAgICAgICAgdXRpbF8xLnByZXZlbnRTZWxlY3Rpb24oJCgnYm9keScpKTtcclxuICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5pc1RvdWNoID0gdXRpbF8xLmdldEV2SXNUb3VjaChldik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNHZW5lcmljID0gZXYudHlwZSA9PT0gJ2RyYWdzdGFydCc7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblggPSB1dGlsXzEuZ2V0RXZYKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5ZID0gdXRpbF8xLmdldEV2WShldik7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWwgPSB1dGlsXzEuZ2V0U2Nyb2xsUGFyZW50KCQoZXYudGFyZ2V0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZEhhbmRsZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEF1dG9TY3JvbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0KGV2KTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERlbGF5KGV2KTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm1pbkRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludGVyYWN0aW9uU3RhcnQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhZyhldik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGF5VGltZW91dElkKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lBdXRvU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5iaW5kSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25FbmQoZXYsIGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgdXRpbF8xLmFsbG93U2VsZWN0aW9uKCQoJ2JvZHknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQgPSBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvbkVuZCcsIGV2LCBpc0NhbmNlbGxlZCB8fCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQmluZGluZyBUbyBET01cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChTYWZhcmkgaW4gaU9TIDEwKSBkb24ndCBhbGxvdyBwcmV2ZW50RGVmYXVsdCBvbiB0b3VjaCBldmVudHMgdGhhdCBhcmUgYm91bmQgYWZ0ZXIgdG91Y2hzdGFydCxcclxuICAgICAgICAvLyBzbyBsaXN0ZW4gdG8gdGhlIEdsb2JhbEVtaXR0ZXIgc2luZ2xldG9uLCB3aGljaCBpcyBhbHdheXMgYm91bmQsIGluc3RlYWQgb2YgdGhlIGRvY3VtZW50IGRpcmVjdGx5LlxyXG4gICAgICAgIHZhciBnbG9iYWxFbWl0dGVyID0gR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNHZW5lcmljKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcclxuICAgICAgICAgICAgICAgIGRyYWc6IHRoaXMuaGFuZGxlTW92ZSxcclxuICAgICAgICAgICAgICAgIGRyYWdzdG9wOiB0aGlzLmVuZEludGVyYWN0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhnbG9iYWxFbWl0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaG1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hlbmQ6IHRoaXMuZW5kSW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHRoaXMuaGFuZGxlVG91Y2hTY3JvbGxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZTogdGhpcy5oYW5kbGVNb3VzZU1vdmUsXHJcbiAgICAgICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmVuZEludGVyYWN0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgc2VsZWN0c3RhcnQ6IHV0aWxfMS5wcmV2ZW50RGVmYXVsdCxcclxuICAgICAgICAgICAgY29udGV4dG1lbnU6IHV0aWxfMS5wcmV2ZW50RGVmYXVsdCAvLyBsb25nIHRhcHMgd291bGQgb3BlbiBtZW51IG9uIENocm9tZSBkZXYgdG9vbHNcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnVuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpKTtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7IC8vIGZvciBpc0dlbmVyaWNcclxuICAgIH07XHJcbiAgICAvLyBEcmFnIChoaWdoLWxldmVsKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV4dHJhT3B0aW9ucyBpZ25vcmVkIGlmIGRyYWcgYWxyZWFkeSBzdGFydGVkXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uIChldiwgZXh0cmFPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydEludGVyYWN0aW9uKGV2LCBleHRyYU9wdGlvbnMpOyAvLyBlbnN1cmUgaW50ZXJhY3Rpb24gYmVnYW5cclxuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnU3RhcnQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGR4ID0gdXRpbF8xLmdldEV2WChldikgLSB0aGlzLm9yaWdpblg7XHJcbiAgICAgICAgdmFyIGR5ID0gdXRpbF8xLmdldEV2WShldikgLSB0aGlzLm9yaWdpblk7XHJcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcclxuICAgICAgICB2YXIgZGlzdGFuY2VTcTsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xyXG4gICAgICAgICAgICBkaXN0YW5jZVNxID0gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZVNxID49IG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnKGR4LCBkeSwgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hpbGUgdGhlIG1vdXNlIGlzIGJlaW5nIG1vdmVkIGFuZCB3aGVuIHdlIGtub3cgYSBsZWdpdGltYXRlIGRyYWcgaXMgdGFraW5nIHBsYWNlXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZHgsIGR5LCBldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZHJhZycsIGR4LCBkeSwgZXYpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXV0b1Njcm9sbChldik7IC8vIHdpbGwgcG9zc2libHkgY2F1c2Ugc2Nyb2xsaW5nXHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmREcmFnID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnRW5kJywgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIERlbGF5XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5zdGFydERlbGF5ID0gZnVuY3Rpb24gKGluaXRpYWxFdikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcclxuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlbGF5RW5kKGluaXRpYWxFdik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRGVsYXlFbmQgPSBmdW5jdGlvbiAoaW5pdGlhbEV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoaW5pdGlhbEV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGlzdGFuY2VcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBNb3VzZSAvIFRvdWNoXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBwcmV2ZW50IGluZXJ0aWEgYW5kIHRvdWNobW92ZS1zY3JvbGxpbmcgd2hpbGUgZHJhZ2dpbmdcclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nICYmIHRoaXMuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZShldik7XHJcbiAgICB9O1xyXG4gICAgLy8gU2Nyb2xsaW5nICh1bnJlbGF0ZWQgdG8gYXV0by1zY3JvbGwpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaFNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIGlmIHRoZSBkcmFnIGlzIGJlaW5nIGluaXRpYXRlZCBieSB0b3VjaCwgYnV0IGEgc2Nyb2xsIGhhcHBlbnMgYmVmb3JlXHJcbiAgICAgICAgLy8gdGhlIGRyYWctaW5pdGlhdGluZyBkZWxheSBpcyBvdmVyLCBjYW5jZWwgdGhlIGRyYWdcclxuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZyB8fCB0aGlzLnNjcm9sbEFsd2F5c0tpbGxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb24oZXYsIHRydWUpOyAvLyBpc0NhbmNlbGxlZD10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjay4gQ2FsbHMgYSBmdW5jdGlvbiBpbiB0aGUgb3B0aW9uIGhhc2ggb2YgdGhlIHNhbWUgbmFtZS5cclxuICAgIC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlcyBfbWV0aG9kcyBjYWxsYWJsZSBieSBldmVudCBuYW1lLiBUT0RPOiBraWxsIHRoaXNcclxuICAgICAgICBpZiAodGhpc1snXycgKyBuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzWydfJyArIG5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBBdXRvLXNjcm9sbFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaW5pdEF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbEVsID0gdGhpcy5zY3JvbGxFbDtcclxuICAgICAgICB0aGlzLmlzQXV0b1Njcm9sbCA9XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGwgJiZcclxuICAgICAgICAgICAgICAgIHNjcm9sbEVsICYmXHJcbiAgICAgICAgICAgICAgICAhc2Nyb2xsRWwuaXMod2luZG93KSAmJlxyXG4gICAgICAgICAgICAgICAgIXNjcm9sbEVsLmlzKGRvY3VtZW50KTtcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgLy8gZGVib3VuY2UgbWFrZXMgc3VyZSByYXBpZCBjYWxscyBkb24ndCBoYXBwZW5cclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhzY3JvbGxFbCwgJ3Njcm9sbCcsIHV0aWxfMS5kZWJvdW5jZSh0aGlzLmhhbmRsZURlYm91bmNlZFNjcm9sbCwgMTAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuZGVzdHJveUF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRBdXRvU2Nyb2xsKCk7IC8vIGtpbGwgYW55IGFuaW1hdGlvbiBsb29wXHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBzY3JvbGwgaGFuZGxlciBpZiB0aGVyZSBpcyBhIHNjcm9sbEVsXHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuc2Nyb2xsRWwsICdzY3JvbGwnKTsgLy8gd2lsbCBwcm9iYWJseSBnZXQgcmVtb3ZlZCBieSB1bmJpbmRIYW5kbGVycyB0b28gOihcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIHN0b3JlcyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIHNjcm9sbEVsXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQm91bmRzID0gdXRpbF8xLmdldE91dGVyUmVjdCh0aGlzLnNjcm9sbEVsKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogdXNlIGdldENsaWVudFJlY3QgaW4gZnV0dXJlLiBidXQgcHJldmVudHMgYXV0byBzY3JvbGxpbmcgd2hlbiBvbiB0b3Agb2Ygc2Nyb2xsYmFyc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZ2dpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kIHNjcm9sbGluZyBzaG91bGQgYmUgdXBkYXRlZFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS51cGRhdGVBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHNlbnNpdGl2aXR5ID0gdGhpcy5zY3JvbGxTZW5zaXRpdml0eTtcclxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5zY3JvbGxCb3VuZHM7XHJcbiAgICAgICAgdmFyIHRvcENsb3NlbmVzcywgYm90dG9tQ2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciBsZWZ0Q2xvc2VuZXNzLCByaWdodENsb3NlbmVzcztcclxuICAgICAgICB2YXIgdG9wVmVsID0gMDtcclxuICAgICAgICB2YXIgbGVmdFZlbCA9IDA7XHJcbiAgICAgICAgaWYgKGJvdW5kcykge1xyXG4gICAgICAgICAgICAvLyBjb21wdXRlIGNsb3NlbmVzcyB0byBlZGdlcy4gdmFsaWQgcmFuZ2UgaXMgZnJvbSAwLjAgLSAxLjBcclxuICAgICAgICAgICAgdG9wQ2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKHV0aWxfMS5nZXRFdlkoZXYpIC0gYm91bmRzLnRvcCkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIGJvdHRvbUNsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChib3VuZHMuYm90dG9tIC0gdXRpbF8xLmdldEV2WShldikpKSAvIHNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICBsZWZ0Q2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKHV0aWxfMS5nZXRFdlgoZXYpIC0gYm91bmRzLmxlZnQpKSAvIHNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICByaWdodENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtIChib3VuZHMucmlnaHQgLSB1dGlsXzEuZ2V0RXZYKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSB2ZXJ0aWNhbCBjbG9zZW5lc3MgaW50byB2ZWxvY2l0eS5cclxuICAgICAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBjb21wbGV0ZWx5IGluIGJvdW5kcyBmb3IgdmVsb2NpdHkgdG8gaGFwcGVuLlxyXG4gICAgICAgICAgICBpZiAodG9wQ2xvc2VuZXNzID49IDAgJiYgdG9wQ2xvc2VuZXNzIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHRvcFZlbCA9IHRvcENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQgKiAtMTsgLy8gbmVnYXRpdmUuIGZvciBzY3JvbGxpbmcgdXBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChib3R0b21DbG9zZW5lc3MgPj0gMCAmJiBib3R0b21DbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgdG9wVmVsID0gYm90dG9tQ2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGUgaG9yaXpvbnRhbCBjbG9zZW5lc3MgaW50byB2ZWxvY2l0eVxyXG4gICAgICAgICAgICBpZiAobGVmdENsb3NlbmVzcyA+PSAwICYmIGxlZnRDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdFZlbCA9IGxlZnRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIGxlZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodENsb3NlbmVzcyA+PSAwICYmIHJpZ2h0Q2xvc2VuZXNzIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRWZWwgPSByaWdodENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxWZWwodG9wVmVsLCBsZWZ0VmVsKTtcclxuICAgIH07XHJcbiAgICAvLyBTZXRzIHRoZSBzcGVlZC1vZi1zY3JvbGxpbmcgZm9yIHRoZSBzY3JvbGxFbFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5zZXRTY3JvbGxWZWwgPSBmdW5jdGlvbiAodG9wVmVsLCBsZWZ0VmVsKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxUb3BWZWwgPSB0b3BWZWw7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxMZWZ0VmVsID0gbGVmdFZlbDtcclxuICAgICAgICB0aGlzLmNvbnN0cmFpblNjcm9sbFZlbCgpOyAvLyBtYXNzYWdlcyBpbnRvIHJlYWxpc3RpYyB2YWx1ZXNcclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBub24temVybyB2ZWxvY2l0eSwgYW5kIGFuIGFuaW1hdGlvbiBsb29wIGhhc24ndCBhbHJlYWR5IHN0YXJ0ZWQsIHRoZW4gU1RBUlRcclxuICAgICAgICBpZiAoKHRoaXMuc2Nyb2xsVG9wVmVsIHx8IHRoaXMuc2Nyb2xsTGVmdFZlbCkgJiYgIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCh1dGlsXzEucHJveHkodGhpcywgJ3Njcm9sbEludGVydmFsRnVuYycpLCAvLyBzY29wZSB0byBgdGhpc2BcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbE1zKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRm9yY2VzIHNjcm9sbFRvcFZlbCBhbmQgc2Nyb2xsTGVmdFZlbCB0byBiZSB6ZXJvIGlmIHNjcm9sbGluZyBoYXMgYWxyZWFkeSBnb25lIGFsbCB0aGUgd2F5XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cmFpblNjcm9sbFZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcFZlbCA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbFRvcCgpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wVmVsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbFRvcFZlbCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbFRvcCgpICsgZWxbMF0uY2xpZW50SGVpZ2h0ID49IGVsWzBdLnNjcm9sbEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5zY3JvbGxMZWZ0KCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0VmVsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5zY3JvbGxMZWZ0KCkgKyBlbFswXS5jbGllbnRXaWR0aCA+PSBlbFswXS5zY3JvbGxXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0VmVsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGdldHMgY2FsbGVkIGR1cmluZyBldmVyeSBpdGVyYXRpb24gb2YgdGhlIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5zY3JvbGxJbnRlcnZhbEZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcclxuICAgICAgICB2YXIgZnJhYyA9IHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyAvIDEwMDA7IC8vIGNvbnNpZGVyaW5nIGFuaW1hdGlvbiBmcmVxdWVuY3ksIHdoYXQgdGhlIHZlbCBzaG91bGQgYmUgbXVsdCdkIGJ5XHJcbiAgICAgICAgLy8gY2hhbmdlIHRoZSB2YWx1ZSBvZiBzY3JvbGxFbCdzIHNjcm9sbFxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcFZlbCkge1xyXG4gICAgICAgICAgICBlbC5zY3JvbGxUb3AoZWwuc2Nyb2xsVG9wKCkgKyB0aGlzLnNjcm9sbFRvcFZlbCAqIGZyYWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxMZWZ0VmVsKSB7XHJcbiAgICAgICAgICAgIGVsLnNjcm9sbExlZnQoZWwuc2Nyb2xsTGVmdCgpICsgdGhpcy5zY3JvbGxMZWZ0VmVsICogZnJhYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIHNpbmNlIHRoZSBzY3JvbGwgdmFsdWVzIGNoYW5nZWQsIHJlY29tcHV0ZSB0aGUgdmVsb2NpdGllc1xyXG4gICAgICAgIC8vIGlmIHNjcm9sbGVkIGFsbCB0aGUgd2F5LCB3aGljaCBjYXVzZXMgdGhlIHZlbHMgdG8gYmUgemVybywgc3RvcCB0aGUgYW5pbWF0aW9uIGxvb3BcclxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsVG9wVmVsICYmICF0aGlzLnNjcm9sbExlZnRWZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRBdXRvU2Nyb2xsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEtpbGxzIGFueSBleGlzdGluZyBzY3JvbGxpbmcgYW5pbWF0aW9uIGxvb3BcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuZW5kQXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxJbnRlcnZhbElkKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbElkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0IGNhbGxlZCB3aGVuIHRoZSBzY3JvbGxFbCBpcyBzY3JvbGxlZCAoTk9URTogdGhpcyBpcyBkZWxheWVkIHZpYSBkZWJvdW5jZSlcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRGVib3VuY2VkU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHJlY29tcHV0ZSBhbGwgY29vcmRpbmF0ZXMsIGJ1dCAqb25seSogaWYgdGhpcyBpcyAqbm90KiBwYXJ0IG9mIG91ciBzY3JvbGxpbmcgYW5pbWF0aW9uXHJcbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxFbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gc2Nyb2xsaW5nIGhhcyBzdG9wcGVkLCB3aGV0aGVyIHRocm91Z2ggYXV0byBzY3JvbGwsIG9yIHRoZSB1c2VyIHNjcm9sbGluZ1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVTY3JvbGxFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERyYWdMaXN0ZW5lcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRHJhZ0xpc3RlbmVyO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKERyYWdMaXN0ZW5lcik7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuLypcclxuQSBzZXQgb2YgcmVuZGVyaW5nIGFuZCBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBmb3IgYSB2aXN1YWwgY29tcG9uZW50IGNvbXByaXNlZCBvZiBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjb2x1bW5zLlxyXG5QcmVyZXF1aXNpdGU6IHRoZSBvYmplY3QgYmVpbmcgbWl4ZWQgaW50byBuZWVkcyB0byBiZSBhICpHcmlkKlxyXG4qL1xyXG52YXIgRGF5VGFibGVNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheVRhYmxlTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlUYWJsZU1peGluKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmJyZWFrT25XZWVrcyA9IGZhbHNlOyAvLyBzaG91bGQgY3JlYXRlIGEgbmV3IHJvdyBmb3IgZWFjaCB3ZWVrP1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFBvcHVsYXRlcyBpbnRlcm5hbCB2YXJpYWJsZXMgdXNlZCBmb3IgZGF0ZSBjYWxjdWxhdGlvbiBhbmQgcmVuZGVyaW5nXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS51cGRhdGVEYXlUYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZGF0ZSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBkYXlJbmRleCA9IC0xO1xyXG4gICAgICAgIHZhciBkYXlJbmRpY2VzID0gW107XHJcbiAgICAgICAgdmFyIGRheURhdGVzID0gW107XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIGZpcnN0RGF5O1xyXG4gICAgICAgIHZhciByb3dDbnQ7XHJcbiAgICAgICAgd2hpbGUgKGRhdGUuaXNCZWZvcmUoZW5kKSkge1xyXG4gICAgICAgICAgICBpZiAodmlldy5pc0hpZGRlbkRheShkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kaWNlcy5wdXNoKGRheUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF0ZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRlLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5icmVha09uV2Vla3MpIHtcclxuICAgICAgICAgICAgLy8gY291bnQgY29sdW1ucyB1bnRpbCB0aGUgZGF5LW9mLXdlZWsgcmVwZWF0c1xyXG4gICAgICAgICAgICBmaXJzdERheSA9IGRheURhdGVzWzBdLmRheSgpO1xyXG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF5RGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXlEYXRlc1tkYXlzUGVyUm93XS5kYXkoKSA9PSBmaXJzdERheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXlEYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XHJcbiAgICAgICAgICAgIGRheXNQZXJSb3cgPSBkYXlEYXRlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF5RGF0ZXMgPSBkYXlEYXRlcztcclxuICAgICAgICB0aGlzLmRheUluZGljZXMgPSBkYXlJbmRpY2VzO1xyXG4gICAgICAgIHRoaXMuZGF5c1BlclJvdyA9IGRheXNQZXJSb3c7XHJcbiAgICAgICAgdGhpcy5yb3dDbnQgPSByb3dDbnQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZUNvbHMoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgYXNzaWduZWQgdGhlIGNvbENudCBwcm9wZXJ0eSBhbmQgdXBkYXRlcyBhbnkgb3B0aW9ucyB0aGF0IG1heSBiZSBjb21wdXRlZCBmcm9tIGl0XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS51cGRhdGVEYXlUYWJsZUNvbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDbnQgPSB0aGlzLmNvbXB1dGVDb2xDbnQoKTtcclxuICAgICAgICB0aGlzLmNvbEhlYWRGb3JtYXQgPSB0aGlzLm9wdCgnY29sdW1uRm9ybWF0JykgfHwgdGhpcy5jb21wdXRlQ29sSGVhZEZvcm1hdCgpO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgaG93IG1hbnkgY29sdW1ucyB0aGVyZSBzaG91bGQgYmUgaW4gdGhlIHRhYmxlXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5jb21wdXRlQ29sQ250ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIG1vbWVudCBmb3IgdGhlIGdpdmVuIGNlbGxcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENlbGxEYXRlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5RGF0ZXNbdGhpcy5nZXRDZWxsRGF5SW5kZXgocm93LCBjb2wpXS5jbG9uZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBkYXRlIHJhbmdlIGZvciB0aGUgZ2l2ZW4gY2VsbFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q2VsbFJhbmdlID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3Qgb2YgdGhlIGdyaWQgKDAtYmFzZWQpXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDZWxsRGF5SW5kZXggPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4gcm93ICogdGhpcy5kYXlzUGVyUm93ICsgdGhpcy5nZXRDb2xEYXlJbmRleChjb2wpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bW5lciBvZiBkYXkgY2VsbHMsIGNocm9ub2xvZ2ljYWxseSwgZnJvbSB0aGUgZmlyc3QgY2VsbCBpbiAqYW55IGdpdmVuIHJvdypcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENvbERheUluZGV4ID0gZnVuY3Rpb24gKGNvbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbENudCAtIDEgLSBjb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXHJcbiAgICAvLyBJZiB0aGUgZGF0ZSBsaWVzIGJldHdlZW4gY2VsbHMgKGJlY2F1c2Ugb2YgaGlkZGVuRGF5cyksIHJldHVybnMgYSBmbG9hdGluZy1wb2ludCB2YWx1ZSBiZXR3ZWVuIG9mZnNldHMuXHJcbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cclxuICAgIC8vIE9ubHkgd29ya3MgZm9yICpzdGFydCogZGF0ZXMgb2YgY2VsbHMuIFdpbGwgbm90IHdvcmsgZm9yIGV4Y2x1c2l2ZSBlbmQgZGF0ZXMgZm9yIGNlbGxzLlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0RGF0ZURheUluZGV4ID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgZGF5SW5kaWNlcyA9IHRoaXMuZGF5SW5kaWNlcztcclxuICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gZGF0ZS5kaWZmKHRoaXMuZGF5RGF0ZXNbMF0sICdkYXlzJyk7XHJcbiAgICAgICAgaWYgKGRheU9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbMF0gLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXlPZmZzZXQgPj0gZGF5SW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbZGF5SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1tkYXlPZmZzZXRdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBPcHRpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGNvbHVtbiBoZWFkZXIgZm9ybWF0dGluZyBzdHJpbmcgaWYgYGNvbEZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuY29tcHV0ZUNvbEhlYWRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcclxuICAgICAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcclxuICAgICAgICBpZiAodGhpcy5yb3dDbnQgPiAxIHx8IHRoaXMuY29sQ250ID4gMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGQnOyAvLyBcIlNhdFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29sQ250ID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2RheU9mTW9udGhGb3JtYXQnKTsgLy8gXCJTYXQgMTIvMTBcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkJzsgLy8gXCJTYXR1cmRheVwiXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNsaWNpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSB3ZWVrLXJvdyBpdCBpbnRlcnNlY3RzIHdpdGhcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnNsaWNlUmFuZ2VCeVJvdyA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZGF5c1BlclJvdyA9IHRoaXMuZGF5c1BlclJvdztcclxuICAgICAgICB2YXIgbm9ybWFsUmFuZ2UgPSB0aGlzLnZpZXcuY29tcHV0ZURheVJhbmdlKHVuem9uZWRSYW5nZSk7IC8vIG1ha2Ugd2hvbGUtZGF5IHJhbmdlLCBjb25zaWRlcmluZyBuZXh0RGF5VGhyZXNob2xkXHJcbiAgICAgICAgdmFyIHJhbmdlRmlyc3QgPSB0aGlzLmdldERhdGVEYXlJbmRleChub3JtYWxSYW5nZS5zdGFydCk7IC8vIGluY2x1c2l2ZSBmaXJzdCBpbmRleFxyXG4gICAgICAgIHZhciByYW5nZUxhc3QgPSB0aGlzLmdldERhdGVEYXlJbmRleChub3JtYWxSYW5nZS5lbmQuY2xvbmUoKS5zdWJ0cmFjdCgxLCAnZGF5cycpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgdmFyIHJvd0ZpcnN0LCByb3dMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBjdXJyZW50IHJvd1xyXG4gICAgICAgIHZhciBzZWdGaXJzdCwgc2VnTGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3Igc2VnbWVudFxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHJvd0ZpcnN0ID0gcm93ICogZGF5c1BlclJvdztcclxuICAgICAgICAgICAgcm93TGFzdCA9IHJvd0ZpcnN0ICsgZGF5c1BlclJvdyAtIDE7XHJcbiAgICAgICAgICAgIC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXHJcbiAgICAgICAgICAgIHNlZ0ZpcnN0ID0gTWF0aC5tYXgocmFuZ2VGaXJzdCwgcm93Rmlyc3QpO1xyXG4gICAgICAgICAgICBzZWdMYXN0ID0gTWF0aC5taW4ocmFuZ2VMYXN0LCByb3dMYXN0KTtcclxuICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICBzZWdMYXN0ID0gTWF0aC5mbG9vcihzZWdMYXN0KTsgLy8gaW4tYmV0d2VlbiBlbmRzIHJvdW5kIHRvIHByZXYgY2VsbFxyXG4gICAgICAgICAgICBpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0Um93RGF5SW5kZXg6IHNlZ0xhc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ0xhc3QgPT09IHJhbmdlTGFzdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgZGF5LWNlbGwgaXQgaW50ZXJzZWN0cyB3aXRoLlxyXG4gICAgLy8gVE9ETzogbWFrZSBtb3JlIERSWSB3aXRoIHNsaWNlUmFuZ2VCeVJvdyBzb21laG93LlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5RGF5ID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xyXG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UodW56b25lZFJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcclxuICAgICAgICB2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgdmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICByb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcclxuICAgICAgICAgICAgZm9yIChpID0gcm93Rmlyc3Q7IGkgPD0gcm93TGFzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3Qgc2VnbWVudCdzIG9mZnNldCByYW5nZSB3aXRoIHRoZSByb3cnc1xyXG4gICAgICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLm1heChyYW5nZUZpcnN0LCBpKTtcclxuICAgICAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIGkpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVhbCB3aXRoIGluLWJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcclxuICAgICAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLmZsb29yKHNlZ0xhc3QpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnRmlyc3QgPD0gc2VnTGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ0ZpcnN0ID09PSByYW5nZUZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogSGVhZGVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdGhlbWUuZ2V0Q2xhc3MoJ2hlYWRlclJvdycpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC90aGVhZD4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZFRySHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCgpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSA6ICcnKSArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsc0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbCwgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiB3aGVuIGludGVybmFsQXBpVmVyc2lvbiwgYWNjZXB0IGFuIG9iamVjdCBmb3IgSFRNTCBhdHRyaWJ1dGVzXHJcbiAgICAvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdC52aWV3O1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHQuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAnZmMtZGF5LWhlYWRlcicsXHJcbiAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgaW5uZXJIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUoZGF0ZS5mb3JtYXQodC5jb2xIZWFkRm9ybWF0KSk7XHJcbiAgICAgICAgLy8gaWYgb25seSBvbmUgcm93IG9mIGRheXMsIHRoZSBjbGFzc05hbWVzIG9uIHRoZSBoZWFkZXIgY2FuIHJlcHJlc2VudCB0aGUgc3BlY2lmaWMgZGF5cyBiZW5lYXRoXHJcbiAgICAgICAgaWYgKHQucm93Q250ID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLmNvbmNhdChcclxuICAgICAgICAgICAgLy8gaW5jbHVkZXMgdGhlIGRheS1vZi13ZWVrIGNsYXNzXHJcbiAgICAgICAgICAgIC8vIG5vVGhlbWVIaWdobGlnaHQ9dHJ1ZSAoZG9uJ3QgaGlnaGxpZ2h0IHRoZSBoZWFkZXIpXHJcbiAgICAgICAgICAgIHQuZ2V0RGF5Q2xhc3NlcyhkYXRlLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLScgKyB1dGlsXzEuZGF5SURzW2RhdGUuZGF5KCldKTsgLy8gb25seSBhZGQgdGhlIGRheS1vZi13ZWVrIGNsYXNzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCInICsgY2xhc3NOYW1lcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKChpc0RhdGVWYWxpZCAmJiB0LnJvd0NudCkgPT09IDEgP1xyXG4gICAgICAgICAgICAgICAgJyBkYXRhLWRhdGU9XCInICsgZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGNvbHNwYW4gPiAxID9cclxuICAgICAgICAgICAgICAgICcgY29sc3Bhbj1cIicgKyBjb2xzcGFuICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAob3RoZXJBdHRycyA/XHJcbiAgICAgICAgICAgICAgICAnICcgKyBvdGhlckF0dHJzIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBtYWtlIGEgbGluayBpZiB0aGUgaGVhZGluZyBjb3VsZCByZXByZXNlbnQgbXVsdGlwbGUgZGF5cywgb3IgaWYgdGhlcmUncyBvbmx5IG9uZSBkYXkgKGZvcmNlT2ZmKVxyXG4gICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKHsgZGF0ZTogZGF0ZSwgZm9yY2VPZmY6IHQucm93Q250ID4gMSB8fCB0LmNvbENudCA9PT0gMSB9LCBpbm5lckh0bWwpIDpcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCB2YWxpZCwgZGlzcGxheSB0ZXh0LCBidXQgbm8gbGlua1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sKSArXHJcbiAgICAgICAgICAgICc8L3RoPic7XHJcbiAgICB9O1xyXG4gICAgLyogQmFja2dyb3VuZCBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ1RySHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJCZ0ludHJvSHRtbChyb3cpKSArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdDZWxsc0h0bWwocm93KSArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJCZ0ludHJvSHRtbChyb3cpIDogJycpICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTsgLy8gZmFsbCBiYWNrIHRvIGdlbmVyaWNcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ0NlbGxzSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICB2YXIgaHRtbHMgPSBbXTtcclxuICAgICAgICB2YXIgY29sLCBkYXRlO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcclxuICAgICAgICAgICAgaHRtbHMucHVzaCh0aGlzLnJlbmRlckJnQ2VsbEh0bWwoZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVyQmdDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlLCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdC52aWV3O1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHQuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBjbGFzc2VzID0gdC5nZXREYXlDbGFzc2VzKGRhdGUpO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5Jywgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpKTtcclxuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoaXNEYXRlVmFsaWQgP1xyXG4gICAgICAgICAgICAgICAgJyBkYXRhLWRhdGU9XCInICsgZGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIicgOiAvLyBpZiBkYXRlIGhhcyBhIHRpbWUsIHdvbid0IGZvcm1hdCBpdFxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKG90aGVyQXR0cnMgP1xyXG4gICAgICAgICAgICAgICAgJyAnICsgb3RoZXJBdHRycyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPjwvdGQ+JztcclxuICAgIH07XHJcbiAgICAvKiBHZW5lcmljXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBkZWZhdWx0IEhUTUwgaW50cm8gZm9yIGFueSByb3cuIFVzZXIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiBhIGdlbmVyaWMgbWV0aG9kIGZvciBkZWFsaW5nIHdpdGggPHRyPiwgUlRMLCBpbnRyb1xyXG4gICAgLy8gd2hlbiBpbmNyZW1lbnQgaW50ZXJuYWxBcGlWZXJzaW9uXHJcbiAgICAvLyB3cmFwVHIgKHNjaGVkdWxlcilcclxuICAgIC8qIFV0aWxzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQXBwbGllcyB0aGUgZ2VuZXJpYyBcImludHJvXCIgYW5kIFwib3V0cm9cIiBIVE1MIHRvIHRoZSBnaXZlbiBjZWxscy5cclxuICAgIC8vIEludHJvIG1lYW5zIHRoZSBsZWZ0bW9zdCBjZWxsIHdoZW4gdGhlIGNhbGVuZGFyIGlzIExUUiBhbmQgdGhlIHJpZ2h0bW9zdCBjZWxsIHdoZW4gUlRMLiBWaWNlLXZlcnNhIGZvciBvdXRyby5cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmJvb2tlbmRDZWxscyA9IGZ1bmN0aW9uICh0ckVsKSB7XHJcbiAgICAgICAgdmFyIGludHJvSHRtbCA9IHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICAgICAgaWYgKGludHJvSHRtbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgdHJFbC5hcHBlbmQoaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyRWwucHJlcGVuZChpbnRyb0h0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlUYWJsZU1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlUYWJsZU1peGluO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wbGVtZW50czpcclxuICAgICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgICAtIGV2ZW50Rm9vdHByaW50c1RvU2Vnc1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIEJ1c2luZXNzSG91clJlbmRlcmVyKGNvbXBvbmVudCwgZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIgPSBmaWxsUmVuZGVyZXI7XHJcbiAgICB9XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gY29tcG9uZW50Ll9nZXREYXRlUHJvZmlsZSgpLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gYnVzaW5lc3NIb3VyR2VuZXJhdG9yLmJ1aWxkRXZlbnRJbnN0YW5jZUdyb3VwKGNvbXBvbmVudC5oYXNBbGxEYXlCdXNpbmVzc0hvdXJzLCB1bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBldmVudEluc3RhbmNlR3JvdXAgP1xyXG4gICAgICAgICAgICBjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXModW56b25lZFJhbmdlKSkgOlxyXG4gICAgICAgICAgICBbXTtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudC5ldmVudEZvb3RwcmludHNUb1NlZ3MoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB0aGlzLnJlbmRlclNlZ3Moc2Vncyk7XHJcbiAgICAgICAgdGhpcy5zZWdzID0gc2VncztcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MoJ2J1c2luZXNzSG91cnMnLCBzZWdzLCB7XHJcbiAgICAgICAgICAgICAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZmMtbm9uYnVzaW5lc3MnLCAnZmMtYmdldmVudCddO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci51bnJlbmRlcignYnVzaW5lc3NIb3VycycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlZ3MgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5nZXRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlZ3MgfHwgW107XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJ1c2luZXNzSG91clJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCdXNpbmVzc0hvdXJSZW5kZXJlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmlsbFJlbmRlcmVyKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuZmlsbFNlZ1RhZyA9ICdkaXYnO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZWxzQnlGaWxsID0ge307XHJcbiAgICB9XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZvb3RwcmludCA9IGZ1bmN0aW9uICh0eXBlLCBjb21wb25lbnRGb290cHJpbnQsIHByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTZWdzKHR5cGUsIHRoaXMuY29tcG9uZW50LmNvbXBvbmVudEZvb3RwcmludFRvU2Vncyhjb21wb25lbnRGb290cHJpbnQpLCBwcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MsIHByb3BzKSB7XHJcbiAgICAgICAgdmFyIGVscztcclxuICAgICAgICBzZWdzID0gdGhpcy5idWlsZFNlZ0Vscyh0eXBlLCBzZWdzLCBwcm9wcyk7IC8vIGFzc2lnbmVzIGAuZWxgIHRvIGVhY2ggc2VnLiByZXR1cm5zIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCBzZWdzXHJcbiAgICAgICAgZWxzID0gdGhpcy5hdHRhY2hTZWdFbHModHlwZSwgc2Vncyk7XHJcbiAgICAgICAgaWYgKGVscykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVscyh0eXBlLCBlbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSBzcGVjaWZpYyB0eXBlIG9mIGZpbGwgdGhhdCBpcyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWxzQnlGaWxsW3R5cGVdO1xyXG4gICAgICAgIGlmIChlbCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZWxzQnlGaWxsW3R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuZCBhc3NpZ25zIGFuIGBlbGAgcHJvcGVydHkgZm9yIGVhY2ggZmlsbCBzZWdtZW50LiBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgLy8gT25seSByZXR1cm5zIHNlZ21lbnRzIHRoYXQgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkLlxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZFNlZ0VscyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzLCBwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgcmVuZGVyZWRTZWdzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBzZWdtZW50IEhUTUxcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5idWlsZFNlZ0h0bWwodHlwZSwgc2Vnc1tpXSwgcHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdyYWIgaW5kaXZpZHVhbCBlbGVtZW50cyBmcm9tIHRoZSBjb21iaW5lZCBIVE1MIHN0cmluZy4gVXNlIGVhY2ggYXMgdGhlIGRlZmF1bHQgcmVuZGVyaW5nLlxyXG4gICAgICAgICAgICAvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICQoaHRtbCkuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgY3VzdG9tIGZpbHRlciBtZXRob2RzIHBlci10eXBlXHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZmlsdGVyRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9IHByb3BzLmZpbHRlckVsKHNlZywgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwgPSAkKGVsKTsgLy8gYWxsb3cgY3VzdG9tIGZpbHRlciB0byByZXR1cm4gcmF3IERPTSBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCBlbGVtZW50IHR5cGU/ICh3b3VsZCBiZSBiYWQgaWYgYSBub24tVEQgd2VyZSBpbnNlcnRlZCBpbnRvIGEgdGFibGUgZm9yIGV4YW1wbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmlzKF90aGlzLmZpbGxTZWdUYWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZy5lbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZFNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZFNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIGZpbGwgc2VnbWVudC4gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGRpZmZlcmVudCB0eXBlcy5cclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRTZWdIdG1sID0gZnVuY3Rpb24gKHR5cGUsIHNlZywgcHJvcHMpIHtcclxuICAgICAgICAvLyBjdXN0b20gaG9va3MgcGVyLXR5cGVcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHByb3BzLmdldENsYXNzZXMgPyBwcm9wcy5nZXRDbGFzc2VzKHNlZykgOiBbXTtcclxuICAgICAgICB2YXIgY3NzID0gdXRpbF8xLmNzc1RvU3RyKHByb3BzLmdldENzcyA/IHByb3BzLmdldENzcyhzZWcpIDoge30pO1xyXG4gICAgICAgIHJldHVybiAnPCcgKyB0aGlzLmZpbGxTZWdUYWcgK1xyXG4gICAgICAgICAgICAoY2xhc3Nlcy5sZW5ndGggPyAnIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyA6ICcnKSArXHJcbiAgICAgICAgICAgIChjc3MgPyAnIHN0eWxlPVwiJyArIGNzcyArICdcIicgOiAnJykgK1xyXG4gICAgICAgICAgICAnIC8+JztcclxuICAgIH07XHJcbiAgICAvLyBTaG91bGQgcmV0dXJuIHdyYXBwaW5nIERPTSBzdHJ1Y3R1cmVcclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZXBvcnRFbHMgPSBmdW5jdGlvbiAodHlwZSwgbm9kZXMpIHtcclxuICAgICAgICBpZiAodGhpcy5lbHNCeUZpbGxbdHlwZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5lbHNCeUZpbGxbdHlwZV0gPSB0aGlzLmVsc0J5RmlsbFt0eXBlXS5hZGQobm9kZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbHNCeUZpbGxbdHlwZV0gPSAkKG5vZGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZpbGxSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRmlsbFJlbmRlcmVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEhlbHBlclJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGVscGVyUmVuZGVyZXIoY29tcG9uZW50LCBldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyID0gZXZlbnRSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJDb21wb25lbnRGb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudEZvb3RwcmludHMoW1xyXG4gICAgICAgICAgICB0aGlzLmZhYnJpY2F0ZUV2ZW50Rm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludClcclxuICAgICAgICBdKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgJ2ZjLWRyYWdnaW5nJywgaXNUb3VjaCA/IG51bGwgOiB0aGlzLnZpZXcub3B0KCdkcmFnT3BhY2l0eScpKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgJ2ZjLXJlc2l6aW5nJyk7XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgZXh0cmFDbGFzc05hbWVzLCBvcGFjaXR5KSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudC5ldmVudEZvb3RwcmludHNUb1NlZ3MoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICdmYy1oZWxwZXIgJyArIChleHRyYUNsYXNzTmFtZXMgfHwgJycpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIGFzc2lnbnMgZWFjaCBzZWcncyBlbCBhbmQgcmV0dXJucyBhIHN1YnNldCBvZiBzZWdzIHRoYXQgd2VyZSByZW5kZXJlZFxyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyRmdTZWdFbHMoc2Vncyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc1tpXS5lbC5hZGRDbGFzcyhjbGFzc05hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wYWNpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5lbC5jc3MoJ29wYWNpdHknLCBvcGFjaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlbHBlckVscyA9IHRoaXMucmVuZGVyU2VncyhzZWdzLCBzb3VyY2VTZWcpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBNdXN0IHJldHVybiBhbGwgbW9jayBldmVudCBlbGVtZW50c1xyXG4gICAgKi9cclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIHNvdXJjZVNlZykge1xyXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVscGVyRWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlckVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5mYWJyaWNhdGVFdmVudEZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGF0ZVByb2ZpbGUgPSBjYWxlbmRhci5mb290cHJpbnRUb0RhdGVQcm9maWxlKGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgdmFyIGR1bW15RXZlbnQgPSBuZXcgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KG5ldyBFdmVudFNvdXJjZV8xLmRlZmF1bHQoY2FsZW5kYXIpKTtcclxuICAgICAgICB2YXIgZHVtbXlJbnN0YW5jZTtcclxuICAgICAgICBkdW1teUV2ZW50LmRhdGVQcm9maWxlID0gZXZlbnREYXRlUHJvZmlsZTtcclxuICAgICAgICBkdW1teUluc3RhbmNlID0gZHVtbXlFdmVudC5idWlsZEluc3RhbmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQoY29tcG9uZW50Rm9vdHByaW50LCBkdW1teUV2ZW50LCBkdW1teUluc3RhbmNlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSGVscGVyUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbHBlclJlbmRlcmVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnRQb2ludGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50UG9pbnRpbmcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFdmVudFBvaW50aW5nKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICovXHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWVudGVyJywgdGhpcy5oYW5kbGVNb3VzZW92ZXIuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlbGVhdmUnLCB0aGlzLmhhbmRsZU1vdXNlb3V0LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgcmVzID0gdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudENsaWNrJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksIGV2LCB0aGlzLnZpZXddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMgZm9yIHdoZW4gYW4gZXZlbnQgZWxlbWVudCBpcyBtb3VzZWQgb3ZlclxyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VvdmVyID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAoIUdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgIXRoaXMubW91c2VkT3ZlclNlZykge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlZE92ZXJTZWcgPSBzZWc7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gRXZlbnRTZWxlY3RpbmcncyByZXNwb25zaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3ZlcicsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksIGV2LCB0aGlzLnZpZXddXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdXQuXHJcbiAgICAvLyBDYW4gYmUgZ2l2ZW4gbm8gYXJndW1lbnRzLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgbW91c2VvdXQgdGhlIHNlZ21lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VzZWQgb3Zlci5cclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlb3V0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VkT3ZlclNlZyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1vdmUgdG8gRXZlbnRTZWxlY3RpbmcncyByZXNwb25zaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAodGhpcy52aWV3LmlzRXZlbnREZWZSZXNpemFibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmVDbGFzcygnZmMtYWxsb3ctbW91c2UtcmVzaXplJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudE1vdXNlb3V0Jywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgICAgICBldiB8fCB7fSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VvdXQodGhpcy5tb3VzZWRPdmVyU2VnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UG9pbnRpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UG9pbnRpbmc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG52YXIgRGF0ZUNsaWNraW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKTtcclxudmFyIERhdGVTZWxlY3RpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XHJcbnZhciBFdmVudERyYWdnaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcclxudmFyIEV2ZW50UmVzaXppbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xyXG52YXIgRXh0ZXJuYWxEcm9wcGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW47XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmRhdGVDbGlja2luZ0NsYXNzID0gRGF0ZUNsaWNraW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZGF0ZVNlbGVjdGluZ0NsYXNzID0gRGF0ZVNlbGVjdGluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV2ZW50UG9pbnRpbmdDbGFzcyA9IEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5ldmVudERyYWdnaW5nQ2xhc3MgPSBFdmVudERyYWdnaW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXZlbnRSZXNpemluZ0NsYXNzID0gRXZlbnRSZXNpemluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV4dGVybmFsRHJvcHBpbmdDbGFzcyA9IEV4dGVybmFsRHJvcHBpbmdfMS5kZWZhdWx0O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIENvb3JkQ2FjaGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG52YXIgUG9wb3Zlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nik7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG52YXIgQnVzaW5lc3NIb3VyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbnZhciBEYXlHcmlkRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XHJcbnZhciBEYXlHcmlkSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xyXG52YXIgRGF5R3JpZEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XHJcbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBhIGdyaWQgb2Ygd2hvbGUtZGF5cyB0aGF0IHJ1bnMgaG9yaXpvbnRhbGx5LiBUaGVyZSBjYW4gYmUgbXVsdGlwbGUgcm93cywgb25lIHBlciB3ZWVrLlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF5R3JpZCh2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7IC8vIGRpc3BsYXkgd2VlayBudW1iZXJzIGluIGRheSBjZWxsP1xyXG4gICAgICAgIF90aGlzLmJvdHRvbUNvb3JkUGFkZGluZyA9IDA7IC8vIGhhY2sgZm9yIGV4dGVuZGluZyB0aGUgaGl0IGFyZWEgZm9yIHRoZSBsYXN0IHJvdyBvZiB0aGUgY29vcmRpbmF0ZSBncmlkXHJcbiAgICAgICAgLy8gaXNSaWdpZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGluZGl2aWR1YWwgcm93cyBzaG91bGQgaWdub3JlIHRoZSBjb250ZW50cyBhbmQgYmUgYSBjb25zdGFudCBoZWlnaHQuXHJcbiAgICAgICAgLy8gUmVsaWVzIG9uIHRoZSB2aWV3J3MgY29sQ250IGFuZCByb3dDbnQuIEluIHRoZSBmdXR1cmUsIHRoaXMgY29tcG9uZW50IHNob3VsZCBwcm9iYWJseSBiZSBzZWxmLXN1ZmZpY2llbnQuXHJcbiAgICAgICAgX3RoaXMuaXNSaWdpZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmhhc0FsbERheUJ1c2luZXNzSG91cnMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcclxuICAgIERheUdyaWQucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5Um93KGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5sYXN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzZWcucmlnaHRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWcubGVmdENvbCA9IHNlZy5maXJzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICAgICAgc2VnLnJpZ2h0Q29sID0gc2VnLmxhc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF5VGFibGUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckdyaWQoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU2VnUG9wb3ZlcigpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgdGhlIHJvd3MgYW5kIGNvbHVtbnMgaW50byB0aGUgY29tcG9uZW50J3MgYHRoaXMuZWxgLCB3aGljaCBzaG91bGQgYWxyZWFkeSBiZSBhc3NpZ25lZC5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHJvd0NudCA9IHRoaXMucm93Q250O1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbENudDtcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBpZiAodGhpcy5oZWFkQ29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkQ29udGFpbmVyRWwuaHRtbCh0aGlzLnJlbmRlckhlYWRIdG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgaHRtbCArPSB0aGlzLnJlbmRlckRheVJvd0h0bWwocm93LCB0aGlzLmlzUmlnaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmh0bWwoaHRtbCk7XHJcbiAgICAgICAgdGhpcy5yb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3cnKTtcclxuICAgICAgICB0aGlzLmNlbGxFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXksIC5mYy1kaXNhYmxlZC1kYXknKTtcclxuICAgICAgICB0aGlzLnJvd0Nvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMucm93RWxzLFxyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLmNlbGxFbHMuc2xpY2UoMCwgdGhpcy5jb2xDbnQpLFxyXG4gICAgICAgICAgICBpc0hvcml6b250YWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyB0cmlnZ2VyIGRheVJlbmRlciB3aXRoIGVhY2ggY2VsbCdzIGVsZW1lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBjb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZGF5UmVuZGVyJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSByb3csIHdoaWNoIGlzIGEgZGl2IHRoYXQgd3JhcHMgYSB0YWJsZS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRGF5Um93SHRtbCA9IGZ1bmN0aW9uIChyb3csIGlzUmlnaWQpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLXJvdycsICdmYy13ZWVrJywgdGhlbWUuZ2V0Q2xhc3MoJ2RheVJvdycpXTtcclxuICAgICAgICBpZiAoaXNSaWdpZCkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXJpZ2lkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJnVHJIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZT4nICtcclxuICAgICAgICAgICAgKHRoaXMuZ2V0SXNOdW1iZXJzVmlzaWJsZSgpID9cclxuICAgICAgICAgICAgICAgICc8dGhlYWQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOdW1iZXJUckh0bWwocm93KSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JztcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSB8fCB0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGU7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3dDbnQgPiAxO1xyXG4gICAgfTtcclxuICAgIC8qIEdyaWQgTnVtYmVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlclRySHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSkgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck51bWJlckNlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpIDogJycpICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2wsIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyTnVtYmVyQ2VsbEh0bWwoZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbHMuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgPHRkPnMgb2YgdGhlIFwibnVtYmVyXCIgcm93IGluIHRoZSBEYXlHcmlkJ3MgY29udGVudCBza2VsZXRvbi5cclxuICAgIC8vIFRoZSBudW1iZXIgcm93IHdpbGwgb25seSBleGlzdCBpZiBlaXRoZXIgZGF5IG51bWJlcnMgb3Igd2VlayBudW1iZXJzIGFyZSB0dXJuZWQgb24uXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgaXNEYXRlVmFsaWQgPSB0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc0RhdGUoZGF0ZSk7IC8vIFRPRE86IGNhbGxlZCB0b28gZnJlcXVlbnRseS4gY2FjaGUgc29tZWhvdy5cclxuICAgICAgICB2YXIgaXNEYXlOdW1iZXJWaXNpYmxlID0gdGhpcy5nZXRJc0RheU51bWJlcnNWaXNpYmxlKCkgJiYgaXNEYXRlVmFsaWQ7XHJcbiAgICAgICAgdmFyIGNsYXNzZXM7XHJcbiAgICAgICAgdmFyIHdlZWtDYWxjRmlyc3REb1c7XHJcbiAgICAgICAgaWYgKCFpc0RheU51bWJlclZpc2libGUgJiYgIXRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBubyBudW1iZXJzIGluIGRheSBjZWxsICh3ZWVrIG51bWJlciBtdXN0IGJlIGFsb25nIHRoZSBzaWRlKVxyXG4gICAgICAgICAgICByZXR1cm4gJzx0ZC8+JzsgLy8gIHdpbGwgY3JlYXRlIGFuIGVtcHR5IHNwYWNlIGFib3ZlIGV2ZW50cyA6KFxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzc2VzID0gdGhpcy5nZXREYXlDbGFzc2VzKGRhdGUpO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LXRvcCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gVG8gZGV0ZXJtaW5lIHRoZSBkYXkgb2Ygd2VlayBudW1iZXIgY2hhbmdlIHVuZGVyIElTTywgd2UgY2Fubm90XHJcbiAgICAgICAgICAgIC8vIHJlbHkgb24gbW9tZW50LmpzIG1ldGhvZHMgc3VjaCBhcyBmaXJzdERheU9mV2VlaygpIG9yIHdlZWtkYXkoKSxcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGV5IHJlbHkgb24gdGhlIGxvY2FsZSdzIGRvdyAocG9zc2libHkgb3ZlcnJpZGRlbiBieVxyXG4gICAgICAgICAgICAvLyBvdXIgZmlyc3REYXkgb3B0aW9uKSwgd2hpY2ggbWF5IG5vdCBiZSBNb25kYXkuIFdlIGNhbm5vdCBjaGFuZ2VcclxuICAgICAgICAgICAgLy8gZG93LCBiZWNhdXNlIHRoYXQgd291bGQgYWZmZWN0IHRoZSBjYWxlbmRhciBzdGFydCBkYXkgYXMgd2VsbC5cclxuICAgICAgICAgICAgaWYgKGRhdGUuX2xvY2FsZS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgd2Vla0NhbGNGaXJzdERvVyA9IDE7IC8vIE1vbmRheSBieSBJU08gODYwMSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrQ2FsY0ZpcnN0RG9XID0gZGF0ZS5fbG9jYWxlLmZpcnN0RGF5T2ZXZWVrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPic7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSAmJiAoZGF0ZS5kYXkoKSA9PSB3ZWVrQ2FsY0ZpcnN0RG9XKSkge1xyXG4gICAgICAgICAgICBodG1sICs9IHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCh7IGRhdGU6IGRhdGUsIHR5cGU6ICd3ZWVrJyB9LCB7ICdjbGFzcyc6ICdmYy13ZWVrLW51bWJlcicgfSwgZGF0ZS5mb3JtYXQoJ3cnKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RheU51bWJlclZpc2libGUpIHtcclxuICAgICAgICAgICAgaHRtbCArPSB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoZGF0ZSwgeyAnY2xhc3MnOiAnZmMtZGF5LW51bWJlcicgfSwgZGF0ZS5kYXRlKCkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8L3RkPic7XHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5ib3R0b21zW3RoaXMucm93Q250IC0gMV0gKz0gdGhpcy5ib3R0b21Db29yZFBhZGRpbmc7IC8vIGhhY2tcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLnJvd0Nvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHRoaXMucm93Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0VmVydGljYWxJbmRleCh0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENlbGxIaXQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldENlbGxSYW5nZShoaXQucm93LCBoaXQuY29sKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCksIHRydWUgLy8gYWxsLWRheT9cclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxFbChoaXQucm93LCBoaXQuY29sKTtcclxuICAgIH07XHJcbiAgICAvKiBDZWxsIFN5c3RlbVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEZZSTogdGhlIGZpcnN0IGNvbHVtbiBpcyB0aGUgbGVmdG1vc3QgY29sdW1uLCByZWdhcmRsZXNzIG9mIGRhdGVcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxIaXQgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgY29sOiBjb2wsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5jb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sKSxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuY29sQ29vcmRDYWNoZS5nZXRSaWdodE9mZnNldChjb2wpLFxyXG4gICAgICAgICAgICB0b3A6IHRoaXMucm93Q29vcmRDYWNoZS5nZXRUb3BPZmZzZXQocm93KSxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnJvd0Nvb3JkQ2FjaGUuZ2V0Qm90dG9tT2Zmc2V0KHJvdylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxFbCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxFbHMuZXEocm93ICogdGhpcy5jb2xDbnQgKyBjb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFVucmVuZGVycyBhbGwgZXZlbnRzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIHJlbW92ZXMgdGhlIFwibW9yZS4uXCIgZXZlbnRzIHBvcG92ZXJcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0cmlldmVzIGFsbCByZW5kZXJlZCBzZWdtZW50IG9iamVjdHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBzZWdtZW50cyBmcm9tIHRoZSBcIm1vcmUuLi5cIiBwb3BvdmVyXHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0T3duRXZlbnRTZWdzLmNhbGwodGhpcykuY29uY2F0KHRoaXMucG9wb3ZlclNlZ3MgfHwgW10pO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWcgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbCBlbGVtZW50IGJlaW5nIGRyYWdnZWQuXHJcbiAgICAvLyBgZXZlbnRMb2NhdGlvbmAgaGFzIHpvbmVkIHN0YXJ0IGFuZCBlbmQgKG9wdGlvbmFsKVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbmRlciBkcmFncyBmcm9tIE9USEVSIGNvbXBvbmVudHMgYXMgaGVscGVyc1xyXG4gICAgICAgIGlmIChldmVudEZvb3RwcmludHMubGVuZ3RoICYmIHNlZyAmJiBzZWcuY29tcG9uZW50ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIGhlbHBlcnMgcmVuZGVyZWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGhvdmVyaW5nIGV2ZW50XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBNb3JlKyBMaW5rIFBvcG92ZXJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW1vdmVTZWdQb3BvdmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlZ1BvcG92ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWdQb3BvdmVyLmhpZGUoKTsgLy8gaW4gaGFuZGxlciwgd2lsbCBjYWxsIHNlZ1BvcG92ZXIncyByZW1vdmVFbGVtZW50XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIExpbWl0cyB0aGUgbnVtYmVyIG9mIFwibGV2ZWxzXCIgKHZlcnRpY2FsbHkgc3RhY2tpbmcgbGF5ZXJzIG9mIGV2ZW50cykgZm9yIGVhY2ggcm93IG9mIHRoZSBncmlkLlxyXG4gICAgLy8gYGxldmVsTGltaXRgIGNhbiBiZSBmYWxzZSAoZG9uJ3QgbGltaXQpLCBhIG51bWJlciwgb3IgdHJ1ZSAoc2hvdWxkIGJlIGNvbXB1dGVkKS5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmxpbWl0Um93cyA9IGZ1bmN0aW9uIChsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0cyB8fCBbXTtcclxuICAgICAgICB2YXIgcm93OyAvLyByb3cgI1xyXG4gICAgICAgIHZhciByb3dMZXZlbExpbWl0O1xyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93U3RydWN0cy5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5saW1pdFJvdyhyb3cpO1xyXG4gICAgICAgICAgICBpZiAoIWxldmVsTGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbGV2ZWxMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHJvd0xldmVsTGltaXQgPSBsZXZlbExpbWl0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IHRoaXMuY29tcHV0ZVJvd0xldmVsTGltaXQocm93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocm93TGV2ZWxMaW1pdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGltaXRSb3cocm93LCByb3dMZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgbnVtYmVyIG9mIGxldmVscyBhIHJvdyB3aWxsIGFjY29tb2RhdGUgd2l0aG91dCBnb2luZyBvdXRzaWRlIGl0cyBib3VuZHMuXHJcbiAgICAvLyBBc3N1bWVzIHRoZSByb3cgaXMgXCJyaWdpZFwiIChtYWludGFpbnMgYSBjb25zdGFudCBoZWlnaHQgcmVnYXJkbGVzcyBvZiB3aGF0IGlzIGluc2lkZSkuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmNvbXB1dGVSb3dMZXZlbExpbWl0ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciByb3dFbCA9IHRoaXMucm93RWxzLmVxKHJvdyk7IC8vIHRoZSBjb250YWluaW5nIFwiZmFrZVwiIHJvdyBkaXZcclxuICAgICAgICB2YXIgcm93SGVpZ2h0ID0gcm93RWwuaGVpZ2h0KCk7IC8vIFRPRE86IGNhY2hlIHNvbWVob3c/XHJcbiAgICAgICAgdmFyIHRyRWxzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XS50Ym9keUVsLmNoaWxkcmVuKCk7XHJcbiAgICAgICAgdmFyIGksIHRyRWw7XHJcbiAgICAgICAgdmFyIHRySGVpZ2h0O1xyXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJJbm5lckhlaWdodHMoaSwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgIHRySGVpZ2h0ID0gTWF0aC5tYXgodHJIZWlnaHQsICQoY2hpbGROb2RlKS5vdXRlckhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV2ZWFsIG9uZSBsZXZlbCA8dHI+IGF0IGEgdGltZSBhbmQgc3RvcCB3aGVuIHdlIGZpbmQgb25lIG91dCBvZiBib3VuZHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdHJFbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJFbCA9IHRyRWxzLmVxKGkpLnJlbW92ZUNsYXNzKCdmYy1saW1pdGVkJyk7IC8vIHJlc2V0IHRvIG9yaWdpbmFsIHN0YXRlIChyZXZlYWwpXHJcbiAgICAgICAgICAgIC8vIHdpdGggcm93c3BhbnM+MSBhbmQgSUU4LCB0ckVsLm91dGVySGVpZ2h0KCkgd291bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGxhcmdlc3QgY2VsbCxcclxuICAgICAgICAgICAgLy8gc28gaW5zdGVhZCwgZmluZCB0aGUgdGFsbGVzdCBpbm5lciBjb250ZW50IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIHRySGVpZ2h0ID0gMDtcclxuICAgICAgICAgICAgdHJFbC5maW5kKCc+IHRkID4gOmZpcnN0LWNoaWxkJykuZWFjaChpdGVySW5uZXJIZWlnaHRzKTtcclxuICAgICAgICAgICAgaWYgKHRyRWwucG9zaXRpb24oKS50b3AgKyB0ckhlaWdodCA+IHJvd0hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaG91bGQgbm90IGxpbWl0IGF0IGFsbFxyXG4gICAgfTtcclxuICAgIC8vIExpbWl0cyB0aGUgZ2l2ZW4gZ3JpZCByb3cgdG8gdGhlIG1heGltdW0gbnVtYmVyIG9mIGxldmVscyBhbmQgaW5qZWN0cyBcIm1vcmVcIiBsaW5rcyBpZiBuZWNlc3NhcnkuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIC8vIGBsZXZlbExpbWl0YCBpcyBhIG51bWJlciBmb3IgdGhlIG1heGltdW0gKGluY2x1c2l2ZSkgbnVtYmVyIG9mIGxldmVscyBhbGxvd2VkLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3cgPSBmdW5jdGlvbiAocm93LCBsZXZlbExpbWl0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcm93U3RydWN0ID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XTtcclxuICAgICAgICB2YXIgbW9yZU5vZGVzID0gW107IC8vIGFycmF5IG9mIFwibW9yZVwiIDxhPiBsaW5rcyBhbmQgPHRkPiBET00gbm9kZXNcclxuICAgICAgICB2YXIgY29sID0gMDsgLy8gY29sICMsIGxlZnQtdG8tcmlnaHQgKG5vdCBjaHJvbm9sb2dpY2FsbHkpXHJcbiAgICAgICAgdmFyIGxldmVsU2VnczsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbCwgb3JkZXJlZCBsZWZ0LXRvLXJpZ2h0XHJcbiAgICAgICAgdmFyIGNlbGxNYXRyaXg7IC8vIGEgbWF0cml4IChieSBsZXZlbCwgdGhlbiBjb2x1bW4pIG9mIGFsbCA8dGQ+IGpRdWVyeSBlbGVtZW50cyBpbiB0aGUgcm93XHJcbiAgICAgICAgdmFyIGxpbWl0ZWROb2RlczsgLy8gYXJyYXkgb2YgdGVtcG9yYXJpbHkgaGlkZGVuIGxldmVsIDx0cj4gYW5kIHNlZ21lbnQgPHRkPiBET00gbm9kZXNcclxuICAgICAgICB2YXIgaSwgc2VnO1xyXG4gICAgICAgIHZhciBzZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cyBiZWxvdyBgc2VnYCBpbiB0aGUgY3VycmVudCBgY29sYFxyXG4gICAgICAgIHZhciB0b3RhbFNlZ3NCZWxvdzsgLy8gdG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIGJlbG93IGBzZWdgIGluIGFueSBvZiB0aGUgY29sdW1ucyBgc2VnYCBvY2N1cGllc1xyXG4gICAgICAgIHZhciBjb2xTZWdzQmVsb3c7IC8vIGFycmF5IG9mIHNlZ21lbnQgYXJyYXlzLCBiZWxvdyBzZWcsIG9uZSBmb3IgZWFjaCBjb2x1bW4gKG9mZnNldCBmcm9tIHNlZ3MncyBmaXJzdCBjb2x1bW4pXHJcbiAgICAgICAgdmFyIHRkLCByb3dzcGFuO1xyXG4gICAgICAgIHZhciBzZWdNb3JlTm9kZXM7IC8vIGFycmF5IG9mIFwibW9yZVwiIDx0ZD4gY2VsbHMgdGhhdCB3aWxsIHN0YW5kLWluIGZvciB0aGUgY3VycmVudCBzZWcncyBjZWxsXHJcbiAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgdmFyIG1vcmVUZCwgbW9yZVdyYXAsIG1vcmVMaW5rO1xyXG4gICAgICAgIC8vIEl0ZXJhdGVzIHRocm91Z2ggZW1wdHkgbGV2ZWwgY2VsbHMgYW5kIHBsYWNlcyBcIm1vcmVcIiBsaW5rcyBpbnNpZGUgaWYgbmVlZCBiZVxyXG4gICAgICAgIHZhciBlbXB0eUNlbGxzVW50aWwgPSBmdW5jdGlvbiAoZW5kQ29sKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NCZWxvdyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdzQmVsb3cubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gX3RoaXMucmVuZGVyTW9yZUxpbmsocm93LCBjb2wsIHNlZ3NCZWxvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgIHRkLmFwcGVuZChtb3JlV3JhcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVdyYXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsZXZlbExpbWl0ICYmIGxldmVsTGltaXQgPCByb3dTdHJ1Y3Quc2VnTGV2ZWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXZlbFNlZ3MgPSByb3dTdHJ1Y3Quc2VnTGV2ZWxzW2xldmVsTGltaXQgLSAxXTtcclxuICAgICAgICAgICAgY2VsbE1hdHJpeCA9IHJvd1N0cnVjdC5jZWxsTWF0cml4O1xyXG4gICAgICAgICAgICBsaW1pdGVkTm9kZXMgPSByb3dTdHJ1Y3QudGJvZHlFbC5jaGlsZHJlbigpLnNsaWNlKGxldmVsTGltaXQpIC8vIGdldCBsZXZlbCA8dHI+IGVsZW1lbnRzIHBhc3QgdGhlIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5nZXQoKTsgLy8gaGlkZSBlbGVtZW50cyBhbmQgZ2V0IGEgc2ltcGxlIERPTS1ub2RlcyBhcnJheVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRlIHRob3VnaCBzZWdtZW50cyBpbiB0aGUgbGFzdCBhbGxvd2FibGUgbGV2ZWxcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxTZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTsgLy8gcHJvY2VzcyBlbXB0eSBjZWxscyBiZWZvcmUgdGhlIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSAqYWxsKiBzZWdtZW50cyBiZWxvdyBgc2VnYCB0aGF0IG9jY3VweSB0aGUgc2FtZSBjb2x1bW5zXHJcbiAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRvdGFsU2Vnc0JlbG93ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb2wgPD0gc2VnLnJpZ2h0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCwgbGV2ZWxMaW1pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sU2Vnc0JlbG93LnB1c2goc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbFNlZ3NCZWxvdyArPSBzZWdzQmVsb3cubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsU2Vnc0JlbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSBjZWxsTWF0cml4W2xldmVsTGltaXQgLSAxXVtzZWcubGVmdENvbF07IC8vIHRoZSBzZWdtZW50J3MgcGFyZW50IGNlbGxcclxuICAgICAgICAgICAgICAgICAgICByb3dzcGFuID0gdGQuYXR0cigncm93c3BhbicpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIHJlcGxhY2VtZW50IDx0ZD4gZm9yIGVhY2ggY29sdW1uIHRoZSBzZWdtZW50IG9jY3VwaWVzLiB3aWxsIGJlIG9uZSBmb3IgZWFjaCBjb2xzcGFuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvbFNlZ3NCZWxvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1tb3JlLWNlbGxcIi8+JykuYXR0cigncm93c3BhbicsIHJvd3NwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSBjb2xTZWdzQmVsb3dbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIHNlZy5sZWZ0Q29sICsgaiwgW3NlZ10uY29uY2F0KHNlZ3NCZWxvdykgLy8gY291bnQgc2VnIGFzIGhpZGRlbiB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQobW9yZUxpbmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlVGQuYXBwZW5kKG1vcmVXcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZU5vZGVzLnB1c2gobW9yZVRkWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYWRkQ2xhc3MoJ2ZjLWxpbWl0ZWQnKS5hZnRlcigkKHNlZ01vcmVOb2RlcykpOyAvLyBoaWRlIG9yaWdpbmFsIDx0ZD4gYW5kIGluamVjdCByZXBsYWNlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBsaW1pdGVkTm9kZXMucHVzaCh0ZFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHRoaXMuY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgbGV2ZWxcclxuICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSAkKG1vcmVOb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSAkKGxpbWl0ZWROb2Rlcyk7IC8vIGZvciBlYXN5IHVuZG9pbmcgbGF0ZXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUmV2ZWFscyBhbGwgbGV2ZWxzIGFuZCByZW1vdmVzIGFsbCBcIm1vcmVcIi1yZWxhdGVkIGVsZW1lbnRzIGZvciBhIGdyaWQncyByb3cuXHJcbiAgICAvLyBgcm93YCBpcyBhIHJvdyBudW1iZXIuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS51bmxpbWl0Um93ID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3QgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddO1xyXG4gICAgICAgIGlmIChyb3dTdHJ1Y3QubW9yZUVscykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgcm93U3RydWN0Lm1vcmVFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm93U3RydWN0LmxpbWl0ZWRFbHMpIHtcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTtcclxuICAgICAgICAgICAgcm93U3RydWN0LmxpbWl0ZWRFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGFuIDxhPiBlbGVtZW50IHRoYXQgcmVwcmVzZW50cyBoaWRkZW4gZXZlbnQgZWxlbWVudCBmb3IgYSBjZWxsLlxyXG4gICAgLy8gUmVzcG9uc2libGUgZm9yIGF0dGFjaGluZyBjbGljayBoYW5kbGVyIGFzIHdlbGwuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJNb3JlTGluayA9IGZ1bmN0aW9uIChyb3csIGNvbCwgaGlkZGVuU2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICQoJzxhIGNsYXNzPVwiZmMtbW9yZVwiLz4nKVxyXG4gICAgICAgICAgICAudGV4dCh0aGlzLmdldE1vcmVMaW5rVGV4dChoaWRkZW5TZWdzLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGNsaWNrT3B0aW9uID0gX3RoaXMub3B0KCdldmVudExpbWl0Q2xpY2snKTtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIHZhciBtb3JlRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZGF5RWwgPSBfdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB2YXIgYWxsU2VncyA9IF90aGlzLmdldENlbGxTZWdzKHJvdywgY29sKTtcclxuICAgICAgICAgICAgLy8gcmVzY29wZSB0aGUgc2VnbWVudHMgdG8gYmUgd2l0aGluIHRoZSBjZWxsJ3MgZGF0ZVxyXG4gICAgICAgICAgICB2YXIgcmVzbGljZWRBbGxTZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoYWxsU2VncywgZGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciByZXNsaWNlZEhpZGRlblNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhoaWRkZW5TZWdzLCBkYXRlKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJldHVybmVkIHZhbHVlIGNhbiBiZSBhbiBhdG9taWMgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICBjbGlja09wdGlvbiA9IF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRMaW1pdENsaWNrJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbDogZGF5RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JlRWw6IG1vcmVFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ3M6IHJlc2xpY2VkQWxsU2VncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHJlc2xpY2VkSGlkZGVuU2Vnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1xyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbGlja09wdGlvbiA9PT0gJ3BvcG92ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93U2VnUG9wb3Zlcihyb3csIGNvbCwgbW9yZUVsLCByZXNsaWNlZEFsbFNlZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjbGlja09wdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIuem9vbVRvKGRhdGUsIGNsaWNrT3B0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFJldmVhbHMgdGhlIHBvcG92ZXIgdGhhdCBkaXNwbGF5cyBhbGwgZXZlbnRzIHdpdGhpbiBhIGNlbGxcclxuICAgIERheUdyaWQucHJvdG90eXBlLnNob3dTZWdQb3BvdmVyID0gZnVuY3Rpb24gKHJvdywgY29sLCBtb3JlTGluaywgc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG1vcmVXcmFwID0gbW9yZUxpbmsucGFyZW50KCk7IC8vIHRoZSA8ZGl2PiB3cmFwcGVyIGFyb3VuZCB0aGUgPGE+XHJcbiAgICAgICAgdmFyIHRvcEVsOyAvLyB0aGUgZWxlbWVudCB3ZSB3YW50IHRvIG1hdGNoIHRoZSB0b3AgY29vcmRpbmF0ZSBvZlxyXG4gICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgIGlmICh0aGlzLnJvd0NudCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHRvcEVsID0gdmlldy5lbDsgLy8gd2lsbCBjYXVzZSB0aGUgcG9wb3ZlciB0byBjb3ZlciBhbnkgc29ydCBvZiBoZWFkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRvcEVsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gd2lsbCBhbGlnbiB3aXRoIHRvcCBvZiByb3dcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmMtbW9yZS1wb3BvdmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMucmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQocm93LCBjb2wsIHNlZ3MpLFxyXG4gICAgICAgICAgICBwYXJlbnRFbDogdmlldy5lbCxcclxuICAgICAgICAgICAgdG9wOiB0b3BFbC5vZmZzZXQoKS50b3AsXHJcbiAgICAgICAgICAgIGF1dG9IaWRlOiB0cnVlLFxyXG4gICAgICAgICAgICB2aWV3cG9ydENvbnN0cmFpbjogdGhpcy5vcHQoJ3BvcG92ZXJWaWV3cG9ydENvbnN0cmFpbicpLFxyXG4gICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBraWxsIGV2ZXJ5dGhpbmcgd2hlbiB0aGUgcG9wb3ZlciBpcyBoaWRkZW5cclxuICAgICAgICAgICAgICAgIC8vIG5vdGlmeSBldmVudHMgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnBvcG92ZXJTZWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckJlZm9yZUV2ZW50U2Vnc0Rlc3Ryb3llZChfdGhpcy5wb3BvdmVyU2Vncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdQb3BvdmVyLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucG9wb3ZlclNlZ3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBEZXRlcm1pbmUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxyXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgbW9yZVdyYXAgaW5zdGVhZCBvZiB0aGUgPHRkPiB0byBhdm9pZCBib3JkZXIgY29uZnVzaW9uLlxyXG4gICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucmlnaHQgPSBtb3JlV3JhcC5vZmZzZXQoKS5sZWZ0ICsgbW9yZVdyYXAub3V0ZXJXaWR0aCgpICsgMTsgLy8gKzEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gbW9yZVdyYXAub2Zmc2V0KCkubGVmdCAtIDE7IC8vIC0xIHRvIGJlIG92ZXIgY2VsbCBib3JkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWdQb3BvdmVyID0gbmV3IFBvcG92ZXJfMS5kZWZhdWx0KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2VnUG9wb3Zlci5zaG93KCk7XHJcbiAgICAgICAgLy8gdGhlIHBvcG92ZXIgZG9lc24ndCBsaXZlIHdpdGhpbiB0aGUgZ3JpZCdzIGNvbnRhaW5lciBlbGVtZW50LCBhbmQgdGh1cyB3b24ndCBnZXQgdGhlIGV2ZW50XHJcbiAgICAgICAgLy8gZGVsZWdhdGVkLWhhbmRsZXJzIGZvciBmcmVlLiBhdHRhY2ggZXZlbnQtcmVsYXRlZCBoYW5kbGVycyB0byB0aGUgcG9wb3Zlci5cclxuICAgICAgICB0aGlzLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwodGhpcy5zZWdQb3BvdmVyLmVsKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkKHNlZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgaW5uZXIgRE9NIGNvbnRlbnRzIG9mIHRoZSBzZWdtZW50IHBvcG92ZXJcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlclNlZ1BvcG92ZXJDb250ZW50ID0gZnVuY3Rpb24gKHJvdywgY29sLCBzZWdzKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKS5mb3JtYXQodGhpcy5vcHQoJ2RheVBvcG92ZXJGb3JtYXQnKSk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpICsgJ1wiPjwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUodGl0bGUpICtcclxuICAgICAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jbGVhclwiLz4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdmFyIHNlZ0NvbnRhaW5lciA9IGNvbnRlbnQuZmluZCgnLmZjLWV2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlbmRlciBlYWNoIHNlZydzIGBlbGAgYW5kIG9ubHkgcmV0dXJuIHRoZSB2aXNpYmxlIHNlZ3NcclxuICAgICAgICBzZWdzID0gdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlckZnU2VnRWxzKHNlZ3MsIHRydWUpOyAvLyBkaXNhYmxlUmVzaXppbmc9dHJ1ZVxyXG4gICAgICAgIHRoaXMucG9wb3ZlclNlZ3MgPSBzZWdzO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugc2VnbWVudHMgaW4gdGhlIHBvcG92ZXIgYXJlIG5vdCBwYXJ0IG9mIGEgZ3JpZCBjb29yZGluYXRlIHN5c3RlbSwgcHJvdmlkZSBhIGhpbnQgdG8gYW55XHJcbiAgICAgICAgICAgIC8vIGdyaWRzIHRoYXQgd2FudCB0byBkbyBkcmFnLW4tZHJvcCBhYm91dCB3aGljaCBjZWxsIGl0IGNhbWUgZnJvbVxyXG4gICAgICAgICAgICB0aGlzLmhpdHNOZWVkZWQoKTtcclxuICAgICAgICAgICAgc2Vnc1tpXS5oaXQgPSB0aGlzLmdldENlbGxIaXQocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB0aGlzLmhpdHNOb3ROZWVkZWQoKTtcclxuICAgICAgICAgICAgc2VnQ29udGFpbmVyLmFwcGVuZChzZWdzW2ldLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdGhlIGV2ZW50cyB3aXRoaW4gYW4gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzLCByZXNsaWNlIHRoZW0gdG8gYmUgaW4gYSBzaW5nbGUgZGF5XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZXNsaWNlRGF5U2VncyA9IGZ1bmN0aW9uIChzZWdzLCBkYXlEYXRlKSB7XHJcbiAgICAgICAgdmFyIGRheVN0YXJ0ID0gZGF5RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBkYXlFbmQgPSBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIHZhciBkYXlSYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRheVN0YXJ0LCBkYXlFbmQpO1xyXG4gICAgICAgIHZhciBuZXdTZWdzID0gW107XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICB2YXIgc2xpY2VkUmFuZ2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2xpY2VkUmFuZ2UgPSBzZWcuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KGRheVJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTZWdzLnB1c2goJC5leHRlbmQoe30sIHNlZywge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvb3RwcmludDogbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChzbGljZWRSYW5nZSwgc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpLCBzZWcuZm9vdHByaW50LmV2ZW50RGVmLCBzZWcuZm9vdHByaW50LmV2ZW50SW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5pc0VuZFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvcmNlIGFuIG9yZGVyIGJlY2F1c2UgZXZlbnRzVG9TZWdzIGRvZXNuJ3QgZ3VhcmFudGVlIG9uZVxyXG4gICAgICAgIC8vIFRPRE86IHJlc2VhcmNoIGlmIHN0aWxsIG5lZWRlZFxyXG4gICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5zb3J0RXZlbnRTZWdzKG5ld1NlZ3MpO1xyXG4gICAgICAgIHJldHVybiBuZXdTZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBpbnNpZGUgYSBcIm1vcmVcIiBsaW5rLCBnaXZlbiB0aGUgbnVtYmVyIG9mIGV2ZW50cyBpdCByZXByZXNlbnRzXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRNb3JlTGlua1RleHQgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0KCdldmVudExpbWl0VGV4dCcpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHQobnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnKycgKyBudW0gKyAnICcgKyBvcHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgc2VnbWVudHMgd2l0aGluIGEgZ2l2ZW4gY2VsbC5cclxuICAgIC8vIElmIGBzdGFydExldmVsYCBpcyBzcGVjaWZpZWQsIHJldHVybnMgb25seSBldmVudHMgaW5jbHVkaW5nIGFuZCBiZWxvdyB0aGF0IGxldmVsLiBPdGhlcndpc2UgcmV0dXJucyBhbGwgc2Vncy5cclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldENlbGxTZWdzID0gZnVuY3Rpb24gKHJvdywgY29sLCBzdGFydExldmVsKSB7XHJcbiAgICAgICAgdmFyIHNlZ01hdHJpeCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd10uc2VnTWF0cml4O1xyXG4gICAgICAgIHZhciBsZXZlbCA9IHN0YXJ0TGV2ZWwgfHwgMDtcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgd2hpbGUgKGxldmVsIDwgc2VnTWF0cml4Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdNYXRyaXhbbGV2ZWxdW2NvbF07XHJcbiAgICAgICAgICAgIGlmIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldmVsKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlHcmlkO1xyXG59KEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZDtcclxuRGF5R3JpZC5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gRGF5R3JpZEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5EYXlHcmlkLnByb3RvdHlwZS5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5EYXlHcmlkLnByb3RvdHlwZS5oZWxwZXJSZW5kZXJlckNsYXNzID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuZmlsbFJlbmRlcmVyQ2xhc3MgPSBEYXlHcmlkRmlsbFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xLmRlZmF1bHQubWl4SW50byhEYXlHcmlkKTtcclxuRGF5VGFibGVNaXhpbl8xLmRlZmF1bHQubWl4SW50byhEYXlHcmlkKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcclxudmFyIERheUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIFwiYmFzaWNcIiB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIERheUdyaWQgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXHJcbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXHJcbnZhciBCYXNpY1ZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCYXNpY1ZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXNpY1ZpZXcoY2FsZW5kYXIsIHZpZXdTcGVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIsIHZpZXdTcGVjKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRheUdyaWQgPSBfdGhpcy5pbnN0YW50aWF0ZURheUdyaWQoKTtcclxuICAgICAgICBfdGhpcy5kYXlHcmlkLmlzUmlnaWQgPSBfdGhpcy5oYXNSaWdpZFJvd3MoKTtcclxuICAgICAgICBpZiAoX3RoaXMub3B0KCd3ZWVrTnVtYmVycycpKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3dlZWtOdW1iZXJzV2l0aGluRGF5cycpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuZGF5R3JpZCk7XHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIERheUdyaWQgb2JqZWN0IHRoaXMgdmlldyBuZWVkcy4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5pbnN0YW50aWF0ZURheUdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgYSBzdWJjbGFzcyBvbiB0aGUgZmx5IHdpdGggQmFzaWNWaWV3LXNwZWNpZmljIGJlaGF2aW9yXHJcbiAgICAgICAgLy8gVE9ETzogY2FjaGUgdGhpcyBzdWJjbGFzc1xyXG4gICAgICAgIHZhciBzdWJjbGFzcyA9IG1ha2VEYXlHcmlkU3ViY2xhc3ModGhpcy5kYXlHcmlkQ2xhc3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgc3ViY2xhc3ModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5icmVha09uV2Vla3MgPSAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIuY2FsbCh0aGlzLCBkYXRlUHJvZmlsZSk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF5R3JpZENvbnRhaW5lckVsO1xyXG4gICAgICAgIHZhciBkYXlHcmlkRWw7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtYmFzaWMtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICBkYXlHcmlkQ29udGFpbmVyRWwgPSB0aGlzLnNjcm9sbGVyLmVsLmFkZENsYXNzKCdmYy1kYXktZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICBkYXlHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtZGF5LWdyaWRcIiAvPicpLmFwcGVuZFRvKGRheUdyaWRDb250YWluZXJFbCk7XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQoZGF5R3JpZENvbnRhaW5lckVsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuaGVhZENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCcuZmMtaGVhZC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuc2V0RWxlbWVudChkYXlHcmlkRWwpO1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXHJcbiAgICAvLyBUaGUgZGF5LWdyaWQgY29tcG9uZW50IHdpbGwgcmVuZGVyIGluc2lkZSBvZiBhIGNvbnRhaW5lciBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLm9wdCgnY29sdW1uSGVhZGVyJykgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiPiZuYnNwOzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLndlZWtOdW1iZXJTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLndlZWtOdW1iZXJXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgd2hldGhlciBlYWNoIHJvdyBzaG91bGQgaGF2ZSBhIGNvbnN0YW50IGhlaWdodFxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5oYXNSaWdpZFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgIHJldHVybiBldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJztcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICB2YXIgaGVhZFJvd0VsID0gdGhpcy5kYXlHcmlkLmhlYWRDb250YWluZXJFbC5maW5kKCcuZmMtcm93Jyk7XHJcbiAgICAgICAgdmFyIHNjcm9sbGVySGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgLy8gaGFjayB0byBnaXZlIHRoZSB2aWV3IHNvbWUgaGVpZ2h0IHByaW9yIHRvIGRheUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyBkYXlHcmlkLlxyXG4gICAgICAgIGlmICghdGhpcy5kYXlHcmlkLnJvd0Vscykge1xyXG4gICAgICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZC5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCB3ZWVrIG51bWJlciBjZWxscyBydW5uaW5nIGRvd24gdGhlIHNpZGUgaGF2ZSB0aGUgc2FtZSB3aWR0aC5cclxuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSB3aWR0aCBmb3IgY2VsbHMgY3JlYXRlZCBsYXRlci5cclxuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyV2lkdGggPSB1dGlsXzEubWF0Y2hDZWxsV2lkdGhzKHRoaXMuZWwuZmluZCgnLmZjLXdlZWstbnVtYmVyJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCBhbGwgaGVpZ2h0cyB0byBiZSBuYXR1cmFsXHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpO1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgIC8vIGlzIHRoZSBldmVudCBsaW1pdCBhIGNvbnN0YW50IGxldmVsIG51bWJlcj9cclxuICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBmaXJzdCBzbyB0aGUgaGVpZ2h0IGNhbiByZWRpc3RyaWJ1dGUgYWZ0ZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXHJcbiAgICAgICAgLy8gKHRvdGFsSGVpZ2h0IGlzIGEgXCJyZWNvbW1lbmRlZFwiIHZhbHVlIGlmIGlzQXV0bylcclxuICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldEdyaWRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQsIGlzQXV0byk7XHJcbiAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XHJcbiAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgYWZ0ZXIgdGhlIGdyaWQncyByb3cgaGVpZ2h0cyBoYXZlIGJlZW4gc2V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0IHx8IHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsLCBzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZG9pbmcgdGhlIHNjcm9sbGJhciBjb21wZW5zYXRpb24gbWlnaHQgaGF2ZSBjcmVhdGVkIHRleHQgb3ZlcmZsb3cgd2hpY2ggY3JlYXRlZCBtb3JlIGhlaWdodC4gcmVkb1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIC8vIFNldHMgdGhlIGhlaWdodCBvZiBqdXN0IHRoZSBEYXlHcmlkIGNvbXBvbmVudCBpbiB0aGlzIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIGlmIChpc0F1dG8pIHtcclxuICAgICAgICAgICAgdXRpbF8xLnVuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzKTsgLy8gbGV0IHRoZSByb3dzIGJlIHRoZWlyIG5hdHVyYWwgaGVpZ2h0IHdpdGggbm8gZXhwYW5kaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1dGlsXzEuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsIHRydWUpOyAvLyB0cnVlID0gY29tcGVuc2F0ZSBmb3IgaGVpZ2h0LWhvZ2dpbmcgcm93c1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBTY3JvbGxcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IDAgfTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICBpZiAoc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0U2Nyb2xsVG9wKHNjcm9sbC50b3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzaWNWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljVmlldztcclxuQmFzaWNWaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG5CYXNpY1ZpZXcucHJvdG90eXBlLmRheUdyaWRDbGFzcyA9IERheUdyaWRfMS5kZWZhdWx0O1xyXG4vLyBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiBCYXNpY1ZpZXcncyBkYXlHcmlkXHJcbmZ1bmN0aW9uIG1ha2VEYXlHcmlkU3ViY2xhc3MoU3VwZXJDbGFzcykge1xyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlOyAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBhbG9uZyB0aGUgc2lkZT9cclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgLy8gbmVlZGVkIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLm9wdCgnd2Vla051bWJlclRpdGxlJykpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgY29udGVudC1za2VsZXRvbiBjZWxscyB0aGF0IGRpc3BsYXkgdGhlIGRheS93ZWVrIG51bWJlcnNcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVyTnVtYmVySW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgdmFyIHdlZWtTdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB7IGRhdGU6IHdlZWtTdGFydCwgdHlwZTogJ3dlZWsnLCBmb3JjZU9mZjogdGhpcy5jb2xDbnQgPT09IDEgfSwgd2Vla1N0YXJ0LmZvcm1hdCgndycpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIHRoZSBkYXkgYmcgY2VsbHMgZm9yIGVhY2ggZGF5LXJvd1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlciAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgZXZlcnkgb3RoZXIgdHlwZSBvZiByb3cgZ2VuZXJhdGVkIGJ5IERheUdyaWQuXHJcbiAgICAgICAgLy8gQWZmZWN0cyBoZWxwZXItc2tlbGV0b24gYW5kIGhpZ2hsaWdodC1za2VsZXRvbiByb3dzLlxyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUuZ2V0SXNOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERheUdyaWRfMS5kZWZhdWx0LnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9KFN1cGVyQ2xhc3MpKTtcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgSXRlcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgVG9vbGJhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XHJcbnZhciBPcHRpb25zTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XHJcbnZhciBWaWV3U3BlY01hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpO1xyXG52YXIgQ29uc3RyYWludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFdmVudE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpO1xyXG52YXIgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxudmFyIEV2ZW50U291cmNlUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxudmFyIEV2ZW50RGVmUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxudmFyIENhbGVuZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIoZWwsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0xldmVsID0gMDsgLy8gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBsb2FkaW5nIHRhc2tzXHJcbiAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGggPSAwO1xyXG4gICAgICAgIC8vIGRlY2xhcmUgdGhlIGN1cnJlbnQgY2FsZW5kYXIgaW5zdGFuY2UgcmVsaWVzIG9uIEdsb2JhbEVtaXR0ZXIuIG5lZWRlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vIHVubmVlZGVkKCkgaXMgY2FsbGVkIGluIGRlc3Ryb3kuXHJcbiAgICAgICAgR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQubmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMudmlld3NCeVR5cGUgPSB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gbmV3IE9wdGlvbnNNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzLCBvdmVycmlkZXMpO1xyXG4gICAgICAgIHRoaXMudmlld1NwZWNNYW5hZ2VyID0gbmV3IFZpZXdTcGVjTWFuYWdlcl8xLmRlZmF1bHQodGhpcy5vcHRpb25zTWFuYWdlciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5pbml0TW9tZW50SW50ZXJuYWxzKCk7IC8vIG5lZWRzIHRvIGhhcHBlbiBhZnRlciBvcHRpb25zIGhhc2ggaW5pdGlhbGl6ZWRcclxuICAgICAgICB0aGlzLmluaXRDdXJyZW50RGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50TWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBuZXcgQ29uc3RyYWludHNfMS5kZWZhdWx0KHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdGVkKCk7XHJcbiAgICB9XHJcbiAgICAvLyB1c2VmdWwgZm9yIG1vbmtleXBhdGNoaW5nLiB1c2VkP1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbnN0cnVjdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXc7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnB1YmxpY2x5VHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCB0cmlnZ2VySW5mbykge1xyXG4gICAgICAgIHZhciBvcHRIYW5kbGVyID0gdGhpcy5vcHQobmFtZSk7XHJcbiAgICAgICAgdmFyIGNvbnRleHQ7XHJcbiAgICAgICAgdmFyIGFyZ3M7XHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh0cmlnZ2VySW5mbykpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IHRyaWdnZXJJbmZvLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGFyZ3MgPSB0cmlnZ2VySW5mby5hcmdzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkodHJpZ2dlckluZm8pKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSB0cmlnZ2VySW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRleHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5lbFswXTsgLy8gZmFsbGJhY2sgY29udGV4dFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3MpIHtcclxuICAgICAgICAgICAgYXJncyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXJXaXRoKG5hbWUsIGNvbnRleHQsIGFyZ3MpOyAvLyBFbWl0dGVyJ3MgbWV0aG9kXHJcbiAgICAgICAgaWYgKG9wdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdEhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5oYXNQdWJsaWNIYW5kbGVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGFuZGxlcnMobmFtZSkgfHxcclxuICAgICAgICAgICAgdGhpcy5vcHQobmFtZSk7IC8vIGhhbmRsZXIgc3BlY2lmaWVkIGluIG9wdGlvbnNcclxuICAgIH07XHJcbiAgICAvLyBPcHRpb25zIFB1YmxpYyBBUElcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBwdWJsaWMgZ2V0dGVyL3NldHRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBuZXdPcHRpb25IYXNoO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNNYW5hZ2VyLmdldChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld09wdGlvbkhhc2ggPSB7fTtcclxuICAgICAgICAgICAgICAgIG5ld09wdGlvbkhhc2hbbmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuYWRkKG5ld09wdGlvbkhhc2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmFkZChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gcHJpdmF0ZSBnZXR0ZXJcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNNYW5hZ2VyLmdldChuYW1lKTtcclxuICAgIH07XHJcbiAgICAvLyBWaWV3XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gR2l2ZW4gYSB2aWV3IG5hbWUgZm9yIGEgY3VzdG9tIHZpZXcgb3IgYSBzdGFuZGFyZCB2aWV3LCBjcmVhdGVzIGEgcmVhZHktdG8tZ28gVmlldyBvYmplY3RcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbnN0YW50aWF0ZVZpZXcgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgc3BlYyA9IHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKTtcclxuICAgICAgICByZXR1cm4gbmV3IHNwZWNbJ2NsYXNzJ10odGhpcywgc3BlYyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc1ZhbGlkVmlld1R5cGUgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jaGFuZ2VWaWV3ID0gZnVuY3Rpb24gKHZpZXdOYW1lLCBkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnJlY29yZE92ZXJyaWRlcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZVJhbmdlOiBkYXRlT3JSYW5nZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGF0ZU9yUmFuZ2UpLnN0cmlwWm9uZSgpOyAvLyBqdXN0IGxpa2UgZ290b0RhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcodmlld05hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbiAobmV3RGF0ZSwgdmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgc3BlYztcclxuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXHJcbiAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBuZXdEYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHNwZWMgPyBzcGVjLnR5cGUgOiBudWxsKTtcclxuICAgIH07XHJcbiAgICAvLyBDdXJyZW50IERhdGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEN1cnJlbnREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0RGF0ZUlucHV0ID0gdGhpcy5vcHQoJ2RlZmF1bHREYXRlJyk7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXHJcbiAgICAgICAgaWYgKGRlZmF1bHREYXRlSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGVmYXVsdERhdGVJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBwcmV2SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAocHJldkluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gcHJldkluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAobmV4dEluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gbmV4dEluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2WWVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlLmFkZCgtMSwgJ3llYXJzJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKDEsICd5ZWFycycpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gc2hvdWxkIGRlbnkgbGlrZSBwcmV2L25leHQ/XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdvdG9EYXRlID0gZnVuY3Rpb24gKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMubW9tZW50KHpvbmVkRGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKG1vbWVudC5kdXJhdGlvbihkZWx0YSkpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIC8vIGZvciBleHRlcm5hbCBBUElcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VGltZXpvbmUodGhpcy5jdXJyZW50RGF0ZSk7IC8vIGluZnVzZSB0aGUgY2FsZW5kYXIncyB0aW1lem9uZVxyXG4gICAgfTtcclxuICAgIC8vIExvYWRpbmcgVHJpZ2dlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGJlZ2luc1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnB1c2hMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMubG9hZGluZ0xldmVsKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW3RydWUsIHRoaXMudmlld10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBjb21wbGV0ZXNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wb3BMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKC0tdGhpcy5sb2FkaW5nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW2ZhbHNlLCB0aGlzLnZpZXddKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RWwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICAvLyBtYWlubHkgZm9yIHRoZSBwdWJsaWMgQVBJXHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3U2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdGlhbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgZWwuYWRkQ2xhc3MoJ2ZjJyk7XHJcbiAgICAgICAgLy8gZXZlbnQgZGVsZWdhdGlvbiBmb3IgbmF2IGxpbmtzXHJcbiAgICAgICAgZWwub24oJ2NsaWNrLmZjJywgJ2FbZGF0YS1nb3RvXScsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5kYXRhKCdnb3RvJyk7IC8vIHdpbGwgYXV0b21hdGljYWxseSBwYXJzZSBKU09OXHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gX3RoaXMubW9tZW50KGdvdG9PcHRpb25zLmRhdGUpO1xyXG4gICAgICAgICAgICB2YXIgdmlld1R5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSBsaWtlIFwibmF2TGlua0RheUNsaWNrXCIuIG1pZ2h0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXcub3B0KCduYXZMaW5rJyArIHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIodmlld1R5cGUpICsgJ0NsaWNrJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24oZGF0ZSwgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy56b29tVG8oZGF0ZSwgdmlld1R5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnc2V0dGluZ1RoZW1lJywgWyc/dGhlbWUnLCAnP3RoZW1lU3lzdGVtJ10sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZUNsYXNzID0gVGhlbWVSZWdpc3RyeV8xLmRlZmF1bHQuZ2V0VGhlbWVDbGFzcyhvcHRzLnRoZW1lU3lzdGVtIHx8IG9wdHMudGhlbWUpO1xyXG4gICAgICAgICAgICB2YXIgdGhlbWUgPSBuZXcgdGhlbWVDbGFzcyhfdGhpcy5vcHRpb25zTWFuYWdlcik7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXRDbGFzcyA9IHRoZW1lLmdldENsYXNzKCd3aWRnZXQnKTtcclxuICAgICAgICAgICAgX3RoaXMudGhlbWUgPSB0aGVtZTtcclxuICAgICAgICAgICAgaWYgKHdpZGdldENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRDbGFzcyh3aWRnZXRDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3aWRnZXRDbGFzcyA9IF90aGlzLnRoZW1lLmdldENsYXNzKCd3aWRnZXQnKTtcclxuICAgICAgICAgICAgX3RoaXMudGhlbWUgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAod2lkZ2V0Q2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKHdpZGdldENsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIud2F0Y2goJ3NldHRpbmdCdXNpbmVzc0hvdXJHZW5lcmF0b3InLCBbJz9idXNpbmVzc0hvdXJzJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvciA9IG5ldyBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMS5kZWZhdWx0KGRlcHMuYnVzaW5lc3NIb3VycywgX3RoaXMpO1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMudmlldykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy5zZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicsIF90aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvciA9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlLlxyXG4gICAgICAgIC8vIEhBQ0s6IGxvY2FsZSBvZnRlbiBhZmZlY3RzIGlzUlRMLCBzbyB3ZSBleHBsaWNpdGx5IGxpc3RlbiB0byB0aGF0IHRvby5cclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdhcHBseWluZ0RpckNsYXNzZXMnLCBbJz9pc1JUTCcsICc/bG9jYWxlJ10sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIGVsLnRvZ2dsZUNsYXNzKCdmYy1sdHInLCAhb3B0cy5pc1JUTCk7XHJcbiAgICAgICAgICAgIGVsLnRvZ2dsZUNsYXNzKCdmYy1ydGwnLCBvcHRzLmlzUlRMKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbCA9ICQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3LWNvbnRhaW5lcicvPlwiKS5wcmVwZW5kVG8oZWwpO1xyXG4gICAgICAgIHRoaXMuaW5pdFRvb2xiYXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJIZWFkZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckZvb3RlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyh0aGlzLm9wdCgnZGVmYXVsdFZpZXcnKSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdoYW5kbGVXaW5kb3dSZXNpemUnKSkge1xyXG4gICAgICAgICAgICAkKHdpbmRvdykucmVzaXplKHRoaXMud2luZG93UmVzaXplUHJveHkgPSB1dGlsXzEuZGVib3VuY2UoLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dSZXNpemUuYmluZCh0aGlzKSwgdGhpcy5vcHQoJ3dpbmRvd1Jlc2l6ZURlbGF5JykpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3JlbW92ZUVsZW1lbnQnKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZUNsYXNzKCdmYyBmYy1sdHIgZmMtcnRsJyk7XHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGVtZS1yZWxhdGVkIHJvb3QgY2xhc3NOYW1lXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci51bndhdGNoKCdzZXR0aW5nVGhlbWUnKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnVud2F0Y2goJ3NldHRpbmdCdXNpbmVzc0hvdXJHZW5lcmF0b3InKTtcclxuICAgICAgICB0aGlzLmVsLm9mZignLmZjJyk7IC8vIHVuYmluZCBuYXYgbGluayBoYW5kbGVyc1xyXG4gICAgICAgIGlmICh0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KSB7XHJcbiAgICAgICAgICAgICQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplUHJveHkpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQudW5uZWVkZWQoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZWxlbWVudFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuaXMoJzp2aXNpYmxlJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVyIFF1ZXVlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmJpbmRWaWV3SGFuZGxlcnMgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmlldy53YXRjaCgndGl0bGVGb3JDYWxlbmRhcicsIFsndGl0bGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgaWYgKHZpZXcgPT09IF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFRvb2xiYXJzVGl0bGUoZGVwcy50aXRsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2aWV3LndhdGNoKCdkYXRlUHJvZmlsZUZvckNhbGVuZGFyJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBpZiAodmlldyA9PT0gX3RoaXMudmlldykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudERhdGUgPSBkZXBzLmRhdGVQcm9maWxlLmRhdGU7IC8vIG1pZ2h0IGhhdmUgYmVlbiBjb25zdHJhaW5lZCBieSB2aWV3IGRhdGVzXHJcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUb29sYmFyQnV0dG9ucyhkZXBzLmRhdGVQcm9maWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51bmJpbmRWaWV3SGFuZGxlcnMgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIHZpZXcudW53YXRjaCgndGl0bGVGb3JDYWxlbmRhcicpO1xyXG4gICAgICAgIHZpZXcudW53YXRjaCgnZGF0ZVByb2ZpbGVGb3JDYWxlbmRhcicpO1xyXG4gICAgfTtcclxuICAgIC8vIFZpZXcgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpZXcgYmVjYXVzZSBvZiBhIGRhdGUgY2hhbmdlLCB2aWV3LXR5cGUgY2hhbmdlLCBvciBmb3IgdGhlIGZpcnN0IHRpbWUuXHJcbiAgICAvLyBJZiBub3QgZ2l2ZW4gYSB2aWV3VHlwZSwga2VlcCB0aGUgY3VycmVudCB2aWV3IGJ1dCByZW5kZXIgZGlmZmVyZW50IGRhdGVzLlxyXG4gICAgLy8gQWNjZXB0cyBhbiBvcHRpb25hbCBzY3JvbGwgc3RhdGUgdG8gcmVzdG9yZSB0by5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJWaWV3ID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIG9sZFZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG5ld1ZpZXc7XHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgaWYgKG9sZFZpZXcgJiYgdmlld1R5cGUgJiYgb2xkVmlldy50eXBlICE9PSB2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB2aWV3VHlwZSBjaGFuZ2VkLCBvciB0aGUgdmlldyB3YXMgbmV2ZXIgY3JlYXRlZCwgY3JlYXRlIGEgZnJlc2ggdmlld1xyXG4gICAgICAgIGlmICghdGhpcy52aWV3ICYmIHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXcgPSB0aGlzLnZpZXcgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3c0J5VHlwZVt2aWV3VHlwZV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy52aWV3c0J5VHlwZVt2aWV3VHlwZV0gPSB0aGlzLmluc3RhbnRpYXRlVmlldyh2aWV3VHlwZSkpO1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRWaWV3SGFuZGxlcnMobmV3Vmlldyk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXcuc3RhcnRCYXRjaFJlbmRlcigpOyAvLyBzbyB0aGF0IHNldEVsZW1lbnQrc2V0RGF0ZSByZW5kZXJpbmcgYXJlIGpvaW5lZFxyXG4gICAgICAgICAgICBuZXdWaWV3LnNldEVsZW1lbnQoJChcIjxkaXYgY2xhc3M9J2ZjLXZpZXcgZmMtXCIgKyB2aWV3VHlwZSArIFwiLXZpZXcnIC8+XCIpLmFwcGVuZFRvKHRoaXMuY29udGVudEVsKSk7XHJcbiAgICAgICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgnYWN0aXZhdGVCdXR0b24nLCB2aWV3VHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgLy8gcHJldmVudCB1bm5lY2Vzc2FyeSBjaGFuZ2UgZmlyaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuZ2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InKSAhPT0gdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5zZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicsIHRoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2V0RGF0ZSh0aGlzLmN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgaWYgKG5ld1ZpZXcpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZpZXcuc3RvcEJhdGNoUmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aGF3Q29udGVudEhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyB0aGUgY3VycmVudCB2aWV3IGFuZCByZWZsZWN0cyB0aGlzIGNoYW5nZSBpbiB0aGUgSGVhZGVyLlxyXG4gICAgLy8gVW5yZWdzaXRlcnMgdGhlIGB2aWV3YCwgYnV0IGRvZXMgbm90IHJlbW92ZSBmcm9tIHZpZXdCeVR5cGUgaGFzaC5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jbGVhclZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgnZGVhY3RpdmF0ZUJ1dHRvbicsIGN1cnJlbnRWaWV3LnR5cGUpO1xyXG4gICAgICAgIHRoaXMudW5iaW5kVmlld0hhbmRsZXJzKGN1cnJlbnRWaWV3KTtcclxuICAgICAgICBjdXJyZW50Vmlldy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgY3VycmVudFZpZXcudW5zZXREYXRlKCk7IC8vIHNvIGJpbmRWaWV3SGFuZGxlcnMgZG9lc24ndCBmaXJlIHdpdGggb2xkIHZhbHVlcyBuZXh0IHRpbWVcclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIERlc3Ryb3lzIHRoZSB2aWV3LCBpbmNsdWRpbmcgdGhlIHZpZXcgb2JqZWN0LiBUaGVuLCByZS1pbnN0YW50aWF0ZXMgaXQgYW5kIHJlbmRlcnMgaXQuXHJcbiAgICAvLyBNYWludGFpbnMgdGhlIHNhbWUgc2Nyb2xsIHN0YXRlLlxyXG4gICAgLy8gVE9ETzogbWFpbnRhaW4gYW55IG90aGVyIHVzZXItbWFuaXB1bGF0ZWQgc3RhdGUuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVpbml0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb2xkVmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgc2Nyb2xsID0gb2xkVmlldy5xdWVyeVNjcm9sbCgpOyAvLyB3b3VsZG4ndCBiZSBzbyBjb21wbGljYXRlZCBpZiBDYWxlbmRhciBvd25lZCB0aGUgc2Nyb2xsXHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB0aGlzLmNhbGNTaXplKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KG9sZFZpZXcudHlwZSk7IC8vIG5lZWRzIHRoZSB0eXBlIHRvIGZyZXNobHkgcmVuZGVyXHJcbiAgICAgICAgdGhpcy52aWV3LmFwcGx5U2Nyb2xsKHNjcm9sbCk7XHJcbiAgICAgICAgdGhpcy50aGF3Q29udGVudEhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlc2l6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodDtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaXNIZWlnaHRBdXRvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnY29udGVudEhlaWdodCcpID09PSAnYXV0bycgfHwgdGhpcy5vcHQoJ2hlaWdodCcpID09PSAnYXV0byc7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZVZpZXdTaXplID0gZnVuY3Rpb24gKGlzUmVzaXplKSB7XHJcbiAgICAgICAgaWYgKGlzUmVzaXplID09PSB2b2lkIDApIHsgaXNSZXNpemUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBzY3JvbGw7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplICYmIHZpZXcpIHtcclxuICAgICAgICAgICAgaWYgKGlzUmVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGNTaXplKCk7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGwgPSB2aWV3LnF1ZXJ5U2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSsrO1xyXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVNpemUodGhpcy5nZXRTdWdnZXN0ZWRWaWV3SGVpZ2h0KCksIHRoaXMuaXNIZWlnaHRBdXRvKCksIGlzUmVzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZS0tO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcuYXBwbHlTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gc2lnbmFsIHN1Y2Nlc3NcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNhbGNTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FsY1NpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLl9jYWxjU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29udGVudEhlaWdodElucHV0ID0gdGhpcy5vcHQoJ2NvbnRlbnRIZWlnaHQnKTtcclxuICAgICAgICB2YXIgaGVpZ2h0SW5wdXQgPSB0aGlzLm9wdCgnaGVpZ2h0Jyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50SGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGNvbnRlbnRIZWlnaHRJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBjb250ZW50SGVpZ2h0SW5wdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGhlaWdodElucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBoZWlnaHRJbnB1dCAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHRJbnB1dCA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gdGhpcy5lbC5wYXJlbnQoKS5oZWlnaHQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmNvbnRlbnRFbC53aWR0aCgpIC9cclxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHRoaXMub3B0KCdhc3BlY3RSYXRpbycpLCAuNSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUud2luZG93UmVzaXplID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKGV2LnRhcmdldCA9PT0gd2luZG93ICYmIC8vIHNvIHdlIGRvbid0IHByb2Nlc3MganF1aSBcInJlc2l6ZVwiIGV2ZW50cyB0aGF0IGhhdmUgYnViYmxlZCB1cFxyXG4gICAgICAgICAgICB0aGlzLnZpZXcgJiZcclxuICAgICAgICAgICAgdGhpcy52aWV3LmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVWaWV3U2l6ZSh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIFt0aGlzLnZpZXddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBIZWlnaHQgXCJGcmVlemluZ1wiXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZnJlZXplQ29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHREZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlRnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmNzcyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5jb250ZW50RWwuaGVpZ2h0KCksXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS50aGF3Q29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHREZXB0aC0tO1xyXG4gICAgICAgIC8vIGFsd2F5cyBicmluZyBiYWNrIHRvIG5hdHVyYWwgaGVpZ2h0XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6ICcnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcnLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJydcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBidXQgaWYgdGhlcmUgYXJlIGZ1dHVyZSB0aGF3cywgcmUtZnJlZXplXHJcbiAgICAgICAgaWYgKHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRvb2xiYXJcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdFRvb2xiYXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IFRvb2xiYXJfMS5kZWZhdWx0KHRoaXMsIHRoaXMuY29tcHV0ZUhlYWRlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgdGhpcy5mb290ZXIgPSBuZXcgVG9vbGJhcl8xLmRlZmF1bHQodGhpcywgdGhpcy5jb21wdXRlRm9vdGVyT3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlciA9IG5ldyBJdGVyYXRvcl8xLmRlZmF1bHQoW3RoaXMuaGVhZGVyLCB0aGlzLmZvb3Rlcl0pO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wdXRlSGVhZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBleHRyYUNsYXNzZXM6ICdmYy1oZWFkZXItdG9vbGJhcicsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5vcHQoJ2hlYWRlcicpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29tcHV0ZUZvb3Rlck9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZXh0cmFDbGFzc2VzOiAnZmMtZm9vdGVyLXRvb2xiYXInLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMub3B0KCdmb290ZXInKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBIZWFkZXIgd2lsbCByZXJlbmRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckhlYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXI7XHJcbiAgICAgICAgaGVhZGVyLnNldFRvb2xiYXJPcHRpb25zKHRoaXMuY29tcHV0ZUhlYWRlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgaGVhZGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGlmIChoZWFkZXIuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5wcmVwZW5kKGhlYWRlci5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgRm9vdGVyIHdpbGwgcmVyZW5kZXJcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJGb290ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvb3RlciA9IHRoaXMuZm9vdGVyO1xyXG4gICAgICAgIGZvb3Rlci5zZXRUb29sYmFyT3B0aW9ucyh0aGlzLmNvbXB1dGVGb290ZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIGZvb3Rlci5yZW5kZXIoKTtcclxuICAgICAgICBpZiAoZm9vdGVyLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYXBwZW5kKGZvb3Rlci5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZXRUb29sYmFyc1RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCd1cGRhdGVUaXRsZScsIHRpdGxlKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlVG9vbGJhckJ1dHRvbnMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgbm93ID0gdGhpcy5nZXROb3coKTtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgdG9kYXlJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3cpO1xyXG4gICAgICAgIHZhciBwcmV2SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICB2YXIgbmV4dEluZm8gPSB2aWV3LmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dCh2aWV3LmdldCgnZGF0ZVByb2ZpbGUnKSk7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCh0b2RheUluZm8uaXNWYWxpZCAmJiAhZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5jb250YWluc0RhdGUobm93KSkgP1xyXG4gICAgICAgICAgICAnZW5hYmxlQnV0dG9uJyA6XHJcbiAgICAgICAgICAgICdkaXNhYmxlQnV0dG9uJywgJ3RvZGF5Jyk7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKHByZXZJbmZvLmlzVmFsaWQgP1xyXG4gICAgICAgICAgICAnZW5hYmxlQnV0dG9uJyA6XHJcbiAgICAgICAgICAgICdkaXNhYmxlQnV0dG9uJywgJ3ByZXYnKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwobmV4dEluZm8uaXNWYWxpZCA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAnbmV4dCcpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5xdWVyeVRvb2xiYXJzSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xiYXJzTWFuYWdlci5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCB0b29sYmFyKSB7XHJcbiAgICAgICAgICAgIHZhciB0b29sYmFySGVpZ2h0ID0gdG9vbGJhci5lbCA/IHRvb2xiYXIuZWwub3V0ZXJIZWlnaHQodHJ1ZSkgOiAwOyAvLyBpbmNsdWRlcyBtYXJnaW5cclxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgdG9vbGJhckhlaWdodDtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWxlY3Rpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHpvbmVkU3RhcnRJbnB1dCwgem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgIHRoaXMudmlldy5zZWxlY3QodGhpcy5idWlsZFNlbGVjdEZvb3RwcmludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcudW5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYXJndW1lbnRzIHRvIHRoZSBzZWxlY3QgbWV0aG9kIGluIHRoZSBBUEksIHJldHVybnMgYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgaW5mbylcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5idWlsZFNlbGVjdEZvb3RwcmludCA9IGZ1bmN0aW9uICh6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm1vbWVudCh6b25lZFN0YXJ0SW5wdXQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKHpvbmVkRW5kSW5wdXQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5tb21lbnQoem9uZWRFbmRJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgIXN0YXJ0Lmhhc1RpbWUoKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZSBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0TW9tZW50SW50ZXJuYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24nKSk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uJykpO1xyXG4gICAgICAgIC8vIENhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHdoZW4gYW55IG9mIHRoZSBvcHRpb25zIGNoYW5nZS5cclxuICAgICAgICAvLyBIYXBwZW5zIGJlZm9yZSBhbnkgaW50ZXJuYWwgb2JqZWN0cyByZWJ1aWxkIG9yIHJlcmVuZGVyLCBiZWNhdXNlIHRoaXMgaXMgdmVyeSBjb3JlLlxyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIud2F0Y2goJ2J1aWxkaW5nTW9tZW50TG9jYWxlJywgW1xyXG4gICAgICAgICAgICAnP2xvY2FsZScsICc/bW9udGhOYW1lcycsICc/bW9udGhOYW1lc1Nob3J0JywgJz9kYXlOYW1lcycsICc/ZGF5TmFtZXNTaG9ydCcsXHJcbiAgICAgICAgICAgICc/Zmlyc3REYXknLCAnP3dlZWtOdW1iZXJDYWxjdWxhdGlvbidcclxuICAgICAgICBdLCBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgICAgICB2YXIgd2Vla051bWJlckNhbGN1bGF0aW9uID0gb3B0cy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XHJcbiAgICAgICAgICAgIHZhciBmaXJzdERheSA9IG9wdHMuZmlyc3REYXk7XHJcbiAgICAgICAgICAgIHZhciBfd2VlaztcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXplXHJcbiAgICAgICAgICAgIGlmICh3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdpc28nKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSAnSVNPJzsgLy8gbm9ybWFsaXplXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvY2FsZURhdGEgPSBPYmplY3QuY3JlYXRlKC8vIG1ha2UgYSBjaGVhcCBjb3B5XHJcbiAgICAgICAgICAgIGxvY2FsZV8xLmdldE1vbWVudExvY2FsZURhdGEob3B0cy5sb2NhbGUpIC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm1vbnRoTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX21vbnRocyA9IG9wdHMubW9udGhOYW1lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5tb250aE5hbWVzU2hvcnQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX21vbnRoc1Nob3J0ID0gb3B0cy5tb250aE5hbWVzU2hvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdHMuZGF5TmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWtkYXlzID0gb3B0cy5kYXlOYW1lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5kYXlOYW1lc1Nob3J0KSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl93ZWVrZGF5c1Nob3J0ID0gb3B0cy5kYXlOYW1lc1Nob3J0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaXJzdERheSA9PSBudWxsICYmIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0RGF5ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3REYXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3dlZWsgPSBPYmplY3QuY3JlYXRlKGxvY2FsZURhdGEuX3dlZWspOyAvLyBfd2VlazogeyBkb3c6ICMgfVxyXG4gICAgICAgICAgICAgICAgX3dlZWsuZG93ID0gZmlyc3REYXk7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl93ZWVrID0gX3dlZWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycgfHxcclxuICAgICAgICAgICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2xvY2FsJyB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fZnVsbENhbGVuZGFyX3dlZWtDYWxjID0gd2Vla051bWJlckNhbGN1bGF0aW9uOyAvLyBtb21lbnQtZXh0IHdpbGwga25vdyB3aGF0IHRvIGRvIHdpdGggaXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGludGVybmFsIGN1cnJlbnQgZGF0ZSBvYmplY3QgYWxyZWFkeSBleGlzdHMsIG1vdmUgdG8gbmV3IGxvY2FsZS5cclxuICAgICAgICAgICAgLy8gV2UgZG8gTk9UIG5lZWQgdG8gZG8gdGhpcyB0ZWNobmlxdWUgZm9yIGV2ZW50IGRhdGVzLCBiZWNhdXNlIHRoaXMgaGFwcGVucyB3aGVuIGNvbnZlcnRpbmcgdG8gXCJzZWdtZW50c1wiLlxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudERhdGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmxvY2FsaXplTW9tZW50KF90aGlzLmN1cnJlbnREYXRlKTsgLy8gc2V0cyB0byBsb2NhbGVEYXRhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBtb21lbnQgdXNpbmcgdGhlIHNldHRpbmdzIG9mIHRoZSBjdXJyZW50IGNhbGVuZGFyOiB0aW1lem9uZSBhbmQgbG9jYWxlLlxyXG4gICAgLy8gQWNjZXB0cyBhbnl0aGluZyB0aGUgdmFuaWxsYSBtb21lbnQoKSBjb25zdHJ1Y3RvciBhY2NlcHRzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm1vbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1vbTtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ3RpbWV6b25lJykgPT09ICdsb2NhbCcpIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSBtb21lbnQgdG8gYmUgbG9jYWwsIGJlY2F1c2UgbW9tZW50RXh0IGRvZXNuJ3QgZ3VhcmFudGVlIGl0LlxyXG4gICAgICAgICAgICBpZiAobW9tLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgbW9tLmxvY2FsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHQoJ3RpbWV6b25lJykgPT09ICdVVEMnKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yy5hcHBseShudWxsLCBhcmdzKTsgLy8gcHJvY2VzcyBhcyBVVENcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnBhcnNlWm9uZS5hcHBseShudWxsLCBhcmdzKTsgLy8gbGV0IHRoZSBpbnB1dCBkZWNpZGUgdGhlIHpvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbGl6ZU1vbWVudChtb20pOyAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubXNUb01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKG1zKTsgLy8gVE9ETzogb3B0aW1pemUgYnkgdXNpbmcgRGF0ZS5VVENcclxuICAgICAgICBpZiAoZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgbW9tLnN0cmlwVGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tID0gdGhpcy5hcHBseVRpbWV6b25lKG1vbSk7IC8vIG1heSBvciBtYXkgbm90IGFwcGx5IGxvY2FsZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7XHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubXNUb1V0Y01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKG1zKTsgLy8gVE9ETzogb3B0aW1pemUgYnkgdXNpbmcgRGF0ZS5VVENcclxuICAgICAgICBpZiAoZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgbW9tLnN0cmlwVGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7XHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIHRoZSBnaXZlbiBtb21lbnQncyBsb2NhbGUgc2V0dGluZ3MgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIgbG9jYWxlIHNldHRpbmdzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmxvY2FsaXplTW9tZW50ID0gZnVuY3Rpb24gKG1vbSkge1xyXG4gICAgICAgIG1vbS5fbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgb3Igbm90IHRoZSBjYWxlbmRhciBrbm93cyBob3cgdG8gY2FsY3VsYXRlXHJcbiAgICAvLyB0aGUgdGltZXpvbmUgb2Zmc2V0IG9mIGFyYml0cmFyeSBkYXRlcyBpbiB0aGUgY3VycmVudCB0aW1lem9uZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRJc0FtYmlnVGltZXpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCd0aW1lem9uZScpICE9PSAnbG9jYWwnICYmIHRoaXMub3B0KCd0aW1lem9uZScpICE9PSAnVVRDJztcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgY3VycmVudCB0aW1lem9uZS4gSGFzIG5vIGVmZmVjdCBvbiBkYXRlcyB3aXRob3V0IHRpbWVzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmFwcGx5VGltZXpvbmUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIGlmICghZGF0ZS5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHpvbmVkRGF0ZSA9IHRoaXMubW9tZW50KGRhdGUudG9BcnJheSgpKTtcclxuICAgICAgICB2YXIgdGltZUFkanVzdCA9IGRhdGUudGltZSgpIC0gem9uZWREYXRlLnRpbWUoKTtcclxuICAgICAgICB2YXIgYWRqdXN0ZWRab25lZERhdGU7XHJcbiAgICAgICAgLy8gU2FmYXJpIHNvbWV0aW1lcyBoYXMgcHJvYmxlbXMgd2l0aCB0aGlzIGNvZXJzaW9uIHdoZW4gbmVhciBEU1QuIEFkanVzdCBpZiBuZWNlc3NhcnkuIChidWcgIzIzOTYpXHJcbiAgICAgICAgaWYgKHRpbWVBZGp1c3QpIHtcclxuICAgICAgICAgICAgYWRqdXN0ZWRab25lZERhdGUgPSB6b25lZERhdGUuY2xvbmUoKS5hZGQodGltZUFkanVzdCk7IC8vIGFkZCBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgaWYgKGRhdGUudGltZSgpIC0gYWRqdXN0ZWRab25lZERhdGUudGltZSgpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lZERhdGUgPSBhZGp1c3RlZFpvbmVkRGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gem9uZWREYXRlO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBBc3N1bWVzIHRoZSBmb290cHJpbnQgaXMgbm9uLW9wZW4tZW5kZWQuXHJcbiAgICAqL1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBpZ25vcmVFbmQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5zdGFydE1zKTtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIGlmICghaWdub3JlRW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuYXBwbHlUaW1lem9uZShzdGFydCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCwgdGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIG1vbWVudCBmb3IgdGhlIGN1cnJlbnQgZGF0ZSwgYXMgZGVmaW5lZCBieSB0aGUgY2xpZW50J3MgY29tcHV0ZXIgb3IgZnJvbSB0aGUgYG5vd2Agb3B0aW9uLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gYW4gbW9tZW50IHdpdGggYW4gYW1iaWd1b3VzIHRpbWV6b25lLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldE5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbm93ID0gdGhpcy5vcHQoJ25vdycpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygbm93ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG5vdyA9IG5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tb21lbnQobm93KS5zdHJpcFpvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBQcm9kdWNlcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4gICAgLy8gU2lkZS1lZmZlY3Q6IGNoYW5nZXMgdGhlIGxvY2FsZSBvZiB0aGUgZ2l2ZW4gZHVyYXRpb24uXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaHVtYW5pemVEdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5sb2NhbGUodGhpcy5vcHQoJ2xvY2FsZScpKS5odW1hbml6ZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIHdpbGwgcmV0dXJuIGBudWxsYCBpZiBpbnZhbGlkIHJhbmdlXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucGFyc2VVbnpvbmVkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2VJbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGVuZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm1vbWVudChyYW5nZUlucHV0LnN0YXJ0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQuZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubW9tZW50KHJhbmdlSW5wdXQuZW5kKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kICYmIGVuZC5pc0JlZm9yZShzdGFydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudC1EYXRlIFV0aWxpdGllc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0RXZlbnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXJfMS5kZWZhdWx0KHRoaXMpO1xyXG4gICAgICAgIHZhciByYXdTb3VyY2VzID0gdGhpcy5vcHQoJ2V2ZW50U291cmNlcycpIHx8IFtdO1xyXG4gICAgICAgIHZhciBzaW5nbGVSYXdTb3VyY2UgPSB0aGlzLm9wdCgnZXZlbnRzJyk7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XHJcbiAgICAgICAgaWYgKHNpbmdsZVJhd1NvdXJjZSkge1xyXG4gICAgICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQoc2luZ2xlUmF3U291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLm9uKCdyZWxlYXNlJywgZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlcignZXZlbnRzUmVzZXQnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgcmF3U291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyYXdTb3VyY2UpIHtcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShyYXdTb3VyY2UsIF90aGlzKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmFkZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVxdWVzdEV2ZW50cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLnJlcXVlc3RFdmVudHMoc3RhcnQsIGVuZCwgdGhpcy5vcHQoJ3RpbWV6b25lJyksICF0aGlzLm9wdCgnbGF6eUZldGNoaW5nJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEdldCBhbiBldmVudCdzIG5vcm1hbGl6ZWQgZW5kIGRhdGUuIElmIG5vdCBwcmVzZW50LCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZGVmYXVsdHMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQuZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5lbmQuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRFdmVudEVuZChldmVudC5hbGxEYXksIGV2ZW50LnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxyXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXREZWZhdWx0RXZlbnRFbmQgPSBmdW5jdGlvbiAoYWxsRGF5LCB6b25lZFN0YXJ0KSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHpvbmVkU3RhcnQuY2xvbmUoKTtcclxuICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKS5hZGQodGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQuYWRkKHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdldElzQW1iaWdUaW1lem9uZSgpKSB7XHJcbiAgICAgICAgICAgIGVuZC5zdHJpcFpvbmUoKTsgLy8gd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSB0em8gc2hvdWxkIGJlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICB9O1xyXG4gICAgLy8gUHVibGljIEV2ZW50cyBBUElcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVyZW5kZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3LmZsYXNoKCdkaXNwbGF5aW5nRXZlbnRzJyk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlZmV0Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIucmVmZXRjaEFsbFNvdXJjZXMoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50SW5wdXRzLCBpc1N0aWNreSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRJbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFdmVudChldmVudElucHV0c1tpXSwgaXNTdGlja3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50SW5wdXQsIGlzU3RpY2t5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IEV2ZW50RGVmUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShldmVudElucHV0LCBldmVudElucHV0LnNvdXJjZSB8fCBldmVudE1hbmFnZXIuc3RpY2t5U291cmNlKTtcclxuICAgICAgICBpZiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmFkZEV2ZW50RGVmKGV2ZW50RGVmLCBpc1N0aWNreSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGxlZ2FjeVF1ZXJ5IG9wZXJhdGVzIG9uIGxlZ2FjeSBldmVudCBpbnN0YW5jZSBvYmplY3RzXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlRXZlbnRzID0gZnVuY3Rpb24gKGxlZ2FjeVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBsZWdhY3lJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB2YXIgaWRNYXAgPSB7fTtcclxuICAgICAgICB2YXIgZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKGxlZ2FjeVF1ZXJ5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZUFsbEV2ZW50RGVmcyh0cnVlKTsgLy8gcGVyc2lzdD10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdhY3lJbnN0YW5jZXMucHVzaChldmVudEluc3RhbmNlLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVnYWN5SW5zdGFuY2VzID0gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSk7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdW5pcXVlIElEc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVnYWN5SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZiA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50RGVmQnlVaWQobGVnYWN5SW5zdGFuY2VzW2ldLl9pZCk7XHJcbiAgICAgICAgICAgICAgICBpZE1hcFtldmVudERlZi5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICAgICAgZm9yIChpIGluIGlkTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlRXZlbnREZWZzQnlJZChpLCB0cnVlKTsgLy8gcGVyc2lzdD10cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gbGVnYWN5UXVlcnkgb3BlcmF0ZXMgb24gbGVnYWN5IGV2ZW50IGluc3RhbmNlIG9iamVjdHNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jbGllbnRFdmVudHMgPSBmdW5jdGlvbiAobGVnYWN5UXVlcnkpIHtcclxuICAgICAgICB2YXIgbGVnYWN5RXZlbnRJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgbGVnYWN5RXZlbnRJbnN0YW5jZXMucHVzaChldmVudEluc3RhbmNlLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJMZWdhY3lFdmVudEluc3RhbmNlcyhsZWdhY3lFdmVudEluc3RhbmNlcywgbGVnYWN5UXVlcnkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRQcm9wc0FycmF5KSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudFByb3BzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVFdmVudChldmVudFByb3BzQXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50UHJvcHMpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudERlZkJ5VWlkKGV2ZW50UHJvcHMuX2lkKTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAoZXZlbnREZWYgaW5zdGFuY2VvZiBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSA9IGV2ZW50RGVmLmJ1aWxkSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0LmNyZWF0ZUZyb21SYXdQcm9wcyhldmVudEluc3RhbmNlLCBldmVudFByb3BzLCAvLyByYXcgcHJvcHNcclxuICAgICAgICAgICAgbnVsbCAvLyBsYXJnZVVuaXQgLS0gd2hvIHVzZXMgaXQ/XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm11dGF0ZUV2ZW50c1dpdGhJZChldmVudERlZi5pZCwgZXZlbnREZWZNdXRhdGlvbik7IC8vIHdpbGwgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIub3RoZXJTb3VyY2VzLnNsaWNlKCk7IC8vIGNsb25lXHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5nZXRTb3VyY2VCeUlkKEV2ZW50U291cmNlXzEuZGVmYXVsdC5ub3JtYWxpemVJZChpZCkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5hZGRFdmVudFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2VJbnB1dCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucGFyc2Uoc291cmNlSW5wdXQsIHRoaXMpO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkU291cmNlKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoc291cmNlTXVsdGlRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgc291cmNlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc291cmNlTXVsdGlRdWVyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZUFsbFNvdXJjZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNvdXJjZXMgPSBldmVudE1hbmFnZXIubXVsdGlRdWVyeVNvdXJjZXMoc291cmNlTXVsdGlRdWVyeSk7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbW92ZUV2ZW50U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gZXZlbnRNYW5hZ2VyLnF1ZXJ5U291cmNlcyhzb3VyY2VRdWVyeSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlZmV0Y2hFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoc291cmNlTXVsdGlRdWVyeSkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgc291cmNlcyA9IGV2ZW50TWFuYWdlci5tdWx0aVF1ZXJ5U291cmNlcyhzb3VyY2VNdWx0aVF1ZXJ5KTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlZmV0Y2hTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhbGVuZGFyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDYWxlbmRhcjtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKENhbGVuZGFyKTtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhDYWxlbmRhcik7XHJcbmZ1bmN0aW9uIGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUV2ZW50SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSkge1xyXG4gICAgaWYgKGxlZ2FjeVF1ZXJ5ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24obGVnYWN5UXVlcnkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLmZpbHRlcihsZWdhY3lRdWVyeSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZWdhY3lRdWVyeSArPSAnJzsgLy8gbm9ybWFsaXplIHRvIHN0cmluZ1xyXG4gICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGxlZ2FjeUV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgLy8gc29mdCBjb21wYXJpc29uIGJlY2F1c2UgaWQgbm90IGJlIG5vcm1hbGl6ZWQgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlLmlkID09IGxlZ2FjeVF1ZXJ5IHx8XHJcbiAgICAgICAgICAgICAgICBsZWdhY3lFdmVudEluc3RhbmNlLl9pZCA9PT0gbGVnYWN5UXVlcnk7IC8vIGNhbiBzcGVjaWZ5IGludGVybmFsIGlkLCBidXQgbXVzdCBleGFjdGx5IG1hdGNoXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxudmFyIEV2ZW50RGVmUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBDb25zdHJhaW50cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnRzKGV2ZW50TWFuYWdlciwgX2NhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICB9XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXIub3B0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBkZXRlcm1pbmVzIGlmIGV2ZW50SW5zdGFuY2VHcm91cCBpcyBhbGxvd2VkLFxyXG4gICAgaW4gcmVsYXRpb24gdG8gb3RoZXIgRVZFTlRTIGFuZCBidXNpbmVzcyBob3Vycy5cclxuICAgICovXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50SW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEFsbEV2ZW50UmFuZ2VzKCkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRJbnN0YW5jZXMgPSB0aGlzLmdldFBlZXJFdmVudEluc3RhbmNlcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudFJhbmdlcyA9IHBlZXJFdmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRWYWwgPSBldmVudERlZi5nZXRDb25zdHJhaW50KCk7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBWYWwgPSBldmVudERlZi5nZXRPdmVybGFwKCk7XHJcbiAgICAgICAgdmFyIGV2ZW50QWxsb3dGdW5jID0gdGhpcy5vcHQoJ2V2ZW50QWxsb3cnKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zvb3RwcmludEFsbG93ZWQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCwgcGVlckV2ZW50Rm9vdHByaW50cywgY29uc3RyYWludFZhbCwgb3ZlcmxhcFZhbCwgZXZlbnRGb290cHJpbnRzW2ldLmV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50QWxsb3dGdW5jKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudEFsbG93RnVuYyhldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnRvTGVnYWN5KHRoaXMuX2NhbGVuZGFyKSwgZXZlbnRGb290cHJpbnRzW2ldLmdldEV2ZW50TGVnYWN5KCkpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZ2V0UGVlckV2ZW50SW5zdGFuY2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkKGV2ZW50RGVmLmlkKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlcygpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRSYW5nZXMgPSBwZWVyRXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhwZWVyRXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWxlY3RBbGxvd0Z1bmM7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGb290cHJpbnRBbGxvd2VkKGNvbXBvbmVudEZvb3RwcmludCwgcGVlckV2ZW50Rm9vdHByaW50cywgdGhpcy5vcHQoJ3NlbGVjdENvbnN0cmFpbnQnKSwgdGhpcy5vcHQoJ3NlbGVjdE92ZXJsYXAnKSkpIHtcclxuICAgICAgICAgICAgc2VsZWN0QWxsb3dGdW5jID0gdGhpcy5vcHQoJ3NlbGVjdEFsbG93Jyk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RBbGxvd0Z1bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RBbGxvd0Z1bmMoY29tcG9uZW50Rm9vdHByaW50LnRvTGVnYWN5KHRoaXMuX2NhbGVuZGFyKSkgIT09IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc0Zvb3RwcmludEFsbG93ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCBjb25zdHJhaW50VmFsLCBvdmVybGFwVmFsLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSAvLyBvcHRpb25hbFxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRGb290cHJpbnRzOyAvLyBDb21wb25lbnRGb290cHJpbnRbXVxyXG4gICAgICAgIHZhciBvdmVybGFwRXZlbnRGb290cHJpbnRzOyAvLyBFdmVudEZvb3RwcmludFtdXHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRWYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50Rm9vdHByaW50cyA9IHRoaXMuY29uc3RyYWludFZhbFRvRm9vdHByaW50cyhjb25zdHJhaW50VmFsLCBjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGb290cHJpbnRXaXRoaW5Db25zdHJhaW50cyhjb21wb25lbnRGb290cHJpbnQsIGNvbnN0cmFpbnRGb290cHJpbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG92ZXJsYXBFdmVudEZvb3RwcmludHMgPSB0aGlzLmNvbGxlY3RPdmVybGFwRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudEZvb3RwcmludHMsIGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBWYWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwRXZlbnRGb290cHJpbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvdmVybGFwVmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNPdmVybGFwc0FsbG93ZWRCeUZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgb3ZlcmxhcFZhbCwgc3ViamVjdEV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1YmplY3RFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNPdmVybGFwRXZlbnRJbnN0YW5jZXNBbGxvd2VkKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIHN1YmplY3RFdmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8vIENvbnN0cmFpbnRcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzRm9vdHByaW50V2l0aGluQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBjb25zdHJhaW50Rm9vdHByaW50cykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdHJhaW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb290cHJpbnRDb250YWluc0Zvb3RwcmludChjb25zdHJhaW50Rm9vdHByaW50c1tpXSwgY29tcG9uZW50Rm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5jb25zdHJhaW50VmFsVG9Gb290cHJpbnRzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRWYWwsIGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzO1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50VmFsID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDdXJyZW50QnVzaW5lc3NGb290cHJpbnRzKGlzQWxsRGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnN0cmFpbnRWYWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzID0gdGhpcy5wYXJzZUV2ZW50RGVmVG9JbnN0YW5jZXMoY29uc3RyYWludFZhbCk7IC8vIGhhbmRsZXMgcmVjdXJyaW5nIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvb3RwcmludHMoY29uc3RyYWludFZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyhldmVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uc3RyYWludFZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQoY29uc3RyYWludFZhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzKGV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gcmV0dXJucyBDb21wb25lbnRGb290cHJpbnRbXVxyXG4gICAgLy8gdXNlcyBjdXJyZW50IHZpZXcncyByYW5nZVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmJ1aWxkQ3VycmVudEJ1c2luZXNzRm9vdHByaW50cyA9IGZ1bmN0aW9uIChpc0FsbERheSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fY2FsZW5kYXIudmlldztcclxuICAgICAgICB2YXIgYnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gdmlldy5nZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicpO1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSB2aWV3LmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gYnVzaW5lc3NIb3VyR2VuZXJhdG9yLmJ1aWxkRXZlbnRJbnN0YW5jZUdyb3VwKGlzQWxsRGF5LCB1bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY29udmVyc2lvbiB1dGlsXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRSYW5nZXMgPSBldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHMubWFwKHV0aWxfMS5ldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgIH07XHJcbiAgICAvLyBPdmVybGFwXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5jb2xsZWN0T3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChwZWVyRXZlbnRGb290cHJpbnRzLCB0YXJnZXRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwZWVyRXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3RwcmludHNJbnRlcnNlY3QodGFyZ2V0Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJsYXBFdmVudEZvb3RwcmludHMucHVzaChwZWVyRXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3ZlcmxhcEV2ZW50Rm9vdHByaW50cztcclxuICAgIH07XHJcbiAgICAvLyBDb252ZXJzaW9uOiBldmVudERlZnMgLT4gZXZlbnRJbnN0YW5jZXMgLT4gZXZlbnRSYW5nZXMgLT4gZXZlbnRGb290cHJpbnRzIC0+IGNvbXBvbmVudEZvb3RwcmludHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gTk9URTogdGhpcyBtaWdodCBzZWVtIGxpa2UgcmVwZXRpdGl2ZSBjb2RlIHdpdGggdGhlIEdyaWQgY2xhc3MsIGhvd2V2ZXIsIHRoaXMgY29kZSBpcyByZWxhdGVkIHRvXHJcbiAgICAvLyBjb25zdHJhaW50cyB3aGVyZWFzIHRoZSBHcmlkIGNvZGUgaXMgcmVsYXRlZCB0byByZW5kZXJpbmcuIEVhY2ggYXBwcm9hY2ggbWlnaHQgd2FudCB0byBjb252ZXJ0XHJcbiAgICAvLyBldmVudFJhbmdlcyAtPiBldmVudEZvb3RwcmludHMgaW4gYSBkaWZmZXJlbnQgd2F5LiBSZWdhcmRsZXNzLCB0aGVyZSBhcmUgb3Bwb3J0dW5pdGllcyB0byBtYWtlXHJcbiAgICAvLyB0aGlzIG1vcmUgRFJZLlxyXG4gICAgLypcclxuICAgIFJldHVybnMgZmFsc2Ugb24gaW52YWxpZCBpbnB1dC5cclxuICAgICovXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUucGFyc2VFdmVudERlZlRvSW5zdGFuY2VzID0gZnVuY3Rpb24gKGV2ZW50SW5wdXQpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIG5ldyBFdmVudFNvdXJjZV8xLmRlZmF1bHQodGhpcy5fY2FsZW5kYXIpKTtcclxuICAgICAgICBpZiAoIWV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50RGVmLmJ1aWxkSW5zdGFuY2VzKGV2ZW50TWFuYWdlci5jdXJyZW50UGVyaW9kLnVuem9uZWRSYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50UmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50Rm9vdHByaW50cy5wdXNoLmFwcGx5KC8vIGZvb3RwcmludHNcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLCB0aGlzLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRGb290cHJpbnRzO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBbdXRpbF8xLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50KGV2ZW50UmFuZ2UpXTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUGFyc2VzIGZvb3RwcmludHMgZGlyZWN0bHkuXHJcbiAgICBWZXJ5IHNpbWlsYXIgdG8gRXZlbnREYXRlUHJvZmlsZTo6cGFyc2UgOihcclxuICAgICovXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUucGFyc2VGb290cHJpbnRzID0gZnVuY3Rpb24gKHJhd0lucHV0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0LCBlbmQ7XHJcbiAgICAgICAgaWYgKHJhd0lucHV0LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY2FsZW5kYXIubW9tZW50KHJhd0lucHV0LnN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKCFzdGFydC5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3SW5wdXQuZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuX2NhbGVuZGFyLm1vbWVudChyYXdJbnB1dC5lbmQpO1xyXG4gICAgICAgICAgICBpZiAoIWVuZC5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCksIChzdGFydCAmJiAhc3RhcnQuaGFzVGltZSgpKSB8fCAoZW5kICYmICFlbmQuaGFzVGltZSgpKSAvLyBpc0FsbERheVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcbiAgICAvLyBGb290cHJpbnQgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5mb290cHJpbnRDb250YWluc0Zvb3RwcmludCA9IGZ1bmN0aW9uIChvdXRlckZvb3RwcmludCwgaW5uZXJGb290cHJpbnQpIHtcclxuICAgICAgICByZXR1cm4gb3V0ZXJGb290cHJpbnQudW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoaW5uZXJGb290cHJpbnQudW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZm9vdHByaW50c0ludGVyc2VjdCA9IGZ1bmN0aW9uIChmb290cHJpbnQwLCBmb290cHJpbnQxKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvb3RwcmludDAudW56b25lZFJhbmdlLmludGVyc2VjdHNXaXRoKGZvb3RwcmludDEudW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29uc3RyYWludHM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbnN0cmFpbnRzO1xyXG4vLyBvcHRpb25hbCBzdWJqZWN0RXZlbnRJbnN0YW5jZVxyXG5mdW5jdGlvbiBpc092ZXJsYXBzQWxsb3dlZEJ5RnVuYyhvdmVybGFwRXZlbnRGb290cHJpbnRzLCBvdmVybGFwRnVuYywgc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG92ZXJsYXBFdmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIW92ZXJsYXBGdW5jKG92ZXJsYXBFdmVudEZvb3RwcmludHNbaV0uZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSA/IHN1YmplY3RFdmVudEluc3RhbmNlLnRvTGVnYWN5KCkgOiBudWxsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gaXNPdmVybGFwRXZlbnRJbnN0YW5jZXNBbGxvd2VkKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIHN1YmplY3RFdmVudEluc3RhbmNlKSB7XHJcbiAgICB2YXIgc3ViamVjdExlZ2FjeUluc3RhbmNlID0gc3ViamVjdEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIG92ZXJsYXBFdmVudEluc3RhbmNlO1xyXG4gICAgdmFyIG92ZXJsYXBFdmVudERlZjtcclxuICAgIHZhciBvdmVybGFwVmFsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG92ZXJsYXBFdmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBvdmVybGFwRXZlbnRJbnN0YW5jZSA9IG92ZXJsYXBFdmVudEZvb3RwcmludHNbaV0uZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICBvdmVybGFwRXZlbnREZWYgPSBvdmVybGFwRXZlbnRJbnN0YW5jZS5kZWY7XHJcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBwYXNzIGluIGNhbGVuZGFyLCBiZWNhdXNlIGRvbid0IHdhbnQgdG8gY29uc2lkZXIgZ2xvYmFsIGV2ZW50T3ZlcmxhcCBwcm9wZXJ0eSxcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFscmVhZHkgY29uc2lkZXJlZCB0aGF0IGVhcmxpZXIgaW4gdGhlIHByb2Nlc3MuXHJcbiAgICAgICAgb3ZlcmxhcFZhbCA9IG92ZXJsYXBFdmVudERlZi5nZXRPdmVybGFwKCk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBWYWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG92ZXJsYXBWYWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFvdmVybGFwVmFsKG92ZXJsYXBFdmVudEluc3RhbmNlLnRvTGVnYWN5KCksIHN1YmplY3RMZWdhY3lJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8qXHJcblVTQUdFOlxyXG4gICAgaW1wb3J0IHsgZGVmYXVsdCBhcyBQYXJzYWJsZU1vZGVsTWl4aW4sIFBhcnNhYmxlTW9kZWxJbnRlcmZhY2UgfSBmcm9tICcuL1BhcnNhYmxlTW9kZWxNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgICBhcHBseVByb3BzOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydhcHBseVByb3BzJ11cclxuICAgIGFwcGx5TWFudWFsU3RhbmRhcmRQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzJ11cclxuICAgIGFwcGx5TWlzY1Byb3BzOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydhcHBseU1pc2NQcm9wcyddXHJcbiAgICBpc1N0YW5kYXJkUHJvcDogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnaXNTdGFuZGFyZFByb3AnXVxyXG4gICAgc3RhdGljIGRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wc1xyXG4gICAgc3RhdGljIGNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW4uY29weVZlcmJhdGltU3RhbmRhcmRQcm9wc1xyXG5hZnRlciBjbGFzczpcclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQYXJzYWJsZU1vZGVsTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQYXJzYWJsZU1vZGVsTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFJldHVybnMgdHJ1ZS9mYWxzZSBmb3Igc3VjY2Vzcy5cclxuICAgIE1lYW50IHRvIGJlIG9ubHkgY2FsbGVkIE9OQ0UsIGF0IG9iamVjdCBjcmVhdGlvbi5cclxuICAgICovXHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLmFwcGx5UHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wTWFwID0gdGhpcy5zdGFuZGFyZFByb3BNYXA7XHJcbiAgICAgICAgdmFyIG1hbnVhbFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIG1pc2NQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZFByb3BNYXBbcHJvcE5hbWVdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdGFuZGFyZFByb3BNYXBbcHJvcE5hbWVdID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgbWFudWFsUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWlzY1Byb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFwcGx5TWlzY1Byb3BzKG1pc2NQcm9wcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzKG1hbnVhbFByb3BzKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgSWYgc3ViY2xhc3NlcyBvdmVycmlkZSwgdGhleSBtdXN0IGNhbGwgdGhpcyBzdXBlcm1ldGhvZCBhbmQgcmV0dXJuIHRoZSBib29sZWFuIHJlc3BvbnNlLlxyXG4gICAgTWVhbnQgdG8gYmUgb25seSBjYWxsZWQgT05DRSwgYXQgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIENhbiBiZSBjYWxsZWQgZXZlbiBhZnRlciBpbml0aWFsIG9iamVjdCBjcmVhdGlvbi5cclxuICAgICovXHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLmFwcGx5TWlzY1Byb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIFRPRE86IHdoeSBpcyB0aGlzIGEgbWV0aG9kIHdoZW4gZGVmaW5lU3RhbmRhcmRQcm9wcyBpcyBzdGF0aWNcclxuICAgICovXHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLmlzU3RhbmRhcmRQcm9wID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BOYW1lIGluIHRoaXMuc3RhbmRhcmRQcm9wTWFwO1xyXG4gICAgfTtcclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5kZWZpbmVTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHByb3BEZWZzKSB7XHJcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGU7XHJcbiAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnc3RhbmRhcmRQcm9wTWFwJykpIHtcclxuICAgICAgICAgICAgcHJvdG8uc3RhbmRhcmRQcm9wTWFwID0gT2JqZWN0LmNyZWF0ZShwcm90by5zdGFuZGFyZFByb3BNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1dGlsXzEuY29weU93blByb3BzKHByb3BEZWZzLCBwcm90by5zdGFuZGFyZFByb3BNYXApO1xyXG4gICAgfTtcclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHNyYywgZGVzdCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLnByb3RvdHlwZS5zdGFuZGFyZFByb3BNYXA7XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gbWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChzcmNbcHJvcE5hbWVdICE9IG51bGwgJiYgLy8gaW4gdGhlIHNyYyBvYmplY3Q/XHJcbiAgICAgICAgICAgICAgICBtYXBbcHJvcE5hbWVdID09PSB0cnVlIC8vIGZhbHNlIG1lYW5zIFwiY29weSB2ZXJiYXRpbVwiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtwcm9wTmFtZV0gPSBzcmNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBQYXJzYWJsZU1vZGVsTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBhcnNhYmxlTW9kZWxNaXhpbjtcclxuUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5zdGFuZGFyZFByb3BNYXAgPSB7fTsgLy8gd2lsbCBiZSBjbG9uZWQgYnkgZGVmaW5lU3RhbmRhcmRQcm9wc1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudEluc3RhbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRJbnN0YW5jZShkZWYsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kZWYgPSBkZWY7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgfVxyXG4gICAgRXZlbnRJbnN0YW5jZS5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5kZWYudG9MZWdhY3koKTtcclxuICAgICAgICBvYmouc3RhcnQgPSBkYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIG9iai5lbmQgPSBkYXRlUHJvZmlsZS5lbmQgPyBkYXRlUHJvZmlsZS5lbmQuY2xvbmUoKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRJbnN0YW5jZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRJbnN0YW5jZTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbnZhciBFdmVudEluc3RhbmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgUmVjdXJyaW5nRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWN1cnJpbmdFdmVudERlZiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlY3VycmluZ0V2ZW50RGVmKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5pc0FsbERheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuc3RhcnRUaW1lICYmICF0aGlzLmVuZFRpbWU7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmJ1aWxkSW5zdGFuY2VzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuc291cmNlLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB1bnpvbmVkRGF0ZSA9IHVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciB1bnpvbmVkRW5kID0gdW56b25lZFJhbmdlLmdldEVuZCgpO1xyXG4gICAgICAgIHZhciB6b25lZERheVN0YXJ0O1xyXG4gICAgICAgIHZhciBpbnN0YW5jZVN0YXJ0LCBpbnN0YW5jZUVuZDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgd2hpbGUgKHVuem9uZWREYXRlLmlzQmVmb3JlKHVuem9uZWRFbmQpKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvd0hhc2ggfHwgdGhpcy5kb3dIYXNoW3Vuem9uZWREYXRlLmRheSgpXSkge1xyXG4gICAgICAgICAgICAgICAgem9uZWREYXlTdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUodW56b25lZERhdGUpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IHpvbmVkRGF5U3RhcnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRW5kID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQudGltZSh0aGlzLnN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kVGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlRW5kID0gem9uZWREYXlTdGFydC5jbG9uZSgpLnRpbWUodGhpcy5lbmRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKG5ldyBFdmVudEluc3RhbmNlXzEuZGVmYXVsdCh0aGlzLCAvLyBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQoaW5zdGFuY2VTdGFydCwgaW5zdGFuY2VFbmQsIGNhbGVuZGFyKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVuem9uZWREYXRlLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzO1xyXG4gICAgfTtcclxuICAgIFJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5zZXREb3cgPSBmdW5jdGlvbiAoZG93TnVtYmVycykge1xyXG4gICAgICAgIGlmICghdGhpcy5kb3dIYXNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG93SGFzaCA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvd051bWJlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5kb3dIYXNoW2Rvd051bWJlcnNbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWYgPSBfc3VwZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKGRlZi5zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgZGVmLnN0YXJ0VGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLnN0YXJ0VGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWYuZW5kVGltZSkge1xyXG4gICAgICAgICAgICBkZWYuZW5kVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLmVuZFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kb3dIYXNoKSB7XHJcbiAgICAgICAgICAgIGRlZi5kb3dIYXNoID0gJC5leHRlbmQoe30sIHRoaXMuZG93SGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlY3VycmluZ0V2ZW50RGVmO1xyXG59KEV2ZW50RGVmXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZWN1cnJpbmdFdmVudERlZjtcclxuLypcclxuSEFDSyB0byB3b3JrIHdpdGggVHlwZVNjcmlwdCBtaXhpbnNcclxuTk9URTogaWYgc3VwZXItbWV0aG9kIGZhaWxzLCBzaG91bGQgc3RpbGwgYXR0ZW1wdCB0byBhcHBseVxyXG4qL1xyXG5SZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgdmFyIHN1cGVyU3VjY2VzcyA9IEV2ZW50RGVmXzEuZGVmYXVsdC5wcm90b3R5cGUuYXBwbHlQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgIGlmIChyYXdQcm9wcy5zdGFydCkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHJhd1Byb3BzLnN0YXJ0KTtcclxuICAgIH1cclxuICAgIGlmIChyYXdQcm9wcy5lbmQpIHtcclxuICAgICAgICB0aGlzLmVuZFRpbWUgPSBtb21lbnQuZHVyYXRpb24ocmF3UHJvcHMuZW5kKTtcclxuICAgIH1cclxuICAgIGlmIChyYXdQcm9wcy5kb3cpIHtcclxuICAgICAgICB0aGlzLnNldERvdyhyYXdQcm9wcy5kb3cpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cGVyU3VjY2VzcztcclxufTtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuUmVjdXJyaW5nRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICBzdGFydDogZmFsc2UsXHJcbiAgICBlbmQ6IGZhbHNlLFxyXG4gICAgZG93OiBmYWxzZVxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UmFuZ2UodW56b25lZFJhbmdlLCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdW56b25lZFJhbmdlO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWYgPSBldmVudERlZjtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBFdmVudFJhbmdlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFJhbmdlO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUyA9IHtcclxuICAgIHN0YXJ0OiAnMDk6MDAnLFxyXG4gICAgZW5kOiAnMTc6MDAnLFxyXG4gICAgZG93OiBbMSwgMiwgMywgNCwgNV0sXHJcbiAgICByZW5kZXJpbmc6ICdpbnZlcnNlLWJhY2tncm91bmQnXHJcbiAgICAvLyBjbGFzc05hbWVzIGFyZSBkZWZpbmVkIGluIGJ1c2luZXNzSG91cnNTZWdDbGFzc2VzXHJcbn07XHJcbnZhciBCdXNpbmVzc0hvdXJHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCdXNpbmVzc0hvdXJHZW5lcmF0b3IocmF3Q29tcGxleERlZiwgY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLnJhd0NvbXBsZXhEZWYgPSByYXdDb21wbGV4RGVmO1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgIH1cclxuICAgIEJ1c2luZXNzSG91ckdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAgPSBmdW5jdGlvbiAoaXNBbGxEYXksIHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSB0aGlzLmJ1aWxkRXZlbnREZWZzKGlzQWxsRGF5KTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgIGlmIChldmVudERlZnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cCA9IG5ldyBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0KHV0aWxfMS5ldmVudERlZnNUb0V2ZW50SW5zdGFuY2VzKGV2ZW50RGVmcywgdW56b25lZFJhbmdlKSk7XHJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgaW52ZXJzZS1iYWNrZ3JvdW5kIHJlbmRlcmluZyBjYW4gaGFwcGVuIGV2ZW4gd2hlbiBubyBldmVudFJhbmdlcyBpbiB2aWV3XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cC5leHBsaWNpdEV2ZW50RGVmID0gZXZlbnREZWZzWzBdO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRXZlbnREZWZzID0gZnVuY3Rpb24gKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHJhd0NvbXBsZXhEZWYgPSB0aGlzLnJhd0NvbXBsZXhEZWY7XHJcbiAgICAgICAgdmFyIHJhd0RlZnMgPSBbXTtcclxuICAgICAgICB2YXIgcmVxdWlyZURvdyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkZWZzID0gW107XHJcbiAgICAgICAgaWYgKHJhd0NvbXBsZXhEZWYgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMgdmVyYmF0aW1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHJhd0NvbXBsZXhEZWYpKSB7XHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBbcmF3Q29tcGxleERlZl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNBcnJheShyYXdDb21wbGV4RGVmKSkge1xyXG4gICAgICAgICAgICByYXdEZWZzID0gcmF3Q29tcGxleERlZjtcclxuICAgICAgICAgICAgcmVxdWlyZURvdyA9IHRydWU7IC8vIGV2ZXJ5IHN1Yi1kZWZpbml0aW9uIE5FRURTIGEgZGF5LW9mLXdlZWtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhd0RlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFyZXF1aXJlRG93IHx8IHJhd0RlZnNbaV0uZG93KSB7XHJcbiAgICAgICAgICAgICAgICBkZWZzLnB1c2godGhpcy5idWlsZEV2ZW50RGVmKGlzQWxsRGF5LCByYXdEZWZzW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZnM7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEV2ZW50RGVmID0gZnVuY3Rpb24gKGlzQWxsRGF5LCByYXdEZWYpIHtcclxuICAgICAgICB2YXIgZnVsbFJhd0RlZiA9ICQuZXh0ZW5kKHt9LCBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTLCByYXdEZWYpO1xyXG4gICAgICAgIGlmIChpc0FsbERheSkge1xyXG4gICAgICAgICAgICBmdWxsUmF3RGVmLnN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgZnVsbFJhd0RlZi5lbmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGZ1bGxSYXdEZWYsIG5ldyBFdmVudFNvdXJjZV8xLmRlZmF1bHQodGhpcy5jYWxlbmRhcikgLy8gZHVtbXkgc291cmNlXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnVzaW5lc3NIb3VyR2VuZXJhdG9yO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCdXNpbmVzc0hvdXJHZW5lcmF0b3I7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFyZFRoZW1lO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAnZmMtdW50aGVtZWQnLFxyXG4gICAgd2lkZ2V0SGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICB3aWRnZXRDb250ZW50OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uJyxcclxuICAgIGNvcm5lckxlZnQ6ICdmYy1jb3JuZXItbGVmdCcsXHJcbiAgICBjb3JuZXJSaWdodDogJ2ZjLWNvcm5lci1yaWdodCcsXHJcbiAgICBzdGF0ZURlZmF1bHQ6ICdmYy1zdGF0ZS1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnZmMtc3RhdGUtYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdmYy1zdGF0ZS1kaXNhYmxlZCcsXHJcbiAgICBzdGF0ZUhvdmVyOiAnZmMtc3RhdGUtaG92ZXInLFxyXG4gICAgc3RhdGVEb3duOiAnZmMtc3RhdGUtZG93bicsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIGRheVJvdzogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICdmYy13aWRnZXQtY29udGVudCdcclxufTtcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ2ZjLWljb24teCcsXHJcbiAgICBwcmV2OiAnZmMtaWNvbi1sZWZ0LXNpbmdsZS1hcnJvdycsXHJcbiAgICBuZXh0OiAnZmMtaWNvbi1yaWdodC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWxlZnQtZG91YmxlLWFycm93JyxcclxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1yaWdodC1kb3VibGUtYXJyb3cnXHJcbn07XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucyc7XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcbnZhciBKcXVlcnlVaVRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSnF1ZXJ5VWlUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEpxdWVyeVVpVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEpxdWVyeVVpVGhlbWU7XHJcbn0oVGhlbWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEpxdWVyeVVpVGhlbWU7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICd1aS13aWRnZXQnLFxyXG4gICAgd2lkZ2V0SGVhZGVyOiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICB3aWRnZXRDb250ZW50OiAndWktd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAndWktYnV0dG9uJyxcclxuICAgIGNvcm5lckxlZnQ6ICd1aS1jb3JuZXItbGVmdCcsXHJcbiAgICBjb3JuZXJSaWdodDogJ3VpLWNvcm5lci1yaWdodCcsXHJcbiAgICBzdGF0ZURlZmF1bHQ6ICd1aS1zdGF0ZS1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAndWktc3RhdGUtYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICd1aS1zdGF0ZS1kaXNhYmxlZCcsXHJcbiAgICBzdGF0ZUhvdmVyOiAndWktc3RhdGUtaG92ZXInLFxyXG4gICAgc3RhdGVEb3duOiAndWktc3RhdGUtZG93bicsXHJcbiAgICB0b2RheTogJ3VpLXN0YXRlLWhpZ2hsaWdodCcsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICd1aS13aWRnZXQtaGVhZGVyJyxcclxuICAgIGRheVJvdzogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICd1aS13aWRnZXQtY29udGVudCdcclxufTtcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICd1aS1pY29uJztcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ3VpLWljb24tY2xvc2V0aGljaycsXHJcbiAgICBwcmV2OiAndWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtdycsXHJcbiAgICBuZXh0OiAndWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtZScsXHJcbiAgICBwcmV2WWVhcjogJ3VpLWljb24tc2Vlay1wcmV2JyxcclxuICAgIG5leHRZZWFyOiAndWktaWNvbi1zZWVrLW5leHQnXHJcbn07XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICd0aGVtZUJ1dHRvbkljb25zJztcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ3RoZW1lSWNvbic7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICd1aS1pY29uLSc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRnVuY0V2ZW50U291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRnVuY0V2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRnVuY0V2ZW50U291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIucHVzaExvYWRpbmcoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQuY29uc3RydWN0KGZ1bmN0aW9uIChvblJlc29sdmUpIHtcclxuICAgICAgICAgICAgX3RoaXMuZnVuYy5jYWxsKF90aGlzLmNhbGVuZGFyLCBzdGFydC5jbG9uZSgpLCBlbmQuY2xvbmUoKSwgdGltZXpvbmUsIGZ1bmN0aW9uIChyYXdFdmVudERlZnMpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIG9uUmVzb2x2ZShfdGhpcy5wYXJzZUV2ZW50RGVmcyhyYXdFdmVudERlZnMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRnVuY0V2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYztcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB0aGlzLmZ1bmMgPSByYXdQcm9wcy5ldmVudHM7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyU3VjY2VzcztcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHJhd0lucHV0LmV2ZW50cykpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgZXZlbnRzOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRnVuY0V2ZW50U291cmNlO1xyXG59KEV2ZW50U291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGdW5jRXZlbnRTb3VyY2U7XHJcbkZ1bmNFdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIGV2ZW50czogZmFsc2UgLy8gZG9uJ3QgYXV0b21hdGljYWxseSB0cmFuc2ZlclxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEpzb25GZWVkRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBKc29uRmVlZEV2ZW50U291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYWpheFNldHRpbmdzID0gdGhpcy5hamF4U2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIG9uU3VjY2VzcyA9IGFqYXhTZXR0aW5ncy5zdWNjZXNzO1xyXG4gICAgICAgIHZhciBvbkVycm9yID0gYWpheFNldHRpbmdzLmVycm9yO1xyXG4gICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gdGhpcy5idWlsZFJlcXVlc3RQYXJhbXMoc3RhcnQsIGVuZCwgdGltZXpvbmUpO1xyXG4gICAgICAgIC8vIHRvZG86IGV2ZW50dWFsbHkgaGFuZGxlIHRoZSBwcm9taXNlJ3MgdGhlbixcclxuICAgICAgICAvLyBkb24ndCBpbnRlcmNlcHQgc3VjY2Vzcy9lcnJvclxyXG4gICAgICAgIC8vIHRobyB3aWxsIGJlIGEgYnJlYWtpbmcgQVBJIGNoYW5nZVxyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIucHVzaExvYWRpbmcoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQuY29uc3RydWN0KGZ1bmN0aW9uIChvblJlc29sdmUsIG9uUmVqZWN0KSB7XHJcbiAgICAgICAgICAgICQuYWpheCgkLmV4dGVuZCh7fSwgLy8gZGVzdGluYXRpb25cclxuICAgICAgICAgICAgSnNvbkZlZWRFdmVudFNvdXJjZS5BSkFYX0RFRkFVTFRTLCBhamF4U2V0dGluZ3MsIHtcclxuICAgICAgICAgICAgICAgIHVybDogX3RoaXMudXJsLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyYXdFdmVudERlZnMsIHN0YXR1cywgeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrUmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrUmVzID0gdXRpbF8xLmFwcGx5QWxsKG9uU3VjY2VzcywgX3RoaXMsIFtyYXdFdmVudERlZnMsIHN0YXR1cywgeGhyXSk7IC8vIHJlZGlyZWN0IGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGNhbGxiYWNrUmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnREZWZzID0gY2FsbGJhY2tSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNvbHZlKF90aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMsIHhocikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXBwbHlBbGwob25FcnJvciwgX3RoaXMsIFtkYXRhLCBzdGF0dXMsIHhocl0pOyAvLyByZWRpcmVjdCBgdGhpc2BcclxuICAgICAgICAgICAgICAgICAgICBvblJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuYnVpbGRSZXF1ZXN0UGFyYW1zID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgYWpheFNldHRpbmdzID0gdGhpcy5hamF4U2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIHN0YXJ0UGFyYW0sIGVuZFBhcmFtLCB0aW1lem9uZVBhcmFtO1xyXG4gICAgICAgIHZhciBjdXN0b21SZXF1ZXN0UGFyYW1zO1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcclxuICAgICAgICBzdGFydFBhcmFtID0gdGhpcy5zdGFydFBhcmFtO1xyXG4gICAgICAgIGlmIChzdGFydFBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhcnRQYXJhbSA9IGNhbGVuZGFyLm9wdCgnc3RhcnRQYXJhbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmRQYXJhbSA9IHRoaXMuZW5kUGFyYW07XHJcbiAgICAgICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgZW5kUGFyYW0gPSBjYWxlbmRhci5vcHQoJ2VuZFBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWV6b25lUGFyYW0gPSB0aGlzLnRpbWV6b25lUGFyYW07XHJcbiAgICAgICAgaWYgKHRpbWV6b25lUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aW1lem9uZVBhcmFtID0gY2FsZW5kYXIub3B0KCd0aW1lem9uZVBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHJpZXZlIGFueSBvdXRib3VuZCBHRVQvUE9TVCAkLmFqYXggZGF0YSBmcm9tIHRoZSBvcHRpb25zXHJcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihhamF4U2V0dGluZ3MuZGF0YSkpIHtcclxuICAgICAgICAgICAgLy8gc3VwcGxpZWQgYXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkvdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBhamF4U2V0dGluZ3MuZGF0YSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBhamF4U2V0dGluZ3MuZGF0YSB8fCB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJC5leHRlbmQocGFyYW1zLCBjdXN0b21SZXF1ZXN0UGFyYW1zKTtcclxuICAgICAgICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBzdGFydC5mb3JtYXQoKTtcclxuICAgICAgICBwYXJhbXNbZW5kUGFyYW1dID0gZW5kLmZvcm1hdCgpO1xyXG4gICAgICAgIGlmICh0aW1lem9uZSAmJiB0aW1lem9uZSAhPT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICBwYXJhbXNbdGltZXpvbmVQYXJhbV0gPSB0aW1lem9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWlzY1Byb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdGhpcy5hamF4U2V0dGluZ3MgPSByYXdQcm9wcztcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciByYXdQcm9wcztcclxuICAgICAgICAvLyBub3JtYWxpemUgcmF3IGlucHV0XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXdJbnB1dC51cmwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0gcmF3SW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByYXdJbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSB7IHVybDogcmF3SW5wdXQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudFNvdXJjZV8xLmRlZmF1bHQucGFyc2UuY2FsbCh0aGlzLCByYXdQcm9wcywgY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5BSkFYX0RFRkFVTFRTID0ge1xyXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgY2FjaGU6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpzb25GZWVkRXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEpzb25GZWVkRXZlbnRTb3VyY2U7XHJcbkpzb25GZWVkRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyICh0cnVlKS4uLlxyXG4gICAgdXJsOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogdHJ1ZSxcclxuICAgIGVuZFBhcmFtOiB0cnVlLFxyXG4gICAgdGltZXpvbmVQYXJhbTogdHJ1ZVxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG52YXIgVGFza1F1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFza1F1ZXVlKCkge1xyXG4gICAgICAgIHRoaXMucSA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5xLnB1c2guYXBwbHkodGhpcy5xLCBhcmdzKTsgLy8gYXBwZW5kXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHJ5U3RhcnQoKTtcclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLmdldElzSWRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUudHJ5U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiB0aGlzLmNhblJ1bk5leHQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcclxuICAgICAgICAgICAgdGhpcy5ydW5SZW1haW5pbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1BhdXNlZCAmJiB0aGlzLnEubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRhc2s7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRhc2sgPSB0aGlzLnEuc2hpZnQoKTsgLy8gYWx3YXlzIGZyZXNobHkgcmVmZXJlbmNlIHEuIG1pZ2h0IGhhdmUgYmVlbiByZWFzc2lnbmVkLlxyXG4gICAgICAgICAgICByZXMgPSB0aGlzLnJ1blRhc2sodGFzayk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuUnVuTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJ1blJlbWFpbmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBwcmV2ZW50IG1hcmtpbmcgYXMgc3RvcHBlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jYW5SdW5OZXh0KCkpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBub3QgcmVhbGx5IGEgJ3N0b3AnIC4uLiBtb3JlIG9mIGEgJ2RyYWluZWQnXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBpZiAnc3RvcCcgaGFuZGxlciBhZGRlZCBtb3JlIHRhc2tzLi4uLiBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhc2soKTsgLy8gdGFzayAqaXMqIHRoZSBmdW5jdGlvbiwgYnV0IHN1YmNsYXNzZXMgY2FuIGNoYW5nZSB0aGUgZm9ybWF0IG9mIGEgdGFza1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYXNrUXVldWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRhc2tRdWV1ZTtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRhc2tRdWV1ZSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgVGFza1F1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxudmFyIFJlbmRlclF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVuZGVyUXVldWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZW5kZXJRdWV1ZSh3YWl0c0J5TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy53YWl0c0J5TmFtZXNwYWNlID0gd2FpdHNCeU5hbWVzcGFjZSB8fCB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbiAodGFza0Z1bmMsIG5hbWVzcGFjZSwgdHlwZSkge1xyXG4gICAgICAgIHZhciB0YXNrID0ge1xyXG4gICAgICAgICAgICBmdW5jOiB0YXNrRnVuYyxcclxuICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB3YWl0TXM7XHJcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICB3YWl0TXMgPSB0aGlzLndhaXRzQnlOYW1lc3BhY2VbbmFtZXNwYWNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlID09PSB0aGlzLndhaXROYW1lc3BhY2UgJiYgd2FpdE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlXYWl0KHdhaXRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyV2FpdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvdW5kVGFzayh0YXNrKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFdhaXQobmFtZXNwYWNlLCB3YWl0TXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5zdGFydFdhaXQgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCB3YWl0TXMpIHtcclxuICAgICAgICB0aGlzLndhaXROYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICAgICAgdGhpcy5zcGF3bldhaXQod2FpdE1zKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuZGVsYXlXYWl0ID0gZnVuY3Rpb24gKHdhaXRNcykge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhaXRJZCk7XHJcbiAgICAgICAgdGhpcy5zcGF3bldhaXQod2FpdE1zKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuc3Bhd25XYWl0ID0gZnVuY3Rpb24gKHdhaXRNcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy53YWl0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMud2FpdE5hbWVzcGFjZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgfSwgd2FpdE1zKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuY2xlYXJXYWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FpdElkKTtcclxuICAgICAgICAgICAgdGhpcy53YWl0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLndhaXROYW1lc3BhY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuY2FuUnVuTmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIV9zdXBlci5wcm90b3R5cGUuY2FuUnVuTmV4dC5jYWxsKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FpdGluZyBmb3IgYSBjZXJ0YWluIG5hbWVzcGFjZSB0byBzdG9wIHJlY2VpdmluZyB0YXNrcz9cclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIGRpZmZlcmVudCBuYW1lc3BhY2UgdGFzayBpbiB0aGUgbWVhbnRpbWUsXHJcbiAgICAgICAgICAgIC8vIHRoYXQgZm9yY2VzIGFsbCBwcmV2aW91c2x5LXdhaXRpbmcgdGFza3MgdG8gc3VkZGVubHkgZXhlY3V0ZS5cclxuICAgICAgICAgICAgLy8gVE9ETzogZmluZCBhIHdheSB0byBkbyB0aGlzIGluIGNvbnN0YW50IHRpbWUuXHJcbiAgICAgICAgICAgIGZvciAodmFyIHEgPSB0aGlzLnEsIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHFbaV0ubmFtZXNwYWNlICE9PSB0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gYWxsb3cgZXhlY3V0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgdGFzay5mdW5jKCk7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLmNvbXBvdW5kVGFzayA9IGZ1bmN0aW9uIChuZXdUYXNrKSB7XHJcbiAgICAgICAgdmFyIHEgPSB0aGlzLnE7XHJcbiAgICAgICAgdmFyIHNob3VsZEFwcGVuZCA9IHRydWU7XHJcbiAgICAgICAgdmFyIGksIHRhc2s7XHJcbiAgICAgICAgaWYgKG5ld1Rhc2submFtZXNwYWNlICYmIG5ld1Rhc2sudHlwZSA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgaW5pdC9hZGQvcmVtb3ZlIG9wcyB3aXRoIHNhbWUgbmFtZXNwYWNlLCByZWdhcmRsZXNzIG9mIG9yZGVyXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHRhc2sgPSBxW2ldO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YXNrLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbml0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQXBwZW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGxhdGVzdCBkZXN0cm95IGlzIGNhbmNlbGxlZCBvdXQgYnkgbm90IGRvaW5nIHRoZSBpbml0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGZhbGx0aHJvdWdoLi4uLlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5zcGxpY2UoaSwgMSk7IC8vIHJlbW92ZSB0YXNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZEFwcGVuZCkge1xyXG4gICAgICAgICAgICBxLnB1c2gobmV3VGFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaG91bGRBcHBlbmQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlbmRlclF1ZXVlO1xyXG59KFRhc2tRdWV1ZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVuZGVyUXVldWU7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBkYXRlX2Zvcm1hdHRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcclxudmFyIHV0aWxfMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgRGF0ZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXRlQ29tcG9uZW50KF92aWV3LCBfb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNSVEwgPSBmYWxzZTsgLy8gZnJlcXVlbnRseSBhY2Nlc3NlZCBvcHRpb25zXHJcbiAgICAgICAgX3RoaXMuaGl0c05lZWRlZERlcHRoID0gMDsgLy8gbmVjZXNzYXJ5IGJlY2F1c2UgbXVsdGlwbGUgY2FsbGVycyBtaWdodCBuZWVkIHRoZSBzYW1lIGhpdHNcclxuICAgICAgICBfdGhpcy5oYXNBbGxEYXlCdXNpbmVzc0hvdXJzID0gZmFsc2U7IC8vIFRPRE86IHVuaWZ5IHdpdGggbGFyZ2VVbml0IGFuZCBpc1RpbWVTY2FsZT9cclxuICAgICAgICBfdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBoYWNrIHRvIHNldCBvcHRpb25zIHByaW9yIHRvIHRoZSB0aGlzLm9wdCBjYWxsc1xyXG4gICAgICAgIGlmIChfdmlldykge1xyXG4gICAgICAgICAgICBfdGhpc1sndmlldyddID0gX3ZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfb3B0aW9ucykge1xyXG4gICAgICAgICAgICBfdGhpc1snb3B0aW9ucyddID0gX29wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnVpZCA9IFN0cmluZyhEYXRlQ29tcG9uZW50Lmd1aWQrKyk7XHJcbiAgICAgICAgX3RoaXMuY2hpbGRyZW5CeVVpZCA9IHt9O1xyXG4gICAgICAgIF90aGlzLm5leHREYXlUaHJlc2hvbGQgPSBtb21lbnQuZHVyYXRpb24oX3RoaXMub3B0KCduZXh0RGF5VGhyZXNob2xkJykpO1xyXG4gICAgICAgIF90aGlzLmlzUlRMID0gX3RoaXMub3B0KCdpc1JUTCcpO1xyXG4gICAgICAgIGlmIChfdGhpcy5maWxsUmVuZGVyZXJDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5maWxsUmVuZGVyZXIgPSBuZXcgX3RoaXMuZmlsbFJlbmRlcmVyQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnRSZW5kZXJlckNsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UmVuZGVyZXIgPSBuZXcgX3RoaXMuZXZlbnRSZW5kZXJlckNsYXNzKF90aGlzLCBfdGhpcy5maWxsUmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuaGVscGVyUmVuZGVyZXJDbGFzcyAmJiBfdGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhlbHBlclJlbmRlcmVyID0gbmV3IF90aGlzLmhlbHBlclJlbmRlcmVyQ2xhc3MoX3RoaXMsIF90aGlzLmV2ZW50UmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyAmJiBfdGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIgPSBuZXcgX3RoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyhfdGhpcywgX3RoaXMuZmlsbFJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdID0gY2hpbGQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRyZW5CeVVpZFtjaGlsZC51aWRdO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IG9ubHkgZG8gaWYgaXNJbkRvbT9cclxuICAgIC8vIFRPRE86IG1ha2UgcGFydCBvZiBDb21wb25lbnQsIGFsb25nIHdpdGggY2hpbGRyZW4vYmF0Y2gtcmVuZGVyIHN5c3RlbT9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndXBkYXRlU2l6ZScsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gT3B0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZpZXcoKS5vcHQobmFtZSk7IC8vIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wdWJsaWNseVRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuX2dldENhbGVuZGFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLnB1YmxpY2x5VHJpZ2dlci5hcHBseShjYWxlbmRhciwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGFzUHVibGljSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuX2dldENhbGVuZGFyKCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmhhc1B1YmxpY0hhbmRsZXJzLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7IC8vIGZvciByZW5kZXJpbmdcclxuICAgICAgICB0aGlzLnJlbmRlckRhdGVzKGRhdGVQcm9maWxlKTtcclxuICAgICAgICB0aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVEYXRlUmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRGF0ZVVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdleGVjdXRlRGF0ZVVucmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRGF0ZXMoKTtcclxuICAgICAgICB0aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8vIGRhdGUtY2VsbCBjb250ZW50IG9ubHlcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gZGF0ZS1jZWxsIGNvbnRlbnQgb25seVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIC8vIE5vdy1JbmRpY2F0b3JcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nIHVuaXQsIGxpa2UgJ3NlY29uZCcgb3IgJ21pbnV0ZScgdGhhdCBkZWZpbmVkIGhvdyBvZnRlbiB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvclxyXG4gICAgLy8gc2hvdWxkIGJlIHJlZnJlc2hlZC4gSWYgc29tZXRoaW5nIGZhbHN5IGlzIHJldHVybmVkLCBubyB0aW1lIGluZGljYXRvciBpcyByZW5kZXJlZCBhdCBhbGwuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGF0IHRoZSBnaXZlbiBkYXRldGltZVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyTm93SW5kaWNhdG9yJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbmRvZXMgdGhlIHJlbmRlcmluZyBhY3Rpb25zIGZyb20gcmVuZGVyTm93SW5kaWNhdG9yXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlck5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJOb3dJbmRpY2F0b3InLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1c2luZXNzIEhvdXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci5yZW5kZXIoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlckJ1c2luZXNzSG91cnMnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBwcmV2aW91c2x5LXJlbmRlcmVkIGJ1c2luZXNzLWhvdXJzXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckJ1c2luZXNzSG91cnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyQnVzaW5lc3NIb3VycycsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEaXNwbGF5aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50UmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5yYW5nZVVwZGF0ZWQoKTsgLy8gcG9vcmx5IG5hbWVkIG5vd1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyKGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzWydyZW5kZXJFdmVudHMnXSkge1xyXG4gICAgICAgICAgICB0aGlzWydyZW5kZXJFdmVudHMnXShjb252ZXJ0RXZlbnRzUGF5bG9hZFRvTGVnYWN5QXJyYXkoZXZlbnRzUGF5bG9hZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZUV2ZW50UmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZUV2ZW50VW5yZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXNbJ2Rlc3Ryb3lFdmVudHMnXSkge1xyXG4gICAgICAgICAgICB0aGlzWydkZXN0cm95RXZlbnRzJ10oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QnVzaW5lc3NIb3VyU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuZ2V0T3duQnVzaW5lc3NIb3VyU2VncygpO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgY2hpbGQuZ2V0QnVzaW5lc3NIb3VyU2VncygpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRPd25CdXNpbmVzc0hvdXJTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyLmdldFNlZ3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuZ2V0T3duRXZlbnRTZWdzKCk7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHNlZ3MucHVzaC5hcHBseShzZWdzLCBjaGlsZC5nZXRFdmVudFNlZ3MoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3duRXZlbnRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZW5kZXJlci5nZXRTZWdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZW5kZXJpbmcgVHJpZ2dlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJBZnRlckV2ZW50c1JlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckFmdGVyRXZlbnRTZWdzUmVuZGVyZWQodGhpcy5nZXRFdmVudFNlZ3MoKSk7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50QWZ0ZXJBbGxSZW5kZXInLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGFuIG9wdGltaXphdGlvbiwgYmVjYXVzZSBnZXRFdmVudExlZ2FjeSBpcyBleHBlbnNpdmVcclxuICAgICAgICBpZiAodGhpcy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnRBZnRlclJlbmRlcicpKSB7XHJcbiAgICAgICAgICAgIHNlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVnYWN5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeSA9IHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50QWZ0ZXJSZW5kZXInLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGxlZ2FjeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xlZ2FjeSwgc2VnLmVsLCBfdGhpc11cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJCZWZvcmVFdmVudHNEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkKHRoaXMuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJCZWZvcmVFdmVudFNlZ3NEZXN0cm95ZWQgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50RGVzdHJveScpKSB7XHJcbiAgICAgICAgICAgIHNlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVnYWN5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeSA9IHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RGVzdHJveScsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbGVnYWN5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbGVnYWN5LCBzZWcuZWwsIF90aGlzXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVuZGVyaW5nIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gSGlkZXMgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcclxuICAgIC8vIFJFQ1VSU0lWRSB3aXRoIHN1YmNvbXBvbmVudHNcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3dFdmVudHNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkID09PSBldmVudERlZklkICYmXHJcbiAgICAgICAgICAgICAgICBzZWcuZWwgLy8gbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignc2hvd0V2ZW50c1dpdGhJZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2hvd3MgYWxsIHJlbmRlcmVkIGV2ZW50IHNlZ21lbnRzIGxpbmtlZCB0byB0aGUgZ2l2ZW4gZXZlbnRcclxuICAgIC8vIFJFQ1VSU0lWRSB3aXRoIHN1YmNvbXBvbmVudHNcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhpZGVFdmVudHNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkID09PSBldmVudERlZklkICYmXHJcbiAgICAgICAgICAgICAgICBzZWcuZWwgLy8gbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignaGlkZUV2ZW50c1dpdGhJZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRHJhZy1uLURyb3AgUmVuZGVyaW5nIChmb3IgYm90aCBldmVudHMgYW5kIGV4dGVybmFsIGVsZW1lbnRzKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGRyYWcgb3ZlciB0aGUgZ2l2ZW4gZHJvcCB6b25lLlxyXG4gICAgLy8gSWYgYW4gZXh0ZXJuYWwtZWxlbWVudCwgc2VnIHdpbGwgYmUgYG51bGxgLlxyXG4gICAgLy8gTXVzdCByZXR1cm4gZWxlbWVudHMgdXNlZCBmb3IgYW55IG1vY2sgZXZlbnRzLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlZEhlbHBlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucmVuZGVyRHJhZyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSGVscGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZW5kZXJlZEhlbHBlcjtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBvciBleHRlcm5hbC1lbGVtZW50IGJlaW5nIGRyYWdnZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyRHJhZycsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJFdmVudFJlc2l6ZScsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVyRXZlbnRSZXNpemUnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFNlbGVjdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgdGhlIHNlbGVjdGlvblxyXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGByZW5kZXJTZWxlY3Rpb25gIGFmdGVyIGxlZ2FjeSBpcyBnb25lXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyU2VsZWN0aW9uRm9vdHByaW50JywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBzZWxlY3Rpb25cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJTZWxlY3Rpb24nLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEhpZ2hsaWdodFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGFuIGVtcGhhc2lzIG9uIHRoZSBnaXZlbiBkYXRlIHJhbmdlLiBHaXZlbiBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJIaWdobGlnaHQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlckZvb3RwcmludCgnaGlnaGxpZ2h0JywgY29tcG9uZW50Rm9vdHByaW50LCB7XHJcbiAgICAgICAgICAgICAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZmMtaGlnaGxpZ2h0J107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVySGlnaGxpZ2h0JywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgdGhlIGVtcGhhc2lzIG9uIGEgZGF0ZSByYW5nZVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJIaWdobGlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdoaWdobGlnaHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3VucmVuZGVySGlnaGxpZ2h0JywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBIaXQgQXJlYXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8ganVzdCBiZWNhdXNlIGFsbCBEYXRlQ29tcG9uZW50cyBzdXBwb3J0IHRoaXMgaW50ZXJmYWNlXHJcbiAgICAvLyBkb2Vzbid0IG1lYW4gdGhleSBuZWVkIHRvIGhhdmUgdGhlaXIgb3duIGludGVybmFsIGNvb3JkIHN5c3RlbS4gdGhleSBjYW4gZGVmZXIgdG8gc3ViLWNvbXBvbmVudHMuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oaXRzTmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMuaGl0c05lZWRlZERlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2hpdHNOZWVkZWQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhpdHNOb3ROZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGl0c05lZWRlZERlcHRoICYmICEoLS10aGlzLmhpdHNOZWVkZWREZXB0aCkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignaGl0c05vdE5lZWRlZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVsZWFzZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gY29vcmRpbmF0ZXMgZnJvbSB0aGUgdG9wbGVmdCBvZiB0aGUgZG9jdW1lbnQsIHJldHVybiBkYXRhIGFib3V0IHRoZSBkYXRlLXJlbGF0ZWQgYXJlYSB1bmRlcm5lYXRoLlxyXG4gICAgLy8gQ2FuIHJldHVybiBhbiBvYmplY3Qgd2l0aCBhcmJpdHJhcnkgcHJvcGVydGllcyAoYWx0aG91Z2ggdG9wL3JpZ2h0L2xlZnQvYm90dG9tIGFyZSBlbmNvdXJhZ2VkKS5cclxuICAgIC8vIE11c3QgaGF2ZSBhIGBncmlkYCBwcm9wZXJ0eSwgYSByZWZlcmVuY2UgdG8gdGhpcyBjdXJyZW50IGdyaWQuIFRPRE86IGF2b2lkIHRoaXNcclxuICAgIC8vIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBiZSBwcm9jZXNzZWQgYnkgZ2V0SGl0Rm9vdHByaW50IGFuZCBnZXRIaXRFbC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbkJ5VWlkID0gdGhpcy5jaGlsZHJlbkJ5VWlkO1xyXG4gICAgICAgIHZhciB1aWQ7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBmb3IgKHVpZCBpbiBjaGlsZHJlbkJ5VWlkKSB7XHJcbiAgICAgICAgICAgIGhpdCA9IGNoaWxkcmVuQnlVaWRbdWlkXS5xdWVyeUhpdChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0O1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldFNhZmVIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgdmFyIGZvb3RwcmludCA9IHRoaXMuZ2V0SGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9vdHByaW50O1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyB3aGF0IGFib3V0IGJlaW5nIGFic3RyYWN0IT9cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBwb3NpdGlvbi1sZXZlbCBpbmZvcm1hdGlvbiBhYm91dCBhIGRhdGUtcmVsYXRlZCBhcmVhIHdpdGhpbiB0aGUgZ3JpZCxcclxuICAgIC8vIHNob3VsZCByZXR1cm4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IGJlc3QgcmVwcmVzZW50cyBpdC4gcGFzc2VkIHRvIGRheUNsaWNrIGNhbGxiYWNrLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gd2hhdCBhYm91dCBiZWluZyBhYnN0cmFjdCE/XHJcbiAgICB9O1xyXG4gICAgLyogQ29udmVydGluZyBldmVudFJhbmdlIC0+IGV2ZW50Rm9vdHByaW50XHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLnB1c2guYXBwbHkoLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGV2ZW50Rm9vdHByaW50cywgdGhpcy5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50cztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudFJhbmdlVG9FdmVudEZvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBbdXRpbF8yLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50KGV2ZW50UmFuZ2UpXTtcclxuICAgIH07XHJcbiAgICAvKiBDb252ZXJ0aW5nIGNvbXBvbmVudEZvb3RwcmludC9ldmVudEZvb3RwcmludCAtPiBzZWdzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXZlbnRGb290cHJpbnRzVG9TZWdzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cykge1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgdGhpcy5ldmVudEZvb3RwcmludFRvU2VncyhldmVudEZvb3RwcmludHNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgbWlzYyBkYXRhKSwgYW5kIHRoZSBldmVudCBpdHNlbGYsXHJcbiAgICAvLyBzbGljZXMgaW50byBzZWdtZW50cyBhbmQgYXR0YWNoZXMgZXZlbnQtZGVyaXZlZCBwcm9wZXJ0aWVzIHRvIHRoZW0uXHJcbiAgICAvLyBldmVudFNwYW4gLSB7IHN0YXJ0LCBlbmQsIGlzU3RhcnQsIGlzRW5kLCBvdGhlcnRoaW5ncy4uLiB9XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBzZWdzO1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgc2VncyA9IHRoaXMuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgaWYgKCF1bnpvbmVkUmFuZ2UuaXNTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXVuem9uZWRSYW5nZS5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VnLmZvb3RwcmludCA9IGV2ZW50Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZW5hbWUgdG8gc2VnLmV2ZW50Rm9vdHByaW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY2FsbENoaWxkcmVuID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGFyZ3MpIHtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgY2hpbGRbbWV0aG9kTmFtZV0uYXBwbHkoY2hpbGQsIGFyZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLml0ZXJDaGlsZHJlbiA9IGZ1bmN0aW9uIChmdW5jKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuQnlVaWQgPSB0aGlzLmNoaWxkcmVuQnlVaWQ7XHJcbiAgICAgICAgdmFyIHVpZDtcclxuICAgICAgICBmb3IgKHVpZCBpbiBjaGlsZHJlbkJ5VWlkKSB7XHJcbiAgICAgICAgICAgIGZ1bmMoY2hpbGRyZW5CeVVpZFt1aWRdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldENhbGVuZGFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdC5jYWxlbmRhciB8fCB0LnZpZXcuY2FsZW5kYXI7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuX2dldFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5fZ2V0RGF0ZVByb2ZpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFZpZXcoKS5nZXQoJ2RhdGVQcm9maWxlJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIEhUTUwgZm9yIGFuIGFuY2hvciB0byBhbm90aGVyIHZpZXcgaW50byB0aGUgY2FsZW5kYXIuXHJcbiAgICAvLyBXaWxsIGVpdGhlciBnZW5lcmF0ZSBhbiA8YT4gdGFnIG9yIGEgbm9uLWNsaWNrYWJsZSA8c3Bhbj4gdGFnLCBkZXBlbmRpbmcgb24gZW5hYmxlZCBzZXR0aW5ncy5cclxuICAgIC8vIGBnb3RvT3B0aW9uc2AgY2FuIGVpdGhlciBiZSBhIG1vbWVudCBpbnB1dCwgb3IgYW4gb2JqZWN0IHdpdGggdGhlIGZvcm06XHJcbiAgICAvLyB7IGRhdGUsIHR5cGUsIGZvcmNlT2ZmIH1cclxuICAgIC8vIGB0eXBlYCBpcyBhIHZpZXctdHlwZSBsaWtlIFwiZGF5XCIgb3IgXCJ3ZWVrXCIuIGRlZmF1bHQgdmFsdWUgaXMgXCJkYXlcIi5cclxuICAgIC8vIGBhdHRyc2AgYW5kIGBpbm5lckh0bWxgIGFyZSB1c2UgdG8gZ2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIEhUTUwgdGFnLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRHb3RvQW5jaG9ySHRtbCA9IGZ1bmN0aW9uIChnb3RvT3B0aW9ucywgYXR0cnMsIGlubmVySHRtbCkge1xyXG4gICAgICAgIHZhciBkYXRlLCB0eXBlLCBmb3JjZU9mZjtcclxuICAgICAgICB2YXIgZmluYWxPcHRpb25zO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoZ290b09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBnb3RvT3B0aW9ucy5kYXRlO1xyXG4gICAgICAgICAgICB0eXBlID0gZ290b09wdGlvbnMudHlwZTtcclxuICAgICAgICAgICAgZm9yY2VPZmYgPSBnb3RvT3B0aW9ucy5mb3JjZU9mZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSBnb3RvT3B0aW9uczsgLy8gYSBzaW5nbGUgbW9tZW50IGlucHV0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGUgPSBtb21lbnRfZXh0XzEuZGVmYXVsdChkYXRlKTsgLy8gaWYgYSBzdHJpbmcsIHBhcnNlIGl0XHJcbiAgICAgICAgZmluYWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkYXRlOiBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlIHx8ICdkYXknXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSBhdHRycztcclxuICAgICAgICAgICAgYXR0cnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdHRycyA9IGF0dHJzID8gJyAnICsgdXRpbF8xLmF0dHJzVG9TdHIoYXR0cnMpIDogJyc7IC8vIHdpbGwgaGF2ZSBhIGxlYWRpbmcgc3BhY2VcclxuICAgICAgICBpbm5lckh0bWwgPSBpbm5lckh0bWwgfHwgJyc7XHJcbiAgICAgICAgaWYgKCFmb3JjZU9mZiAmJiB0aGlzLm9wdCgnbmF2TGlua3MnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJzxhJyArIGF0dHJzICtcclxuICAgICAgICAgICAgICAgICcgZGF0YS1nb3RvPVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKEpTT04uc3RyaW5naWZ5KGZpbmFsT3B0aW9ucykpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sICtcclxuICAgICAgICAgICAgICAgICc8L2E+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHNwYW4nICsgYXR0cnMgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sICtcclxuICAgICAgICAgICAgICAgICc8L3NwYW4+JztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0QWxsRGF5SHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ2FsbERheUh0bWwnKSB8fCB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLm9wdCgnYWxsRGF5VGV4dCcpKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBIVE1MIGNsYXNzTmFtZXMgZm9yIGEgc2luZ2xlLWRheSBlbGVtZW50XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXREYXlDbGFzc2VzID0gZnVuY3Rpb24gKGRhdGUsIG5vVGhlbWVIaWdobGlnaHQpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgIHZhciB0b2RheTtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKSkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWRpc2FibGVkLWRheScpOyAvLyBUT0RPOiBqUXVlcnkgVUkgdGhlbWU/XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLScgKyB1dGlsXzEuZGF5SURzW2RhdGUuZGF5KCldKTtcclxuICAgICAgICAgICAgaWYgKHZpZXcuaXNEYXRlSW5PdGhlck1vbnRoKGRhdGUsIHRoaXMuZGF0ZVByb2ZpbGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLW90aGVyLW1vbnRoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9kYXkgPSB2aWV3LmNhbGVuZGFyLmdldE5vdygpO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZS5pc1NhbWUodG9kYXksICdkYXknKSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy10b2RheScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vVGhlbWVIaWdobGlnaHQgIT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2godmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0ZSA8IHRvZGF5KSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXBhc3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZnV0dXJlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbGl0eSBmb3IgZm9ybWF0dGluZyBhIHJhbmdlLiBBY2NlcHRzIGEgcmFuZ2Ugb2JqZWN0LCBmb3JtYXR0aW5nIHN0cmluZywgYW5kIG9wdGlvbmFsIHNlcGFyYXRvci5cclxuICAgIC8vIERpc3BsYXlzIGFsbC1kYXkgcmFuZ2VzIG5hdHVyYWxseSwgd2l0aCBhbiBpbmNsdXNpdmUgZW5kLiBUYWtlcyB0aGUgY3VycmVudCBpc1JUTCBpbnRvIGFjY291bnQuXHJcbiAgICAvLyBUaGUgdGltZXpvbmVzIG9mIHRoZSBkYXRlcyB3aXRoaW4gYHJhbmdlYCB3aWxsIGJlIHJlc3BlY3RlZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlLCBpc0FsbERheSwgZm9ybWF0U3RyLCBzZXBhcmF0b3IpIHtcclxuICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xyXG4gICAgICAgIGlmIChpc0FsbERheSkge1xyXG4gICAgICAgICAgICBlbmQgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdCgxKTsgLy8gY29udmVydCB0byBpbmNsdXNpdmUuIGxhc3QgbXMgb2YgcHJldmlvdXMgZGF5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlX2Zvcm1hdHRpbmdfMS5mb3JtYXRSYW5nZShyYW5nZS5zdGFydCwgZW5kLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgdGhpcy5pc1JUTCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHRoZSBnaXZlIHVuaXRzIGluIHRoZSBcImN1cnJlbnRcIiByYW5nZS5cclxuICAgIC8vIFdpbGwgcmV0dXJuIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLiBXb24ndCByb3VuZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRSYW5nZUFzID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGF0ZVByb2ZpbGUoKS5jdXJyZW50VW56b25lZFJhbmdlLmFzKHVuaXQpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIGRhdGUgcmFuZ2Ugb2YgdGhlIGZ1bGwgZGF5cyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFycyB0byBvY2N1cHkuXHJcbiAgICAvLyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHdpdGggc3RhcnQvZW5kLCBOT1QgYW4gVW56b25lZFJhbmdlIVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcHV0ZURheVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuX2dldENhbGVuZGFyKCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0RGF5ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh1bnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXHJcbiAgICAgICAgdmFyIGVuZCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodW56b25lZFJhbmdlLmVuZE1zKTtcclxuICAgICAgICB2YXIgZW5kVGltZU1TID0gK2VuZC50aW1lKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcclxuICAgICAgICB2YXIgZW5kRGF5ID0gZW5kLmNsb25lKCkuc3RyaXBUaW1lKCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2UgZXhjbHVzaXZlbHkgZW5kc1xyXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZWF2aW5nIGl0IGFzIGluY2x1c2l2ZSB3aWxsIGNhdXNlIGl0IHRvIGV4Y2x1ZGUgYGVuZERheWAuXHJcbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gdGhpcy5uZXh0RGF5VGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIGVuZERheS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgZW5kIGlzIHdpdGhpbiBgc3RhcnREYXlgIGJ1dCBub3QgcGFzdCBuZXh0RGF5VGhyZXNob2xkLCBhc3NpZ24gdGhlIGRlZmF1bHQgZHVyYXRpb24gb2Ygb25lIGRheS5cclxuICAgICAgICBpZiAoZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XHJcbiAgICAgICAgICAgIGVuZERheSA9IHN0YXJ0RGF5LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydERheSwgZW5kOiBlbmREYXkgfTtcclxuICAgIH07XHJcbiAgICAvLyBEb2VzIHRoZSBnaXZlbiByYW5nZSB2aXN1YWxseSBhcHBlYXIgdG8gb2NjdXB5IG1vcmUgdGhhbiBvbmUgZGF5P1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNNdWx0aURheVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlSYW5nZSA9IHRoaXMuY29tcHV0ZURheVJhbmdlKHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIGRheVJhbmdlLmVuZC5kaWZmKGRheVJhbmdlLnN0YXJ0LCAnZGF5cycpID4gMTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50Lmd1aWQgPSAwOyAvLyBUT0RPOiBiZXR0ZXIgc3lzdGVtIGZvciB0aGlzP1xyXG4gICAgcmV0dXJuIERhdGVDb21wb25lbnQ7XHJcbn0oQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRlQ29tcG9uZW50O1xyXG4vLyBsZWdhY3lcclxuZnVuY3Rpb24gY29udmVydEV2ZW50c1BheWxvYWRUb0xlZ2FjeUFycmF5KGV2ZW50c1BheWxvYWQpIHtcclxuICAgIHZhciBldmVudERlZklkO1xyXG4gICAgdmFyIGV2ZW50SW5zdGFuY2VzO1xyXG4gICAgdmFyIGxlZ2FjeUV2ZW50cyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGV2ZW50RGVmSWQgaW4gZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VzID0gZXZlbnRzUGF5bG9hZFtldmVudERlZklkXS5ldmVudEluc3RhbmNlcztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGVnYWN5RXZlbnRzLnB1c2goZXZlbnRJbnN0YW5jZXNbaV0udG9MZWdhY3koKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZ2FjeUV2ZW50cztcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0ZVByb2ZpbGVHZW5lcmF0b3IoX3ZpZXcpIHtcclxuICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XHJcbiAgICB9XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnRyaW1IaWRkZW5EYXlzKHVuem9uZWRSYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLm1zVG9VdGNNb21lbnQgPSBmdW5jdGlvbiAobXMsIGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuY2FsZW5kYXIubXNUb1V0Y01vbWVudChtcywgZm9yY2VBbGxEYXkpO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFByZXYgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHByZXZEYXRlID0gY3VycmVudERhdGVQcm9maWxlLmRhdGUuY2xvbmUoKVxyXG4gICAgICAgICAgICAuc3RhcnRPZihjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdClcclxuICAgICAgICAgICAgLnN1YnRyYWN0KGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkTmV4dCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgbmV4dERhdGUgPSBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZS5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5zdGFydE9mKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxyXG4gICAgICAgICAgICAuYWRkKGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlSW5jcmVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXHJcbiAgICAvLyBmcm9tIGl0cyBwcmV2aW91cyB2YWx1ZS4gZGVjcmVtZW50ZWQgPSAtMSwgaW5jcmVtZW50ZWQgPSAxIChkZWZhdWx0KS5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCkge1xyXG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQgPT09IHZvaWQgMCkgeyBmb3JjZVRvVmFsaWQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBpc0RhdGVBbGxEYXkgPSAhZGF0ZS5oYXNUaW1lKCk7XHJcbiAgICAgICAgdmFyIHZhbGlkVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBtaW5UaW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgbWF4VGltZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRJbmZvO1xyXG4gICAgICAgIHZhciBpc1JhbmdlQWxsRGF5O1xyXG4gICAgICAgIHZhciByZW5kZXJVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgaXNWYWxpZDtcclxuICAgICAgICB2YWxpZFVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XHJcbiAgICAgICAgdmFsaWRVbnpvbmVkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkVW56b25lZFJhbmdlKTtcclxuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLm1zVG9VdGNNb21lbnQodmFsaWRVbnpvbmVkUmFuZ2UuY29uc3RyYWluRGF0ZShkYXRlKSwgLy8gcmV0dXJucyBNU1xyXG4gICAgICAgICAgICBpc0RhdGVBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgaXNSYW5nZUFsbERheSA9IC9eKHllYXJ8bW9udGh8d2Vla3xkYXkpJC8udGVzdChjdXJyZW50SW5mby51bml0KTtcclxuICAgICAgICByZW5kZXJVbnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UodGhpcy50cmltSGlkZGVuRGF5cyhjdXJyZW50SW5mby51bnpvbmVkUmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICByZW5kZXJVbnpvbmVkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gcmVuZGVyVW56b25lZFJhbmdlLmNsb25lKCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdCgnc2hvd05vbkN1cnJlbnREYXRlcycpKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IGFjdGl2ZVVuem9uZWRSYW5nZS5pbnRlcnNlY3QoY3VycmVudEluZm8udW56b25lZFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWluVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnbWluVGltZScpKTtcclxuICAgICAgICBtYXhUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtYXhUaW1lJykpO1xyXG4gICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlVW56b25lZFJhbmdlLCBtaW5UaW1lLCBtYXhUaW1lKTtcclxuICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2UgPSBhY3RpdmVVbnpvbmVkUmFuZ2UuaW50ZXJzZWN0KHZhbGlkVW56b25lZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcclxuICAgICAgICBpZiAoYWN0aXZlVW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLm1zVG9VdGNNb21lbnQoYWN0aXZlVW56b25lZFJhbmdlLmNvbnN0cmFpbkRhdGUoZGF0ZSksIC8vIHJldHVybnMgTVNcclxuICAgICAgICAgICAgaXNEYXRlQWxsRGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXHJcbiAgICAgICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXHJcbiAgICAgICAgaXNWYWxpZCA9IGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZS5pbnRlcnNlY3RzV2l0aCh2YWxpZFVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gY29uc3RyYWludCBmb3Igd2hlcmUgcHJldi9uZXh0IG9wZXJhdGlvbnMgY2FuIGdvIGFuZCB3aGVyZSBldmVudHMgY2FuIGJlIGRyYWdnZWQvcmVzaXplZCB0by5cclxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICB2YWxpZFVuem9uZWRSYW5nZTogdmFsaWRVbnpvbmVkUmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cclxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXHJcbiAgICAgICAgICAgIGN1cnJlbnRVbnpvbmVkUmFuZ2U6IGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxyXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxyXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5OiBpc1JhbmdlQWxsRGF5LFxyXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcclxuICAgICAgICAgICAgLy8gd2lsbCBiZSBgbnVsbGAgaWYgbm8gZGF0ZXMgYWNjZXB0IGV2ZW50c1xyXG4gICAgICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2U6IGFjdGl2ZVVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cclxuICAgICAgICAgICAgLy8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXHJcbiAgICAgICAgICAgIHJlbmRlclVuem9uZWRSYW5nZTogcmVuZGVyVW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxyXG4gICAgICAgICAgICBtaW5UaW1lOiBtaW5UaW1lLFxyXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBleGNsdXNpdmUgdmlzaWJsZSBlbmQgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XHJcbiAgICAgICAgICAgIG1heFRpbWU6IG1heFRpbWUsXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IGlzVmFsaWQsXHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGUsXHJcbiAgICAgICAgICAgIC8vIGhvdyBmYXIgdGhlIGN1cnJlbnQgZGF0ZSB3aWxsIG1vdmUgZm9yIGEgcHJldi9uZXh0IG9wZXJhdGlvblxyXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbilcclxuICAgICAgICAgICAgLy8gcGFzcyBhIGZhbGxiYWNrIChtaWdodCBiZSBudWxsKSBeXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXHJcbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxyXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFZhbGlkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2YWxpZFJhbmdlJywgdGhpcy5fdmlldy5jYWxlbmRhci5nZXROb3coKSkgfHxcclxuICAgICAgICAgICAgbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoKTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXHJcbiAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cclxuICAgIC8vIFNlZSBidWlsZCgpIGZvciBhIGRlc2NyaXB0aW9uIG9mIGBkaXJlY3Rpb25gLlxyXG4gICAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxyXG4gICAgLy8gVE9ETzogYWNjZXB0IGEgTVMtdGltZSBpbnN0ZWFkIG9mIGEgbW9tZW50IGBkYXRlYD9cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEN1cnJlbnRSYW5nZUluZm8gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gdGhpcy5fdmlldy52aWV3U3BlYztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlID0gbnVsbDtcclxuICAgICAgICB2YXIgZGF5Q291bnQ7XHJcbiAgICAgICAgaWYgKHZpZXdTcGVjLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdmlld1NwZWMuZHVyYXRpb247XHJcbiAgICAgICAgICAgIHVuaXQgPSB2aWV3U3BlYy5kdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5vcHQoJ2RheUNvdW50JykpKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodW56b25lZFJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcclxuICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0KHVuem9uZWRSYW5nZS5nZXRTdGFydCgpLCB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcclxuICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIHVuaXQ6IHVuaXQsIHVuem9uZWRSYW5nZTogdW56b25lZFJhbmdlIH07XHJcbiAgICB9O1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmdldEZhbGxiYWNrRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVVbnpvbmVkUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxyXG4gICAgLy8gbWluVGltZSBvciBtYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmFkanVzdEFjdGl2ZVJhbmdlID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSwgbWluVGltZSwgbWF4VGltZSkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBlbmQgPSB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcudXNlc01pbk1heFRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKG1pblRpbWUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKDApLmFkZChtaW5UaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4VGltZSA+IDI0ICogNjAgKiA2MCAqIDEwMDApIHtcclxuICAgICAgICAgICAgICAgIGVuZC50aW1lKG1heFRpbWUgLSAoMjQgKiA2MCAqIDYwICogMTAwMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxyXG4gICAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGNvbXB1dGVHcmVhdGVzdFVuaXQgdmFsdWUgb2YgZHVyYXRpb24uXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCkge1xyXG4gICAgICAgIHZhciBhbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpO1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQ7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgd2hhdCB0aGUgYWxpZ25tZW50IHNob3VsZCBiZVxyXG4gICAgICAgIGlmICghYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0KCdkYXRlSW5jcmVtZW50Jyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50SW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGVJbmNyZW1lbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkYXRlSW5jcmVtZW50SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50RHVyYXRpb24gPCBkdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHV0aWxfMS5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZGF0ZUluY3JlbWVudER1cmF0aW9uLCBkYXRlSW5jcmVtZW50SW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHVuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHZpZXcgZGlzcGxheXMgYSBzaW5nbGUgZGF5IG9yIHNtYWxsZXJcclxuICAgICAgICBpZiAoZHVyYXRpb24uYXMoJ2RheXMnKSA8PSAxKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl92aWV3LmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3RhcnQuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBkYXRlLmNsb25lKCkuc3RhcnRPZihhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZChkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHJlcyA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXHJcbiAgICAgICAgaWYgKCF0aGlzLnRyaW1IaWRkZW5EYXlzKHJlcykpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuX3ZpZXcuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EYXlDb3VudCA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XHJcbiAgICAgICAgdmFyIGN1c3RvbUFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50Jyk7XHJcbiAgICAgICAgdmFyIHJ1bm5pbmdDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKGN1c3RvbUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICBzdGFydC5zdGFydE9mKGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fdmlldy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgZW5kLmFkZCgxLCAnZGF5Jyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdmlldy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICBydW5uaW5nQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcclxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFVuem9uZWRSYW5nZSBhbmQgYWN0aXZlVW56b25lZFJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgdmlzaWJsZVVuem9uZWRSYW5nZSA9IHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2aXNpYmxlUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoZGF0ZSkgLy8gY29ycmVjdCB6b25lLiBhbHNvIGdlbmVyYXRlcyBuZXcgb2JqIHRoYXQgYXZvaWRzIG11dGF0aW9uc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHZpc2libGVVbnpvbmVkUmFuZ2UgJiYgKHZpc2libGVVbnpvbmVkUmFuZ2Uuc3RhcnRNcyA9PSBudWxsIHx8IHZpc2libGVVbnpvbmVkUmFuZ2UuZW5kTXMgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aXNpYmxlVW56b25lZFJhbmdlO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcclxuICAgIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cclxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXHJcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRGF0ZUluY3JlbWVudCA9IGZ1bmN0aW9uIChmYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xyXG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XHJcbiAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG5hbWVzcGFjZV9ob29rc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXh0ZXJuYWxEcm9wcGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV4dGVybmFsRHJvcHBpbmcoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlOyAvLyBqcXVpLWRyYWdnaW5nIGFuIGV4dGVybmFsIGVsZW1lbnQ/IGJvb2xlYW5cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGVtZW50czpcclxuICAgICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgICAtIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgICAgIC0gaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgICAgLSByZW5kZXJEcmFnXHJcbiAgICAgICAgLSB1bnJlbmRlckRyYWdcclxuICAgICovXHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmJpbmRUb0RvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcclxuICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLmhhbmRsZURyYWdTdGFydCxcclxuICAgICAgICAgICAgc29ydHN0YXJ0OiB0aGlzLmhhbmRsZURyYWdTdGFydCAvLyBqcXVpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUudW5iaW5kRnJvbURvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIGpRdWVyeSBVSSBkcmFnIGlzIGluaXRpYXRlZCBhbnl3aGVyZSBpbiB0aGUgRE9NXHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYsIHVpKSB7XHJcbiAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgIHZhciBhY2NlcHQ7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdkcm9wcGFibGUnKSkge1xyXG4gICAgICAgICAgICBlbCA9ICQoKHVpID8gdWkuaXRlbSA6IG51bGwpIHx8IGV2LnRhcmdldCk7XHJcbiAgICAgICAgICAgIC8vIFRlc3QgdGhhdCB0aGUgZHJhZ2dlZCBlbGVtZW50IHBhc3NlcyB0aGUgZHJvcEFjY2VwdCBzZWxlY3RvciBvciBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgIC8vIEZZSSwgdGhlIGRlZmF1bHQgaXMgXCIqXCIgKG1hdGNoZXMgYWxsKVxyXG4gICAgICAgICAgICBhY2NlcHQgPSB0aGlzLm9wdCgnZHJvcEFjY2VwdCcpO1xyXG4gICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGFjY2VwdCkgPyBhY2NlcHQuY2FsbChlbFswXSwgZWwpIDogZWwuaXMoYWNjZXB0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvRXh0ZXJuYWxEcmFnKGVsLCBldiwgdWkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgc3RhcnRzIGFuZCBpdCBuZWVkcyB0byBiZSBtb25pdG9yZWQgZm9yIGRyb3BwaW5nXHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5saXN0ZW5Ub0V4dGVybmFsRHJhZyA9IGZ1bmN0aW9uIChlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG1ldGEgPSBnZXREcmFnZ2VkRWxNZXRhKGVsKTsgLy8gZXh0cmEgZGF0YSBhYm91dCBldmVudCBkcm9wLCBpbmNsdWRpbmcgcG9zc2libGUgZXZlbnQgdG8gY3JlYXRlXHJcbiAgICAgICAgdmFyIHNpbmdsZUV2ZW50RGVmOyAvLyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiB1bnN1Y2Nlc3NmdWwgZHJhZ1xyXG4gICAgICAgIC8vIGxpc3RlbmVyIHRoYXQgdHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgZGF0ZS1hc3NvY2lhdGVkIHBpeGVsIHJlZ2lvbnNcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEZvb3RwcmludCA9IGhpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpOyAvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWRcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmID0gX3RoaXMuY29tcHV0ZUV4dGVybmFsRHJvcChoaXRGb290cHJpbnQsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFdmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoc2luZ2xlRXZlbnREZWYuYnVpbGRJbnN0YW5jZXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IG1ldGEuZXZlbnRQcm9wcyA/IC8vIGlzRXZlbnQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyRHJhZygvLyBjYWxsZWQgd2l0aG91dCBhIHNlZyBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGNvbXBvbmVudC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UsIHZpZXcuY2FsZW5kYXIpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBudWxsOyAvLyBzaWduYWwgdW5zdWNjZXNzZnVsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bnJlbmRlckRyYWcoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZXBvcnRFeHRlcm5hbERyb3Aoc2luZ2xlRXZlbnREZWYsIEJvb2xlYW4obWV0YS5ldmVudFByb3BzKSwgLy8gaXNFdmVudFxyXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW4obWV0YS5zdGljayksIC8vIGlzU3RpY2t5XHJcbiAgICAgICAgICAgICAgICAgICAgZWwsIGV2LCB1aSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0RHJhZyhldik7IC8vIHN0YXJ0IGxpc3RlbmluZyBpbW1lZGlhdGVseVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgaGl0IHRvIGJlIGRyb3BwZWQgdXBvbiwgYW5kIG1pc2MgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGpxdWkgZHJhZyAoZ3VhcmFudGVlZCB0byBiZSBhIHBsYWluIG9iamVjdCksXHJcbiAgICAvLyByZXR1cm5zIHRoZSB6b25lZCBzdGFydC9lbmQgZGF0ZXMgZm9yIHRoZSBldmVudCB0aGF0IHdvdWxkIHJlc3VsdCBmcm9tIHRoZSBoeXBvdGhldGljYWwgZHJvcC4gZW5kIG1pZ2h0IGJlIG51bGwuXHJcbiAgICAvLyBSZXR1cm5pbmcgYSBudWxsIHZhbHVlIHNpZ25hbHMgYW4gaW52YWxpZCBkcm9wIGhpdC5cclxuICAgIC8vIERPRVMgTk9UIGNvbnNpZGVyIG92ZXJsYXAvY29uc3RyYWludC5cclxuICAgIC8vIEFzc3VtZXMgYm90aCBmb290cHJpbnRzIGFyZSBub24tb3Blbi1lbmRlZC5cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmNvbXB1dGVFeHRlcm5hbERyb3AgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBtZXRhKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy52aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBzdGFydCA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLnN0YXJ0TXMpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgLy8gaWYgZHJvcHBlZCBvbiBhbiBhbGwtZGF5IHNwYW4sIGFuZCBlbGVtZW50J3MgbWV0YWRhdGEgc3BlY2lmaWVkIGEgdGltZSwgc2V0IGl0XHJcbiAgICAgICAgICAgIGlmIChtZXRhLnN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQudGltZShtZXRhLnN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWV0YS5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZChtZXRhLmR1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKHN0YXJ0KTtcclxuICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnREZWYgPSBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoJC5leHRlbmQoe30sIG1ldGEuZXZlbnRQcm9wcywge1xyXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgIGVuZDogZW5kXHJcbiAgICAgICAgfSksIG5ldyBFdmVudFNvdXJjZV8xLmRlZmF1bHQoY2FsZW5kYXIpKTtcclxuICAgICAgICByZXR1cm4gZXZlbnREZWY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV4dGVybmFsRHJvcHBpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV4dGVybmFsRHJvcHBpbmc7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXh0ZXJuYWxEcm9wcGluZyk7XHJcbi8qIEV4dGVybmFsLURyYWdnaW5nLUVsZW1lbnQgRGF0YVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gR2l2ZW4gYSBqUXVlcnkgZWxlbWVudCB0aGF0IG1pZ2h0IHJlcHJlc2VudCBhIGRyYWdnZWQgRnVsbENhbGVuZGFyIGV2ZW50LCByZXR1cm5zIGFuIGludGVybWVkaWF0ZSBkYXRhIHN0cnVjdHVyZVxyXG4vLyB0byBiZSB1c2VkIGZvciBFdmVudCBPYmplY3QgY3JlYXRpb24uXHJcbi8vIEEgZGVmaW5lZCBgLmV2ZW50UHJvcHNgLCBldmVuIHdoZW4gZW1wdHksIGluZGljYXRlcyB0aGF0IGFuIGV2ZW50IHNob3VsZCBiZSBjcmVhdGVkLlxyXG5mdW5jdGlvbiBnZXREcmFnZ2VkRWxNZXRhKGVsKSB7XHJcbiAgICB2YXIgcHJlZml4ID0gbmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC5kYXRhQXR0clByZWZpeDtcclxuICAgIHZhciBldmVudFByb3BzOyAvLyBwcm9wZXJ0aWVzIGZvciBjcmVhdGluZyB0aGUgZXZlbnQsIG5vdCByZWxhdGVkIHRvIGRhdGUvdGltZVxyXG4gICAgdmFyIHN0YXJ0VGltZTsgLy8gYSBEdXJhdGlvblxyXG4gICAgdmFyIGR1cmF0aW9uO1xyXG4gICAgdmFyIHN0aWNrO1xyXG4gICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgIHByZWZpeCArPSAnLSc7XHJcbiAgICB9XHJcbiAgICBldmVudFByb3BzID0gZWwuZGF0YShwcmVmaXggKyAnZXZlbnQnKSB8fCBudWxsO1xyXG4gICAgaWYgKGV2ZW50UHJvcHMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UHJvcHMgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudFByb3BzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBsdWNrIHNwZWNpYWwtY2FzZWQgZGF0ZS90aW1lIHByb3BlcnRpZXNcclxuICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgICAgICBkdXJhdGlvbiA9IGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgc3RpY2sgPSBldmVudFByb3BzLnN0aWNrO1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuc3RpY2s7XHJcbiAgICB9XHJcbiAgICAvLyBmYWxsYmFjayB0byBzdGFuZGFsb25lIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIGRhdGUvdGltZSBwcm9wZXJ0aWVzXHJcbiAgICBpZiAoc3RhcnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICdzdGFydCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gZWwuZGF0YShwcmVmaXggKyAndGltZScpO1xyXG4gICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0aWNrID09IG51bGwpIHtcclxuICAgICAgICBzdGljayA9IGVsLmRhdGEocHJlZml4ICsgJ3N0aWNrJyk7XHJcbiAgICB9XHJcbiAgICAvLyBtYXNzYWdlIGludG8gY29ycmVjdCBkYXRhIHR5cGVzXHJcbiAgICBzdGFydFRpbWUgPSBzdGFydFRpbWUgIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihzdGFydFRpbWUpIDogbnVsbDtcclxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xyXG4gICAgc3RpY2sgPSBCb29sZWFuKHN0aWNrKTtcclxuICAgIHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcbnZhciBIaXREcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnRSZXNpemluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50UmVzaXppbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGVtZW50czpcclxuICAgICAgICAtIGJpbmRTZWdIYW5kbGVyVG9FbFxyXG4gICAgICAgIC0gcHVibGljbHlUcmlnZ2VyXHJcbiAgICAgICAgLSBkaWZmRGF0ZXNcclxuICAgICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgICAtIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgICAgIC0gZ2V0U2FmZUhpdEZvb3RwcmludFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIEV2ZW50UmVzaXppbmcoY29tcG9uZW50LCBldmVudFBvaW50aW5nKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nID0gZXZlbnRQb2ludGluZztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bi5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZywgJChldi50YXJnZXQpLmlzKCcuZmMtc3RhcnQtcmVzaXplcicpKVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHsgZGlzdGFuY2U6IDUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZywgJChldi50YXJnZXQpLmlzKCcuZmMtc3RhcnQtcmVzaXplcicpKVxyXG4gICAgICAgICAgICAgICAgLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIgYXMgdGhleSByZXNpemUgYW4gZXZlbnQgc2VnbWVudC5cclxuICAgIC8vIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBHcmlkLlxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnLCBpc1N0YXJ0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBlbCA9IHNlZy5lbDtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBpc0RyYWdnaW5nO1xyXG4gICAgICAgIHZhciByZXNpemVNdXRhdGlvbjsgLy8gem9uZWQgZXZlbnQgZGF0ZSBwcm9wZXJ0aWVzLiBmYWxzeSBpZiBpbnZhbGlkIHJlc2l6ZVxyXG4gICAgICAgIC8vIFRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZSAqZ3JpZCdzKiBjb29yZGluYXRlIG1hcFxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIHN1YmplY3RFbDogZWwsXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgbW91c2VvdXQgb24gdGhlIG1hbmlwdWxhdGVkIGV2ZW50IGhhcyBiZWVuIHJlcG9ydGVkXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nLmhhbmRsZU1vdXNlb3V0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnUmVzaXplU3RhcnQoc2VnLCBldik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0hpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KG9yaWdIaXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnSGl0Rm9vdHByaW50ICYmIGhpdEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gaXNTdGFydCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVFdmVudFN0YXJ0UmVzaXplTXV0YXRpb24ob3JpZ0hpdEZvb3RwcmludCwgaGl0Rm9vdHByaW50LCBzZWcuZm9vdHByaW50KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXB1dGVFdmVudEVuZFJlc2l6ZU11dGF0aW9uKG9yaWdIaXRGb290cHJpbnQsIGhpdEZvb3RwcmludCwgc2VnLmZvb3RwcmludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBldmVudE1hbmFnZXIuYnVpbGRNdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKGV2ZW50RGVmLmlkLCByZXNpemVNdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNpemVNdXRhdGlvbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjaGFuZ2UuIChGWUksIGV2ZW50IGRhdGVzIG1pZ2h0IGhhdmUgem9uZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5oaWRlRXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyRXZlbnRSZXNpemUoY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhjb21wb25lbnQuZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLCBjYWxlbmRhcikpLCBzZWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmlldy51bnJlbmRlckV2ZW50UmVzaXplKHNlZyk7XHJcbiAgICAgICAgICAgICAgICB2aWV3LnNob3dFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VnUmVzaXplU3RvcChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmUtc2hvdyBvcmlnaW5hbCwgd2lsbCByZXJlbmRlciBhbGwgYW55d2F5cy4gZXNwIGltcG9ydGFudCBpZiBldmVudFJlbmRlcldhaXRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV2ZW50UmVzaXplKGV2ZW50SW5zdGFuY2UsIHJlc2l6ZU11dGF0aW9uLCBlbCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0YXJ0c1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuc2VnUmVzaXplU3RhcnQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHRoaXMuaXNSZXNpemluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBldmVudCBzZWdtZW50IHJlc2l6aW5nIHN0b3BzXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5zZWdSZXNpemVTdG9wID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzUmVzaXppbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplU3RvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmNvbXB1dGVFdmVudFN0YXJ0UmVzaXplTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgb3JpZ0V2ZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIG9yaWdSYW5nZSA9IG9yaWdFdmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBzdGFydERlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKSwgc3RhcnRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCkpO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKG9yaWdSYW5nZS5nZXRTdGFydCgpLmFkZChzdGFydERlbHRhKSA8IG9yaWdSYW5nZS5nZXRFbmQoKSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbi5zZXRTdGFydERlbHRhKHN0YXJ0RGVsdGEpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKGRhdGVNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBuZXcgZGF0ZS1pbmZvcm1hdGlvbiBmb3IgYW4gZXZlbnQgc2VnbWVudCBiZWluZyByZXNpemVkIGZyb20gaXRzIGVuZFxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RW5kUmVzaXplTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgb3JpZ0V2ZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIG9yaWdSYW5nZSA9IG9yaWdFdmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBlbmREZWx0YSA9IHRoaXMuY29tcG9uZW50LmRpZmZEYXRlcyhlbmRGb290cHJpbnQudW56b25lZFJhbmdlLmdldEVuZCgpLCBzdGFydEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKG9yaWdSYW5nZS5nZXRFbmQoKS5hZGQoZW5kRGVsdGEpID4gb3JpZ1JhbmdlLmdldFN0YXJ0KCkpIHtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24uc2V0RW5kRGVsdGEoZW5kRGVsdGEpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKGRhdGVNdXRhdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UmVzaXppbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmVzaXppbmc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBNb3VzZUZvbGxvd2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV2ZW50RHJhZ2dpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudERyYWdnaW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBsZW1lbnRzOlxyXG4gICAgICAgIC0gYmluZFNlZ0hhbmRsZXJUb0VsXHJcbiAgICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICAgICAtIGRpZmZEYXRlc1xyXG4gICAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXZlbnREcmFnZ2luZyhjb21wb25lbnQsIGV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcgPSBldmVudFBvaW50aW5nO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5vcHQoJ2V2ZW50TG9uZ1ByZXNzRGVsYXknKTtcclxuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IHRoaXMub3B0KCdsb25nUHJlc3NEZWxheScpOyAvLyBmYWxsYmFja1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVsYXk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmNhblN0YXJ0RHJhZyhzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgeyBkaXN0YW5jZTogNSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgZGVsYXk6IHRoaXMudmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoc2VnLmZvb3RwcmludC5ldmVudERlZikgPyAvLyBhbHJlYWR5IHNlbGVjdGVkP1xyXG4gICAgICAgICAgICAgICAgMCA6IHRoaXMuZ2V0U2VsZWN0aW9uRGVsYXkoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5jYW5TdGFydERyYWcoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcpLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50LmNhblN0YXJ0U2VsZWN0aW9uKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTZWxlY3RMaXN0ZW5lcihzZWcpLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gc2VnIGlzbid0IGRyYWdnYWJsZSwgYnV0IGxldCdzIHVzZSBhIGdlbmVyaWMgRHJhZ0xpc3RlbmVyXHJcbiAgICAvLyBzaW1wbHkgZm9yIHRoZSBkZWxheSwgc28gaXQgY2FuIGJlIHNlbGVjdGVkLlxyXG4gICAgLy8gSGFzIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcvdW5zZXR0aW5nIGBkcmFnTGlzdGVuZXJgXHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5idWlsZFNlbGVjdExpc3RlbmVyID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTsgLy8gbnVsbCBmb3IgaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50c1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFnTGlzdGVuZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBEcmFnTGlzdGVuZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF2aWV3LmlzRXZlbnREZWZTZWxlY3RlZChldmVudERlZikgJiZcclxuICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZWxlY3RFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgdHJhY2sgdXNlci1kcmFnZ2luZyBvbiBhbiBldmVudCBzZWdtZW50LlxyXG4gICAgLy8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXHJcbiAgICAvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYGRyYWdMaXN0ZW5lcmBcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IGNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZWwgPSBzZWcuZWw7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTsgLy8gbnVsbCBmb3IgaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50c1xyXG4gICAgICAgIHZhciBpc0RyYWdnaW5nO1xyXG4gICAgICAgIHZhciBtb3VzZUZvbGxvd2VyOyAvLyBBIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoYXQgd2lsbCBtb3ZlIHdpdGggdGhlIG1vdXNlXHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgdGhlICp2aWV3J3MqIGNvb3JkaW5hdGUgbWFwLiBBbGxvd3MgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIGJldHdlZW4gc3ViY29tcG9uZW50c1xyXG4gICAgICAgIC8vIG9mIHRoZSB2aWV3LlxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KHZpZXcsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBzdWJqZWN0RWw6IGVsLFxyXG4gICAgICAgICAgICBzdWJqZWN0Q2VudGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5jb21wb25lbnQgPSBjb21wb25lbnQ7IC8vIGZvciByZW5kZXJEcmFnXHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyID0gbmV3IE1vdXNlRm9sbG93ZXJfMS5kZWZhdWx0KHNlZy5lbCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFzczogJ2ZjLWRyYWdnaW5nJyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbDogdmlldy5lbCxcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBkcmFnTGlzdGVuZXIuaXNUb3VjaCA/IG51bGwgOiBfdGhpcy5vcHQoJ2RyYWdPcGFjaXR5JyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0RHVyYXRpb246IF90aGlzLm9wdCgnZHJhZ1JldmVydER1cmF0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiAyIC8vIG9uZSBhYm92ZSB0aGUgLmZjLXZpZXdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGRvbid0IHNob3cgdW50aWwgd2Uga25vdyB0aGlzIGlzIGEgcmVhbCBkcmFnXHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnN0YXJ0KGV2KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF2aWV3LmlzRXZlbnREZWZTZWxlY3RlZChldmVudERlZikgJiZcclxuICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZWxlY3RFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcclxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcuaGFuZGxlTW91c2VvdXQoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdEcmFnU3RhcnQoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmhpZGVFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0Zvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBmb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIGhpdCBjb3VsZCBiZSBmb3JjZWQgKERheUdyaWQubGltaXQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdIaXQgPSBzZWcuaGl0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaGl0IG1pZ2h0IG5vdCBiZWxvbmcgdG8gdGhpcyBncmlkLCBzbyBxdWVyeSBvcmlnaW4gZ3JpZFxyXG4gICAgICAgICAgICAgICAgb3JpZ0Zvb3RwcmludCA9IG9yaWdIaXQuY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQob3JpZ0hpdCk7XHJcbiAgICAgICAgICAgICAgICBmb290cHJpbnQgPSBoaXQuY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnRm9vdHByaW50ICYmIGZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBfdGhpcy5jb21wdXRlRXZlbnREcm9wTXV0YXRpb24ob3JpZ0Zvb3RwcmludCwgZm9vdHByaW50LCBldmVudERlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50TWFuYWdlci5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAoZXZlbnREZWYuaWQsIGV2ZW50RGVmTXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHZhbGlkIGRyb3AgbG9jYXRpb24sIGhhdmUgdGhlIHN1YmNsYXNzIHJlbmRlciBhIHZpc3VhbCBpbmRpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZNdXRhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyRHJhZygvLyB0cnV0aHkgaWYgcmVuZGVyZWQgc29tZXRoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhjb21wb25lbnQuZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLCBjYWxlbmRhcikpLCBzZWcsIGRyYWdMaXN0ZW5lci5pc1RvdWNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBpZiB0aGUgc3ViY2xhc3MgaXMgYWxyZWFkeSB1c2luZyBhIG1vY2sgZXZlbnQgXCJoZWxwZXJcIiwgaGlkZSBvdXIgb3duXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnNob3coKTsgLy8gb3RoZXJ3aXNlLCBoYXZlIHRoZSBoZWxwZXIgZm9sbG93IHRoZSBtb3VzZSAobm8gc25hcHBpbmcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPcmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gaGF2ZSBtb3ZlZCBoaXRzIHRvIGJlIGEgdmFsaWQgZHJvcFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJEcmFnKHNlZyk7IC8vIHVucmVuZGVyIHdoYXRldmVyIHdhcyBkb25lIGluIHJlbmRlckRyYWdcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBzaG93IGluIGNhc2Ugd2UgYXJlIG1vdmluZyBvdXQgb2YgYWxsIGhpdHNcclxuICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWcuY29tcG9uZW50OyAvLyBwcmV2ZW50IHNpZGUgZWZmZWN0c1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gcmV2ZXJ0IGFuaW1hdGlvbiBpZiBoYXNuJ3QgY2hhbmdlZC4gY2FsbHMgYSBjYWxsYmFjayB3aGVuIGZpbmlzaGVkICh3aGV0aGVyIGFuaW1hdGlvbiBvciBub3QpXHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnN0b3AoIWV2ZW50RGVmTXV0YXRpb24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnVucmVuZGVyRHJhZyhzZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWdEcmFnU3RvcChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zaG93RXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudERlZk11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmUtc2hvdyBvcmlnaW5hbCwgd2lsbCByZXJlbmRlciBhbGwgYW55d2F5cy4gZXNwIGltcG9ydGFudCBpZiBldmVudFJlbmRlcldhaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5yZXBvcnRFdmVudERyb3AoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWZNdXRhdGlvbiwgZWwsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBiZWZvcmUgZXZlbnQgc2VnbWVudCBkcmFnZ2luZyBzdGFydHNcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLnNlZ0RyYWdTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJhZ1N0YXJ0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0b3BzXHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5zZWdEcmFnU3RvcCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudERyYWdTdG9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIERPRVMgTk9UIGNvbnNpZGVyIG92ZXJsYXAvY29uc3RyYWludFxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RHJvcE11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQsIGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBldmVudERlZk11dGF0aW9uLnNldERhdGVNdXRhdGlvbih0aGlzLmNvbXB1dGVFdmVudERhdGVNdXRhdGlvbihzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50KSk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RGF0ZU11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgZGF0ZTAgPSBzdGFydEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgZGF0ZTEgPSBlbmRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGZvcmNlVGltZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZGF0ZURlbHRhO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgaWYgKHN0YXJ0Rm9vdHByaW50LmlzQWxsRGF5ICE9PSBlbmRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgY2xlYXJFbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZW5kRm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUFsbERheSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBkYXRlMC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlVGltZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVEZWx0YSA9IHRoaXMuY29tcG9uZW50LmRpZmZEYXRlcyhkYXRlMSwgZGF0ZTApO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBkYXRlTXV0YXRpb24uY2xlYXJFbmQgPSBjbGVhckVuZDtcclxuICAgICAgICBkYXRlTXV0YXRpb24uZm9yY2VUaW1lZCA9IGZvcmNlVGltZWQ7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uLmZvcmNlQWxsRGF5ID0gZm9yY2VBbGxEYXk7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uLnNldERhdGVEZWx0YShkYXRlRGVsdGEpO1xyXG4gICAgICAgIHJldHVybiBkYXRlTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RHJhZ2dpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RHJhZ2dpbmc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRGF0ZVNlbGVjdGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVTZWxlY3RpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IG11c3QgaW1wbGVtZW50OlxyXG4gICAgICAgIC0gYmluZERhdGVIYW5kbGVyVG9FbFxyXG4gICAgICAgIC0gZ2V0U2FmZUhpdEZvb3RwcmludFxyXG4gICAgICAgIC0gcmVuZGVySGlnaGxpZ2h0XHJcbiAgICAgICAgLSB1bnJlbmRlckhpZ2hsaWdodFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGVTZWxlY3RpbmcoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29tcG9uZW50KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IF90aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuZ2V0RGVsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5vcHQoJ3NlbGVjdExvbmdQcmVzc0RlbGF5Jyk7XHJcbiAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsYXkgPSB0aGlzLm9wdCgnbG9uZ1ByZXNzRGVsYXknKTsgLy8gZmFsbGJhY2tcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfTtcclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHQoJ3NlbGVjdGFibGUnKSAmJiAhY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IF90aGlzLm9wdCgnc2VsZWN0TWluRGlzdGFuY2UnKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb21wb25lbnQuYmluZERhdGVIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnc2VsZWN0YWJsZScpICYmICFjb21wb25lbnQuc2hvdWxkSWdub3JlVG91Y2goKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheTogX3RoaXMuZ2V0RGVsYXkoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB1dGlsXzEucHJldmVudFNlbGVjdGlvbihlbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyJ3MgZHJhZyBhY3Jvc3MgZGF5IGVsZW1lbnRzLCBmb3IgZGF5IHNlbGVjdGluZy5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBzZWxlY3Rpb25Gb290cHJpbnQ7IC8vIG51bGwgaWYgaW52YWxpZCBzZWxlY3Rpb25cclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgIHNjcm9sbDogdGhpcy5vcHQoJ2RyYWdTY3JvbGwnKSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcudW5zZWxlY3QoZXYpOyAvLyBzaW5jZSB3ZSBjb3VsZCBiZSByZW5kZXJpbmcgYSBuZXcgc2VsZWN0aW9uLCB3ZSB3YW50IHRvIGNsZWFyIGFueSBvbGQgb25lXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdIaXRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGl0Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnSGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQob3JpZ0hpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdEZvb3RwcmludCAmJiBoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gX3RoaXMuY29tcHV0ZVNlbGVjdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KHNlbGVjdGlvbkZvb3RwcmludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbkZvb3RwcmludCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bnJlbmRlclNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkICYmIHNlbGVjdGlvbkZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb24gd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiByZW5kZXJlZC4ganVzdCByZXBvcnQgaXRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnJlcG9ydFNlbGVjdGlvbihzZWxlY3Rpb25Gb290cHJpbnQsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdGhlIGZpcnN0IGFuZCBsYXN0IGRhdGUtc3BhbnMgb2YgYSBzZWxlY3Rpb24sIHJldHVybnMgYW5vdGhlciBkYXRlLXNwYW4gb2JqZWN0LlxyXG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgYW5kIHByb3ZpZGUgYWRkaXRpb25hbCBkYXRhIGluIHRoZSBzcGFuIG9iamVjdC4gV2lsbCBiZSBwYXNzZWQgdG8gcmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KCkuXHJcbiAgICAvLyBXaWxsIHJldHVybiBmYWxzZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGludmFsaWQgYW5kIHRoaXMgc2hvdWxkIGJlIGluZGljYXRlZCB0byB0aGUgdXNlci5cclxuICAgIC8vIFdpbGwgcmV0dXJuIG51bGwvdW5kZWZpbmVkIGlmIGEgc2VsZWN0aW9uIGludmFsaWQgYnV0IG5vIGVycm9yIHNob3VsZCBiZSByZXBvcnRlZC5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmNvbXB1dGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZm9vdHByaW50MCwgZm9vdHByaW50MSkge1xyXG4gICAgICAgIHZhciB3aG9sZUZvb3RwcmludCA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvbkZvb3RwcmludChmb290cHJpbnQwLCBmb290cHJpbnQxKTtcclxuICAgICAgICBpZiAod2hvbGVGb290cHJpbnQgJiYgIXRoaXMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKHdob2xlRm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3aG9sZUZvb3RwcmludDtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiB0d28gc3BhbnMsIG11c3QgcmV0dXJuIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxyXG4gICAgLy8gVE9ETzogZG8gdGhpcyBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIChjb21iaW5pbmcgVlMgdmFsaWRhdGlvbikgZm9yIGV2ZW50IGRuZC9yZXNpemUgdG9vLlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuY29tcHV0ZVNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChmb290cHJpbnQwLCBmb290cHJpbnQxKSB7XHJcbiAgICAgICAgdmFyIG1zID0gW1xyXG4gICAgICAgICAgICBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MS51bnpvbmVkUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MS51bnpvbmVkUmFuZ2UuZW5kTXNcclxuICAgICAgICBdO1xyXG4gICAgICAgIG1zLnNvcnQodXRpbF8xLmNvbXBhcmVOdW1iZXJzKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQobXNbMF0sIG1zWzNdKSwgZm9vdHByaW50MC5pc0FsbERheSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5kYXRlUHJvZmlsZS52YWxpZFVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpICYmXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVNlbGVjdGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZVNlbGVjdGluZztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcbnZhciBUaW1lR3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcclxudmFyIEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUID0gNTtcclxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIGFsbCBhZ2VuZGEtcmVsYXRlZCB2aWV3cy4gRGlzcGxheXMgb25lIG1vcmUgY29sdW1ucyB3aXRoIHRpbWUgc2xvdHMgcnVubmluZyB2ZXJ0aWNhbGx5LlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gSXMgYSBtYW5hZ2VyIGZvciB0aGUgVGltZUdyaWQgc3ViY29tcG9uZW50IGFuZCBwb3NzaWJseSB0aGUgRGF5R3JpZCBzdWJjb21wb25lbnQgKGlmIGFsbERheVNsb3QgaXMgb24pLlxyXG4vLyBSZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxyXG52YXIgQWdlbmRhVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEFnZW5kYVZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZ2VuZGFWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy51c2VzTWluTWF4VGltZSA9IHRydWU7IC8vIGluZGljYXRlcyB0aGF0IG1pblRpbWUvbWF4VGltZSBhZmZlY3RzIHJlbmRlcmluZ1xyXG4gICAgICAgIF90aGlzLnRpbWVHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVUaW1lR3JpZCgpO1xyXG4gICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLnRpbWVHcmlkKTtcclxuICAgICAgICBpZiAoX3RoaXMub3B0KCdhbGxEYXlTbG90JykpIHtcclxuICAgICAgICAgICAgX3RoaXMuZGF5R3JpZCA9IF90aGlzLmluc3RhbnRpYXRlRGF5R3JpZCgpOyAvLyB0aGUgYWxsLWRheSBzdWJjb21wb25lbnQgb2YgdGhpcyB2aWV3XHJcbiAgICAgICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLmRheUdyaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIEluc3RhbnRpYXRlcyB0aGUgVGltZUdyaWQgb2JqZWN0IHRoaXMgdmlldyBuZWVkcy4gRHJhd3MgZnJvbSB0aGlzLnRpbWVHcmlkQ2xhc3NcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlVGltZUdyaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIFN1YkNsYXNzID0gbWFrZVRpbWVHcmlkU3ViY2xhc3ModGhpcy50aW1lR3JpZENsYXNzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFN1YkNsYXNzKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8vIEluc3RhbnRpYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG1pZ2h0IG5lZWQuIERyYXdzIGZyb20gdGhpcy5kYXlHcmlkQ2xhc3NcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlRGF5R3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgU3ViQ2xhc3MgPSBtYWtlRGF5R3JpZFN1YmNsYXNzKHRoaXMuZGF5R3JpZENsYXNzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFN1YkNsYXNzKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8qIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZFdyYXBFbDtcclxuICAgICAgICB2YXIgdGltZUdyaWRFbDtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1hZ2VuZGEtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICB0aW1lR3JpZFdyYXBFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLXRpbWUtZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICB0aW1lR3JpZEVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXRpbWUtZ3JpZFwiIC8+JykuYXBwZW5kVG8odGltZUdyaWRXcmFwRWwpO1xyXG4gICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLWJvZHkgPiB0ciA+IHRkJykuYXBwZW5kKHRpbWVHcmlkV3JhcEVsKTtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmhlYWRDb250YWluZXJFbCA9IHRoaXMuZWwuZmluZCgnLmZjLWhlYWQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5zZXRFbGVtZW50KHRpbWVHcmlkRWwpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnNldEVsZW1lbnQodGhpcy5lbC5maW5kKCcuZmMtZGF5LWdyaWQnKSk7XHJcbiAgICAgICAgICAgIC8vIGhhdmUgdGhlIGRheS1ncmlkIGV4dGVuZCBpdCdzIGNvb3JkaW5hdGUgYXJlYSBvdmVyIHRoZSA8aHI+IGRpdmlkaW5nIHRoZSB0d28gZ3JpZHNcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmJvdHRvbUNvb3JkUGFkZGluZyA9IHRoaXMuZGF5R3JpZC5lbC5uZXh0KCdocicpLm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmRlc3Ryb3koKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIEhUTUwgc2tlbGV0b24gZm9yIHRoZSB2aWV3LlxyXG4gICAgLy8gVGhlIGRheS1ncmlkIGFuZCB0aW1lLWdyaWQgY29tcG9uZW50cyB3aWxsIHJlbmRlciBpbnNpZGUgY29udGFpbmVycyBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5vcHQoJ2NvbHVtbkhlYWRlcicpID9cclxuICAgICAgICAgICAgICAgICc8dGhlYWQgY2xhc3M9XCJmYy1oZWFkXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtaGVhZC1jb250YWluZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIj4mbmJzcDs8L3RkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzx0Ym9keSBjbGFzcz1cImZjLWJvZHlcIj4nICtcclxuICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5kYXlHcmlkID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZGF5LWdyaWRcIi8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIi8+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSBheGlzLCBpZiBpdCBpcyBrbm93blxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuYXhpc1N0eWxlQXR0ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5heGlzV2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMuYXhpc1dpZHRoICsgJ3B4XCInO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgLyogTm93IEluZGljYXRvclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmdldE5vd0luZGljYXRvclVuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZUdyaWQuZ2V0Tm93SW5kaWNhdG9yVW5pdCgpO1xyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBBZGp1c3RzIHRoZSB2ZXJ0aWNhbCBkaW1lbnNpb25zIG9mIHRoZSB2aWV3IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWVzXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbGVySGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIC8vIG1ha2UgYWxsIGF4aXMgY2VsbHMgbGluZSB1cCwgYW5kIHJlY29yZCB0aGUgd2lkdGggc28gbmV3bHkgY3JlYXRlZCBheGlzIGNlbGxzIHdpbGwgaGF2ZSBpdFxyXG4gICAgICAgIHRoaXMuYXhpc1dpZHRoID0gdXRpbF8xLm1hdGNoQ2VsbFdpZHRocyh0aGlzLmVsLmZpbmQoJy5mYy1heGlzJykpO1xyXG4gICAgICAgIC8vIGhhY2sgdG8gZ2l2ZSB0aGUgdmlldyBzb21lIGhlaWdodCBwcmlvciB0byB0aW1lR3JpZCdzIGNvbHVtbnMgYmVpbmcgcmVuZGVyZWRcclxuICAgICAgICAvLyBUT0RPOiBzZXBhcmF0ZSBzZXR0aW5nIGhlaWdodCBmcm9tIHNjcm9sbGVyIFZTIHRpbWVHcmlkLlxyXG4gICAgICAgIGlmICghdGhpcy50aW1lR3JpZC5jb2xFbHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IG9mIGZha2Ugcm93IGVsZW1lbnRzIHRoYXQgbXVzdCBjb21wZW5zYXRlIHdoZW4gc2Nyb2xsZXIgaGFzIHNjcm9sbGJhcnNcclxuICAgICAgICB2YXIgbm9TY3JvbGxSb3dFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1yb3c6bm90KC5mYy1zY3JvbGxlciAqKScpO1xyXG4gICAgICAgIC8vIHJlc2V0IGFsbCBkaW1lbnNpb25zIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHN0YXRlXHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5ib3R0b21SdWxlRWwuaGlkZSgpOyAvLyAuc2hvdygpIHdpbGwgYmUgY2FsbGVkIGxhdGVyIGlmIHRoaXMgPGhyPiBpcyBuZWNlc3NhcnlcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmNsZWFyKCk7IC8vIHNldHMgaGVpZ2h0IHRvICdhdXRvJyBhbmQgY2xlYXJzIG92ZXJmbG93XHJcbiAgICAgICAgdXRpbF8xLnVuY29tcGVuc2F0ZVNjcm9sbChub1Njcm9sbFJvd0Vscyk7XHJcbiAgICAgICAgLy8gbGltaXQgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUgYWxsLWRheSBhcmVhXHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgICAgICBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudExpbWl0ID0gQUdFTkRBX0FMTF9EQVlfRVZFTlRfTElNSVQ7IC8vIG1ha2Ugc3VyZSBcImF1dG9cIiBnb2VzIHRvIGEgcmVhbCBudW1iZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnRMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBhbGwtZGF5IGFuZCBoZWFkZXIgcm93cyBsaW5lcyB1cFxyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmNvbXBlbnNhdGVTY3JvbGwobm9TY3JvbGxSb3dFbHMsIHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNoYW5nZWQgdGV4dCBmbG93LCB3aGljaCBtaWdodCBhZmZlY3QgaGVpZ2h0LCBzbyByZWNhbGN1bGF0ZVxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJlYXBwbHkgdGhlIGRlc2lyZWQgaGVpZ2h0IHRvIHRoZSBzY3JvbGxlci5cclxuICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBzcGFjZSBiZWxvdyB0aGUgc2xhdHMsIHNob3cgdGhlIGhvcml6b250YWwgcnVsZS5cclxuICAgICAgICAgICAgLy8gdGhpcyB3b24ndCBjYXVzZSBhbnkgbmV3IG92ZXJmbG93LCBiZWNhdXNlIGxvY2tPdmVyZmxvdyBhbHJlYWR5IGNhbGxlZC5cclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZUdyaWQuZ2V0VG90YWxTbGF0SGVpZ2h0KCkgPCBzY3JvbGxlckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lR3JpZC5ib3R0b21SdWxlRWwuc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGEgZGVzaXJlZCB0b3RhbCBoZWlnaHQgb2YgdGhlIHZpZXcsIHJldHVybnMgd2hhdCB0aGUgaGVpZ2h0IG9mIHRoZSBzY3JvbGxlciBzaG91bGQgYmVcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckhlaWdodCA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbEhlaWdodCAtXHJcbiAgICAgICAgICAgIHV0aWxfMS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgIH07XHJcbiAgICAvKiBTY3JvbGxcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyB0aGUgaW5pdGlhbCBwcmUtY29uZmlndXJlZCBzY3JvbGwgc3RhdGUgcHJpb3IgdG8gYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2hhbmdlIGl0XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ3Njcm9sbFRpbWUnKSk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMudGltZUdyaWQuY29tcHV0ZVRpbWVUb3Aoc2Nyb2xsVGltZSk7XHJcbiAgICAgICAgLy8gem9vbSBjYW4gZ2l2ZSB3ZWlyZCBmbG9hdGluZy1wb2ludCB2YWx1ZXMuIHJhdGhlciBzY3JvbGwgYSBsaXR0bGUgYml0IGZ1cnRoZXJcclxuICAgICAgICB0b3AgPSBNYXRoLmNlaWwodG9wKTtcclxuICAgICAgICBpZiAodG9wKSB7XHJcbiAgICAgICAgICAgIHRvcCsrOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AgfTtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5xdWVyeURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuYXBwbHlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3Aoc2Nyb2xsLnRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhpdCBBcmVhc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIGZvcndhcmQgYWxsIGhpdC1yZWxhdGVkIG1ldGhvZCBjYWxscyB0byB0aGUgZ3JpZHMgKGRheUdyaWQgbWlnaHQgbm90IGJlIGRlZmluZWQpXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXRIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXHJcbiAgICAgICAgcmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0Rm9vdHByaW50KGhpdCk7XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgLy8gVE9ETzogaGl0LmNvbXBvbmVudCBpcyBzZXQgYXMgYSBoYWNrIHRvIGlkZW50aWZ5IHdoZXJlIHRoZSBoaXQgY2FtZSBmcm9tXHJcbiAgICAgICAgcmV0dXJuIGhpdC5jb21wb25lbnQuZ2V0SGl0RWwoaGl0KTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5leGVjdXRlRXZlbnRSZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBkYXlFdmVudHNQYXlsb2FkID0ge307XHJcbiAgICAgICAgdmFyIHRpbWVkRXZlbnRzUGF5bG9hZCA9IHt9O1xyXG4gICAgICAgIHZhciBpZCwgZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgIC8vIHNlcGFyYXRlIHRoZSBldmVudHMgaW50byBhbGwtZGF5IGFuZCB0aW1lZFxyXG4gICAgICAgIGZvciAoaWQgaW4gZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXAgPSBldmVudHNQYXlsb2FkW2lkXTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpLmlzQWxsRGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGRheUV2ZW50c1BheWxvYWRbaWRdID0gZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGltZWRFdmVudHNQYXlsb2FkW2lkXSA9IGV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmV4ZWN1dGVFdmVudFJlbmRlcih0aW1lZEV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmV4ZWN1dGVFdmVudFJlbmRlcihkYXlFdmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRHJhZ2dpbmcvUmVzaXppbmcgUm91dGluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHZhciByZW5kZXJlZEhlbHBlciA9IGZhbHNlO1xyXG4gICAgICAgIHJlbmRlcmVkSGVscGVyID0gdGhpcy50aW1lR3JpZC5yZW5kZXJEcmFnKGdyb3Vwcy50aW1lZCwgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVkSGVscGVyID0gdGhpcy5kYXlHcmlkLnJlbmRlckRyYWcoZ3JvdXBzLmFsbERheSwgc2VnLCBpc1RvdWNoKSB8fCByZW5kZXJlZEhlbHBlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkSGVscGVyO1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IGdyb3VwRXZlbnRGb290cHJpbnRzQnlBbGxEYXkoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLnJlbmRlckV2ZW50UmVzaXplKGdyb3Vwcy50aW1lZCwgc2VnLCBpc1RvdWNoKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW5kZXJFdmVudFJlc2l6ZShncm91cHMuYWxsRGF5LCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVHcmlkLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQWdlbmRhVmlldztcclxufShWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBZ2VuZGFWaWV3O1xyXG5BZ2VuZGFWaWV3LnByb3RvdHlwZS50aW1lR3JpZENsYXNzID0gVGltZUdyaWRfMS5kZWZhdWx0O1xyXG5BZ2VuZGFWaWV3LnByb3RvdHlwZS5kYXlHcmlkQ2xhc3MgPSBEYXlHcmlkXzEuZGVmYXVsdDtcclxuLy8gV2lsbCBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBiZWhhdmlvciBvZiB0aGUgQWdlbmRhVmlldydzIHRpbWVHcmlkXHJcbmZ1bmN0aW9uIG1ha2VUaW1lR3JpZFN1YmNsYXNzKFN1cGVyQ2xhc3MpIHtcclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViQ2xhc3MsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJIZWFkSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICAgICAgdmFyIHdlZWtTdGFydCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodGhpcy5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB3ZWVrVGV4dDtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0KCd3ZWVrTnVtYmVycycpKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrVGV4dCA9IHdlZWtTdGFydC5mb3JtYXQodGhpcy5vcHQoJ3NtYWxsV2Vla0Zvcm1hdCcpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0aCBjbGFzcz1cImZjLWF4aXMgZmMtd2Vlay1udW1iZXIgJyArIGNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCgvLyBhc2lkZSBmcm9tIGxpbmssIGltcG9ydGFudCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgeyBkYXRlOiB3ZWVrU3RhcnQsIHR5cGU6ICd3ZWVrJywgZm9yY2VPZmY6IHRoaXMuY29sQ250ID4gMSB9LCB1dGlsXzEuaHRtbEVzY2FwZSh3ZWVrVGV4dCkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0aCBjbGFzcz1cImZjLWF4aXMgJyArIGNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGg+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGJnIG9mIHRoZSBUaW1lR3JpZCBzbG90IGFyZWEuIExvbmcgdmVydGljYWwgY29sdW1uLlxyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgYWxsIG90aGVyIHR5cGVzIG9mIGNlbGxzLlxyXG4gICAgICAgIC8vIEFmZmVjdHMgY29udGVudC1za2VsZXRvbiwgaGVscGVyLXNrZWxldG9uLCBoaWdobGlnaHQtc2tlbGV0b24gZm9yIGJvdGggdGhlIHRpbWUtZ3JpZCBhbmQgZGF5LWdyaWQuXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtYXhpc1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFN1YkNsYXNzO1xyXG4gICAgfShTdXBlckNsYXNzKSk7XHJcbn1cclxuO1xyXG4vLyBXaWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgZGF5R3JpZFxyXG5mdW5jdGlvbiBtYWtlRGF5R3JpZFN1YmNsYXNzKFN1cGVyQ2xhc3MpIHtcclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViQ2xhc3MsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGFsbC1kYXkgY2VsbHNcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVyQmdJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgdmlldy5nZXRBbGxEYXlIdG1sKCkgK1xyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgY2VsbHMuXHJcbiAgICAgICAgLy8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVySW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9KFN1cGVyQ2xhc3MpKTtcclxufVxyXG47XHJcbmZ1bmN0aW9uIGdyb3VwRXZlbnRGb290cHJpbnRzQnlBbGxEYXkoZXZlbnRGb290cHJpbnRzKSB7XHJcbiAgICB2YXIgYWxsRGF5ID0gW107XHJcbiAgICB2YXIgdGltZWQgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGFsbERheS5wdXNoKGV2ZW50Rm9vdHByaW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aW1lZC5wdXNoKGV2ZW50Rm9vdHByaW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYWxsRGF5OiBhbGxEYXksIHRpbWVkOiB0aW1lZCB9O1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcclxudmFyIERheVRhYmxlTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgVGltZUdyaWRFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKTtcclxudmFyIFRpbWVHcmlkSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xyXG52YXIgVGltZUdyaWRGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODUpO1xyXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBXZSBtaXhpbiBEYXlUYWJsZSwgZXZlbiB0aG91Z2ggdGhlcmUgaXMgb25seSBhIHNpbmdsZSByb3cgb2YgZGF5c1xyXG4vLyBwb3RlbnRpYWwgbmljZSB2YWx1ZXMgZm9yIHRoZSBzbG90LWR1cmF0aW9uIGFuZCBpbnRlcnZhbC1kdXJhdGlvblxyXG4vLyBmcm9tIGxhcmdlc3QgdG8gc21hbGxlc3RcclxudmFyIEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TID0gW1xyXG4gICAgeyBob3VyczogMSB9LFxyXG4gICAgeyBtaW51dGVzOiAzMCB9LFxyXG4gICAgeyBtaW51dGVzOiAxNSB9LFxyXG4gICAgeyBzZWNvbmRzOiAzMCB9LFxyXG4gICAgeyBzZWNvbmRzOiAxNSB9XHJcbl07XHJcbnZhciBUaW1lR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZUdyaWQodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucHJvY2Vzc09wdGlvbnMoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlUaW1lcyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5jb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2Vnc1tpXS5kYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NbaV0uY29sID0gc2Vnc1tpXS5kYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIEhhbmRsaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnNsaWNlUmFuZ2VCeVRpbWVzID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHNlZ1JhbmdlO1xyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCB0aGlzLmRheXNQZXJSb3c7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VnUmFuZ2UgPSB1bnpvbmVkUmFuZ2UuaW50ZXJzZWN0KHRoaXMuZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1zOiBzZWdSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZE1zOiBzZWdSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5pc0VuZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleDogZGF5SW5kZXhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIE9wdGlvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBQYXJzZXMgdmFyaW91cyBvcHRpb25zIGludG8gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzbG90RHVyYXRpb24gPSB0aGlzLm9wdCgnc2xvdER1cmF0aW9uJyk7XHJcbiAgICAgICAgdmFyIHNuYXBEdXJhdGlvbiA9IHRoaXMub3B0KCdzbmFwRHVyYXRpb24nKTtcclxuICAgICAgICB2YXIgaW5wdXQ7XHJcbiAgICAgICAgc2xvdER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uID8gbW9tZW50LmR1cmF0aW9uKHNuYXBEdXJhdGlvbikgOiBzbG90RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbG90RHVyYXRpb24gPSBzbG90RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5zbmFwc1BlclNsb3QgPSBzbG90RHVyYXRpb24gLyBzbmFwRHVyYXRpb247IC8vIFRPRE86IGVuc3VyZSBhbiBpbnRlZ2VyIG11bHRpcGxlP1xyXG4gICAgICAgIC8vIG1pZ2h0IGJlIGFuIGFycmF5IHZhbHVlIChmb3IgVGltZWxpbmVWaWV3KS5cclxuICAgICAgICAvLyBpZiBzbywgZ2V0dGluZyB0aGUgbW9zdCBncmFudWxhciBlbnRyeSAodGhlIGxhc3Qgb25lIHByb2JhYmx5KS5cclxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0KCdzbG90TGFiZWxGb3JtYXQnKTtcclxuICAgICAgICBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhYmVsRm9ybWF0ID0gaW5wdXQgfHxcclxuICAgICAgICAgICAgdGhpcy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpOyAvLyB0aGUgY29tcHV0ZWQgZGVmYXVsdFxyXG4gICAgICAgIGlucHV0ID0gdGhpcy5vcHQoJ3Nsb3RMYWJlbEludGVydmFsJyk7XHJcbiAgICAgICAgdGhpcy5sYWJlbEludGVydmFsID0gaW5wdXQgP1xyXG4gICAgICAgICAgICBtb21lbnQuZHVyYXRpb24oaW5wdXQpIDpcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlTGFiZWxJbnRlcnZhbChzbG90RHVyYXRpb24pO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuIGF1dG9tYXRpYyB2YWx1ZSBmb3Igc2xvdExhYmVsSW50ZXJ2YWxcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlTGFiZWxJbnRlcnZhbCA9IGZ1bmN0aW9uIChzbG90RHVyYXRpb24pIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGFiZWxJbnRlcnZhbDtcclxuICAgICAgICB2YXIgc2xvdHNQZXJMYWJlbDtcclxuICAgICAgICAvLyBmaW5kIHRoZSBzbWFsbGVzdCBzdG9jayBsYWJlbCBpbnRlcnZhbCB0aGF0IHJlc3VsdHMgaW4gbW9yZSB0aGFuIG9uZSBzbG90cy1wZXItbGFiZWxcclxuICAgICAgICBmb3IgKGkgPSBBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBsYWJlbEludGVydmFsID0gbW9tZW50LmR1cmF0aW9uKEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TW2ldKTtcclxuICAgICAgICAgICAgc2xvdHNQZXJMYWJlbCA9IHV0aWxfMS5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24obGFiZWxJbnRlcnZhbCwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0ludChzbG90c1BlckxhYmVsKSAmJiBzbG90c1BlckxhYmVsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbihzbG90RHVyYXRpb24pOyAvLyBmYWxsIGJhY2suIGNsb25lXHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2xhdHMoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckNvbHVtbnMoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3RoaXMudW5yZW5kZXJTbGF0cygpOyAvLyBkb24ndCBuZWVkIHRoaXMgYmVjYXVzZSByZXBlYXRlZCAuaHRtbCgpIGNhbGxzIGNsZWFyXHJcbiAgICAgICAgdGhpcy51bnJlbmRlckNvbHVtbnMoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHRoaXMuZWwuaHRtbCgnPGRpdiBjbGFzcz1cImZjLWJnXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtc2xhdHNcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIC8+Jyk7XHJcbiAgICAgICAgdGhpcy5ib3R0b21SdWxlRWwgPSB0aGlzLmVsLmZpbmQoJ2hyJyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNsYXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB0aGlzLnNsYXRDb250YWluZXJFbCA9IHRoaXMuZWwuZmluZCgnPiAuZmMtc2xhdHMnKVxyXG4gICAgICAgICAgICAuaHRtbCgvLyBhdm9pZHMgbmVlZGluZyA6OnVucmVuZGVyU2xhdHMoKVxyXG4gICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNsYXRSb3dIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nKTtcclxuICAgICAgICB0aGlzLnNsYXRFbHMgPSB0aGlzLnNsYXRDb250YWluZXJFbC5maW5kKCd0cicpO1xyXG4gICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMuc2xhdEVscyxcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlclNsYXRSb3dIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIGlzUlRMID0gdGhpcy5pc1JUTDtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHNsb3RUaW1lID0gbW9tZW50LmR1cmF0aW9uKCtkYXRlUHJvZmlsZS5taW5UaW1lKTsgLy8gd2lzaCB0aGVyZSB3YXMgLmNsb25lKCkgZm9yIGR1cmF0aW9uc1xyXG4gICAgICAgIHZhciBzbG90SXRlcmF0b3IgPSBtb21lbnQuZHVyYXRpb24oMCk7XHJcbiAgICAgICAgdmFyIHNsb3REYXRlOyAvLyB3aWxsIGJlIG9uIHRoZSB2aWV3J3MgZmlyc3QgZGF5LCBidXQgd2Ugb25seSBjYXJlIGFib3V0IGl0cyB0aW1lXHJcbiAgICAgICAgdmFyIGlzTGFiZWxlZDtcclxuICAgICAgICB2YXIgYXhpc0h0bWw7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0aW1lIGZvciBlYWNoIHNsb3RcclxuICAgICAgICB3aGlsZSAoc2xvdFRpbWUgPCBkYXRlUHJvZmlsZS5tYXhUaW1lKSB7XHJcbiAgICAgICAgICAgIHNsb3REYXRlID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcykudGltZShzbG90VGltZSk7XHJcbiAgICAgICAgICAgIGlzTGFiZWxlZCA9IHV0aWxfMS5pc0ludCh1dGlsXzEuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKHNsb3RJdGVyYXRvciwgdGhpcy5sYWJlbEludGVydmFsKSk7XHJcbiAgICAgICAgICAgIGF4aXNIdG1sID1cclxuICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1heGlzIGZjLXRpbWUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAoaXNMYWJlbGVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShzbG90RGF0ZS5mb3JtYXQodGhpcy5sYWJlbEZvcm1hdCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgICAgICAgICAgaHRtbCArPVxyXG4gICAgICAgICAgICAgICAgJzx0ciBkYXRhLXRpbWU9XCInICsgc2xvdERhdGUuZm9ybWF0KCdISDptbTpzcycpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzTGFiZWxlZCA/ICcnIDogJyBjbGFzcz1cImZjLW1pbm9yXCInKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAoIWlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIi8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPC90cj5cIjtcclxuICAgICAgICAgICAgc2xvdFRpbWUuYWRkKHRoaXMuc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgc2xvdEl0ZXJhdG9yLmFkZCh0aGlzLnNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1sO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHRoaXMuZGF5UmFuZ2VzID0gdGhpcy5kYXlEYXRlcy5tYXAoZnVuY3Rpb24gKGRheURhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRheURhdGUuY2xvbmUoKS5hZGQoZGF0ZVByb2ZpbGUubWluVGltZSksIGRheURhdGUuY2xvbmUoKS5hZGQoZGF0ZVByb2ZpbGUubWF4VGltZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmhlYWRDb250YWluZXJFbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRDb250YWluZXJFbC5odG1sKHRoaXMucmVuZGVySGVhZEh0bWwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuZmluZCgnPiAuZmMtYmcnKS5odG1sKCc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJnVHJIdG1sKDApICsgLy8gcm93PTBcclxuICAgICAgICAgICAgJzwvdGFibGU+Jyk7XHJcbiAgICAgICAgdGhpcy5jb2xFbHMgPSB0aGlzLmVsLmZpbmQoJy5mYy1kYXksIC5mYy1kaXNhYmxlZC1kYXknKTtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMuY29sRWxzLFxyXG4gICAgICAgICAgICBpc0hvcml6b250YWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlbmRlckNvbnRlbnRTa2VsZXRvbigpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckNvbnRlbnRTa2VsZXRvbigpO1xyXG4gICAgfTtcclxuICAgIC8qIENvbnRlbnQgU2tlbGV0b25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIHRoZSBET00gdGhhdCB0aGUgdmlldydzIGNvbnRlbnQgd2lsbCBsaXZlIGluXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyQ29udGVudFNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjZWxsSHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNlbGxIdG1sICs9XHJcbiAgICAgICAgICAgICAgICAnPHRkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1jb2xcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lciBmYy1oZWxwZXItY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWhpZ2hsaWdodC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1idXNpbmVzcy1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tlbGV0b25FbCA9IHRoaXMuY29udGVudFNrZWxldG9uRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlPicgK1xyXG4gICAgICAgICAgICAnPHRyPicgKyBjZWxsSHRtbCArICc8L3RyPicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIHRoaXMuY29sQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtY29udGVudC1jb2wnKTtcclxuICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWhlbHBlci1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmZnQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtZXZlbnQtY29udGFpbmVyOm5vdCguZmMtaGVscGVyLWNvbnRhaW5lciknKTtcclxuICAgICAgICB0aGlzLmJnQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtYmdldmVudC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmhpZ2hsaWdodENvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWhpZ2hsaWdodC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtYnVzaW5lc3MtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5ib29rZW5kQ2VsbHMoc2tlbGV0b25FbC5maW5kKCd0cicpKTsgLy8gVE9ETzogZG8gdGhpcyBvbiBzdHJpbmcgbGV2ZWxcclxuICAgICAgICB0aGlzLmVsLmFwcGVuZChza2VsZXRvbkVsKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJDb250ZW50U2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50U2tlbGV0b25FbC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbENvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYmdDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGZsYXQgYXJyYXkgb2Ygc2VnbWVudHMsIHJldHVybiBhbiBhcnJheSBvZiBzdWItYXJyYXlzLCBncm91cGVkIGJ5IGVhY2ggc2VnbWVudCdzIGNvbFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdyb3VwU2Vnc0J5Q29sID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5Q29sID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29sQ250OyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzQnlDb2xbc2Vnc1tpXS5jb2xdLnB1c2goc2Vnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzQnlDb2w7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgZ3JvdXBlZCBieSBjb2x1bW4sIGluc2VydCB0aGUgc2VnbWVudHMnIGVsZW1lbnRzIGludG8gYSBwYXJhbGxlbCBhcnJheSBvZiBjb250YWluZXJcclxuICAgIC8vIGVsZW1lbnRzLCBlYWNoIGxpdmluZyB3aXRoaW4gYSBjb2x1bW4uXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuYXR0YWNoU2Vnc0J5Q29sID0gZnVuY3Rpb24gKHNlZ3NCeUNvbCwgY29udGFpbmVyRWxzKSB7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgc2VncztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBzZWdzID0gc2Vnc0J5Q29sW2NvbF07XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbHMuZXEoY29sKS5hcHBlbmQoc2Vnc1tpXS5lbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogTm93IEluZGljYXRvclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnbWludXRlJzsgLy8gd2lsbCByZWZyZXNoIG9uIHRoZSBtaW51dGVcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAvLyBIQUNLOiBpZiBkYXRlIGNvbHVtbnMgbm90IHJlYWR5IGZvciBzb21lIHJlYXNvbiAoc2NoZWR1bGVyKVxyXG4gICAgICAgIGlmICghdGhpcy5jb2xDb250YWluZXJFbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZWcgc3lzdGVtIG1pZ2h0IGJlIG92ZXJraWxsLCBidXQgaXQgaGFuZGxlcyBzY2VuYXJpbyB3aGVyZSBsaW5lIG5lZWRzIHRvIGJlIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gIG1vcmUgdGhhbiBvbmNlIGJlY2F1c2Ugb2YgY29sdW1ucyB3aXRoIHRoZSBzYW1lIGRhdGUgKHJlc291cmNlcyBjb2x1bW5zIGZvciBleGFtcGxlKVxyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF0ZSwgZGF0ZS52YWx1ZU9mKCkgKyAxKSwgLy8gcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcclxuICAgICAgICBmYWxzZSAvLyBhbGwtZGF5XHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3AoZGF0ZSwgZGF0ZSk7XHJcbiAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gcmVuZGVyIGxpbmVzIHdpdGhpbiB0aGUgY29sdW1uc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lXCI+PC9kaXY+JylcclxuICAgICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIHRvcClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmNvbENvbnRhaW5lckVscy5lcShzZWdzW2ldLmNvbCkpWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1hcnJvd1wiPjwvZGl2PicpXHJcbiAgICAgICAgICAgICAgICAuY3NzKCd0b3AnLCB0b3ApXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8odGhpcy5lbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbicpKVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm93SW5kaWNhdG9yRWxzID0gJChub2Rlcyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvckVscykge1xyXG4gICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBDb29yZGluYXRlc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcclxuICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWdWZXJ0aWNhbHMoW10uY29uY2F0KHRoaXMuZXZlbnRSZW5kZXJlci5nZXRTZWdzKCksIHRoaXMuYnVzaW5lc3NTZWdzIHx8IFtdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXRUb3RhbFNsYXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xhdENvbnRhaW5lckVsLm91dGVySGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgIC8vIGBtc2AgY2FuIGJlIGEgbWlsbGlzZWNvbmQgVVRDIHRpbWUgT1IgYSBVVEMgbW9tZW50LlxyXG4gICAgLy8gQSBgc3RhcnRPZkRheURhdGVgIG11c3QgYmUgZ2l2ZW4gZm9yIGF2b2lkaW5nIGFtYmlndWl0eSBvdmVyIGhvdyB0byB0cmVhdCBtaWRuaWdodC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlRGF0ZVRvcCA9IGZ1bmN0aW9uIChtcywgc3RhcnRPZkRheURhdGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChtb21lbnQuZHVyYXRpb24obXMgLSBzdGFydE9mRGF5RGF0ZS5jbG9uZSgpLnN0cmlwVGltZSgpKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gdGltZSAoYSBEdXJhdGlvbikuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVRpbWVUb3AgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnNsYXRFbHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIHNsYXRDb3ZlcmFnZSA9ICh0aW1lIC0gZGF0ZVByb2ZpbGUubWluVGltZSkgLyB0aGlzLnNsb3REdXJhdGlvbjsgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXHJcbiAgICAgICAgdmFyIHNsYXRJbmRleDtcclxuICAgICAgICB2YXIgc2xhdFJlbWFpbmRlcjtcclxuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxyXG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgb2Ygc2xhdHMgKGluY2x1c2l2ZSlcclxuICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIG1pblRpbWUvbWF4VGltZSBtaWdodCBiZSBjdXN0b21pemVkLlxyXG4gICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgIC8vIGFuIGludGVnZXIgaW5kZXggb2YgdGhlIGZ1cnRoZXN0IHdob2xlIHNsYXRcclxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXHJcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xyXG4gICAgICAgIHNsYXRJbmRleCA9IE1hdGgubWluKHNsYXRJbmRleCwgbGVuIC0gMSk7XHJcbiAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXHJcbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcclxuICAgICAgICBzbGF0UmVtYWluZGVyID0gc2xhdENvdmVyYWdlIC0gc2xhdEluZGV4O1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNsYXRDb29yZENhY2hlLmdldFRvcFBvc2l0aW9uKHNsYXRJbmRleCkgK1xyXG4gICAgICAgICAgICB0aGlzLnNsYXRDb29yZENhY2hlLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcclxuICAgIH07XHJcbiAgICAvLyBSZWZyZXNoZXMgdGhlIENTUyB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIGZvciBlYWNoIHNlZ21lbnQgZWxlbWVudC5cclxuICAgIC8vIFdvcmtzIHdoZW4gY2FsbGVkIGFmdGVyIGluaXRpYWwgcmVuZGVyLCBhZnRlciBhIHdpbmRvdyByZXNpemUvem9vbSBmb3IgZXhhbXBsZS5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51cGRhdGVTZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgICAgICB0aGlzLmFzc2lnblNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBGb3IgZWFjaCBzZWdtZW50IGluIGFuIGFycmF5LCBjb21wdXRlcyBhbmQgYXNzaWducyBpdHMgdG9wIGFuZCBib3R0b20gcHJvcGVydGllc1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVTZWdWZXJ0aWNhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBldmVudE1pbkhlaWdodCA9IHRoaXMub3B0KCdhZ2VuZGFFdmVudE1pbkhlaWdodCcpO1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgdmFyIGRheURhdGU7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgZGF5RGF0ZSA9IHRoaXMuZGF5RGF0ZXNbc2VnLmRheUluZGV4XTtcclxuICAgICAgICAgICAgc2VnLnRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0TXMsIGRheURhdGUpO1xyXG4gICAgICAgICAgICBzZWcuYm90dG9tID0gTWF0aC5tYXgoc2VnLnRvcCArIGV2ZW50TWluSGVpZ2h0LCB0aGlzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmRNcywgZGF5RGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBzZWdtZW50cyB0aGF0IGFscmVhZHkgaGF2ZSB0aGVpciB0b3AvYm90dG9tIHByb3BlcnRpZXMgY29tcHV0ZWQsIGFwcGxpZXMgdGhvc2UgdmFsdWVzIHRvXHJcbiAgICAvLyB0aGUgc2VnbWVudHMnIGVsZW1lbnRzLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmFzc2lnblNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIENTUyBwcm9wZXJ0aWVzIGZvciB0aGUgdG9wL2JvdHRvbSBjb29yZGluYXRlcyBvZiBhIHNlZ21lbnQgZWxlbWVudFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdlbmVyYXRlU2VnVmVydGljYWxDc3MgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9wOiBzZWcudG9wLFxyXG4gICAgICAgICAgICBib3R0b206IC1zZWcuYm90dG9tIC8vIGZsaXBwZWQgYmVjYXVzZSBuZWVkcyB0byBiZSBzcGFjZSBiZXlvbmQgYm90dG9tIGVkZ2Ugb2YgZXZlbnQgY29udGFpbmVyXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKiBIaXQgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUuYnVpbGQoKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVsZWFzZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmNsZWFyKCk7XHJcbiAgICAgICAgLy8gTk9URTogZG9uJ3QgY2xlYXIgc2xhdENvb3JkQ2FjaGUgYmVjYXVzZSB3ZSByZWx5IG9uIGl0IGZvciBjb21wdXRlVGltZVRvcFxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICB2YXIgc25hcHNQZXJTbG90ID0gdGhpcy5zbmFwc1BlclNsb3Q7XHJcbiAgICAgICAgdmFyIGNvbENvb3JkQ2FjaGUgPSB0aGlzLmNvbENvb3JkQ2FjaGU7XHJcbiAgICAgICAgdmFyIHNsYXRDb29yZENhY2hlID0gdGhpcy5zbGF0Q29vcmRDYWNoZTtcclxuICAgICAgICBpZiAoY29sQ29vcmRDYWNoZS5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiBzbGF0Q29vcmRDYWNoZS5pc1RvcEluQm91bmRzKHRvcE9mZnNldCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbEluZGV4ID0gY29sQ29vcmRDYWNoZS5nZXRIb3Jpem9udGFsSW5kZXgobGVmdE9mZnNldCk7XHJcbiAgICAgICAgICAgIHZhciBzbGF0SW5kZXggPSBzbGF0Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xJbmRleCAhPSBudWxsICYmIHNsYXRJbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xhdFRvcCA9IHNsYXRDb29yZENhY2hlLmdldFRvcE9mZnNldChzbGF0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRDYWNoZS5nZXRIZWlnaHQoc2xhdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gKHRvcE9mZnNldCAtIHNsYXRUb3ApIC8gc2xhdEhlaWdodDsgLy8gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsU25hcEluZGV4ID0gTWF0aC5mbG9vcihwYXJ0aWFsICogc25hcHNQZXJTbG90KTsgLy8gdGhlIHNuYXAgIyByZWxhdGl2ZSB0byBzdGFydCBvZiBzbGF0XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcEluZGV4ID0gc2xhdEluZGV4ICogc25hcHNQZXJTbG90ICsgbG9jYWxTbmFwSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgc25hcFRvcCA9IHNsYXRUb3AgKyAobG9jYWxTbmFwSW5kZXggLyBzbmFwc1BlclNsb3QpICogc2xhdEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwQm90dG9tID0gc2xhdFRvcCArICgobG9jYWxTbmFwSW5kZXggKyAxKSAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHNuYXA6IHNuYXBJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sQ29vcmRDYWNoZS5nZXRMZWZ0T2Zmc2V0KGNvbEluZGV4KSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sQ29vcmRDYWNoZS5nZXRSaWdodE9mZnNldChjb2xJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBzbmFwVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogc25hcEJvdHRvbVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUoMCwgaGl0LmNvbCk7IC8vIHJvdz0wXHJcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLmNvbXB1dGVTbmFwVGltZShoaXQuc25hcCk7IC8vIHBhc3MgaW4gdGhlIHNuYXAtaW5kZXhcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIHN0YXJ0LnRpbWUodGltZSk7XHJcbiAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5zbmFwRHVyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgZmFsc2UgLy8gYWxsLWRheT9cclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgcm93IG51bWJlciBvZiB0aGUgZ3JpZCwgcmVwcmVzZW50aW5nIGEgXCJzbmFwXCIsIHJldHVybnMgYSB0aW1lIChEdXJhdGlvbikgZnJvbSBpdHMgc3RhcnQtb2YtZGF5XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNuYXBUaW1lID0gZnVuY3Rpb24gKHNuYXBJbmRleCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24odGhpcy5kYXRlUHJvZmlsZS5taW5UaW1lICsgdGhpcy5zbmFwRHVyYXRpb24gKiBzbmFwSW5kZXgpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXRIaXRFbCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xFbHMuZXEoaGl0LmNvbCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWQgb3ZlciB0aGUgc3BlY2lmaWVkIGRhdGUocykuXHJcbiAgICAvLyBBIHJldHVybmVkIHZhbHVlIG9mIGB0cnVlYCBzaWduYWxzIHRoYXQgYSBtb2NrIFwiaGVscGVyXCIgZXZlbnQgaGFzIGJlZW4gcmVuZGVyZWQuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzZWcpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYSBoZWxwZXIgaGFzIGJlZW4gcmVuZGVyZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIGRyYWdnZWRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckRyYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZXNpemUgVmlzdWFsaXphdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnJlbmRlckV2ZW50UmVzaXppbmdGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvKiBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb24uIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCwgd2hpY2ggd2FzIHRvIHNpbXBseSByZW5kZXIgYSBoaWdobGlnaHQuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnc2VsZWN0SGVscGVyJykpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJDb21wb25lbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYSBzZWxlY3Rpb25cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lR3JpZDtcclxufShJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVHcmlkO1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gVGltZUdyaWRFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuVGltZUdyaWQucHJvdG90eXBlLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MgPSBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5oZWxwZXJSZW5kZXJlckNsYXNzID0gVGltZUdyaWRIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5maWxsUmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkRmlsbFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xLmRlZmF1bHQubWl4SW50byhUaW1lR3JpZCk7XHJcbkRheVRhYmxlTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGltZUdyaWQpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpOyAvLyBhbiBVbnpvbmVkUmFuZ2VcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLm1zVG9VdGNNb21lbnQocmVuZGVyVW56b25lZFJhbmdlLmVuZE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICAvLyB5ZWFyIGFuZCBtb250aCB2aWV3cyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHdlZWtzLiB0aGlzIGlzIGFscmVhZHkgZG9uZSBmb3Igd2Vla1xyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RhcnRPZignd2VlaycpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XHJcbiAgICAgICAgICAgIGlmIChlbmQud2Vla2RheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKDEsICd3ZWVrJykuc3RhcnRPZignd2VlaycpOyAvLyBleGNsdXNpdmVseSBtb3ZlIGJhY2t3YXJkc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3MCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgQmFzaWNWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcclxuLyogQSBtb250aCB2aWV3IHdpdGggZGF5IGNlbGxzIHJ1bm5pbmcgaW4gcm93cyAob25lLXBlci13ZWVrKSBhbmQgY29sdW1uc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXHJcbiAgICBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZS5jYWxsKHRoaXMsIGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMubXNUb1V0Y01vbWVudChyZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMubXNUb1V0Y01vbWVudChyZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHZhciByb3dDbnQ7XHJcbiAgICAgICAgLy8gZW5zdXJlIDYgd2Vla3NcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ2ZpeGVkV2Vla0NvdW50JykpIHtcclxuICAgICAgICAgICAgcm93Q250ID0gTWF0aC5jZWlsKC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcclxuICAgICAgICAgICAgZW5kLmRpZmYoc3RhcnQsICd3ZWVrcycsIHRydWUpIC8vIGRvbnRSb3VuZD10cnVlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGVuZC5hZGQoNiAtIHJvd0NudCwgJ3dlZWtzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0KSk7XHJcbnZhciBNb250aFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb250aFZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb250aFZpZXcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IEJhc2ljVmlldyBiZWhhdmlvciB0byBoYXZlIHNwZWNpYWwgbXVsdGktd2VlayBhdXRvLWhlaWdodCBsb2dpY1xyXG4gICAgTW9udGhWaWV3LnByb3RvdHlwZS5zZXRHcmlkSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgLy8gaWYgYXV0bywgbWFrZSB0aGUgaGVpZ2h0IG9mIGVhY2ggcm93IHRoZSBoZWlnaHQgdGhhdCBpdCB3b3VsZCBiZSBpZiB0aGVyZSB3ZXJlIDYgd2Vla3NcclxuICAgICAgICBpZiAoaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAqPSB0aGlzLmRheUdyaWQucm93Q250IC8gNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbF8xLmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0VscywgaGVpZ2h0LCAhaXNBdXRvKTsgLy8gaWYgYXV0bywgZG9uJ3QgY29tcGVuc2F0ZSBmb3IgaGVpZ2h0LWhvZ2dpbmcgcm93c1xyXG4gICAgfTtcclxuICAgIE1vbnRoVmlldy5wcm90b3R5cGUuaXNEYXRlSW5PdGhlck1vbnRoID0gZnVuY3Rpb24gKGRhdGUsIGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGUubW9udGgoKSAhPT0gbW9tZW50LnV0YyhkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLnN0YXJ0TXMpLm1vbnRoKCk7IC8vIFRPRE86IG9wdGltaXplXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vbnRoVmlldztcclxufShCYXNpY1ZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vbnRoVmlldztcclxuTW9udGhWaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcbnZhciBMaXN0RXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XHJcbnZhciBMaXN0RXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XHJcbi8qXHJcblJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cclxuKi9cclxudmFyIExpc3RWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdFZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0VmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhciwgdmlld1NwZWMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgPSAnLmZjLWxpc3QtaXRlbSc7IC8vIHdoaWNoIGVsZW1lbnRzIGFjY2VwdCBldmVudCBhY3Rpb25zXHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtbGlzdC12aWV3ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdsaXN0VmlldycpKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZWwuYXBwZW5kVG8odGhpcy5lbCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSB0aGlzLnNjcm9sbGVyLnNjcm9sbEVsOyAvLyBzaG9ydGN1dFxyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpOyAvLyB3aWxsIHJlbW92ZSB0aGUgR3JpZCB0b29cclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KSk7XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckhlaWdodCA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbEhlaWdodCAtXHJcbiAgICAgICAgICAgIHV0aWxfMS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBkYXlTdGFydCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQoZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIHRydWUpO1xyXG4gICAgICAgIHZhciB2aWV3RW5kID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBkYXlEYXRlcyA9IFtdO1xyXG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XHJcbiAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGRheVJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRheVN0YXJ0LCBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5JykpKTtcclxuICAgICAgICAgICAgZGF5U3RhcnQuYWRkKDEsICdkYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xyXG4gICAgICAgIHRoaXMuZGF5UmFuZ2VzID0gZGF5UmFuZ2VzO1xyXG4gICAgICAgIC8vIGFsbCByZWFsIHJlbmRlcmluZyBoYXBwZW5zIGluIEV2ZW50UmVuZGVyZXJcclxuICAgIH07XHJcbiAgICAvLyBzbGljZXMgYnkgZGF5XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSB0aGlzLmRheVJhbmdlcztcclxuICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgdmFyIHNlZ1JhbmdlO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBkYXlSYW5nZXMubGVuZ3RoOyBkYXlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHNlZ1JhbmdlID0gZm9vdHByaW50LnVuem9uZWRSYW5nZS5pbnRlcnNlY3QoZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2VnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TXM6IHNlZ1JhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTXM6IHNlZ1JhbmdlLmVuZE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmlzRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4OiBkYXlJbmRleFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHdoZW4gZm9vdHByaW50IHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIG11dGF0ZSB0aGUgbGF0ZXN0IHNlZyB0byB0aGUgYmUgdGhlIGVuZC5cclxuICAgICAgICAgICAgICAgIGlmICghc2VnLmlzRW5kICYmICFmb290cHJpbnQuaXNBbGxEYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZm9vdHByaW50LnVuem9uZWRSYW5nZS5lbmRNcyA8IGRheVJhbmdlc1tkYXlJbmRleCArIDFdLnN0YXJ0TXMgKyB0aGlzLm5leHREYXlUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZW5kTXMgPSBmb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlckVtcHR5TWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5odG1sKCc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMlwiPicgKyAvLyBUT0RPOiB0cnkgbGVzcyB3cmFwc1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDFcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5XCI+JyArXHJcbiAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHRoaXMub3B0KCdub0V2ZW50c01lc3NhZ2UnKSkgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgfTtcclxuICAgIC8vIHJlbmRlciB0aGUgZXZlbnQgc2VnbWVudHMgaW4gdGhlIHZpZXdcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWdMaXN0ID0gZnVuY3Rpb24gKGFsbFNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5RGF5ID0gdGhpcy5ncm91cFNlZ3NCeURheShhbGxTZWdzKTsgLy8gc3BhcnNlIGFycmF5XHJcbiAgICAgICAgdmFyIGRheUluZGV4O1xyXG4gICAgICAgIHZhciBkYXlTZWdzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0YWJsZUVsID0gJCgnPHRhYmxlIGNsYXNzPVwiZmMtbGlzdC10YWJsZSAnICsgdGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndGFibGVMaXN0JykgKyAnXCI+PHRib2R5Lz48L3RhYmxlPicpO1xyXG4gICAgICAgIHZhciB0Ym9keUVsID0gdGFibGVFbC5maW5kKCd0Ym9keScpO1xyXG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHNlZ3NCeURheS5sZW5ndGg7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgZGF5U2VncyA9IHNlZ3NCeURheVtkYXlJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgYSBkYXkgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICB0Ym9keUVsLmFwcGVuZCh0aGlzLmRheUhlYWRlckh0bWwodGhpcy5kYXlEYXRlc1tkYXlJbmRleF0pKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5zb3J0RXZlbnRTZWdzKGRheVNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRheVNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0Ym9keUVsLmFwcGVuZChkYXlTZWdzW2ldLmVsKTsgLy8gYXBwZW5kIGV2ZW50IHJvd1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCkuYXBwZW5kKHRhYmxlRWwpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBzcGFyc2UgYXJyYXkgb2YgYXJyYXlzLCBzZWdzIGdyb3VwZWQgYnkgdGhlaXIgZGF5SW5kZXhcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5ncm91cFNlZ3NCeURheSA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3NCeURheSA9IFtdOyAvLyBzcGFyc2UgYXJyYXlcclxuICAgICAgICB2YXIgaSwgc2VnO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSB8fCAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gPSBbXSkpXHJcbiAgICAgICAgICAgICAgICAucHVzaChzZWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Vnc0J5RGF5O1xyXG4gICAgfTtcclxuICAgIC8vIGdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRheSBoZWFkZXJzIHRoYXQgbGl2ZSBhbW9uZ3N0IHRoZSBldmVudCByb3dzXHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuZGF5SGVhZGVySHRtbCA9IGZ1bmN0aW9uIChkYXlEYXRlKSB7XHJcbiAgICAgICAgdmFyIG1haW5Gb3JtYXQgPSB0aGlzLm9wdCgnbGlzdERheUZvcm1hdCcpO1xyXG4gICAgICAgIHZhciBhbHRGb3JtYXQgPSB0aGlzLm9wdCgnbGlzdERheUFsdEZvcm1hdCcpO1xyXG4gICAgICAgIHJldHVybiAnPHRyIGNsYXNzPVwiZmMtbGlzdC1oZWFkaW5nXCIgZGF0YS1kYXRlPVwiJyArIGRheURhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgY29sc3Bhbj1cIjNcIj4nICtcclxuICAgICAgICAgICAgKG1haW5Gb3JtYXQgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEdvdG9BbmNob3JIdG1sKGRheURhdGUsIHsgJ2NsYXNzJzogJ2ZjLWxpc3QtaGVhZGluZy1tYWluJyB9LCB1dGlsXzEuaHRtbEVzY2FwZShkYXlEYXRlLmZvcm1hdChtYWluRm9ybWF0KSkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoYWx0Rm9ybWF0ID9cclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRHb3RvQW5jaG9ySHRtbChkYXlEYXRlLCB7ICdjbGFzcyc6ICdmYy1saXN0LWhlYWRpbmctYWx0JyB9LCB1dGlsXzEuaHRtbEVzY2FwZShkYXlEYXRlLmZvcm1hdChhbHRGb3JtYXQpKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L3RkPicgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0VmlldztcclxufShWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0VmlldztcclxuTGlzdFZpZXcucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IExpc3RFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuTGlzdFZpZXcucHJvdG90eXBlLmV2ZW50UG9pbnRpbmdDbGFzcyA9IExpc3RFdmVudFBvaW50aW5nXzEuZGVmYXVsdDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBuYW1lc3BhY2VfaG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBuYW1lc3BhY2VFeHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQ2FsZW5kYXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG4vLyBmb3IgaW50ZW50aW9uYWwgc2lkZS1lZmZlY3RzXHJcbl9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXyg5Myk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oOTUpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDk2KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XHJcbiQuZnVsbENhbGVuZGFyID0gJC5leHRlbmQobmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdCwgbmFtZXNwYWNlRXhwb3J0cyk7IC8vIGdyYWZ0IG92ZXIgdGhlIG9yaWdpbmFsIGhvb2tzIG9iamVjdFxyXG4kLmZuLmZ1bGxDYWxlbmRhciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBhIHBvc3NpYmxlIG1ldGhvZCBjYWxsXHJcbiAgICB2YXIgcmVzID0gdGhpczsgLy8gd2hhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuICh0aGlzIGpRdWVyeSBvYmplY3QgYnkgZGVmYXVsdClcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgX2VsZW1lbnQpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoX2VsZW1lbnQpO1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJyk7IC8vIGdldCB0aGUgZXhpc3RpbmcgY2FsZW5kYXIgb2JqZWN0IChpZiBhbnkpXHJcbiAgICAgICAgdmFyIHNpbmdsZVJlczsgLy8gdGhlIHJldHVybmVkIHZhbHVlIG9mIHRoaXMgc2luZ2xlIG1ldGhvZCBjYWxsXHJcbiAgICAgICAgLy8gYSBtZXRob2QgY2FsbFxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09ICdnZXRDYWxlbmRhcicpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGNhbGVuZGFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09ICdkZXN0cm95Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRGF0YSgnZnVsbENhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEud2FybihcIkF0dGVtcHRpbmcgdG8gY2FsbCBhIEZ1bGxDYWxlbmRhciBtZXRob2Qgb24gYW4gZWxlbWVudCB3aXRoIG5vIGNhbGVuZGFyLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24oY2FsZW5kYXJbb3B0aW9uc10pKSB7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVSZXMgPSBjYWxlbmRhcltvcHRpb25zXS5hcHBseShjYWxlbmRhciwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBzaW5nbGVSZXM7IC8vIHJlY29yZCB0aGUgZmlyc3QgbWV0aG9kIGNhbGwgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVEYXRhKCdmdWxsQ2FsZW5kYXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS53YXJuKFwiJ1wiICsgb3B0aW9ucyArIFwiJyBpcyBhbiB1bmtub3duIEZ1bGxDYWxlbmRhciBtZXRob2QuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFjYWxlbmRhcikge1xyXG4gICAgICAgICAgICBjYWxlbmRhciA9IG5ldyBDYWxlbmRhcl8xLmRlZmF1bHQoZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJywgY2FsZW5kYXIpO1xyXG4gICAgICAgICAgICBjYWxlbmRhci5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDczICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8vIFRPRE86IGxpbnRlcj9cclxuLy8gYWZ0ZXIgbWVyZ2U6IHB1dCBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciBhZnRlclxyXG4vLyBcImFic3RyYWN0XCIgaXNzdWVcclxuLy8gZW5zdXJlICQgYWx3YXlzIGdldHMgYSBsb2NhbCBtb2R1bGUgcmVmZXJlbmNlXHJcbi8vIGJldHRlciBVTUQgc29sdXRpb25cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQ2FsZW5kYXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xyXG5leHBvcnRzLkNhbGVuZGFyID0gQ2FsZW5kYXJfMS5kZWZhdWx0O1xyXG52YXIgb3B0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbkNhbGVuZGFyXzEuZGVmYXVsdC5kZWZhdWx0cyA9IG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cztcclxuQ2FsZW5kYXJfMS5kZWZhdWx0LmVuZ2xpc2hEZWZhdWx0cyA9IG9wdGlvbnNfMS5lbmdsaXNoRGVmYXVsdHM7XHJcbkNhbGVuZGFyXzEuZGVmYXVsdC5ydGxEZWZhdWx0cyA9IG9wdGlvbnNfMS5ydGxEZWZhdWx0cztcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbmV4cG9ydHMuYXBwbHlBbGwgPSB1dGlsXzEuYXBwbHlBbGw7XHJcbmV4cG9ydHMuZGVib3VuY2UgPSB1dGlsXzEuZGVib3VuY2U7XHJcbmV4cG9ydHMuaXNJbnQgPSB1dGlsXzEuaXNJbnQ7XHJcbmV4cG9ydHMuaHRtbEVzY2FwZSA9IHV0aWxfMS5odG1sRXNjYXBlO1xyXG5leHBvcnRzLmNzc1RvU3RyID0gdXRpbF8xLmNzc1RvU3RyO1xyXG5leHBvcnRzLnByb3h5ID0gdXRpbF8xLnByb3h5O1xyXG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbmV4cG9ydHMuZ2V0T3V0ZXJSZWN0ID0gdXRpbF8xLmdldE91dGVyUmVjdDtcclxuZXhwb3J0cy5nZXRDbGllbnRSZWN0ID0gdXRpbF8xLmdldENsaWVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSB1dGlsXzEuZ2V0Q29udGVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gdXRpbF8xLmdldFNjcm9sbGJhcldpZHRocztcclxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHV0aWxfMS5wcmV2ZW50RGVmYXVsdDtcclxuZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSB1dGlsXzEucGFyc2VGaWVsZFNwZWNzO1xyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcztcclxuZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWMgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IHV0aWxfMS5mbGV4aWJsZUNvbXBhcmU7XHJcbmV4cG9ydHMuY29tcHV0ZUdyZWF0ZXN0VW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0O1xyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IHV0aWxfMS5kaXZpZGVSYW5nZUJ5RHVyYXRpb247XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gdXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcclxuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gdXRpbF8xLm11bHRpcGx5RHVyYXRpb247XHJcbmV4cG9ydHMuZHVyYXRpb25IYXNUaW1lID0gdXRpbF8xLmR1cmF0aW9uSGFzVGltZTtcclxuZXhwb3J0cy5sb2cgPSB1dGlsXzEubG9nO1xyXG5leHBvcnRzLndhcm4gPSB1dGlsXzEud2FybjtcclxuZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHV0aWxfMS5yZW1vdmVFeGFjdDtcclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IHV0aWxfMS5pbnRlcnNlY3RSZWN0cztcclxudmFyIGRhdGVfZm9ybWF0dGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdERhdGU7XHJcbmV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBkYXRlX2Zvcm1hdHRpbmdfMS5mb3JtYXRSYW5nZTtcclxuZXhwb3J0cy5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQgPSBkYXRlX2Zvcm1hdHRpbmdfMS5xdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQ7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5leHBvcnRzLmRhdGVwaWNrZXJMb2NhbGUgPSBsb2NhbGVfMS5kYXRlcGlja2VyTG9jYWxlO1xyXG5leHBvcnRzLmxvY2FsZSA9IGxvY2FsZV8xLmxvY2FsZTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbmV4cG9ydHMubW9tZW50ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQ7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbmV4cG9ydHMuRW1pdHRlck1peGluID0gRW1pdHRlck1peGluXzEuZGVmYXVsdDtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbmV4cG9ydHMuTGlzdGVuZXJNaXhpbiA9IExpc3RlbmVyTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG5leHBvcnRzLk1vZGVsID0gTW9kZWxfMS5kZWZhdWx0O1xyXG52YXIgQ29uc3RyYWludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG5leHBvcnRzLkNvbnN0cmFpbnRzID0gQ29uc3RyYWludHNfMS5kZWZhdWx0O1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5leHBvcnRzLlVuem9uZWRSYW5nZSA9IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQ7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5leHBvcnRzLkNvbXBvbmVudEZvb3RwcmludCA9IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQ7XHJcbnZhciBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG5leHBvcnRzLkJ1c2luZXNzSG91ckdlbmVyYXRvciA9IEJ1c2luZXNzSG91ckdlbmVyYXRvcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbmV4cG9ydHMuRXZlbnREZWYgPSBFdmVudERlZl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERlZk11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxuZXhwb3J0cy5FdmVudERlZk11dGF0aW9uID0gRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcbmV4cG9ydHMuRXZlbnRTb3VyY2VQYXJzZXIgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuZXhwb3J0cy5FdmVudFNvdXJjZSA9IEV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIFRoZW1lUmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5leHBvcnRzLlRoZW1lUmVnaXN0cnkgPSBUaGVtZVJlZ2lzdHJ5XzEuZGVmYXVsdDtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbmV4cG9ydHMuRXZlbnRJbnN0YW5jZUdyb3VwID0gRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdDtcclxudmFyIEFycmF5RXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5leHBvcnRzLkFycmF5RXZlbnRTb3VyY2UgPSBBcnJheUV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XHJcbmV4cG9ydHMuRnVuY0V2ZW50U291cmNlID0gRnVuY0V2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEpzb25GZWVkRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG5leHBvcnRzLkpzb25GZWVkRXZlbnRTb3VyY2UgPSBKc29uRmVlZEV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxuZXhwb3J0cy5FdmVudEZvb3RwcmludCA9IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdDtcclxudmFyIENsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuZXhwb3J0cy5DbGFzcyA9IENsYXNzXzEuZGVmYXVsdDtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuZXhwb3J0cy5NaXhpbiA9IE1peGluXzEuZGVmYXVsdDtcclxudmFyIENvb3JkQ2FjaGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xyXG5leHBvcnRzLkNvb3JkQ2FjaGUgPSBDb29yZENhY2hlXzEuZGVmYXVsdDtcclxudmFyIERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbmV4cG9ydHMuRHJhZ0xpc3RlbmVyID0gRHJhZ0xpc3RlbmVyXzEuZGVmYXVsdDtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG5leHBvcnRzLlByb21pc2UgPSBQcm9taXNlXzEuZGVmYXVsdDtcclxudmFyIFRhc2tRdWV1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XHJcbmV4cG9ydHMuVGFza1F1ZXVlID0gVGFza1F1ZXVlXzEuZGVmYXVsdDtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxuZXhwb3J0cy5SZW5kZXJRdWV1ZSA9IFJlbmRlclF1ZXVlXzEuZGVmYXVsdDtcclxudmFyIFNjcm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxuZXhwb3J0cy5TY3JvbGxlciA9IFNjcm9sbGVyXzEuZGVmYXVsdDtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxuZXhwb3J0cy5UaGVtZSA9IFRoZW1lXzEuZGVmYXVsdDtcclxudmFyIERhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5leHBvcnRzLkRhdGVDb21wb25lbnQgPSBEYXRlQ29tcG9uZW50XzEuZGVmYXVsdDtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcbmV4cG9ydHMuSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50ID0gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdDtcclxudmFyIFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xyXG5leHBvcnRzLlZpZXcgPSBWaWV3XzEuZGVmYXVsdDtcclxudmFyIERheVRhYmxlTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5leHBvcnRzLkRheVRhYmxlTWl4aW4gPSBEYXlUYWJsZU1peGluXzEuZGVmYXVsdDtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxuZXhwb3J0cy5CdXNpbmVzc0hvdXJSZW5kZXJlciA9IEJ1c2luZXNzSG91clJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG5leHBvcnRzLkV2ZW50UmVuZGVyZXIgPSBFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcbmV4cG9ydHMuRmlsbFJlbmRlcmVyID0gRmlsbFJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcclxuZXhwb3J0cy5IZWxwZXJSZW5kZXJlciA9IEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEV4dGVybmFsRHJvcHBpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xyXG5leHBvcnRzLkV4dGVybmFsRHJvcHBpbmcgPSBFeHRlcm5hbERyb3BwaW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UmVzaXppbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xyXG5leHBvcnRzLkV2ZW50UmVzaXppbmcgPSBFdmVudFJlc2l6aW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xyXG5leHBvcnRzLkV2ZW50UG9pbnRpbmcgPSBFdmVudFBvaW50aW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50RHJhZ2dpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xyXG5leHBvcnRzLkV2ZW50RHJhZ2dpbmcgPSBFdmVudERyYWdnaW5nXzEuZGVmYXVsdDtcclxudmFyIERhdGVTZWxlY3RpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xyXG5leHBvcnRzLkRhdGVTZWxlY3RpbmcgPSBEYXRlU2VsZWN0aW5nXzEuZGVmYXVsdDtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xyXG5leHBvcnRzLlN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4gPSBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEuZGVmYXVsdDtcclxudmFyIEFnZW5kYVZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xyXG5leHBvcnRzLkFnZW5kYVZpZXcgPSBBZ2VuZGFWaWV3XzEuZGVmYXVsdDtcclxudmFyIFRpbWVHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcclxuZXhwb3J0cy5UaW1lR3JpZCA9IFRpbWVHcmlkXzEuZGVmYXVsdDtcclxudmFyIERheUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xyXG5leHBvcnRzLkRheUdyaWQgPSBEYXlHcmlkXzEuZGVmYXVsdDtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcbmV4cG9ydHMuQmFzaWNWaWV3ID0gQmFzaWNWaWV3XzEuZGVmYXVsdDtcclxudmFyIE1vbnRoVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XHJcbmV4cG9ydHMuTW9udGhWaWV3ID0gTW9udGhWaWV3XzEuZGVmYXVsdDtcclxudmFyIExpc3RWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxuZXhwb3J0cy5MaXN0VmlldyA9IExpc3RWaWV3XzEuZGVmYXVsdDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSXRlcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJdGVyYXRvcihpdGVtcykge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcyB8fCBbXTtcclxuICAgIH1cclxuICAgIC8qIENhbGxzIGEgbWV0aG9kIG9uIGV2ZXJ5IGl0ZW0gcGFzc2luZyB0aGUgYXJndW1lbnRzIHRocm91Z2ggKi9cclxuICAgIEl0ZXJhdG9yLnByb3RvdHlwZS5wcm94eUNhbGwgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1bbWV0aG9kTmFtZV0uYXBwbHkoaXRlbSwgYXJncykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJdGVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSXRlcmF0b3I7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDc1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuLyogVG9vbGJhciB3aXRoIGJ1dHRvbnMgYW5kIHRpdGxlXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgVG9vbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRvb2xiYXIoY2FsZW5kYXIsIHRvb2xiYXJPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IG51bGw7IC8vIG1pcnJvcnMgbG9jYWwgYGVsYFxyXG4gICAgICAgIHRoaXMudmlld3NXaXRoQnV0dG9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICB0aGlzLnRvb2xiYXJPcHRpb25zID0gdG9vbGJhck9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvLyBtZXRob2QgdG8gdXBkYXRlIHRvb2xiYXItc3BlY2lmaWMgb3B0aW9ucywgbm90IGNhbGVuZGFyLXdpZGUgb3B0aW9uc1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuc2V0VG9vbGJhck9wdGlvbnMgPSBmdW5jdGlvbiAobmV3VG9vbGJhck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnRvb2xiYXJPcHRpb25zID0gbmV3VG9vbGJhck9wdGlvbnM7XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCB3aWxsIHJlcmVuZGVyXHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlY3Rpb25zID0gdGhpcy50b29sYmFyT3B0aW9ucy5sYXlvdXQ7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICBpZiAoc2VjdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICAgICAgZWwgPSB0aGlzLmVsID0gJChcIjxkaXYgY2xhc3M9J2ZjLXRvb2xiYXIgXCIgKyB0aGlzLnRvb2xiYXJPcHRpb25zLmV4dHJhQ2xhc3NlcyArIFwiJy8+XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWwuZW1wdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbC5hcHBlbmQodGhpcy5yZW5kZXJTZWN0aW9uKCdsZWZ0JykpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMucmVuZGVyU2VjdGlvbigncmlnaHQnKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5yZW5kZXJTZWN0aW9uKCdjZW50ZXInKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJzxkaXYgY2xhc3M9XCJmYy1jbGVhclwiLz4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IGNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IGNhbGVuZGFyLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB2aWV3U3BlY01hbmFnZXIgPSBjYWxlbmRhci52aWV3U3BlY01hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNlY3Rpb25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy0nICsgcG9zaXRpb24gKyAnXCIvPicpO1xyXG4gICAgICAgIHZhciBidXR0b25TdHIgPSB0aGlzLnRvb2xiYXJPcHRpb25zLmxheW91dFtwb3NpdGlvbl07XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyQ3VzdG9tQnV0dG9ucyA9IG9wdGlvbnNNYW5hZ2VyLmdldCgnY3VzdG9tQnV0dG9ucycpIHx8IHt9O1xyXG4gICAgICAgIHZhciBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXMgPSBvcHRpb25zTWFuYWdlci5vdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICB2YXIgY2FsZW5kYXJCdXR0b25UZXh0ID0gb3B0aW9uc01hbmFnZXIuZ2V0KCdidXR0b25UZXh0JykgfHwge307XHJcbiAgICAgICAgaWYgKGJ1dHRvblN0cikge1xyXG4gICAgICAgICAgICAkLmVhY2goYnV0dG9uU3RyLnNwbGl0KCcgJyksIGZ1bmN0aW9uIChpLCBidXR0b25Hcm91cFN0cikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwQ2hpbGRyZW4gPSAkKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNPbmx5QnV0dG9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBFbDtcclxuICAgICAgICAgICAgICAgICQuZWFjaChidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLCBmdW5jdGlvbiAoaiwgYnV0dG9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21CdXR0b25Qcm9wcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld1NwZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkNsaWNrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25JY29uOyAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25UZXh0OyAvLyBcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25Jbm5lckh0bWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkVsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbiA9IGdyb3VwQ2hpbGRyZW4uYWRkKCQoJzxoMj4mbmJzcDs8L2gyPicpKTsgLy8gd2UgYWx3YXlzIHdhbnQgaXQgdG8gdGFrZSB1cCBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoYnV0dG9uRWxbMF0sIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZpZXdTcGVjID0gdmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKGJ1dHRvbk5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXIuY2hhbmdlVmlldyhidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjYWxlbmRhcltidXR0b25OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJbYnV0dG9uTmFtZV0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgIF4gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25DbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3NlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdzdGF0ZURlZmF1bHQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5uZXJIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUoYnV0dG9uVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0nXCIgKyBidXR0b25JY29uICsgXCInPjwvc3Bhbj5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsID0gJCgvLyB0eXBlPVwiYnV0dG9uXCIgc28gdGhhdCBpdCBkb2Vzbid0IHN1Ym1pdCBhIGZvcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIicgKyBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L2J1dHRvbj4nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBwcm9jZXNzIGNsaWNrcyBmb3IgZGlzYWJsZWQgYnV0dG9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnV0dG9uRWwuaGFzQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2soZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgY2xpY2sgYWN0aW9uLCBpZiB0aGUgYnV0dG9uIGJlY29tZXMgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5ldmVyIGhhdmUgYSBob3ZlciBjbGFzcywgc28gcmVtb3ZlIGl0IG5vdy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwuaGFzQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZUhvdmVyJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubW91c2Vkb3duKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgKmRvd24qIGVmZmVjdCAobW91c2UgcHJlc3NlZCBpbikuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1vdXNldXAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZG8gdGhlICpkb3duKiBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVEb3duJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaG92ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSAqaG92ZXIqIGVmZmVjdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubm90KCcuJyArIHRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubm90KCcuJyArIHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRvIHRoZSAqaG92ZXIqIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTsgLy8gaWYgbW91c2VsZWF2ZSBoYXBwZW5zIGJlZm9yZSBtb3VzZXVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZChidXR0b25FbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc09ubHlCdXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3QoKS5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnY29ybmVyTGVmdCcpKS5lbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubGFzdCgpLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdjb3JuZXJSaWdodCcpKS5lbmQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChncm91cENoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cEVsID0gJCgnPGRpdi8+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT25seUJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbC5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25FbC5hcHBlbmQoZ3JvdXBFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pOyAvLyAxIG9yIDAgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWN0aW9uRWw7XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnaDInKS50ZXh0KHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5hY3RpdmF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmRlYWN0aXZhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5kaXNhYmxlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZW5hYmxlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmdldFZpZXdzV2l0aEJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3NXaXRoQnV0dG9ucztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVG9vbGJhcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbGJhcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBNb2RlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbnZhciBPcHRpb25zTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE9wdGlvbnNNYW5hZ2VyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gT3B0aW9uc01hbmFnZXIoX2NhbGVuZGFyLCBvdmVycmlkZXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9jYWxlbmRhciA9IF9jYWxlbmRhcjtcclxuICAgICAgICBfdGhpcy5vdmVycmlkZXMgPSAkLmV4dGVuZCh7fSwgb3ZlcnJpZGVzKTsgLy8gbWFrZSBhIGNvcHlcclxuICAgICAgICBfdGhpcy5keW5hbWljT3ZlcnJpZGVzID0ge307XHJcbiAgICAgICAgX3RoaXMuY29tcHV0ZSgpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgIHZhciBvcHRpb25DbnQgPSAwO1xyXG4gICAgICAgIHZhciBvcHRpb25OYW1lO1xyXG4gICAgICAgIHRoaXMucmVjb3JkT3ZlcnJpZGVzKG5ld09wdGlvbkhhc2gpOyAvLyB3aWxsIHRyaWdnZXIgdGhpcyBtb2RlbCdzIHdhdGNoZXJzXHJcbiAgICAgICAgZm9yIChvcHRpb25OYW1lIGluIG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICAgICAgb3B0aW9uQ250Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwZWNpYWwtY2FzZSBoYW5kbGluZyBvZiBzaW5nbGUgb3B0aW9uIGNoYW5nZS5cclxuICAgICAgICAvLyBpZiBvbmx5IG9uZSBvcHRpb24gY2hhbmdlLCBgb3B0aW9uTmFtZWAgd2lsbCBiZSBpdHMgbmFtZS5cclxuICAgICAgICBpZiAob3B0aW9uQ250ID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25OYW1lID09PSAnaGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnY29udGVudEhlaWdodCcgfHwgb3B0aW9uTmFtZSA9PT0gJ2FzcGVjdFJhdGlvJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsZW5kYXIudXBkYXRlVmlld1NpemUodHJ1ZSk7IC8vIGlzUmVzaXplPXRydWVcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25OYW1lID09PSAnZGVmYXVsdERhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNhbid0IGNoYW5nZSBkYXRlIHRoaXMgd2F5LiB1c2UgZ290b0RhdGUgaW5zdGVhZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB0aGlzIG1vZGVsIGFscmVhZHkgcmVhY3RzIHRvIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25OYW1lID09PSAndGltZXpvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3LmZsYXNoKCdpbml0aWFsRXZlbnRzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2F0Y2gtYWxsLiByZXJlbmRlciB0aGUgaGVhZGVyIGFuZCBmb290ZXIgYW5kIHJlYnVpbGQvcmVyZW5kZXIgdGhlIGN1cnJlbnQgdmlld1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlbmRlckhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlbmRlckZvb3RlcigpO1xyXG4gICAgICAgIC8vIGV2ZW4gbm9uLWN1cnJlbnQgdmlld3Mgd2lsbCBiZSBhZmZlY3RlZCBieSB0aGlzIG9wdGlvbiBjaGFuZ2UuIGRvIGJlZm9yZSByZXJlbmRlclxyXG4gICAgICAgIC8vIFRPRE86IGRldGFuZ2xlXHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIudmlld3NCeVR5cGUgPSB7fTtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhci5yZWluaXRWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGZsYXR0ZW5lZCBvcHRpb25zIGhhc2ggZm9yIHRoZSBjYWxlbmRhciBhbmQgYXNzaWducyB0byBgdGhpcy5vcHRpb25zYC5cclxuICAgIC8vIEFzc3VtZXMgdGhpcy5vdmVycmlkZXMgYW5kIHRoaXMuZHluYW1pY092ZXJyaWRlcyBoYXZlIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cclxuICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsb2NhbGUsIGxvY2FsZURlZmF1bHRzO1xyXG4gICAgICAgIHZhciBpc1JUTCwgZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgdmFyIHJhd09wdGlvbnM7XHJcbiAgICAgICAgbG9jYWxlID0gdXRpbF8xLmZpcnN0RGVmaW5lZCgvLyBleHBsaWNpdCBsb2NhbGUgb3B0aW9uIGdpdmVuP1xyXG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5sb2NhbGUsIHRoaXMub3ZlcnJpZGVzLmxvY2FsZSk7XHJcbiAgICAgICAgbG9jYWxlRGVmYXVsdHMgPSBsb2NhbGVfMS5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZV07XHJcbiAgICAgICAgaWYgKCFsb2NhbGVEZWZhdWx0cykge1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMubG9jYWxlO1xyXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZV8xLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXSB8fCB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNSVEwgPSB1dGlsXzEuZmlyc3REZWZpbmVkKC8vIGJhc2VkIG9uIG9wdGlvbnMgY29tcHV0ZWQgc28gZmFyLCBpcyBkaXJlY3Rpb24gUlRMP1xyXG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlcy5pc1JUTCwgdGhpcy5vdmVycmlkZXMuaXNSVEwsIGxvY2FsZURlZmF1bHRzLmlzUlRMLCBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMuaXNSVEwpO1xyXG4gICAgICAgIGRpckRlZmF1bHRzID0gaXNSVEwgPyBvcHRpb25zXzEucnRsRGVmYXVsdHMgOiB7fTtcclxuICAgICAgICB0aGlzLmRpckRlZmF1bHRzID0gZGlyRGVmYXVsdHM7XHJcbiAgICAgICAgdGhpcy5sb2NhbGVEZWZhdWx0cyA9IGxvY2FsZURlZmF1bHRzO1xyXG4gICAgICAgIHJhd09wdGlvbnMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtcclxuICAgICAgICAgICAgb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzLFxyXG4gICAgICAgICAgICBkaXJEZWZhdWx0cyxcclxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIHRoaXMub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXNcclxuICAgICAgICBdKTtcclxuICAgICAgICBsb2NhbGVfMS5wb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMocmF3T3B0aW9ucyk7IC8vIGZpbGwgaW4gZ2FwcyB3aXRoIGNvbXB1dGVkIG9wdGlvbnNcclxuICAgICAgICB0aGlzLnJlc2V0KHJhd09wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIC8vIHN0b3JlcyB0aGUgbmV3IG9wdGlvbnMgaW50ZXJuYWxseSwgYnV0IGRvZXMgbm90IHJlcmVuZGVyIGFueXRoaW5nLlxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLnJlY29yZE92ZXJyaWRlcyA9IGZ1bmN0aW9uIChuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgZm9yIChvcHRpb25OYW1lIGluIG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzW29wdGlvbk5hbWVdID0gbmV3T3B0aW9uSGFzaFtvcHRpb25OYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIudmlld1NwZWNNYW5hZ2VyLmNsZWFyQ2FjaGUoKTsgLy8gdGhlIGR5bmFtaWMgb3ZlcnJpZGUgaW52YWxpZGF0ZXMgdGhlIG9wdGlvbnMgaW4gdGhpcyBjYWNoZSwgc28ganVzdCBjbGVhciBpdFxyXG4gICAgICAgIHRoaXMuY29tcHV0ZSgpOyAvLyB0aGlzLm9wdGlvbnMgbmVlZHMgdG8gYmUgcmVjb21wdXRlZCBhZnRlciB0aGUgZHluYW1pYyBvdmVycmlkZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBPcHRpb25zTWFuYWdlcjtcclxufShNb2RlbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gT3B0aW9uc01hbmFnZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDc3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG5hbWVzcGFjZV9ob29rc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBWaWV3U3BlY01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWaWV3U3BlY01hbmFnZXIob3B0aW9uc01hbmFnZXIsIF9jYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIgPSBvcHRpb25zTWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhciA9IF9jYWxlbmRhcjtcclxuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcclxuICAgIH1cclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnZpZXdTcGVjQ2FjaGUgPSB7fTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0byBjcmVhdGUgYSB2aWV3LiBXaWxsIHVzZSBhIGNhY2hlLlxyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5nZXRWaWV3U3BlYyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMudmlld1NwZWNDYWNoZTtcclxuICAgICAgICByZXR1cm4gY2FjaGVbdmlld1R5cGVdIHx8IChjYWNoZVt2aWV3VHlwZV0gPSB0aGlzLmJ1aWxkVmlld1NwZWModmlld1R5cGUpKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXHJcbiAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmdldFVuaXRWaWV3U3BlYyA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgdmFyIHZpZXdUeXBlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc3BlYztcclxuICAgICAgICBpZiAoJC5pbkFycmF5KHVuaXQsIHV0aWxfMS51bml0c0Rlc2MpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIHB1dCB2aWV3cyB0aGF0IGhhdmUgYnV0dG9ucyBmaXJzdC4gdGhlcmUgd2lsbCBiZSBkdXBsaWNhdGVzLCBidXQgb2ggd2VsbFxyXG4gICAgICAgICAgICB2aWV3VHlwZXMgPSB0aGlzLl9jYWxlbmRhci5oZWFkZXIuZ2V0Vmlld3NXaXRoQnV0dG9ucygpOyAvLyBUT0RPOiBpbmNsdWRlIGZvb3RlciBhcyB3ZWxsP1xyXG4gICAgICAgICAgICAkLmVhY2gobmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC52aWV3cywgZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0gdGhpcy5nZXRWaWV3U3BlYyh2aWV3VHlwZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09IHVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBvbiBob3cgdG8gY3JlYXRlIGEgZ2l2ZW4gdmlld1xyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5idWlsZFZpZXdTcGVjID0gZnVuY3Rpb24gKHJlcXVlc3RlZFZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIHZpZXdPdmVycmlkZXMgPSB0aGlzLm9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy52aWV3cyB8fCB7fTtcclxuICAgICAgICB2YXIgc3BlY0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICB2YXIgZGVmYXVsdHNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgdmFyIG92ZXJyaWRlc0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICB2YXIgdmlld1R5cGUgPSByZXF1ZXN0ZWRWaWV3VHlwZTtcclxuICAgICAgICB2YXIgc3BlYzsgLy8gZm9yIHRoZSB2aWV3XHJcbiAgICAgICAgdmFyIG92ZXJyaWRlczsgLy8gZm9yIHRoZSB2aWV3XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uSW5wdXQ7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uO1xyXG4gICAgICAgIHZhciB1bml0O1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgZnJvbSB0aGUgc3BlY2lmaWMgdmlldyBkZWZpbml0aW9uIHRvIGEgbW9yZSBnZW5lcmFsIG9uZSB1bnRpbCB3ZSBoaXQgYW4gYWN0dWFsIFZpZXcgY2xhc3NcclxuICAgICAgICB3aGlsZSAodmlld1R5cGUpIHtcclxuICAgICAgICAgICAgc3BlYyA9IG5hbWVzcGFjZV9ob29rc18xLmRlZmF1bHQudmlld3Nbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICBvdmVycmlkZXMgPSB2aWV3T3ZlcnJpZGVzW3ZpZXdUeXBlXTtcclxuICAgICAgICAgICAgdmlld1R5cGUgPSBudWxsOyAvLyBjbGVhci4gbWlnaHQgcmVwb3B1bGF0ZSBmb3IgYW5vdGhlciBpdGVyYXRpb25cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0geyAnY2xhc3MnOiBzcGVjIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNDaGFpbi51bnNoaWZ0KHNwZWMpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdHNDaGFpbi51bnNoaWZ0KHNwZWMuZGVmYXVsdHMgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25JbnB1dCA9IGR1cmF0aW9uSW5wdXQgfHwgc3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgc3BlYy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlc0NoYWluLnVuc2hpZnQob3ZlcnJpZGVzKTsgLy8gdmlldy1zcGVjaWZpYyBvcHRpb24gaGFzaGVzIGhhdmUgb3B0aW9ucyBhdCB6ZXJvLWxldmVsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fCBvdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8IG92ZXJyaWRlcy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNwZWMgPSB1dGlsXzEubWVyZ2VQcm9wcyhzcGVjQ2hhaW4pO1xyXG4gICAgICAgIHNwZWMudHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIGlmICghc3BlY1snY2xhc3MnXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB0b3AtbGV2ZWwgYGR1cmF0aW9uYCBvcHRpb25cclxuICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5vdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbi52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSB1dGlsXzEuY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0KGR1cmF0aW9uLCBkdXJhdGlvbklucHV0KTtcclxuICAgICAgICAgICAgICAgIHNwZWMuZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHNwZWMuZHVyYXRpb25Vbml0ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIC8vIHZpZXcgaXMgYSBzaW5nbGUtdW5pdCBkdXJhdGlvbiwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvcnBvcmF0ZSBvcHRpb25zIGZvciB0aGlzLiBsb3dlc3QgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbi5hcyh1bml0KSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwZWMuc2luZ2xlVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzQ2hhaW4udW5zaGlmdCh2aWV3T3ZlcnJpZGVzW3VuaXRdIHx8IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzcGVjLmRlZmF1bHRzID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhkZWZhdWx0c0NoYWluKTtcclxuICAgICAgICBzcGVjLm92ZXJyaWRlcyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMob3ZlcnJpZGVzQ2hhaW4pO1xyXG4gICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY09wdGlvbnMoc3BlYyk7XHJcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGFuZCBhc3NpZ25zIGEgdmlldyBzcGVjJ3Mgb3B0aW9ucyBvYmplY3QgZnJvbSBpdHMgYWxyZWFkeS1hc3NpZ25lZCBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWNPcHRpb25zID0gZnVuY3Rpb24gKHNwZWMpIHtcclxuICAgICAgICB2YXIgb3B0aW9uc01hbmFnZXIgPSB0aGlzLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHNwZWMub3B0aW9ucyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW1xyXG4gICAgICAgICAgICBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIHNwZWMuZGVmYXVsdHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICBzcGVjLm92ZXJyaWRlcyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcyAvLyBkeW5hbWljYWxseSBzZXQgdmlhIHNldHRlci4gaGlnaGVzdCBwcmVjZWRlbmNlXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgbG9jYWxlXzEucG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKHNwZWMub3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBidXR0b25UZXh0LXJlbGF0ZWQgb3B0aW9uc1xyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5idWlsZFZpZXdTcGVjQnV0dG9uVGV4dCA9IGZ1bmN0aW9uIChzcGVjLCByZXF1ZXN0ZWRWaWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IHRoaXMub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgLy8gZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIHBvc3NpYmxlIGBidXR0b25UZXh0YCBoYXNoLCBsb29rdXAgdGhlIGJ1dHRvblRleHQgZm9yIHRoZVxyXG4gICAgICAgIC8vIHJlcXVlc3RlZCB2aWV3LCBmYWxsaW5nIGJhY2sgdG8gYSBnZW5lcmljIHVuaXQgZW50cnkgbGlrZSBcIndlZWtcIiBvciBcImRheVwiXHJcbiAgICAgICAgZnVuY3Rpb24gcXVlcnlCdXR0b25UZXh0KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0W3JlcXVlc3RlZFZpZXdUeXBlXSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gdmlldyBjYW4gZGVjaWRlIHRvIGxvb2sgdXAgYSBjZXJ0YWluIGtleVxyXG4gICAgICAgICAgICAgICAgKHNwZWMuYnV0dG9uVGV4dEtleSA/IGJ1dHRvblRleHRbc3BlYy5idXR0b25UZXh0S2V5XSA6IG51bGwpIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBhIGtleSBsaWtlIFwibW9udGhcIlxyXG4gICAgICAgICAgICAgICAgKHNwZWMuc2luZ2xlVW5pdCA/IGJ1dHRvblRleHRbc3BlYy5zaW5nbGVVbml0XSA6IG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgICAgIHNwZWMuYnV0dG9uVGV4dE92ZXJyaWRlID1cclxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXHJcbiAgICAgICAgICAgICAgICBzcGVjLm92ZXJyaWRlcy5idXR0b25UZXh0OyAvLyBgYnV0dG9uVGV4dGAgZm9yIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBpcyBhIHN0cmluZ1xyXG4gICAgICAgIC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5LiBtaXJyb3JzIGJ1aWxkVmlld1NwZWNPcHRpb25zXHJcbiAgICAgICAgc3BlYy5idXR0b25UZXh0RGVmYXVsdCA9XHJcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5sb2NhbGVEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5kaXJEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHNwZWMuZGVmYXVsdHMuYnV0dG9uVGV4dCB8fCAvLyBhIHNpbmdsZSBzdHJpbmcuIGZyb20gVmlld1N1YmNsYXNzLmRlZmF1bHRzXHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc18xLmdsb2JhbERlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgKHNwZWMuZHVyYXRpb24gPyB0aGlzLl9jYWxlbmRhci5odW1hbml6ZUR1cmF0aW9uKHNwZWMuZHVyYXRpb24pIDogbnVsbCkgfHwgLy8gbGlrZSBcIjMgZGF5c1wiXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWaWV3VHlwZTsgLy8gZmFsbCBiYWNrIHRvIGdpdmVuIHZpZXcgbmFtZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBWaWV3U3BlY01hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFZpZXdTcGVjTWFuYWdlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnRQZXJpb2RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEV2ZW50U291cmNlUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgRXZlbnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuc3RpY2t5U291cmNlID0gbmV3IEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0KGNhbGVuZGFyKTtcclxuICAgICAgICB0aGlzLm90aGVyU291cmNlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lLCBmb3JjZSkge1xyXG4gICAgICAgIGlmIChmb3JjZSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5jdXJyZW50UGVyaW9kIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRQZXJpb2QuaXNXaXRoaW5SYW5nZShzdGFydCwgZW5kKSB8fFxyXG4gICAgICAgICAgICB0aW1lem9uZSAhPT0gdGhpcy5jdXJyZW50UGVyaW9kLnRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGVyaW9kKC8vIHdpbGwgY2hhbmdlIHRoaXMuY3VycmVudFBlcmlvZFxyXG4gICAgICAgICAgICBuZXcgRXZlbnRQZXJpb2RfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRpbWV6b25lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2Qud2hlblJlbGVhc2VkKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIEFkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkU291cmNlID0gZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclNvdXJjZXMucHVzaChldmVudFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVxdWVzdFNvdXJjZShldmVudFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAoZG9vbWVkU291cmNlKSB7XHJcbiAgICAgICAgdXRpbF8xLnJlbW92ZUV4YWN0KHRoaXMub3RoZXJTb3VyY2VzLCBkb29tZWRTb3VyY2UpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGRvb21lZFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVBbGxTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3RoZXJTb3VyY2VzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucHVyZ2VBbGxTb3VyY2VzKCk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIFJlZmV0Y2hpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hTb3VyY2UgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVmZXRjaEFsbFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRQZXJpb2QgPSB0aGlzLmN1cnJlbnRQZXJpb2Q7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5mcmVlemUoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5wdXJnZUFsbFNvdXJjZXMoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgUXVlcnlpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0aWNreVNvdXJjZV0uY29uY2F0KHRoaXMub3RoZXJTb3VyY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIHF1ZXJ5U291cmNlcywgYnV0IGFjY2VwdHMgbXVsdHBsZSBtYXRjaCBjcml0ZXJpYSAobGlrZSBtdWx0aXBsZSBJRHMpXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLm11bHRpUXVlcnlTb3VyY2VzID0gZnVuY3Rpb24gKG1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgLy8gY29lcmNlIGludG8gYW4gYXJyYXlcclxuICAgICAgICBpZiAoIW1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCEkLmlzQXJyYXkobWF0Y2hJbnB1dHMpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW21hdGNoSW5wdXRzXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nU291cmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlc29sdmUgcmF3IGlucHV0cyB0byByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3RzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdGNoSW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1hdGNoaW5nU291cmNlcy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBtYXRjaGluZ1NvdXJjZXMsIHRoaXMucXVlcnlTb3VyY2VzKG1hdGNoSW5wdXRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGluZ1NvdXJjZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gbWF0Y2hJbnB1dCBjYW4gZWl0aGVyIGJ5IGEgcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0LCBhbiBJRCwgb3IgdGhlIGZ1bmN0aW9uL1VSTCBmb3IgdGhlIHNvdXJjZS5cclxuICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgc291cmNlIG9iamVjdHMuXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnF1ZXJ5U291cmNlcyA9IGZ1bmN0aW9uIChtYXRjaElucHV0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLm90aGVyU291cmNlcztcclxuICAgICAgICB2YXIgaSwgc291cmNlO1xyXG4gICAgICAgIC8vIGdpdmVuIGEgcHJvcGVyIGV2ZW50IHNvdXJjZSBvYmplY3RcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBtYXRjaElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NvdXJjZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gSUQgbWF0Y2hcclxuICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZUJ5SWQoRXZlbnRTb3VyY2VfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKG1hdGNoSW5wdXQpKTtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbc291cmNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGFyc2UgYXMgYW4gZXZlbnQgc291cmNlXHJcbiAgICAgICAgbWF0Y2hJbnB1dCA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShtYXRjaElucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICBpZiAobWF0Y2hJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NvdXJjZXNFcXVpdmFsZW50KG1hdGNoSW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgSUQgYXNzdW1lZCB0byBhbHJlYWR5IGJlIG5vcm1hbGl6ZWRcclxuICAgICovXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gJC5ncmVwKHRoaXMub3RoZXJTb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UuaWQgJiYgc291cmNlLmlkID09PSBpZDtcclxuICAgICAgICB9KVswXTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudC1QZXJpb2RcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnNldFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRQZXJpb2QodGhpcy5jdXJyZW50UGVyaW9kKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gZXZlbnRQZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5iaW5kUGVyaW9kKGV2ZW50UGVyaW9kKTtcclxuICAgICAgICBldmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kUGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhldmVudFBlcmlvZCwgJ3JlbGVhc2UnLCBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKGV2ZW50UGVyaW9kKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBHZXR0aW5nL0FkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZCeVVpZCA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnREZWZCeVVpZCh1aWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmLCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0aWNreVNvdXJjZS5hZGRFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmFkZEV2ZW50RGVmKGV2ZW50RGVmKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnRJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlLnJlbW92ZUV2ZW50RGVmc0J5SWQoZXZlbnRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWZzQnlJZChldmVudElkKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdldFNvdXJjZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICBldmVudFNvdXJjZS5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgTXV0YXRpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUubXV0YXRlRXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQsIGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzO1xyXG4gICAgICAgIHZhciB1bmRvRnVuY3MgPSBbXTtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBldmVudERlZnMgPSBjdXJyZW50UGVyaW9kLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSBlc3AgYmVjYXVzZSBpZCBtaWdodCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmNzLnB1c2goZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZXZlbnREZWYpKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuYWRkRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kb0Z1bmNzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5hZGRFdmVudERlZihldmVudERlZnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGNvcGllcyBhbmQgdGhlbiBtdXRhdGVzXHJcbiAgICAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCwgZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSB0aGlzLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZkNvcHk7XHJcbiAgICAgICAgdmFyIGFsbEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVmQ29weSA9IGV2ZW50RGVmc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoZGVmQ29weSBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZGVmQ29weSk7XHJcbiAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXMucHVzaC5hcHBseShhbGxJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZGVmQ29weS5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoYWxsSW5zdGFuY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBGcmVlemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBtZXRob2RzIHRoYXQgc2ltcGx5IGZvcndhcmQgdG8gRXZlbnRQZXJpb2RcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlcygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQoZXZlbnREZWZJZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZChldmVudERlZklkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudE1hbmFnZXI7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudE1hbmFnZXIpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50TWFuYWdlcik7XHJcbmZ1bmN0aW9uIGlzU291cmNlc0VxdWl2YWxlbnQoc291cmNlMCwgc291cmNlMSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZTAuZ2V0UHJpbWl0aXZlKCkgPT0gc291cmNlMS5nZXRQcmltaXRpdmUoKTtcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBQcm9taXNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBFdmVudFBlcmlvZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UGVyaW9kKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ250ID0gMDtcclxuICAgICAgICB0aGlzLmZyZWV6ZURlcHRoID0gMDtcclxuICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLCBlbmQuY2xvbmUoKS5zdHJpcFpvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlJZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB7fTtcclxuICAgIH1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5pc1dpdGhpblJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyBUT0RPOiB1c2UgYSByYW5nZSB1dGlsIGZ1bmN0aW9uP1xyXG4gICAgICAgIHJldHVybiAhc3RhcnQuaXNCZWZvcmUodGhpcy5zdGFydCkgJiYgIWVuZC5pc0FmdGVyKHRoaXMuZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXF1ZXN0aW5nIGFuZCBQdXJnaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlcXVlc3RTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGhhdygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZXF1ZXN0U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7IHNvdXJjZTogc291cmNlLCBzdGF0dXM6ICdwZW5kaW5nJywgZXZlbnREZWZzOiBudWxsIH07XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgKz0gMTtcclxuICAgICAgICBzb3VyY2UuZmV0Y2godGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMudGltZXpvbmUpLnRoZW4oZnVuY3Rpb24gKGV2ZW50RGVmcykge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ldmVudERlZnMgPSBldmVudERlZnM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRFdmVudERlZnMoZXZlbnREZWZzKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnZmFpbGVkJztcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5wdXJnZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNCeVVpZFtzb3VyY2UudWlkXTtcclxuICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmV2ZW50RGVmcy5mb3JFYWNoKHRoaXMucmVtb3ZlRXZlbnREZWYuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnB1cmdlQWxsU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdHNCeVVpZCA9IHRoaXMucmVxdWVzdHNCeVVpZDtcclxuICAgICAgICB2YXIgdWlkLCByZXF1ZXN0O1xyXG4gICAgICAgIHZhciBjb21wbGV0ZWRDbnQgPSAwO1xyXG4gICAgICAgIGZvciAodWlkIGluIHJlcXVlc3RzQnlVaWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3RzQnlVaWRbdWlkXTtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAncGVuZGluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgPSAwO1xyXG4gICAgICAgIGlmIChjb21wbGV0ZWRDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxFdmVudERlZnMoKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEZWZpbml0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZkJ5VWlkID0gZnVuY3Rpb24gKGV2ZW50RGVmVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWZVaWRdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZXZlbnREZWZzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50RGVmcyA9IGZ1bmN0aW9uIChldmVudERlZnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5hZGRFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZnNCeUlkID0gdGhpcy5ldmVudERlZnNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudERlZklkID0gZXZlbnREZWYuaWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gfHwgKGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gPSBbXSk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXModGhpcy51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50RGVmcy5wdXNoKGV2ZW50RGVmKTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5VWlkW2V2ZW50RGVmLnVpZF0gPSBldmVudERlZjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2VzW2ldLCBldmVudERlZklkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc0VtcHR5ID0gJC5pc0VtcHR5T2JqZWN0KHRoaXMuZXZlbnREZWZzQnlVaWQpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5SWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0ge307XHJcbiAgICAgICAgaWYgKCFpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzQnlJZCA9IHRoaXMuZXZlbnREZWZzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWYudWlkXTtcclxuICAgICAgICBpZiAoZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS5yZW1vdmVFeGFjdChldmVudERlZnMsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgaWYgKCFldmVudERlZnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEluc3RhbmNlc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzLnB1c2guYXBwbHkoZXZlbnRJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXBzQnlJZFtpZF0uZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMuc2xpY2UoKTsgLy8gY2xvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgZm9yIChpZCBpbiBldmVudEluc3RhbmNlR3JvdXBzQnlJZCkge1xyXG4gICAgICAgICAgICBpZiAoaWQgIT09IGV2ZW50RGVmSWQpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoaW5nSW5zdGFuY2VzLnB1c2guYXBwbHkobWF0Y2hpbmdJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbaWRdLmV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdIHx8XHJcbiAgICAgICAgICAgIChldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXSA9IG5ldyBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICB2YXIgcmVtb3ZlQ250O1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmVtb3ZlQ250ID0gdXRpbF8xLnJlbW92ZU1hdGNoaW5nKGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcywgZnVuY3Rpb24gKGN1cnJlbnRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEV2ZW50SW5zdGFuY2UuZGVmID09PSBldmVudERlZjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlQ250KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZWxlYXNpbmcgYW5kIEZyZWV6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRyeVJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmZyZWV6ZURlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQrKztcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUud2hlblJlbGVhc2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZUNudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub25lKCdyZWxlYXNlJywgb25SZXNvbHZlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5mcmVlemVEZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmZyZWV6ZURlcHRoKSAmJiB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ICYmICF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFBlcmlvZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRQZXJpb2Q7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudFBlcmlvZCk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDgwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICB0aGlzLmJpbmRHbG9iYWxIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2tlbGV0b24oKTtcclxuICAgICAgICB0aGlzLnNldCgnaXNJbkRvbScsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVuc2V0KCdpc0luRG9tJyk7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlclNrZWxldG9uKCk7XHJcbiAgICAgICAgdGhpcy51bmJpbmRHbG9iYWxIYW5kbGVycygpO1xyXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgLy8gTk9URTogZG9uJ3QgbnVsbC1vdXQgdGhpcy5lbCBpbiBjYXNlIHRoZSBWaWV3IHdhcyBkZXN0cm95ZWQgd2l0aGluIGFuIEFQSSBjYWxsYmFjay5cclxuICAgICAgICAvLyBXZSBkb24ndCBudWxsLW91dCB0aGUgVmlldydzIG90aGVyIGpRdWVyeSBlbGVtZW50IHJlZmVyZW5jZXMgdXBvbiBkZXN0cm95LFxyXG4gICAgICAgIC8vICBzbyB3ZSBzaG91bGRuJ3Qga2lsbCB0aGlzLmVsIGVpdGhlci5cclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOT1RFOiBDYW4ndCBoYXZlIGEgYHJlbmRlcmAgbWV0aG9kLiBSZWFkIHRoZSBkZXByZWNhdGlvbiBub3RpY2UgaW4gVmlldzo6ZXhlY3V0ZURhdGVSZW5kZXJcclxuICAgICovXHJcbiAgICAvLyBSZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXcgYmVmb3JlIGFueSBjb250ZW50IGlzIHJlbmRlcmVkXHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyB0aGUgYmFzaWMgc3RydWN0dXJlIG9mIHRoZSB2aWV3XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbXBvbmVudDtcclxufShNb2RlbF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9uZW50O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG4vKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZWxlbWVudCBhbmQgbGV0cyBpdCB0cmFjayB0aGUgbW91c2UgYXMgaXQgbW92ZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBNb3VzZUZvbGxvd2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW91c2VGb2xsb3dlcihzb3VyY2VFbCwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNGb2xsb3dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyBkb2luZyB0aGUgcmV2ZXJ0IGFuaW1hdGlvbj9cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gc291cmNlRWw7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRFbCA9IG9wdGlvbnMucGFyZW50RWwgPyAkKG9wdGlvbnMucGFyZW50RWwpIDogc291cmNlRWwucGFyZW50KCk7IC8vIGRlZmF1bHQgdG8gc291cmNlRWwncyBwYXJlbnRcclxuICAgIH1cclxuICAgIC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdGFydCBmb2xsb3dpbmcgdGhlIG1vdXNlXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0ZvbGxvd2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRm9sbG93aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy55MCA9IHV0aWxfMS5nZXRFdlkoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLngwID0gdXRpbF8xLmdldEV2WChldik7XHJcbiAgICAgICAgICAgIHRoaXMudG9wRGVsdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnREZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RvcCBmb2xsb3dpbmcgdGhlIG1vdXNlLiBJZiBzaG91bGRSZXZlcnQgaXMgdHJ1ZSwgd2lsbCBhbmltYXRlIGJhY2sgdG8gb3JpZ2luYWwgcG9zaXRpb24uXHJcbiAgICAvLyBgY2FsbGJhY2tgIGdldHMgaW52b2tlZCB3aGVuIHRoZSBhbmltYXRpb24gaXMgY29tcGxldGUuIElmIG5vIGFuaW1hdGlvbiwgaXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseS5cclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoc2hvdWxkUmV2ZXJ0LCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJldmVydER1cmF0aW9uID0gdGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uO1xyXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBfdGhpcy50b3AwID0gX3RoaXMubGVmdDAgPSBudWxsOyAvLyByZXNldCBzdGF0ZSBmb3IgZnV0dXJlIHVwZGF0ZVBvc2l0aW9uIGNhbGxzXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGb2xsb3dpbmcgJiYgIXRoaXMuaXNBbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXZlcnQgJiYgcmV2ZXJ0RHVyYXRpb24gJiYgIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wMCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQwXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHJldmVydER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRyYWNraW5nIGVsZW1lbnQuIENyZWF0ZSBpdCBpZiBuZWNlc3NhcnlcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmdldEVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lKClcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbENsYXNzIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogdGhpcy5pc0hpZGRlbiA/ICdub25lJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc291cmNlRWwud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zb3VyY2VFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5vcGFjaXR5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLm9wdGlvbnMuekluZGV4XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxyXG4gICAgICAgICAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJyk7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZFRvKHRoaXMucGFyZW50RWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVtb3ZlcyB0aGUgdHJhY2tpbmcgZWxlbWVudCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZSB0aGUgQ1NTIHBvc2l0aW9uIG9mIHRoZSB0cmFja2luZyBlbGVtZW50XHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlT2Zmc2V0O1xyXG4gICAgICAgIHZhciBvcmlnaW47XHJcbiAgICAgICAgdGhpcy5nZXRFbCgpOyAvLyBlbnN1cmUgdGhpcy5lbFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvcmlnaW4gaW5mbyB3YXMgY29tcHV0ZWRcclxuICAgICAgICBpZiAodGhpcy50b3AwID09IG51bGwpIHtcclxuICAgICAgICAgICAgc291cmNlT2Zmc2V0ID0gdGhpcy5zb3VyY2VFbC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy50b3AwID0gc291cmNlT2Zmc2V0LnRvcCAtIG9yaWdpbi50b3A7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdDAgPSBzb3VyY2VPZmZzZXQubGVmdCAtIG9yaWdpbi5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmNzcyh7XHJcbiAgICAgICAgICAgIHRvcDogdGhpcy50b3AwICsgdGhpcy50b3BEZWx0YSxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5sZWZ0MCArIHRoaXMubGVmdERlbHRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2VcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRvcERlbHRhID0gdXRpbF8xLmdldEV2WShldikgLSB0aGlzLnkwO1xyXG4gICAgICAgIHRoaXMubGVmdERlbHRhID0gdXRpbF8xLmdldEV2WChldikgLSB0aGlzLngwO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRlbXBvcmFyaWx5IG1ha2VzIHRoZSB0cmFja2luZyBlbGVtZW50IGludmlzaWJsZS4gQ2FuIGJlIGNhbGxlZCBiZWZvcmUgZm9sbG93aW5nIHN0YXJ0c1xyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG93IHRoZSB0cmFja2luZyBlbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHRlbXBvcmFyaWx5IGhpZGRlblxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRFbCgpLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vdXNlRm9sbG93ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vdXNlRm9sbG93ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW91c2VGb2xsb3dlcik7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDgyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIERhdGVDbGlja2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVDbGlja2luZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgICAgLSBiaW5kRGF0ZUhhbmRsZXJUb0VsXHJcbiAgICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAgICAgLSBnZXRIaXRFbFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGVDbGlja2luZyhjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gX3RoaXMuYnVpbGREcmFnTGlzdGVuZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIERhdGVDbGlja2luZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5zaG91bGRJZ25vcmVUb3VjaCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgY2xpY2tpbmcuXHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkYXlDbGlja0hpdDsgLy8gbnVsbCBpZiBpbnZhbGlkIGRheUNsaWNrXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRheUNsaWNrSGl0ID0gZHJhZ0xpc3RlbmVyLm9yaWdIaXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkcmFnZ2VkIHRvIGFub3RoZXIgY2VsbCBhdCBhbnkgcG9pbnQsIGl0IGNhbiBubyBsb25nZXIgYmUgYSBkYXlDbGlja1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09yaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXlDbGlja0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGF5Q2xpY2tIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQgJiYgZGF5Q2xpY2tIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChkYXlDbGlja0hpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnRyaWdnZXJEYXlDbGljayhjb21wb25lbnRGb290cHJpbnQsIGNvbXBvbmVudC5nZXRIaXRFbChkYXlDbGlja0hpdCksIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBiZWNhdXNlIGRyYWdMaXN0ZW5lciB3b24ndCBiZSBjYWxsZWQgd2l0aCBhbnkgdGltZSBkZWxheSwgXCJkcmFnZ2luZ1wiIHdpbGwgYmVnaW4gaW1tZWRpYXRlbHksXHJcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBraWxsIGFueSB0b3VjaG1vdmluZy9zY3JvbGxpbmcuIFByZXZlbnQgdGhpcy5cclxuICAgICAgICBkcmFnTGlzdGVuZXIuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc2Nyb2xsQWx3YXlzS2lsbHMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVDbGlja2luZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZUNsaWNraW5nO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcclxuLypcclxuT25seSBoYW5kbGVzIGZvcmVncm91bmQgc2Vncy5cclxuRG9lcyBub3Qgb3duIHJlbmRlcmluZy4gVXNlIGZvciBsb3ctbGV2ZWwgdXRpbCBtZXRob2RzIGJ5IFRpbWVHcmlkLlxyXG4qL1xyXG52YXIgVGltZUdyaWRFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWRFdmVudFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZUdyaWRFdmVudFJlbmRlcmVyKHRpbWVHcmlkLCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0aW1lR3JpZCwgZmlsbFJlbmRlcmVyKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnRpbWVHcmlkID0gdGltZUdyaWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMoc2VncywgdGhpcy50aW1lR3JpZC5mZ0NvbnRhaW5lckVscyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gYXJyYXkgb2YgZm9yZWdyb3VuZCBzZWdtZW50cywgcmVuZGVyIGEgRE9NIGVsZW1lbnQgZm9yIGVhY2gsIGNvbXB1dGVzIHBvc2l0aW9uLFxyXG4gICAgLy8gYW5kIGF0dGFjaGVzIHRvIHRoZSBjb2x1bW4gaW5uZXItY29udGFpbmVyIGVsZW1lbnRzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyA9IGZ1bmN0aW9uIChzZWdzLCBjb250YWluZXJFbHMpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5Q29sO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgc2Vnc0J5Q29sID0gdGhpcy50aW1lR3JpZC5ncm91cFNlZ3NCeUNvbChzZWdzKTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMudGltZUdyaWQuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZnU2VnQ29vcmRzKHNlZ3NCeUNvbFtjb2xdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5hdHRhY2hTZWdzQnlDb2woc2Vnc0J5Q29sLCBjb250YWluZXJFbHMpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmdTZWdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmdTZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ25vTWVyaWRpZW1UaW1lRm9ybWF0Jyk7IC8vIGxpa2UgXCI2OjMwXCIgKG5vIEFNL1BNKVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGEgZGVmYXVsdCBgZGlzcGxheUV2ZW50RW5kYCB2YWx1ZSBpZiBvbmUgaXMgbm90IGV4cGxpY2x0eSBkZWZpbmVkXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgZXZlbnQgc2VnbWVudCdzIGRlZmF1bHQgcmVuZGVyaW5nXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudEZvb3RwcmludCA9IHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHZhciBpc0FsbERheSA9IGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheTtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERlZkRyYWdnYWJsZShldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xyXG4gICAgICAgIHZhciBza2luQ3NzID0gdXRpbF8xLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciB0aW1lVGV4dDtcclxuICAgICAgICB2YXIgZnVsbFRpbWVUZXh0OyAvLyBtb3JlIHZlcmJvc2UgdGltZSB0ZXh0LiBmb3IgdGhlIHByaW50IHN0eWxlc2hlZXRcclxuICAgICAgICB2YXIgc3RhcnRUaW1lVGV4dDsgLy8ganVzdCB0aGUgc3RhcnQgdGltZSB0ZXh0XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy10aW1lLWdyaWQtZXZlbnQnLCAnZmMtdi1ldmVudCcpO1xyXG4gICAgICAgIC8vIGlmIHRoZSBldmVudCBhcHBlYXJzIHRvIHNwYW4gbW9yZSB0aGFuIG9uZSBkYXkuLi5cclxuICAgICAgICBpZiAodmlldy5pc011bHRpRGF5UmFuZ2UoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgZGlzcGxheSB0aW1lIHRleHQgb24gc2VnbWVudHMgdGhhdCBydW4gZW50aXJlbHkgdGhyb3VnaCBhIGRheS5cclxuICAgICAgICAgICAgLy8gVGhhdCB3b3VsZCBhcHBlYXIgYXMgbWlkbmlnaHQtbWlkbmlnaHQgYW5kIHdvdWxkIGxvb2sgZHVtYi5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkaXNwbGF5IHRoZSB0aW1lIHRleHQgZm9yIHRoZSAqc2VnbWVudCdzKiB0aW1lcyAobGlrZSA2cG0tbWlkbmlnaHQgb3IgbWlkbmlnaHQtMTBhbSlcclxuICAgICAgICAgICAgaWYgKHNlZy5pc1N0YXJ0IHx8IHNlZy5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvbmVkU3RhcnQgPSBjYWxlbmRhci5tc1RvTW9tZW50KHNlZy5zdGFydE1zKTtcclxuICAgICAgICAgICAgICAgIHZhciB6b25lZEVuZCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLmVuZE1zKTtcclxuICAgICAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5fZ2V0VGltZVRleHQoem9uZWRTdGFydCwgem9uZWRFbmQsIGlzQWxsRGF5KTtcclxuICAgICAgICAgICAgICAgIGZ1bGxUaW1lVGV4dCA9IHRoaXMuX2dldFRpbWVUZXh0KHpvbmVkU3RhcnQsIHpvbmVkRW5kLCBpc0FsbERheSwgJ0xUJyk7XHJcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVUZXh0ID0gdGhpcy5fZ2V0VGltZVRleHQoem9uZWRTdGFydCwgem9uZWRFbmQsIGlzQWxsRGF5LCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGlzcGxheSB0aGUgbm9ybWFsIHRpbWUgdGV4dCBmb3IgdGhlICpldmVudCdzKiB0aW1lc1xyXG4gICAgICAgICAgICB0aW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoc2VnLmZvb3RwcmludCk7XHJcbiAgICAgICAgICAgIGZ1bGxUaW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoc2VnLmZvb3RwcmludCwgJ0xUJyk7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQsIG51bGwsIGZhbHNlKTsgLy8gZGlzcGxheUVuZD1mYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJzxhIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChldmVudERlZi51cmwgP1xyXG4gICAgICAgICAgICAgICAgJyBocmVmPVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKGV2ZW50RGVmLnVybCkgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChza2luQ3NzID9cclxuICAgICAgICAgICAgICAgICcgc3R5bGU9XCInICsgc2tpbkNzcyArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50XCI+JyArXHJcbiAgICAgICAgICAgICh0aW1lVGV4dCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXRpbWVcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgZGF0YS1zdGFydD1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShzdGFydFRpbWVUZXh0KSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgZGF0YS1mdWxsPVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKGZ1bGxUaW1lVGV4dCkgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8c3Bhbj4nICsgdXRpbF8xLmh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoZXZlbnREZWYudGl0bGUgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKGV2ZW50RGVmLnRpdGxlKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJnXCIvPicgK1xyXG4gICAgICAgICAgICAvKiBUT0RPOiB3cml0ZSBDU1MgZm9yIHRoaXNcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnXHJcbiAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbUVuZCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtZW5kLXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvYT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHNlZ21lbnRzIHRoYXQgYXJlIGFzc3VtZWQgdG8gYWxsIGxpdmUgaW4gdGhlICpzYW1lIGNvbHVtbiosXHJcbiAgICAvLyBjb21wdXRlIHRoZWlyIHZlcmljYWwvaG9yaXpvbnRhbCBjb29yZGluYXRlcyBhbmQgYXNzaWduIHRvIHRoZWlyIGVsZW1lbnRzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVGZ1NlZ0Nvb3JkcyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpOyAvLyBob3Jpem9udGFscyByZWxpZXMgb24gdGhpc1xyXG4gICAgICAgIHRoaXMuY29tcHV0ZUZnU2VnSG9yaXpvbnRhbHMoc2Vncyk7IC8vIGNvbXB1dGUgaG9yaXpvbnRhbCBjb29yZGluYXRlcywgei1pbmRleCdzLCBhbmQgcmVvcmRlciB0aGUgYXJyYXlcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmFzc2lnblNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgICAgICB0aGlzLmFzc2lnbkZnU2VnSG9yaXpvbnRhbHMoc2Vncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYW4gYXJyYXkgb2Ygc2VnbWVudHMgdGhhdCBhcmUgYWxsIGluIHRoZSBzYW1lIGNvbHVtbiwgc2V0cyB0aGUgYmFja3dhcmRDb29yZCBhbmQgZm9yd2FyZENvb3JkIG9uIGVhY2guXHJcbiAgICAvLyBOT1RFOiBBbHNvIHJlb3JkZXJzIHRoZSBnaXZlbiBhcnJheSBieSBkYXRlIVxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRmdTZWdIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGxldmVscztcclxuICAgICAgICB2YXIgbGV2ZWwwO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHRoaXMuc29ydEV2ZW50U2VncyhzZWdzKTsgLy8gb3JkZXIgYnkgY2VydGFpbiBjcml0ZXJpYVxyXG4gICAgICAgIGxldmVscyA9IGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKTtcclxuICAgICAgICBjb21wdXRlRm9yd2FyZFNsb3RTZWdzKGxldmVscyk7XHJcbiAgICAgICAgaWYgKChsZXZlbDAgPSBsZXZlbHNbMF0pKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbDAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGxldmVsMFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhsZXZlbDBbaV0sIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGN1bGF0ZSBzZWcuZm9yd2FyZENvb3JkIGFuZCBzZWcuYmFja3dhcmRDb29yZCBmb3IgdGhlIHNlZ21lbnQsIHdoZXJlIGJvdGggdmFsdWVzIHJhbmdlXHJcbiAgICAvLyBmcm9tIDAgdG8gMS4gSWYgdGhlIGNhbGVuZGFyIGlzIGxlZnQtdG8tcmlnaHQsIHRoZSBzZWcuYmFja3dhcmRDb29yZCBtYXBzIHRvIFwibGVmdFwiIGFuZFxyXG4gICAgLy8gc2VnLmZvcndhcmRDb29yZCBtYXBzIHRvIFwicmlnaHRcIiAodmlhIHBlcmNlbnRhZ2UpLiBWaWNlLXZlcnNhIGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBzZWdtZW50IG1pZ2h0IGJlIHBhcnQgb2YgYSBcInNlcmllc1wiLCB3aGljaCBtZWFucyBjb25zZWN1dGl2ZSBzZWdtZW50cyB3aXRoIHRoZSBzYW1lIHByZXNzdXJlXHJcbiAgICAvLyB3aG8ncyB3aWR0aCBpcyB1bmtub3duIHVudGlsIGFuIGVkZ2UgaGFzIGJlZW4gaGl0LiBgc2VyaWVzQmFja3dhcmRQcmVzc3VyZWAgaXMgdGhlIG51bWJlciBvZlxyXG4gICAgLy8gc2VnbWVudHMgYmVoaW5kIHRoaXMgb25lIGluIHRoZSBjdXJyZW50IHNlcmllcywgYW5kIGBzZXJpZXNCYWNrd2FyZENvb3JkYCBpcyB0aGUgc3RhcnRpbmdcclxuICAgIC8vIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHNlZ21lbnQgaW4gdGhlIHNlcmllcy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2sgPSBmdW5jdGlvbiAoc2VnLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlLCBzZXJpZXNCYWNrd2FyZENvb3JkKSB7XHJcbiAgICAgICAgdmFyIGZvcndhcmRTZWdzID0gc2VnLmZvcndhcmRTZWdzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzZWcuZm9yd2FyZENvb3JkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFmb3J3YXJkU2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBmb3J3YXJkIHNlZ21lbnRzLCB0aGlzIHNlZ21lbnQgc2hvdWxkIGJ1dHQgdXAgYWdhaW5zdCB0aGUgZWRnZVxyXG4gICAgICAgICAgICAgICAgc2VnLmZvcndhcmRDb29yZCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzb3J0IGhpZ2hlc3QgcHJlc3N1cmUgZmlyc3RcclxuICAgICAgICAgICAgICAgIHRoaXMuc29ydEZvcndhcmRTZWdzKGZvcndhcmRTZWdzKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2VnbWVudCdzIGZvcndhcmRDb29yZCB3aWxsIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgYmFja3dhcmRDb29yZCBvZiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGhpZ2hlc3QtcHJlc3N1cmUgZm9yd2FyZCBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1swXSwgc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEsIHNlcmllc0JhY2t3YXJkQ29vcmQpO1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvcndhcmRDb29yZCA9IGZvcndhcmRTZWdzWzBdLmJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBiYWNrd2FyZENvb3JkIGZyb20gdGhlIGZvcndhcmRDb29yZC4gY29uc2lkZXIgdGhlIHNlcmllc1xyXG4gICAgICAgICAgICBzZWcuYmFja3dhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQgLVxyXG4gICAgICAgICAgICAgICAgKHNlZy5mb3J3YXJkQ29vcmQgLSBzZXJpZXNCYWNrd2FyZENvb3JkKSAvIC8vIGF2YWlsYWJsZSB3aWR0aCBmb3Igc2VyaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgKHNlcmllc0JhY2t3YXJkUHJlc3N1cmUgKyAxKTsgLy8gIyBvZiBzZWdtZW50cyBpbiB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgIC8vIHVzZSB0aGlzIHNlZ21lbnQncyBjb29yZGluYXRlcyB0byBjb21wdXRlZCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGxlc3MtcHJlc3N1cml6ZWRcclxuICAgICAgICAgICAgLy8gZm9yd2FyZCBzZWdtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUZnU2VnRm9yd2FyZEJhY2soZm9yd2FyZFNlZ3NbaV0sIDAsIHNlZy5mb3J3YXJkQ29vcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuc29ydEZvcndhcmRTZWdzID0gZnVuY3Rpb24gKGZvcndhcmRTZWdzKSB7XHJcbiAgICAgICAgZm9yd2FyZFNlZ3Muc29ydCh1dGlsXzEucHJveHkodGhpcywgJ2NvbXBhcmVGb3J3YXJkU2VncycpKTtcclxuICAgIH07XHJcbiAgICAvLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hpY2ggZm9yd2FyZCBzZWdtZW50IHRvIHJlbHkgb24gbW9yZSB3aGVuIGNvbXB1dGluZyBjb29yZGluYXRlcy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcGFyZUZvcndhcmRTZWdzID0gZnVuY3Rpb24gKHNlZzEsIHNlZzIpIHtcclxuICAgICAgICAvLyBwdXQgaGlnaGVyLXByZXNzdXJlIGZpcnN0XHJcbiAgICAgICAgcmV0dXJuIHNlZzIuZm9yd2FyZFByZXNzdXJlIC0gc2VnMS5mb3J3YXJkUHJlc3N1cmUgfHxcclxuICAgICAgICAgICAgLy8gcHV0IHNlZ21lbnRzIHRoYXQgYXJlIGNsb3NlciB0byBpbml0aWFsIGVkZ2UgZmlyc3QgKGFuZCBmYXZvciBvbmVzIHdpdGggbm8gY29vcmRzIHlldClcclxuICAgICAgICAgICAgKHNlZzEuYmFja3dhcmRDb29yZCB8fCAwKSAtIChzZWcyLmJhY2t3YXJkQ29vcmQgfHwgMCkgfHxcclxuICAgICAgICAgICAgLy8gZG8gbm9ybWFsIHNvcnRpbmcuLi5cclxuICAgICAgICAgICAgdGhpcy5jb21wYXJlRXZlbnRTZWdzKHNlZzEsIHNlZzIpO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgdGhhdCBoYXZlIGFscmVhZHkgaGFkIHRoZWlyIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGNvbXB1dGVkLFxyXG4gICAgLy8gYXNzaWducyBwb3NpdGlvbi1yZWxhdGVkIENTUyB2YWx1ZXMgdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmFzc2lnbkZnU2VnSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2VnLmVsLmNzcyh0aGlzLmdlbmVyYXRlRmdTZWdIb3Jpem9udGFsQ3NzKHNlZykpO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgaGVpZ2h0IGlzIHNob3J0LCBhZGQgYSBjbGFzc05hbWUgZm9yIGFsdGVybmF0ZSBzdHlsaW5nXHJcbiAgICAgICAgICAgIGlmIChzZWcuYm90dG9tIC0gc2VnLnRvcCA8IDMwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuYWRkQ2xhc3MoJ2ZjLXNob3J0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIENTUyBwcm9wZXJ0aWVzL3ZhbHVlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFuIGV2ZW50IHNlZ21lbnQgZWxlbWVudC5cclxuICAgIC8vIENvbnRhaW5zIGltcG9ydGFudCBwb3NpdGlvbmluZy1yZWxhdGVkIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhbnkgZXZlbnQgZWxlbWVudCwgY3VzdG9taXplZCBvciBub3QuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlRmdTZWdIb3Jpem9udGFsQ3NzID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHZhciBzaG91bGRPdmVybGFwID0gdGhpcy5vcHQoJ3Nsb3RFdmVudE92ZXJsYXAnKTtcclxuICAgICAgICB2YXIgYmFja3dhcmRDb29yZCA9IHNlZy5iYWNrd2FyZENvb3JkOyAvLyB0aGUgbGVmdCBzaWRlIGlmIExUUi4gdGhlIHJpZ2h0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxyXG4gICAgICAgIHZhciBmb3J3YXJkQ29vcmQgPSBzZWcuZm9yd2FyZENvb3JkOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMudGltZUdyaWQuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyhzZWcpOyAvLyBnZXQgdG9wL2JvdHRvbSBmaXJzdFxyXG4gICAgICAgIHZhciBpc1JUTCA9IHRoaXMudGltZUdyaWQuaXNSVEw7XHJcbiAgICAgICAgdmFyIGxlZnQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIGxlZnQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcclxuICAgICAgICB2YXIgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXHJcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXApIHtcclxuICAgICAgICAgICAgLy8gZG91YmxlIHRoZSB3aWR0aCwgYnV0IGRvbid0IGdvIGJleW9uZCB0aGUgbWF4aW11bSBmb3J3YXJkIGNvb3JkaW5hdGUgKDEuMClcclxuICAgICAgICAgICAgZm9yd2FyZENvb3JkID0gTWF0aC5taW4oMSwgYmFja3dhcmRDb29yZCArIChmb3J3YXJkQ29vcmQgLSBiYWNrd2FyZENvb3JkKSAqIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSVEwpIHtcclxuICAgICAgICAgICAgbGVmdCA9IDEgLSBmb3J3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gYmFja3dhcmRDb29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBiYWNrd2FyZENvb3JkO1xyXG4gICAgICAgICAgICByaWdodCA9IDEgLSBmb3J3YXJkQ29vcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3BzLnpJbmRleCA9IHNlZy5sZXZlbCArIDE7IC8vIGNvbnZlcnQgZnJvbSAwLWJhc2UgdG8gMS1iYXNlZFxyXG4gICAgICAgIHByb3BzLmxlZnQgPSBsZWZ0ICogMTAwICsgJyUnO1xyXG4gICAgICAgIHByb3BzLnJpZ2h0ID0gcmlnaHQgKiAxMDAgKyAnJSc7XHJcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgc2VnLmZvcndhcmRQcmVzc3VyZSkge1xyXG4gICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXHJcbiAgICAgICAgICAgIHByb3BzW2lzUlRMID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVHcmlkRXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZEV2ZW50UmVuZGVyZXI7XHJcbi8vIEJ1aWxkcyBhbiBhcnJheSBvZiBzZWdtZW50cyBcImxldmVsc1wiLiBUaGUgZmlyc3QgbGV2ZWwgd2lsbCBiZSB0aGUgbGVmdG1vc3QgdGllciBvZiBzZWdtZW50cyBpZiB0aGUgY2FsZW5kYXIgaXNcclxuLy8gbGVmdC10by1yaWdodCwgb3IgdGhlIHJpZ2h0bW9zdCBpZiB0aGUgY2FsZW5kYXIgaXMgcmlnaHQtdG8tbGVmdC4gQXNzdW1lcyB0aGUgc2VnbWVudHMgYXJlIGFscmVhZHkgb3JkZXJlZCBieSBkYXRlLlxyXG5mdW5jdGlvbiBidWlsZFNsb3RTZWdMZXZlbHMoc2Vncykge1xyXG4gICAgdmFyIGxldmVscyA9IFtdO1xyXG4gICAgdmFyIGksIHNlZztcclxuICAgIHZhciBqO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIHRoZSBsZXZlbHMgYW5kIHN0b3Agb24gdGhlIGZpcnN0IGxldmVsIHdoZXJlIHRoZXJlIGFyZSBubyBjb2xsaXNpb25zXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1tqXSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgIChsZXZlbHNbal0gfHwgKGxldmVsc1tqXSA9IFtdKSkucHVzaChzZWcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxldmVscztcclxufVxyXG4vLyBGb3IgZXZlcnkgc2VnbWVudCwgZmlndXJlIG91dCB0aGUgb3RoZXIgc2VnbWVudHMgdGhhdCBhcmUgaW4gc3Vic2VxdWVudFxyXG4vLyBsZXZlbHMgdGhhdCBhbHNvIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZS4gQWNjdW11bGF0ZSBpbiBzZWcuZm9yd2FyZFNlZ3NcclxuZnVuY3Rpb24gY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpIHtcclxuICAgIHZhciBpLCBsZXZlbDtcclxuICAgIHZhciBqLCBzZWc7XHJcbiAgICB2YXIgaztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXZlbCA9IGxldmVsc1tpXTtcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWwubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgc2VnID0gbGV2ZWxbal07XHJcbiAgICAgICAgICAgIHNlZy5mb3J3YXJkU2VncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGsgPSBpICsgMTsgayA8IGxldmVscy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgbGV2ZWxzW2tdLCBzZWcuZm9yd2FyZFNlZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIEZpZ3VyZSBvdXQgd2hpY2ggcGF0aCBmb3J3YXJkICh2aWEgc2VnLmZvcndhcmRTZWdzKSByZXN1bHRzIGluIHRoZSBsb25nZXN0IHBhdGggdW50aWxcclxuLy8gdGhlIGZ1cnRoZXN0IGVkZ2UgaXMgcmVhY2hlZC4gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhdGggd2lsbCBiZSBzZWcuZm9yd2FyZFByZXNzdXJlXHJcbmZ1bmN0aW9uIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKHNlZykge1xyXG4gICAgdmFyIGZvcndhcmRTZWdzID0gc2VnLmZvcndhcmRTZWdzO1xyXG4gICAgdmFyIGZvcndhcmRQcmVzc3VyZSA9IDA7XHJcbiAgICB2YXIgaSwgZm9yd2FyZFNlZztcclxuICAgIGlmIChzZWcuZm9yd2FyZFByZXNzdXJlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yd2FyZFNlZyA9IGZvcndhcmRTZWdzW2ldO1xyXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBjaGlsZCdzIG1heGltdW0gZm9yd2FyZCBwYXRoXHJcbiAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGZvcndhcmRTZWcpO1xyXG4gICAgICAgICAgICAvLyBlaXRoZXIgdXNlIHRoZSBleGlzdGluZyBtYXhpbXVtLCBvciB1c2UgdGhlIGNoaWxkJ3MgZm9yd2FyZCBwcmVzc3VyZVxyXG4gICAgICAgICAgICAvLyBwbHVzIG9uZSAoZm9yIHRoZSBmb3J3YXJkU2VnIGl0c2VsZilcclxuICAgICAgICAgICAgZm9yd2FyZFByZXNzdXJlID0gTWF0aC5tYXgoZm9yd2FyZFByZXNzdXJlLCAxICsgZm9yd2FyZFNlZy5mb3J3YXJkUHJlc3N1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWcuZm9yd2FyZFByZXNzdXJlID0gZm9yd2FyZFByZXNzdXJlO1xyXG4gICAgfVxyXG59XHJcbi8vIEZpbmQgYWxsIHRoZSBzZWdtZW50cyBpbiBgb3RoZXJTZWdzYCB0aGF0IHZlcnRpY2FsbHkgY29sbGlkZSB3aXRoIGBzZWdgLlxyXG4vLyBBcHBlbmQgaW50byBhbiBvcHRpb25hbGx5LXN1cHBsaWVkIGByZXN1bHRzYCBhcnJheSBhbmQgcmV0dXJuLlxyXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBvdGhlclNlZ3MsIHJlc3VsdHMpIHtcclxuICAgIGlmIChyZXN1bHRzID09PSB2b2lkIDApIHsgcmVzdWx0cyA9IFtdOyB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpc1Nsb3RTZWdDb2xsaXNpb24oc2VnLCBvdGhlclNlZ3NbaV0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChvdGhlclNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbi8vIERvIHRoZXNlIHNlZ21lbnRzIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZT9cclxuZnVuY3Rpb24gaXNTbG90U2VnQ29sbGlzaW9uKHNlZzEsIHNlZzIpIHtcclxuICAgIHJldHVybiBzZWcxLmJvdHRvbSA+IHNlZzIudG9wICYmIHNlZzEudG9wIDwgc2VnMi5ib3R0b207XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogODQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcclxudmFyIFRpbWVHcmlkSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEhlbHBlclJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVGltZUdyaWRIZWxwZXJSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIHNvdXJjZVNlZykge1xyXG4gICAgICAgIHZhciBoZWxwZXJOb2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgdmFyIHNvdXJjZUVsO1xyXG4gICAgICAgIC8vIFRPRE86IG5vdCBnb29kIHRvIGNhbGwgZXZlbnRSZW5kZXJlciB0aGlzIHdheVxyXG4gICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLmNvbXBvbmVudC5oZWxwZXJDb250YWluZXJFbHMpO1xyXG4gICAgICAgIC8vIFRyeSB0byBtYWtlIHRoZSBzZWdtZW50IHRoYXQgaXMgaW4gdGhlIHNhbWUgcm93IGFzIHNvdXJjZVNlZyBsb29rIHRoZSBzYW1lXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcuY29sID09PSBzZWcuY29sKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VFbCA9IHNvdXJjZVNlZy5lbDtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNvdXJjZUVsLmNzcygnbGVmdCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzb3VyY2VFbC5jc3MoJ3JpZ2h0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1sZWZ0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tbGVmdCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiBzb3VyY2VFbC5jc3MoJ21hcmdpbi1yaWdodCcpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoZWxwZXJOb2Rlcy5wdXNoKHNlZy5lbFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAkKGhlbHBlck5vZGVzKTsgLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVHcmlkSGVscGVyUmVuZGVyZXI7XHJcbn0oSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVHcmlkSGVscGVyUmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxudmFyIFRpbWVHcmlkRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEZpbGxSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgdGltZUdyaWQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgY29udGFpbmVyRWxzO1xyXG4gICAgICAgIC8vIFRPRE86IG1vcmUgZWZmaWNpZW50IGxvb2t1cFxyXG4gICAgICAgIGlmICh0eXBlID09PSAnYmdFdmVudCcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxzID0gdGltZUdyaWQuYmdDb250YWluZXJFbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5idXNpbmVzc0NvbnRhaW5lckVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2hpZ2hsaWdodCcpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyRWxzID0gdGltZUdyaWQuaGlnaGxpZ2h0Q29udGFpbmVyRWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lR3JpZC51cGRhdGVTZWdWZXJ0aWNhbHMoc2Vncyk7XHJcbiAgICAgICAgdGltZUdyaWQuYXR0YWNoU2Vnc0J5Q29sKHRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpLCBjb250YWluZXJFbHMpO1xyXG4gICAgICAgIHJldHVybiBzZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWcuZWxbMF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVHcmlkRmlsbFJlbmRlcmVyO1xyXG59KEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8qIEEgcmVjdGFuZ3VsYXIgcGFuZWwgdGhhdCBpcyBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgb3ZlciBvdGhlciBjb250ZW50XHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5PcHRpb25zOlxyXG4gICAgLSBjbGFzc05hbWUgKHN0cmluZylcclxuICAgIC0gY29udGVudCAoSFRNTCBzdHJpbmcgb3IgalF1ZXJ5IGVsZW1lbnQgc2V0KVxyXG4gICAgLSBwYXJlbnRFbFxyXG4gICAgLSB0b3BcclxuICAgIC0gbGVmdFxyXG4gICAgLSByaWdodCAodGhlIHggY29vcmQgb2Ygd2hlcmUgdGhlIHJpZ2h0IGVkZ2Ugc2hvdWxkIGJlLiBub3QgYSBcIkNTU1wiIHJpZ2h0KVxyXG4gICAgLSBhdXRvSGlkZSAoYm9vbGVhbilcclxuICAgIC0gc2hvdyAoY2FsbGJhY2spXHJcbiAgICAtIGhpZGUgKGNhbGxiYWNrKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgUG9wb3ZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvcG92ZXIob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubWFyZ2luID0gMTA7IC8vIHRoZSBzcGFjZSByZXF1aXJlZCBiZXR3ZWVuIHRoZSBwb3BvdmVyIGFuZCB0aGUgZWRnZXMgb2YgdGhlIHNjcm9sbCBjb250YWluZXJcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgLy8gU2hvd3MgdGhlIHBvcG92ZXIgb24gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gUmVuZGVycyBpdCBpZiBub3QgYWxyZWFkeVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5lbC5zaG93KCk7XHJcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlkZXMgdGhlIHBvcG92ZXIsIHRocm91Z2ggQ1NTLCBidXQgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIERPTVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5oaWRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpZGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBgdGhpcy5lbGAgYW5kIHJlbmRlcnMgY29udGVudCBpbnNpZGUgb2YgaXRcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIHRoaXMuZWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtcG9wb3ZlclwiLz4nKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpXHJcbiAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBpbml0aWFsbHkgdG8gdGhlIHRvcCBsZWZ0IHRvIGF2b2lkIGNyZWF0aW5nIHNjcm9sbGJhcnNcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmFwcGVuZChvcHRpb25zLmNvbnRlbnQpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhvcHRpb25zLnBhcmVudEVsKTtcclxuICAgICAgICAvLyB3aGVuIGEgY2xpY2sgaGFwcGVucyBvbiBhbnl0aGluZyBpbnNpZGUgd2l0aCBhICdmYy1jbG9zZScgY2xhc3NOYW1lLCBoaWRlIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgdGhpcy5lbC5vbignY2xpY2snLCAnLmZjLWNsb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0hpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicsIHRoaXMuZG9jdW1lbnRNb3VzZWRvd24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZG9jdW1lbnRNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcclxuICAgICAgICBpZiAodGhpcy5lbCAmJiAhJChldi50YXJnZXQpLmNsb3Nlc3QodGhpcy5lbCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBIaWRlcyBhbmQgdW5yZWdpc3RlcnMgYW55IGhhbmRsZXJzXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicpO1xyXG4gICAgfTtcclxuICAgIC8vIFBvc2l0aW9ucyB0aGUgcG9wb3ZlciBvcHRpbWFsbHksIHVzaW5nIHRoZSB0b3AvbGVmdC9yaWdodCBvcHRpb25zXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmVsLm91dGVyV2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5lbC5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIHZhciB3aW5kb3dFbCA9ICQod2luZG93KTtcclxuICAgICAgICB2YXIgdmlld3BvcnRFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQodGhpcy5lbCk7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0VG9wO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydExlZnQ7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0O1xyXG4gICAgICAgIHZhciB0b3A7IC8vIHRoZSBcInBvc2l0aW9uXCIgKG5vdCBcIm9mZnNldFwiKSB2YWx1ZXMgZm9yIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgdmFyIGxlZnQ7IC8vXHJcbiAgICAgICAgLy8gY29tcHV0ZSB0b3AgYW5kIGxlZnRcclxuICAgICAgICB0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMucmlnaHQgLSB3aWR0aDsgLy8gZGVyaXZlIHRoZSBsZWZ0IHZhbHVlIGZyb20gdGhlIHJpZ2h0IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0RWwuaXMod2luZG93KSB8fCB2aWV3cG9ydEVsLmlzKGRvY3VtZW50KSkge1xyXG4gICAgICAgICAgICB2aWV3cG9ydEVsID0gd2luZG93RWw7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wID0gMDsgLy8gdGhlIHdpbmRvdyBpcyBhbHdheXMgYXQgdGhlIHRvcCBsZWZ0XHJcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IDA7IC8vIChhbmQgLm9mZnNldCgpIHdvbid0IHdvcmsgaWYgY2FsbGVkIGhlcmUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2aWV3cG9ydE9mZnNldCA9IHZpZXdwb3J0RWwub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wID0gdmlld3BvcnRPZmZzZXQudG9wO1xyXG4gICAgICAgICAgICB2aWV3cG9ydExlZnQgPSB2aWV3cG9ydE9mZnNldC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgd2luZG93IGlzIHNjcm9sbGVkLCBpdCBjYXVzZXMgdGhlIHZpc2libGUgYXJlYSB0byBiZSBmdXJ0aGVyIGRvd25cclxuICAgICAgICB2aWV3cG9ydFRvcCArPSB3aW5kb3dFbC5zY3JvbGxUb3AoKTtcclxuICAgICAgICB2aWV3cG9ydExlZnQgKz0gd2luZG93RWwuc2Nyb2xsTGVmdCgpO1xyXG4gICAgICAgIC8vIGNvbnN0cmFpbiB0byB0aGUgdmlldyBwb3J0LiBpZiBjb25zdHJhaW5lZCBieSB0d28gZWRnZXMsIGdpdmUgcHJlY2VkZW5jZSB0byB0b3AvbGVmdFxyXG4gICAgICAgIGlmIChvcHRpb25zLnZpZXdwb3J0Q29uc3RyYWluICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIHZpZXdwb3J0VG9wICsgdmlld3BvcnRFbC5vdXRlckhlaWdodCgpIC0gaGVpZ2h0IC0gdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHZpZXdwb3J0VG9wICsgdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgdmlld3BvcnRMZWZ0ICsgdmlld3BvcnRFbC5vdXRlcldpZHRoKCkgLSB3aWR0aCAtIHRoaXMubWFyZ2luKTtcclxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIHZpZXdwb3J0TGVmdCArIHRoaXMubWFyZ2luKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbC5jc3Moe1xyXG4gICAgICAgICAgICB0b3A6IHRvcCAtIG9yaWdpbi50b3AsXHJcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQgLSBvcmlnaW4ubGVmdFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGEgY2FsbGJhY2suIENhbGxzIGEgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbiBoYXNoIG9mIHRoZSBzYW1lIG5hbWUuXHJcbiAgICAvLyBBcmd1bWVudHMgYmV5b25kIHRoZSBmaXJzdCBgbmFtZWAgYXJlIGZvcndhcmRlZCBvbi5cclxuICAgIC8vIFRPRE86IGJldHRlciBjb2RlIHJldXNlIGZvciB0aGlzLiBSZXBlYXQgY29kZVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBQb3BvdmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQb3BvdmVyO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKFBvcG92ZXIpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG4vKiBFdmVudC1yZW5kZXJpbmcgbWV0aG9kcyBmb3IgdGhlIERheUdyaWQgY2xhc3NcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBEYXlHcmlkRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWRFdmVudFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF5R3JpZEV2ZW50UmVuZGVyZXIoZGF5R3JpZCwgZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGF5R3JpZCwgZmlsbFJlbmRlcmVyKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmRheUdyaWQgPSBkYXlHcmlkO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCZ1JhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIC8vIGRvbid0IHJlbmRlciB0aW1lZCBiYWNrZ3JvdW5kIGV2ZW50c1xyXG4gICAgICAgIGV2ZW50UmFuZ2VzID0gJC5ncmVwKGV2ZW50UmFuZ2VzLCBmdW5jdGlvbiAoZXZlbnRSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRSYW5nZS5ldmVudERlZi5pc0FsbERheSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyQmdSYW5nZXMuY2FsbCh0aGlzLCBldmVudFJhbmdlcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyB0aGUgZ2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyA9IHRoaXMucmVuZGVyU2VnUm93cyhzZWdzKTtcclxuICAgICAgICAvLyBhcHBlbmQgdG8gZWFjaCByb3cncyBjb250ZW50IHNrZWxldG9uXHJcbiAgICAgICAgdGhpcy5kYXlHcmlkLnJvd0Vscy5lYWNoKGZ1bmN0aW9uIChpLCByb3dOb2RlKSB7XHJcbiAgICAgICAgICAgICQocm93Tm9kZSkuZmluZCgnLmZjLWNvbnRlbnQtc2tlbGV0b24gPiB0YWJsZScpLmFwcGVuZChyb3dTdHJ1Y3RzW2ldLnRib2R5RWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHNcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMucm93U3RydWN0cyB8fCBbXTtcclxuICAgICAgICB2YXIgcm93U3RydWN0O1xyXG4gICAgICAgIHdoaWxlICgocm93U3RydWN0ID0gcm93U3RydWN0cy5wb3AoKSkpIHtcclxuICAgICAgICAgICAgcm93U3RydWN0LnRib2R5RWwucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm93U3RydWN0cyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gVXNlcyB0aGUgZ2l2ZW4gZXZlbnRzIGFycmF5IHRvIGdlbmVyYXRlIDx0Ym9keT4gZWxlbWVudHMgdGhhdCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gZWFjaCByb3cncyBjb250ZW50IHNrZWxldG9uLlxyXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiByb3dTdHJ1Y3Qgb2JqZWN0cyAoc2VlIHRoZSBib3R0b20gb2YgYHJlbmRlclNlZ1Jvd2ApLlxyXG4gICAgLy8gUFJFQ09ORElUSU9OOiBlYWNoIHNlZ21lbnQgc2hvdWQgYWxyZWFkeSBoYXZlIGEgcmVuZGVyZWQgYW5kIGFzc2lnbmVkIGAuZWxgXHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VnUm93cyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHMgPSBbXTtcclxuICAgICAgICB2YXIgc2VnUm93cztcclxuICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgIHNlZ1Jvd3MgPSB0aGlzLmdyb3VwU2VnUm93cyhzZWdzKTsgLy8gZ3JvdXAgaW50byBuZXN0ZWQgYXJyYXlzXHJcbiAgICAgICAgLy8gaXRlcmF0ZSBlYWNoIHJvdyBvZiBzZWdtZW50IGdyb3VwaW5nc1xyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgc2VnUm93cy5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIHJvd1N0cnVjdHMucHVzaCh0aGlzLnJlbmRlclNlZ1Jvdyhyb3csIHNlZ1Jvd3Nbcm93XSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm93U3RydWN0cztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIHJvdyAjIGFuZCBhbiBhcnJheSBvZiBzZWdtZW50cyBhbGwgaW4gdGhlIHNhbWUgcm93LCByZW5kZXIgYSA8dGJvZHk+IGVsZW1lbnQsIGEgc2tlbGV0b24gdGhhdCBjb250YWluc1xyXG4gICAgLy8gdGhlIHNlZ21lbnRzLiBSZXR1cm5zIG9iamVjdCB3aXRoIGEgYnVuY2ggb2YgaW50ZXJuYWwgZGF0YSBhYm91dCBob3cgdGhlIHJlbmRlciB3YXMgY2FsY3VsYXRlZC5cclxuICAgIC8vIE5PVEU6IG1vZGlmaWVzIHJvd1NlZ3NcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdSb3cgPSBmdW5jdGlvbiAocm93LCByb3dTZWdzKSB7XHJcbiAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuZGF5R3JpZC5jb2xDbnQ7XHJcbiAgICAgICAgdmFyIHNlZ0xldmVscyA9IHRoaXMuYnVpbGRTZWdMZXZlbHMocm93U2Vncyk7IC8vIGdyb3VwIGludG8gc3ViLWFycmF5cyBvZiBsZXZlbHNcclxuICAgICAgICB2YXIgbGV2ZWxDbnQgPSBNYXRoLm1heCgxLCBzZWdMZXZlbHMubGVuZ3RoKTsgLy8gZW5zdXJlIGF0IGxlYXN0IG9uZSBsZXZlbFxyXG4gICAgICAgIHZhciB0Ym9keSA9ICQoJzx0Ym9keS8+Jyk7XHJcbiAgICAgICAgdmFyIHNlZ01hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIHdoaWNoIHNlZ21lbnRzIGFyZSByZW5kZXJlZCBpbnRvIHdoaWNoIGxldmVsK2NvbCBjZWxsc1xyXG4gICAgICAgIHZhciBjZWxsTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3IgYWxsIDx0ZD4gZWxlbWVudHMgb2YgdGhlIGxldmVsK2NvbCBtYXRyaXhcclxuICAgICAgICB2YXIgbG9uZUNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciA8dGQ+IGVsZW1lbnRzIHRoYXQgb25seSB0YWtlIHVwIGEgc2luZ2xlIGNvbHVtblxyXG4gICAgICAgIHZhciBpLCBsZXZlbFNlZ3M7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgdHI7XHJcbiAgICAgICAgdmFyIGosIHNlZztcclxuICAgICAgICB2YXIgdGQ7XHJcbiAgICAgICAgLy8gcG9wdWxhdGVzIGVtcHR5IGNlbGxzIGZyb20gdGhlIGN1cnJlbnQgY29sdW1uIChgY29sYCkgdG8gYGVuZENvbGBcclxuICAgICAgICBmdW5jdGlvbiBlbXB0eUNlbGxzVW50aWwoZW5kQ29sKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb2wgPCBlbmRDb2wpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBncmFiIGEgY2VsbCBmcm9tIHRoZSBsZXZlbCBhYm92ZSBhbmQgZXh0ZW5kIGl0cyByb3dzcGFuLiBvdGhlcndpc2UsIGNyZWF0ZSBhIGZyZXNoIGNlbGxcclxuICAgICAgICAgICAgICAgIHRkID0gKGxvbmVDZWxsTWF0cml4W2kgLSAxXSB8fCBbXSlbY29sXTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRkLmF0dHIoJ3Jvd3NwYW4nLCBwYXJzZUludCh0ZC5hdHRyKCdyb3dzcGFuJykgfHwgMSwgMTApICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZCA9ICQoJzx0ZC8+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKHRkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgbG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsQ250OyBpKyspIHtcclxuICAgICAgICAgICAgbGV2ZWxTZWdzID0gc2VnTGV2ZWxzW2ldO1xyXG4gICAgICAgICAgICBjb2wgPSAwO1xyXG4gICAgICAgICAgICB0ciA9ICQoJzx0ci8+Jyk7XHJcbiAgICAgICAgICAgIHNlZ01hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgY2VsbE1hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgbG9uZUNlbGxNYXRyaXgucHVzaChbXSk7XHJcbiAgICAgICAgICAgIC8vIGxldmVsQ250IG1pZ2h0IGJlIDEgZXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIGFjdHVhbCBsZXZlbHMuIHByb3RlY3QgYWdhaW5zdCB0aGlzLlxyXG4gICAgICAgICAgICAvLyB0aGlzIHNpbmdsZSBlbXB0eSByb3cgaXMgdXNlZnVsIGZvciBzdHlsaW5nLlxyXG4gICAgICAgICAgICBpZiAobGV2ZWxTZWdzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxTZWdzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVtcHR5Q2VsbHNVbnRpbChzZWcubGVmdENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29udGFpbmVyIHRoYXQgb2NjdXBpZXMgb3IgbW9yZSBjb2x1bW5zLiBhcHBlbmQgdGhlIGV2ZW50IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIi8+JykuYXBwZW5kKHNlZy5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZy5sZWZ0Q29sICE9IHNlZy5yaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5hdHRyKCdjb2xzcGFuJywgc2VnLnJpZ2h0Q29sIC0gc2VnLmxlZnRDb2wgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01hdHJpeFtpXVtjb2xdID0gc2VnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKHRkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib29rZW5kQ2VsbHModHIpO1xyXG4gICAgICAgICAgICB0Ym9keS5hcHBlbmQodHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgdGJvZHlFbDogdGJvZHksXHJcbiAgICAgICAgICAgIGNlbGxNYXRyaXg6IGNlbGxNYXRyaXgsXHJcbiAgICAgICAgICAgIHNlZ01hdHJpeDogc2VnTWF0cml4LFxyXG4gICAgICAgICAgICBzZWdMZXZlbHM6IHNlZ0xldmVscyxcclxuICAgICAgICAgICAgc2Vnczogcm93U2Vnc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gU3RhY2tzIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgd2hpY2ggYXJlIGFsbCBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdywgaW50byBzdWJhcnJheXMgb2YgdmVydGljYWwgbGV2ZWxzLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgc2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnTGV2ZWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcclxuICAgICAgICAvLyBhIGNoYW5jZSB0byBiZSBjbG9zZXIgdG8gdGhlIHRvcC5cclxuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCwgdW50aWwgdGhlIHNlZ21lbnQgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgc2VnbWVudHNcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0RheVNlZ0NvbGxpc2lvbihzZWcsIGxldmVsc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBgamAgbm93IGhvbGRzIHRoZSBkZXNpcmVkIHN1YnJvdyBpbmRleFxyXG4gICAgICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGxldmVsIGFycmF5IGlmIG5lZWRlZCBhbmQgYXBwZW5kIHNlZ21lbnRcclxuICAgICAgICAgICAgKGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV2ZWxzW2pdLnNvcnQoY29tcGFyZURheVNlZ0NvbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGV2ZWxzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3Mgcm93XHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ3JvdXBTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2VnUm93cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRheUdyaWQucm93Q250OyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93cy5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93c1tzZWdzW2ldLnJvd10ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ1Jvd3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnZXh0cmFTbWFsbFRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjZwXCIgb3IgXCI2OjMwcFwiXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheUdyaWQuY29sQ250ID09PSAxOyAvLyB3ZSdsbCBsaWtlbHkgaGF2ZSBzcGFjZSBpZiB0aGVyZSdzIG9ubHkgb25lIGRheVxyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCBlbGVtZW50IGZvciBhbiBpbmRpdmlkdWFsIHNlZ21lbnRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBpc0FsbERheSA9IHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERlZkRyYWdnYWJsZShldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBpc0FsbERheSAmJlxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xyXG4gICAgICAgIHZhciBza2luQ3NzID0gdXRpbF8xLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciB0aW1lSHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciB0aW1lVGV4dDtcclxuICAgICAgICB2YXIgdGl0bGVIdG1sO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LWdyaWQtZXZlbnQnLCAnZmMtaC1ldmVudCcpO1xyXG4gICAgICAgIC8vIE9ubHkgZGlzcGxheSBhIHRpbWVkIGV2ZW50cyB0aW1lIGlmIGl0IGlzIHRoZSBzdGFydGluZyBzZWdtZW50XHJcbiAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgaWYgKHRpbWVUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9ICc8c3BhbiBjbGFzcz1cImZjLXRpbWVcIj4nICsgdXRpbF8xLmh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpdGxlSHRtbCA9XHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAodXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZC5pc1JUTCA/XHJcbiAgICAgICAgICAgICAgICB0aXRsZUh0bWwgKyAnICcgKyB0aW1lSHRtbCA6IC8vIHB1dCBhIG5hdHVyYWwgc3BhY2UgaW4gYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgLy9cclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21FbmQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCIgLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L2E+JztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEV2ZW50UmVuZGVyZXI7XHJcbi8vIENvbXB1dGVzIHdoZXRoZXIgdHdvIHNlZ21lbnRzJyBjb2x1bW5zIGNvbGxpZGUuIFRoZXkgYXJlIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LlxyXG5mdW5jdGlvbiBpc0RheVNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vncykge1xyXG4gICAgdmFyIGksIG90aGVyU2VnO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG90aGVyU2VnID0gb3RoZXJTZWdzW2ldO1xyXG4gICAgICAgIGlmIChvdGhlclNlZy5sZWZ0Q29sIDw9IHNlZy5yaWdodENvbCAmJlxyXG4gICAgICAgICAgICBvdGhlclNlZy5yaWdodENvbCA+PSBzZWcubGVmdENvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHRoZSBsZWZ0bW9zdCBldmVudFxyXG5mdW5jdGlvbiBjb21wYXJlRGF5U2VnQ29scyhhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5sZWZ0Q29sIC0gYi5sZWZ0Q29sO1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XHJcbnZhciBEYXlHcmlkSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkSGVscGVyUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkSGVscGVyUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUmVuZGVycyBhIG1vY2sgXCJoZWxwZXJcIiBldmVudC4gYHNvdXJjZVNlZ2AgaXMgdGhlIGFzc29jaWF0ZWQgaW50ZXJuYWwgc2VnbWVudCBvYmplY3QuIEl0IGNhbiBiZSBudWxsLlxyXG4gICAgRGF5R3JpZEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIHNvdXJjZVNlZykge1xyXG4gICAgICAgIHZhciBoZWxwZXJOb2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzO1xyXG4gICAgICAgIC8vIFRPRE86IG5vdCBnb29kIHRvIGNhbGwgZXZlbnRSZW5kZXJlciB0aGlzIHdheVxyXG4gICAgICAgIHJvd1N0cnVjdHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyU2VnUm93cyhzZWdzKTtcclxuICAgICAgICAvLyBpbmplY3QgZWFjaCBuZXcgZXZlbnQgc2tlbGV0b24gaW50byBlYWNoIGFzc29jaWF0ZWQgcm93XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucm93RWxzLmVhY2goZnVuY3Rpb24gKHJvdywgcm93Tm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcm93RWwgPSAkKHJvd05vZGUpOyAvLyB0aGUgLmZjLXJvd1xyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1oZWxwZXItc2tlbGV0b25cIj48dGFibGUvPjwvZGl2PicpOyAvLyB3aWxsIGJlIGFic29sdXRlbHkgcG9zaXRpb25lZFxyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3BFbDtcclxuICAgICAgICAgICAgdmFyIHNrZWxldG9uVG9wO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmlnaW5hbCBzZWdtZW50LCBtYXRjaCB0aGUgdG9wIHBvc2l0aW9uLiBPdGhlcndpc2UsIHB1dCBpdCBhdCB0aGUgcm93J3MgdG9wIGxldmVsXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvblRvcCA9IHNvdXJjZVNlZy5lbC5wb3NpdGlvbigpLnRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0Ym9keScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFza2VsZXRvblRvcEVsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0YWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3AgPSBza2VsZXRvblRvcEVsLnBvc2l0aW9uKCkudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwuY3NzKCd0b3AnLCBza2VsZXRvblRvcClcclxuICAgICAgICAgICAgICAgIC5maW5kKCd0YWJsZScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHJvd1N0cnVjdHNbcm93XS50Ym9keUVsKTtcclxuICAgICAgICAgICAgcm93RWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICBoZWxwZXJOb2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAkKGhlbHBlck5vZGVzKTsgLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxudmFyIERheUdyaWRGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXlHcmlkRmlsbFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGF5R3JpZEZpbGxSZW5kZXJlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5maWxsU2VnVGFnID0gJ3RkJzsgLy8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGFnIG5hbWVcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgc2tlbGV0b25FbCA9IHRoaXMucmVuZGVyRmlsbFJvdyh0eXBlLCBzZWcpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yb3dFbHMuZXEoc2VnLnJvdykuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIG5lZWRlZCBmb3Igb25lIHJvdyBvZiBhIGZpbGwuIFJlcXVpcmVzIHRoZSBzZWcncyBlbCB0byBiZSByZW5kZXJlZC5cclxuICAgIERheUdyaWRGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZpbGxSb3cgPSBmdW5jdGlvbiAodHlwZSwgc2VnKSB7XHJcbiAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuY29tcG9uZW50LmNvbENudDtcclxuICAgICAgICB2YXIgc3RhcnRDb2wgPSBzZWcubGVmdENvbDtcclxuICAgICAgICB2YXIgZW5kQ29sID0gc2VnLnJpZ2h0Q29sICsgMTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lO1xyXG4gICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgIHZhciB0ckVsO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gJ2JnZXZlbnQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBjbGFzc05hbWUgKyAnLXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGU+PHRyLz48L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdHJFbCA9IHNrZWxldG9uRWwuZmluZCgndHInKTtcclxuICAgICAgICBpZiAoc3RhcnRDb2wgPiAwKSB7XHJcbiAgICAgICAgICAgIHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyBzdGFydENvbCArICdcIi8+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyRWwuYXBwZW5kKHNlZy5lbC5hdHRyKCdjb2xzcGFuJywgZW5kQ29sIC0gc3RhcnRDb2wpKTtcclxuICAgICAgICBpZiAoZW5kQ29sIDwgY29sQ250KSB7XHJcbiAgICAgICAgICAgIHRyRWwuYXBwZW5kKCc8dGQgY29sc3Bhbj1cIicgKyAoY29sQ250IC0gZW5kQ29sKSArICdcIi8+Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmJvb2tlbmRDZWxscyh0ckVsKTtcclxuICAgICAgICByZXR1cm4gc2tlbGV0b25FbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEZpbGxSZW5kZXJlcjtcclxufShGaWxsUmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheUdyaWRGaWxsUmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG52YXIgTGlzdEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0RXZlbnRSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RFdmVudFJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIGlmICghc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyRW1wdHlNZXNzYWdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZW5kZXJTZWdMaXN0KHNlZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBnZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGV2ZW50IHJvd1xyXG4gICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IGNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludCA9IHNlZy5mb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRGb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudEZvb3RwcmludCA9IGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgdXJsID0gZXZlbnREZWYudXJsO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gWydmYy1saXN0LWl0ZW0nXS5jb25jYXQodGhpcy5nZXRDbGFzc2VzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIGJnQ29sb3IgPSB0aGlzLmdldEJnQ29sb3IoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciB0aW1lSHRtbDtcclxuICAgICAgICBpZiAoY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHRpbWVIdG1sID0gdmlldy5nZXRBbGxEYXlIdG1sKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaXNNdWx0aURheVJhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5fZ2V0VGltZVRleHQoY2FsZW5kYXIubXNUb01vbWVudChzZWcuc3RhcnRNcyksIGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLmVuZE1zKSwgY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgIHRpbWVIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5nZXRUaW1lVGV4dChldmVudEZvb3RwcmludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtaGFzLXVybCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGlzcGxheUV2ZW50VGltZSA/XHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLXRpbWUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHRpbWVIdG1sIHx8ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLW1hcmtlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtZXZlbnQtZG90XCInICtcclxuICAgICAgICAgICAgKGJnQ29sb3IgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGJnQ29sb3IgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aXRsZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxhJyArICh1cmwgPyAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUodXJsKSArICdcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSB8fCAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIFwiNDowMGFtXCJcclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnbWVkaXVtVGltZUZvcm1hdCcpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0RXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0RXZlbnRSZW5kZXJlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIEV2ZW50UG9pbnRpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xyXG52YXIgTGlzdEV2ZW50UG9pbnRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0RXZlbnRQb2ludGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RFdmVudFBvaW50aW5nKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIGZvciBldmVudHMgd2l0aCBhIHVybCwgdGhlIHdob2xlIDx0cj4gc2hvdWxkIGJlIGNsaWNrYWJsZSxcclxuICAgIC8vIGJ1dCBpdCdzIGltcG9zc2libGUgdG8gd3JhcCB3aXRoIGFuIDxhPiB0YWcuIHNpbXVsYXRlIHRoaXMuXHJcbiAgICBMaXN0RXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIHNlZywgZXYpOyAvLyBtaWdodCBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvblxyXG4gICAgICAgIC8vIG5vdCBjbGlja2luZyBvbiBvciB3aXRoaW4gYW4gPGE+IHdpdGggYW4gaHJlZlxyXG4gICAgICAgIGlmICghJChldi50YXJnZXQpLmNsb3Nlc3QoJ2FbaHJlZl0nKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdXJsID0gc2VnLmZvb3RwcmludC5ldmVudERlZi51cmw7XHJcbiAgICAgICAgICAgIGlmICh1cmwgJiYgIWV2LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDsgLy8gc2ltdWxhdGUgbGluayBjbGlja1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0RXZlbnRQb2ludGluZztcclxufShFdmVudFBvaW50aW5nXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0RXZlbnRQb2ludGluZztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbkV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5yZWdpc3RlckNsYXNzKEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoRnVuY0V2ZW50U291cmNlXzEuZGVmYXVsdCk7XHJcbkV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5yZWdpc3RlckNsYXNzKEpzb25GZWVkRXZlbnRTb3VyY2VfMS5kZWZhdWx0KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVGhlbWVSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcbnZhciBTdGFuZGFyZFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcclxudmFyIEpxdWVyeVVpVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xyXG52YXIgQm9vdHN0cmFwVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmYXVsdC5yZWdpc3Rlcignc3RhbmRhcmQnLCBTdGFuZGFyZFRoZW1lXzEuZGVmYXVsdCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZhdWx0LnJlZ2lzdGVyKCdqcXVlcnktdWknLCBKcXVlcnlVaVRoZW1lXzEuZGVmYXVsdCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZhdWx0LnJlZ2lzdGVyKCdib290c3RyYXAzJywgQm9vdHN0cmFwVGhlbWVfMS5kZWZhdWx0KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcbnZhciBCb290c3RyYXBUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJvb3RzdHJhcFRoZW1lLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQm9vdHN0cmFwVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJvb3RzdHJhcFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb290c3RyYXBUaGVtZTtcclxuQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy1ib290c3RyYXAzJyxcclxuICAgIHRhYmxlR3JpZDogJ3RhYmxlLWJvcmRlcmVkJyxcclxuICAgIHRhYmxlTGlzdDogJ3RhYmxlIHRhYmxlLXN0cmlwZWQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdidG4tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnYnRuIGJ0bi1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdkaXNhYmxlZCcsXHJcbiAgICB0b2RheTogJ2FsZXJ0IGFsZXJ0LWluZm8nLFxyXG4gICAgcG9wb3ZlcjogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ3BhbmVsLWhlYWRpbmcnLFxyXG4gICAgcG9wb3ZlckNvbnRlbnQ6ICdwYW5lbC1ib2R5JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICdwYW5lbC1kZWZhdWx0JyxcclxuICAgIGRheVJvdzogJ3BhbmVsLWRlZmF1bHQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnXHJcbn07XHJcbkJvb3RzdHJhcFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2dseXBoaWNvbic7XHJcbkJvb3RzdHJhcFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcclxuICAgIGNsb3NlOiAnZ2x5cGhpY29uLXJlbW92ZScsXHJcbiAgICBwcmV2OiAnZ2x5cGhpY29uLWNoZXZyb24tbGVmdCcsXHJcbiAgICBuZXh0OiAnZ2x5cGhpY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgcHJldlllYXI6ICdnbHlwaGljb24tYmFja3dhcmQnLFxyXG4gICAgbmV4dFllYXI6ICdnbHlwaGljb24tZm9yd2FyZCdcclxufTtcclxuQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdib290c3RyYXBHbHlwaGljb25zJztcclxuQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdib290c3RyYXBHbHlwaGljb24nO1xyXG5Cb290c3RyYXBUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2dseXBoaWNvbi0nO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5NSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBuYW1lc3BhY2VfaG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBCYXNpY1ZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG52YXIgTW9udGhWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcclxudmFyIHZpZXdzID0gbmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC52aWV3cztcclxudmlld3MuYmFzaWMgPSB7XHJcbiAgICAnY2xhc3MnOiBCYXNpY1ZpZXdfMS5kZWZhdWx0XHJcbn07XHJcbnZpZXdzLmJhc2ljRGF5ID0ge1xyXG4gICAgdHlwZTogJ2Jhc2ljJyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfVxyXG59O1xyXG52aWV3cy5iYXNpY1dlZWsgPSB7XHJcbiAgICB0eXBlOiAnYmFzaWMnLFxyXG4gICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfVxyXG59O1xyXG52aWV3cy5tb250aCA9IHtcclxuICAgICdjbGFzcyc6IE1vbnRoVmlld18xLmRlZmF1bHQsXHJcbiAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWVcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbmFtZXNwYWNlX2hvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgQWdlbmRhVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcbnZhciB2aWV3cyA9IG5hbWVzcGFjZV9ob29rc18xLmRlZmF1bHQudmlld3M7XHJcbnZpZXdzLmFnZW5kYSA9IHtcclxuICAgICdjbGFzcyc6IEFnZW5kYVZpZXdfMS5kZWZhdWx0LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxyXG4gICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcclxuICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxyXG4gICAgfVxyXG59O1xyXG52aWV3cy5hZ2VuZGFEYXkgPSB7XHJcbiAgICB0eXBlOiAnYWdlbmRhJyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfVxyXG59O1xyXG52aWV3cy5hZ2VuZGFXZWVrID0ge1xyXG4gICAgdHlwZTogJ2FnZW5kYScsXHJcbiAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbn07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDk3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG5hbWVzcGFjZV9ob29rc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIExpc3RWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcclxudmFyIHZpZXdzID0gbmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC52aWV3cztcclxudmlld3MubGlzdCA9IHtcclxuICAgICdjbGFzcyc6IExpc3RWaWV3XzEuZGVmYXVsdCxcclxuICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JyxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgYnV0dG9uVGV4dDogJ2xpc3QnLFxyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdMTCcsXHJcbiAgICAgICAgbm9FdmVudHNNZXNzYWdlOiAnTm8gZXZlbnRzIHRvIGRpc3BsYXknXHJcbiAgICB9XHJcbn07XHJcbnZpZXdzLmxpc3REYXkgPSB7XHJcbiAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBhbGwgd2UgbmVlZC4gZnVsbCBkYXRlIGlzIHByb2JhYmx5IGluIGhlYWRlclxyXG4gICAgfVxyXG59O1xyXG52aWV3cy5saXN0V2VlayA9IHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdkZGRkJyxcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnTEwnXHJcbiAgICB9XHJcbn07XHJcbnZpZXdzLmxpc3RNb250aCA9IHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcclxuICAgIH1cclxufTtcclxudmlld3MubGlzdFllYXIgPSB7XHJcbiAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICBkdXJhdGlvbjogeyB5ZWFyOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KVxyXG4vKioqKioqLyBdKTtcclxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9mdWxsY2FsZW5kYXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgbWFwID0ge1xuXHRcIi4vYWZcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FmLmpzXCIsXG5cdFwiLi9hZi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYWYuanNcIixcblx0XCIuL2FyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci5qc1wiLFxuXHRcIi4vYXItZHpcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWR6LmpzXCIsXG5cdFwiLi9hci1kei5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItZHouanNcIixcblx0XCIuL2FyLWt3XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1rdy5qc1wiLFxuXHRcIi4vYXIta3cuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWt3LmpzXCIsXG5cdFwiLi9hci1seVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItbHkuanNcIixcblx0XCIuL2FyLWx5LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1seS5qc1wiLFxuXHRcIi4vYXItbWFcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLW1hLmpzXCIsXG5cdFwiLi9hci1tYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItbWEuanNcIixcblx0XCIuL2FyLXNhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1zYS5qc1wiLFxuXHRcIi4vYXItc2EuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXNhLmpzXCIsXG5cdFwiLi9hci10blwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItdG4uanNcIixcblx0XCIuL2FyLXRuLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qc1wiLFxuXHRcIi4vYXIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLmpzXCIsXG5cdFwiLi9helwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXouanNcIixcblx0XCIuL2F6LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qc1wiLFxuXHRcIi4vYmVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JlLmpzXCIsXG5cdFwiLi9iZS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmUuanNcIixcblx0XCIuL2JnXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iZy5qc1wiLFxuXHRcIi4vYmcuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzXCIsXG5cdFwiLi9ibVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm0uanNcIixcblx0XCIuL2JtLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibS5qc1wiLFxuXHRcIi4vYm5cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JuLmpzXCIsXG5cdFwiLi9ibi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm4uanNcIixcblx0XCIuL2JvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iby5qc1wiLFxuXHRcIi4vYm8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzXCIsXG5cdFwiLi9iclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnIuanNcIixcblx0XCIuL2JyLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ici5qc1wiLFxuXHRcIi4vYnNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JzLmpzXCIsXG5cdFwiLi9icy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnMuanNcIixcblx0XCIuL2NhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jYS5qc1wiLFxuXHRcIi4vY2EuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzXCIsXG5cdFwiLi9jc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3MuanNcIixcblx0XCIuL2NzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qc1wiLFxuXHRcIi4vY3ZcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N2LmpzXCIsXG5cdFwiLi9jdi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3YuanNcIixcblx0XCIuL2N5XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jeS5qc1wiLFxuXHRcIi4vY3kuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N5LmpzXCIsXG5cdFwiLi9kYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGEuanNcIixcblx0XCIuL2RhLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kYS5qc1wiLFxuXHRcIi4vZGVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLmpzXCIsXG5cdFwiLi9kZS1hdFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtYXQuanNcIixcblx0XCIuL2RlLWF0LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1hdC5qc1wiLFxuXHRcIi4vZGUtY2hcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWNoLmpzXCIsXG5cdFwiLi9kZS1jaC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtY2guanNcIixcblx0XCIuL2RlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS5qc1wiLFxuXHRcIi4vZHZcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2R2LmpzXCIsXG5cdFwiLi9kdi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZHYuanNcIixcblx0XCIuL2VsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbC5qc1wiLFxuXHRcIi4vZWwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzXCIsXG5cdFwiLi9lbi1hdVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tYXUuanNcIixcblx0XCIuL2VuLWF1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1hdS5qc1wiLFxuXHRcIi4vZW4tY2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWNhLmpzXCIsXG5cdFwiLi9lbi1jYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tY2EuanNcIixcblx0XCIuL2VuLWdiXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1nYi5qc1wiLFxuXHRcIi4vZW4tZ2IuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzXCIsXG5cdFwiLi9lbi1pZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4taWUuanNcIixcblx0XCIuL2VuLWllLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qc1wiLFxuXHRcIi4vZW4tbnpcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzXCIsXG5cdFwiLi9lbi1uei5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tbnouanNcIixcblx0XCIuL2VvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lby5qc1wiLFxuXHRcIi4vZW8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VvLmpzXCIsXG5cdFwiLi9lc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMuanNcIixcblx0XCIuL2VzLWRvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy1kby5qc1wiLFxuXHRcIi4vZXMtZG8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzXCIsXG5cdFwiLi9lcy11c1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtdXMuanNcIixcblx0XCIuL2VzLXVzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy11cy5qc1wiLFxuXHRcIi4vZXMuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLmpzXCIsXG5cdFwiLi9ldFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXQuanNcIixcblx0XCIuL2V0LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qc1wiLFxuXHRcIi4vZXVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V1LmpzXCIsXG5cdFwiLi9ldS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXUuanNcIixcblx0XCIuL2ZhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mYS5qc1wiLFxuXHRcIi4vZmEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzXCIsXG5cdFwiLi9maVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmkuanNcIixcblx0XCIuL2ZpLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9maS5qc1wiLFxuXHRcIi4vZm9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZvLmpzXCIsXG5cdFwiLi9mby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZm8uanNcIixcblx0XCIuL2ZyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qc1wiLFxuXHRcIi4vZnItY2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzXCIsXG5cdFwiLi9mci1jYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2EuanNcIixcblx0XCIuL2ZyLWNoXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jaC5qc1wiLFxuXHRcIi4vZnItY2guanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzXCIsXG5cdFwiLi9mci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnIuanNcIixcblx0XCIuL2Z5XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9meS5qc1wiLFxuXHRcIi4vZnkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2Z5LmpzXCIsXG5cdFwiLi9nZFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2QuanNcIixcblx0XCIuL2dkLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nZC5qc1wiLFxuXHRcIi4vZ2xcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dsLmpzXCIsXG5cdFwiLi9nbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2wuanNcIixcblx0XCIuL2dvbS1sYXRuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nb20tbGF0bi5qc1wiLFxuXHRcIi4vZ29tLWxhdG4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dvbS1sYXRuLmpzXCIsXG5cdFwiLi9ndVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ3UuanNcIixcblx0XCIuL2d1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qc1wiLFxuXHRcIi4vaGVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hlLmpzXCIsXG5cdFwiLi9oZS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGUuanNcIixcblx0XCIuL2hpXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oaS5qc1wiLFxuXHRcIi4vaGkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzXCIsXG5cdFwiLi9oclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHIuanNcIixcblx0XCIuL2hyLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oci5qc1wiLFxuXHRcIi4vaHVcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h1LmpzXCIsXG5cdFwiLi9odS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHUuanNcIixcblx0XCIuL2h5LWFtXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oeS1hbS5qc1wiLFxuXHRcIi4vaHktYW0uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzXCIsXG5cdFwiLi9pZFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaWQuanNcIixcblx0XCIuL2lkLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pZC5qc1wiLFxuXHRcIi4vaXNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lzLmpzXCIsXG5cdFwiLi9pcy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXMuanNcIixcblx0XCIuL2l0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pdC5qc1wiLFxuXHRcIi4vaXQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzXCIsXG5cdFwiLi9qYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvamEuanNcIixcblx0XCIuL2phLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qc1wiLFxuXHRcIi4vanZcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzXCIsXG5cdFwiLi9qdi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvanYuanNcIixcblx0XCIuL2thXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rYS5qc1wiLFxuXHRcIi4va2EuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2thLmpzXCIsXG5cdFwiLi9ra1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva2suanNcIixcblx0XCIuL2trLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ray5qc1wiLFxuXHRcIi4va21cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ttLmpzXCIsXG5cdFwiLi9rbS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva20uanNcIixcblx0XCIuL2tuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbi5qc1wiLFxuXHRcIi4va24uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tuLmpzXCIsXG5cdFwiLi9rb1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva28uanNcIixcblx0XCIuL2tvLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rby5qc1wiLFxuXHRcIi4va3lcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2t5LmpzXCIsXG5cdFwiLi9reS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva3kuanNcIixcblx0XCIuL2xiXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sYi5qc1wiLFxuXHRcIi4vbGIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xiLmpzXCIsXG5cdFwiLi9sb1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbG8uanNcIixcblx0XCIuL2xvLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sby5qc1wiLFxuXHRcIi4vbHRcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x0LmpzXCIsXG5cdFwiLi9sdC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHQuanNcIixcblx0XCIuL2x2XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdi5qc1wiLFxuXHRcIi4vbHYuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x2LmpzXCIsXG5cdFwiLi9tZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWUuanNcIixcblx0XCIuL21lLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tZS5qc1wiLFxuXHRcIi4vbWlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21pLmpzXCIsXG5cdFwiLi9taS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWkuanNcIixcblx0XCIuL21rXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tay5qc1wiLFxuXHRcIi4vbWsuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21rLmpzXCIsXG5cdFwiLi9tbFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWwuanNcIixcblx0XCIuL21sLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbC5qc1wiLFxuXHRcIi4vbXJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21yLmpzXCIsXG5cdFwiLi9tci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXIuanNcIixcblx0XCIuL21zXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy5qc1wiLFxuXHRcIi4vbXMtbXlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLW15LmpzXCIsXG5cdFwiLi9tcy1teS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXMtbXkuanNcIixcblx0XCIuL21zLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy5qc1wiLFxuXHRcIi4vbXlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL215LmpzXCIsXG5cdFwiLi9teS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXkuanNcIixcblx0XCIuL25iXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uYi5qc1wiLFxuXHRcIi4vbmIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzXCIsXG5cdFwiLi9uZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmUuanNcIixcblx0XCIuL25lLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uZS5qc1wiLFxuXHRcIi4vbmxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzXCIsXG5cdFwiLi9ubC1iZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwtYmUuanNcIixcblx0XCIuL25sLWJlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qc1wiLFxuXHRcIi4vbmwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzXCIsXG5cdFwiLi9ublwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbm4uanNcIixcblx0XCIuL25uLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubi5qc1wiLFxuXHRcIi4vcGEtaW5cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BhLWluLmpzXCIsXG5cdFwiLi9wYS1pbi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGEtaW4uanNcIixcblx0XCIuL3BsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wbC5qc1wiLFxuXHRcIi4vcGwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzXCIsXG5cdFwiLi9wdFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQuanNcIixcblx0XCIuL3B0LWJyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC1ici5qc1wiLFxuXHRcIi4vcHQtYnIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzXCIsXG5cdFwiLi9wdC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQuanNcIixcblx0XCIuL3JvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9yby5qc1wiLFxuXHRcIi4vcm8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzXCIsXG5cdFwiLi9ydVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcnUuanNcIixcblx0XCIuL3J1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ydS5qc1wiLFxuXHRcIi4vc2RcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NkLmpzXCIsXG5cdFwiLi9zZC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2QuanNcIixcblx0XCIuL3NlXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZS5qc1wiLFxuXHRcIi4vc2UuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzXCIsXG5cdFwiLi9zaVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2kuanNcIixcblx0XCIuL3NpLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zaS5qc1wiLFxuXHRcIi4vc2tcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NrLmpzXCIsXG5cdFwiLi9zay5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2suanNcIixcblx0XCIuL3NsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zbC5qc1wiLFxuXHRcIi4vc2wuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NsLmpzXCIsXG5cdFwiLi9zcVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3EuanNcIixcblx0XCIuL3NxLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcS5qc1wiLFxuXHRcIi4vc3JcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLmpzXCIsXG5cdFwiLi9zci1jeXJsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzXCIsXG5cdFwiLi9zci1jeXJsLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzXCIsXG5cdFwiLi9zci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3IuanNcIixcblx0XCIuL3NzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcy5qc1wiLFxuXHRcIi4vc3MuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NzLmpzXCIsXG5cdFwiLi9zdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3YuanNcIixcblx0XCIuL3N2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdi5qc1wiLFxuXHRcIi4vc3dcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3N3LmpzXCIsXG5cdFwiLi9zdy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanNcIixcblx0XCIuL3RhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90YS5qc1wiLFxuXHRcIi4vdGEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RhLmpzXCIsXG5cdFwiLi90ZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGUuanNcIixcblx0XCIuL3RlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZS5qc1wiLFxuXHRcIi4vdGV0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZXQuanNcIixcblx0XCIuL3RldC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGV0LmpzXCIsXG5cdFwiLi90aFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGguanNcIixcblx0XCIuL3RoLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90aC5qc1wiLFxuXHRcIi4vdGwtcGhcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsLXBoLmpzXCIsXG5cdFwiLi90bC1waC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGwtcGguanNcIixcblx0XCIuL3RsaFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGxoLmpzXCIsXG5cdFwiLi90bGguanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsaC5qc1wiLFxuXHRcIi4vdHJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RyLmpzXCIsXG5cdFwiLi90ci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHIuanNcIixcblx0XCIuL3R6bFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHpsLmpzXCIsXG5cdFwiLi90emwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bC5qc1wiLFxuXHRcIi4vdHptXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0uanNcIixcblx0XCIuL3R6bS1sYXRuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0tbGF0bi5qc1wiLFxuXHRcIi4vdHptLWxhdG4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bS1sYXRuLmpzXCIsXG5cdFwiLi90em0uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bS5qc1wiLFxuXHRcIi4vdWtcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VrLmpzXCIsXG5cdFwiLi91ay5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdWsuanNcIixcblx0XCIuL3VyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ci5qc1wiLFxuXHRcIi4vdXIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzXCIsXG5cdFwiLi91elwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXouanNcIixcblx0XCIuL3V6LWxhdG5cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LWxhdG4uanNcIixcblx0XCIuL3V6LWxhdG4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LWxhdG4uanNcIixcblx0XCIuL3V6LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei5qc1wiLFxuXHRcIi4vdmlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3ZpLmpzXCIsXG5cdFwiLi92aS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanNcIixcblx0XCIuL3gtcHNldWRvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS94LXBzZXVkby5qc1wiLFxuXHRcIi4veC1wc2V1ZG8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3gtcHNldWRvLmpzXCIsXG5cdFwiLi95b1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveW8uanNcIixcblx0XCIuL3lvLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS95by5qc1wiLFxuXHRcIi4vemgtY25cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWNuLmpzXCIsXG5cdFwiLi96aC1jbi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtY24uanNcIixcblx0XCIuL3poLWhrXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1oay5qc1wiLFxuXHRcIi4vemgtaGsuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWhrLmpzXCIsXG5cdFwiLi96aC10d1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtdHcuanNcIixcblx0XCIuL3poLXR3LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC10dy5qc1wiXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHZhciBpZCA9IG1hcFtyZXFdO1xuXHRpZighKGlkICsgMSkpIC8vIGNoZWNrIGZvciBudW1iZXIgb3Igc3RyaW5nXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJy5cIik7XG5cdHJldHVybiBpZDtcbn07XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlIHJlY3Vyc2l2ZSBeXFxcXC5cXFxcLy4qJFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUgXlxcLlxcLy4qJFxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSByZWN1cnNpdmUgXlxcLlxcLy4qJFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFmcmlrYWFucyBbYWZdXHJcbi8vISBhdXRob3IgOiBXZXJuZXIgTW9sbGVudHplIDogaHR0cHM6Ly9naXRodWIuY29tL3dlcm5lcm1cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBhZiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FmJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcmllX0ZlYnJ1YXJpZV9NYWFydF9BcHJpbF9NZWlfSnVuaWVfSnVsaWVfQXVndXN0dXNfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01ydF9BcHJfTWVpX0p1bl9KdWxfQXVnX1NlcF9Pa3RfTm92X0Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1NvbmRhZ19NYWFuZGFnX0RpbnNkYWdfV29lbnNkYWdfRG9uZGVyZGFnX1ZyeWRhZ19TYXRlcmRhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU29uX01hYV9EaW5fV29lX0Rvbl9WcnlfU2F0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU29fTWFfRGlfV29fRG9fVnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvdm18bm0vaSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL15ubSQvaS50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3ZtJyA6ICdWTSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnbm0nIDogJ05NJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1ZhbmRhZyBvbV0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW03DtHJlIG9tXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbb21dIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tHaXN0ZXIgb21dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbTGFhc10gZGRkZCBbb21dIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb29yICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGdlbGVkZScsXHJcbiAgICAgICAgcyA6ICdcXCduIHBhYXIgc2Vrb25kZXMnLFxyXG4gICAgICAgIG0gOiAnXFwnbiBtaW51dXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZScsXHJcbiAgICAgICAgaCA6ICdcXCduIHV1cicsXHJcbiAgICAgICAgaGggOiAnJWQgdXJlJyxcclxuICAgICAgICBkIDogJ1xcJ24gZGFnJyxcclxuICAgICAgICBkZCA6ICclZCBkYWUnLFxyXG4gICAgICAgIE0gOiAnXFwnbiBtYWFuZCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbWFhbmRlJyxcclxuICAgICAgICB5IDogJ1xcJ24gamFhcicsXHJcbiAgICAgICAgeXkgOiAnJWQgamFhcidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3RlfGRlKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAoKG51bWJlciA9PT0gMSB8fCBudW1iZXIgPT09IDggfHwgbnVtYmVyID49IDIwKSA/ICdzdGUnIDogJ2RlJyk7IC8vIFRoYW5rcyB0byBKb3JpcyBSw7ZsaW5nIDogaHR0cHM6Ly9naXRodWIuY29tL2pqdXBpdGVyXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNYWFuZGFnIGlzIGRpZSBlZXJzdGUgZGFnIHZhbiBkaWUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBEaWUgd2VlayB3YXQgZGllIDRkZSBKYW51YXJpZSBiZXZhdCBpcyBkaWUgZWVyc3RlIHdlZWsgdmFuIGRpZSBqYWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhZjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYWYuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYWYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBcmFiaWMgKEFsZ2VyaWEpIFthci1kel1cclxuLy8hIGF1dGhvciA6IE5vdXJlZGRpbmUgTE9VQUhFREogOiBodHRwczovL2dpdGh1Yi5jb20vbm91cmVkZGluZW1lXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgYXJEeiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyLWR6Jywge1xyXG4gICAgbW9udGhzIDogJ9is2KfZhtmB2Ypf2YHZitmB2LHZil/Zhdin2LHYs1/Yo9mB2LHZitmEX9mF2KfZil/YrNmI2KfZhl/YrNmI2YrZhNmK2Klf2KPZiNiqX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9is2KfZhtmB2Ypf2YHZitmB2LHZil/Zhdin2LHYs1/Yo9mB2LHZitmEX9mF2KfZil/YrNmI2KfZhl/YrNmI2YrZhNmK2Klf2KPZiNiqX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn2KfYrdivX9in2KvZhtmK2YZf2KvZhNin2KvYp9ihX9in2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfYo9itX9il2Ktf2KvZhNinX9ij2LFf2K7ZhV/YrNmFX9iz2KgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vYp9mE2YrZiNmFINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9i62K/YpyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1vYo9mF2LMg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9mB2YogJXMnLFxyXG4gICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcclxuICAgICAgICBzIDogJ9ir2YjYp9mGJyxcclxuICAgICAgICBtIDogJ9iv2YLZitmC2KknLFxyXG4gICAgICAgIG1tIDogJyVkINiv2YLYp9im2YInLFxyXG4gICAgICAgIGggOiAn2LPYp9i52KknLFxyXG4gICAgICAgIGhoIDogJyVkINiz2KfYudin2KonLFxyXG4gICAgICAgIGQgOiAn2YrZiNmFJyxcclxuICAgICAgICBkZCA6ICclZCDYo9mK2KfZhScsXHJcbiAgICAgICAgTSA6ICfYtNmH2LEnLFxyXG4gICAgICAgIE1NIDogJyVkINij2LTZh9ixJyxcclxuICAgICAgICB5IDogJ9iz2YbYqScsXHJcbiAgICAgICAgeXkgOiAnJWQg2LPZhtmI2KfYqidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYXJEejtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItZHouanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItZHouanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBcmFiaWMgKEt1d2FpdCkgW2FyLWt3XVxyXG4vLyEgYXV0aG9yIDogTnVzcmV0IFBhcmxhazogaHR0cHM6Ly9naXRodWIuY29tL251c3JldHBhcmxha1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGFyS3cgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdhci1rdycsIHtcclxuICAgIG1vbnRocyA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2Ypf2YrZiNmG2YrZiF/ZitmI2YTZitmI2LJf2LrYtNiqX9i02KrZhtio2LFf2KPZg9iq2YjYqNixX9mG2YjZhtio2LFf2K/YrNmG2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KrZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn2KfYrdivX9in2KrZhtmK2YZf2KvZhNin2KvYp9ihX9in2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfYrV/Zhl/Yq1/YsV/Yrl/YrF/Ysycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb2LrYr9inINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn2YHZiiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxyXG4gICAgICAgIHMgOiAn2KvZiNin2YYnLFxyXG4gICAgICAgIG0gOiAn2K/ZgtmK2YLYqScsXHJcbiAgICAgICAgbW0gOiAnJWQg2K/Zgtin2KbZgicsXHJcbiAgICAgICAgaCA6ICfYs9in2LnYqScsXHJcbiAgICAgICAgaGggOiAnJWQg2LPYp9i52KfYqicsXHJcbiAgICAgICAgZCA6ICfZitmI2YUnLFxyXG4gICAgICAgIGRkIDogJyVkINij2YrYp9mFJyxcclxuICAgICAgICBNIDogJ9i02YfYsScsXHJcbiAgICAgICAgTU0gOiAnJWQg2KPYtNmH2LEnLFxyXG4gICAgICAgIHkgOiAn2LPZhtipJyxcclxuICAgICAgICB5eSA6ICclZCDYs9mG2YjYp9iqJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYXJLdztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIta3cuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIta3cuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBcmFiaWMgKEx5YmlhKSBbYXItbHldXHJcbi8vISBhdXRob3IgOiBBbGkgSG1lcjogaHR0cHM6Ly9naXRodWIuY29tL2tpa29hbmlzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAnMScsXHJcbiAgICAnMic6ICcyJyxcclxuICAgICczJzogJzMnLFxyXG4gICAgJzQnOiAnNCcsXHJcbiAgICAnNSc6ICc1JyxcclxuICAgICc2JzogJzYnLFxyXG4gICAgJzcnOiAnNycsXHJcbiAgICAnOCc6ICc4JyxcclxuICAgICc5JzogJzknLFxyXG4gICAgJzAnOiAnMCdcclxufTtcclxudmFyIHBsdXJhbEZvcm0gPSBmdW5jdGlvbiAobikge1xyXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogbiA9PT0gMSA/IDEgOiBuID09PSAyID8gMiA6IG4gJSAxMDAgPj0gMyAmJiBuICUgMTAwIDw9IDEwID8gMyA6IG4gJSAxMDAgPj0gMTEgPyA0IDogNTtcclxufTtcclxudmFyIHBsdXJhbHMgPSB7XHJcbiAgICBzIDogWyfYo9mC2YQg2YXZhiDYq9in2YbZitipJywgJ9ir2KfZhtmK2Kkg2YjYp9it2K/YqScsIFsn2KvYp9mG2YrYqtin2YYnLCAn2KvYp9mG2YrYqtmK2YYnXSwgJyVkINir2YjYp9mGJywgJyVkINir2KfZhtmK2KknLCAnJWQg2KvYp9mG2YrYqSddLFxyXG4gICAgbSA6IFsn2KPZgtmEINmF2YYg2K/ZgtmK2YLYqScsICfYr9mC2YrZgtipINmI2KfYrdiv2KknLCBbJ9iv2YLZitmC2KrYp9mGJywgJ9iv2YLZitmC2KrZitmGJ10sICclZCDYr9mC2KfYptmCJywgJyVkINiv2YLZitmC2KknLCAnJWQg2K/ZgtmK2YLYqSddLFxyXG4gICAgaCA6IFsn2KPZgtmEINmF2YYg2LPYp9i52KknLCAn2LPYp9i52Kkg2YjYp9it2K/YqScsIFsn2LPYp9i52KrYp9mGJywgJ9iz2KfYudiq2YrZhiddLCAnJWQg2LPYp9i52KfYqicsICclZCDYs9in2LnYqScsICclZCDYs9in2LnYqSddLFxyXG4gICAgZCA6IFsn2KPZgtmEINmF2YYg2YrZiNmFJywgJ9mK2YjZhSDZiNin2K3YrycsIFsn2YrZiNmF2KfZhicsICfZitmI2YXZitmGJ10sICclZCDYo9mK2KfZhScsICclZCDZitmI2YXZi9inJywgJyVkINmK2YjZhSddLFxyXG4gICAgTSA6IFsn2KPZgtmEINmF2YYg2LTZh9ixJywgJ9i02YfYsSDZiNin2K3YrycsIFsn2LTZh9ix2KfZhicsICfYtNmH2LHZitmGJ10sICclZCDYo9i02YfYsScsICclZCDYtNmH2LHYpycsICclZCDYtNmH2LEnXSxcclxuICAgIHkgOiBbJ9ij2YLZhCDZhdmGINi52KfZhScsICfYudin2YUg2YjYp9it2K8nLCBbJ9i52KfZhdin2YYnLCAn2LnYp9mF2YrZhiddLCAnJWQg2KPYudmI2KfZhScsICclZCDYudin2YXZi9inJywgJyVkINi52KfZhSddXHJcbn07XHJcbnZhciBwbHVyYWxpemUgPSBmdW5jdGlvbiAodSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcclxuICAgICAgICB2YXIgZiA9IHBsdXJhbEZvcm0obnVtYmVyKSxcclxuICAgICAgICAgICAgc3RyID0gcGx1cmFsc1t1XVtwbHVyYWxGb3JtKG51bWJlcildO1xyXG4gICAgICAgIGlmIChmID09PSAyKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0clt3aXRob3V0U3VmZml4ID8gMCA6IDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XHJcbiAgICB9O1xyXG59O1xyXG52YXIgbW9udGhzID0gW1xyXG4gICAgJ9mK2YbYp9mK2LEnLFxyXG4gICAgJ9mB2KjYsdin2YrYsScsXHJcbiAgICAn2YXYp9ix2LMnLFxyXG4gICAgJ9ij2KjYsdmK2YQnLFxyXG4gICAgJ9mF2KfZitmIJyxcclxuICAgICfZitmI2YbZitmIJyxcclxuICAgICfZitmI2YTZitmIJyxcclxuICAgICfYo9i62LPYt9izJyxcclxuICAgICfYs9io2KrZhdio2LEnLFxyXG4gICAgJ9ij2YPYqtmI2KjYsScsXHJcbiAgICAn2YbZiNmB2YXYqNixJyxcclxuICAgICfYr9mK2LPZhdio2LEnXHJcbl07XHJcblxyXG52YXIgYXJMeSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyLWx5Jywge1xyXG4gICAgbW9udGhzIDogbW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQgOiBtb250aHMsXHJcbiAgICB3ZWVrZGF5cyA6ICfYp9mE2KPYrdivX9in2YTYpdir2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9ij2K3Yr1/Ypdir2YbZitmGX9ir2YTYp9ir2KfYoV/Yo9ix2KjYudin2KFf2K7ZhdmK2LNf2KzZhdi52Klf2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdEL1xcdTIwMEZNL1xcdTIwMEZZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9i1fNmFLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJ9mFJyA9PT0gaW5wdXQ7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9i1JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9mFJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vYp9mE2YrZiNmFINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9i62K/Zi9inINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn2KjYudivICVzJyxcclxuICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXHJcbiAgICAgICAgcyA6IHBsdXJhbGl6ZSgncycpLFxyXG4gICAgICAgIG0gOiBwbHVyYWxpemUoJ20nKSxcclxuICAgICAgICBtbSA6IHBsdXJhbGl6ZSgnbScpLFxyXG4gICAgICAgIGggOiBwbHVyYWxpemUoJ2gnKSxcclxuICAgICAgICBoaCA6IHBsdXJhbGl6ZSgnaCcpLFxyXG4gICAgICAgIGQgOiBwbHVyYWxpemUoJ2QnKSxcclxuICAgICAgICBkZCA6IHBsdXJhbGl6ZSgnZCcpLFxyXG4gICAgICAgIE0gOiBwbHVyYWxpemUoJ00nKSxcclxuICAgICAgICBNTSA6IHBsdXJhbGl6ZSgnTScpLFxyXG4gICAgICAgIHkgOiBwbHVyYWxpemUoJ3knKSxcclxuICAgICAgICB5eSA6IHBsdXJhbGl6ZSgneScpXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KS5yZXBsYWNlKC8sL2csICfYjCcpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhckx5O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1seS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1seS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFyYWJpYyAoTW9yb2NjbykgW2FyLW1hXVxyXG4vLyEgYXV0aG9yIDogRWxGYWRpbGkgWWFzc2luZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9FbEZhZGlsaVlcclxuLy8hIGF1dGhvciA6IEFiZGVsIFNhaWQgOiBodHRwczovL2dpdGh1Yi5jb20vYWJkZWxzYWlkXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgYXJNYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyLW1hJywge1xyXG4gICAgbW9udGhzIDogJ9mK2YbYp9mK2LFf2YHYqNix2KfZitixX9mF2KfYsdizX9ij2KjYsdmK2YRf2YXYp9mKX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiNiyX9i62LTYql/YtNiq2YbYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YbYqNixX9iv2KzZhtio2LEnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn2KfZhNij2K3Yr1/Yp9mE2KXYqtmG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfYp9it2K9f2KfYqtmG2YrZhl/Yq9mE2KfYq9in2KFf2KfYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb2KfZhNmK2YjZhSDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfZgdmKICVzJyxcclxuICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXHJcbiAgICAgICAgcyA6ICfYq9mI2KfZhicsXHJcbiAgICAgICAgbSA6ICfYr9mC2YrZgtipJyxcclxuICAgICAgICBtbSA6ICclZCDYr9mC2KfYptmCJyxcclxuICAgICAgICBoIDogJ9iz2KfYudipJyxcclxuICAgICAgICBoaCA6ICclZCDYs9in2LnYp9iqJyxcclxuICAgICAgICBkIDogJ9mK2YjZhScsXHJcbiAgICAgICAgZGQgOiAnJWQg2KPZitin2YUnLFxyXG4gICAgICAgIE0gOiAn2LTZh9ixJyxcclxuICAgICAgICBNTSA6ICclZCDYo9i02YfYsScsXHJcbiAgICAgICAgeSA6ICfYs9mG2KknLFxyXG4gICAgICAgIHl5IDogJyVkINiz2YbZiNin2KonXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGFyTWE7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLW1hLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLW1hLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQXJhYmljIChTYXVkaSBBcmFiaWEpIFthci1zYV1cclxuLy8hIGF1dGhvciA6IFN1aGFpbCBBbGtvd2FpbGVldCA6IGh0dHBzOi8vZ2l0aHViLmNvbS94c29oXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAn2aEnLFxyXG4gICAgJzInOiAn2aInLFxyXG4gICAgJzMnOiAn2aMnLFxyXG4gICAgJzQnOiAn2aQnLFxyXG4gICAgJzUnOiAn2aUnLFxyXG4gICAgJzYnOiAn2aYnLFxyXG4gICAgJzcnOiAn2acnLFxyXG4gICAgJzgnOiAn2agnLFxyXG4gICAgJzknOiAn2aknLFxyXG4gICAgJzAnOiAn2aAnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn2aEnOiAnMScsXHJcbiAgICAn2aInOiAnMicsXHJcbiAgICAn2aMnOiAnMycsXHJcbiAgICAn2aQnOiAnNCcsXHJcbiAgICAn2aUnOiAnNScsXHJcbiAgICAn2aYnOiAnNicsXHJcbiAgICAn2acnOiAnNycsXHJcbiAgICAn2agnOiAnOCcsXHJcbiAgICAn2aknOiAnOScsXHJcbiAgICAn2aAnOiAnMCdcclxufTtcclxuXHJcbnZhciBhclNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItc2EnLCB7XHJcbiAgICBtb250aHMgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2YrZiF/ZitmI2YbZitmIX9mK2YjZhNmK2Yhf2KPYutiz2LfYs1/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZitmIX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiF/Yo9i62LPYt9izX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfYrV/Zhl/Yq1/YsV/Yrl/YrF/Ysycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAn2YUnID09PSBpbnB1dDtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2LUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2YUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb2LrYr9inINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn2YHZiiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxyXG4gICAgICAgIHMgOiAn2KvZiNin2YYnLFxyXG4gICAgICAgIG0gOiAn2K/ZgtmK2YLYqScsXHJcbiAgICAgICAgbW0gOiAnJWQg2K/Zgtin2KbZgicsXHJcbiAgICAgICAgaCA6ICfYs9in2LnYqScsXHJcbiAgICAgICAgaGggOiAnJWQg2LPYp9i52KfYqicsXHJcbiAgICAgICAgZCA6ICfZitmI2YUnLFxyXG4gICAgICAgIGRkIDogJyVkINij2YrYp9mFJyxcclxuICAgICAgICBNIDogJ9i02YfYsScsXHJcbiAgICAgICAgTU0gOiAnJWQg2KPYtNmH2LEnLFxyXG4gICAgICAgIHkgOiAn2LPZhtipJyxcclxuICAgICAgICB5eSA6ICclZCDYs9mG2YjYp9iqJ1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b2aHZotmj2aTZpdmm2afZqNmp2aBdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KS5yZXBsYWNlKC/YjC9nLCAnLCcpO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSkucmVwbGFjZSgvLC9nLCAn2IwnKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYXJTYTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItc2EuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItc2EuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgIDogIEFyYWJpYyAoVHVuaXNpYSkgW2FyLXRuXVxyXG4vLyEgYXV0aG9yIDogTmFkZXIgVG91a2FicmkgOiBodHRwczovL2dpdGh1Yi5jb20vbmFkZXJpb1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGFyVG4gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdhci10bicsIHtcclxuICAgIG1vbnRoczogJ9is2KfZhtmB2Ypf2YHZitmB2LHZil/Zhdin2LHYs1/Yo9mB2LHZitmEX9mF2KfZil/YrNmI2KfZhl/YrNmI2YrZhNmK2Klf2KPZiNiqX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0OiAn2KzYp9mG2YHZil/ZgdmK2YHYsdmKX9mF2KfYsdizX9ij2YHYsdmK2YRf2YXYp9mKX9is2YjYp9mGX9is2YjZitmE2YrYqV/Yo9mI2Kpf2LPYqNiq2YXYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YHZhdio2LFf2K/Zitiz2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXM6ICfYp9mE2KPYrdivX9in2YTYpdir2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0OiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdISDptbScsXHJcbiAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEw6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXI6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb2LrYr9inINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZToge1xyXG4gICAgICAgIGZ1dHVyZTogJ9mB2YogJXMnLFxyXG4gICAgICAgIHBhc3Q6ICfZhdmG2LAgJXMnLFxyXG4gICAgICAgIHM6ICfYq9mI2KfZhicsXHJcbiAgICAgICAgbTogJ9iv2YLZitmC2KknLFxyXG4gICAgICAgIG1tOiAnJWQg2K/Zgtin2KbZgicsXHJcbiAgICAgICAgaDogJ9iz2KfYudipJyxcclxuICAgICAgICBoaDogJyVkINiz2KfYudin2KonLFxyXG4gICAgICAgIGQ6ICfZitmI2YUnLFxyXG4gICAgICAgIGRkOiAnJWQg2KPZitin2YUnLFxyXG4gICAgICAgIE06ICfYtNmH2LEnLFxyXG4gICAgICAgIE1NOiAnJWQg2KPYtNmH2LEnLFxyXG4gICAgICAgIHk6ICfYs9mG2KknLFxyXG4gICAgICAgIHl5OiAnJWQg2LPZhtmI2KfYqidcclxuICAgIH0sXHJcbiAgICB3ZWVrOiB7XHJcbiAgICAgICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3k6IDQgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhclRuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFyYWJpYyBbYXJdXHJcbi8vISBhdXRob3IgOiBBYmRlbCBTYWlkOiBodHRwczovL2dpdGh1Yi5jb20vYWJkZWxzYWlkXHJcbi8vISBhdXRob3IgOiBBaG1lZCBFbGtoYXRpYlxyXG4vLyEgYXV0aG9yIDogZm9yYWJpIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JhYmlcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfZoScsXHJcbiAgICAnMic6ICfZoicsXHJcbiAgICAnMyc6ICfZoycsXHJcbiAgICAnNCc6ICfZpCcsXHJcbiAgICAnNSc6ICfZpScsXHJcbiAgICAnNic6ICfZpicsXHJcbiAgICAnNyc6ICfZpycsXHJcbiAgICAnOCc6ICfZqCcsXHJcbiAgICAnOSc6ICfZqScsXHJcbiAgICAnMCc6ICfZoCdcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfZoSc6ICcxJyxcclxuICAgICfZoic6ICcyJyxcclxuICAgICfZoyc6ICczJyxcclxuICAgICfZpCc6ICc0JyxcclxuICAgICfZpSc6ICc1JyxcclxuICAgICfZpic6ICc2JyxcclxuICAgICfZpyc6ICc3JyxcclxuICAgICfZqCc6ICc4JyxcclxuICAgICfZqSc6ICc5JyxcclxuICAgICfZoCc6ICcwJ1xyXG59O1xyXG52YXIgcGx1cmFsRm9ybSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiBuID09PSAxID8gMSA6IG4gPT09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1O1xyXG59O1xyXG52YXIgcGx1cmFscyA9IHtcclxuICAgIHMgOiBbJ9ij2YLZhCDZhdmGINir2KfZhtmK2KknLCAn2KvYp9mG2YrYqSDZiNin2K3Yr9ipJywgWyfYq9in2YbZitiq2KfZhicsICfYq9in2YbZitiq2YrZhiddLCAnJWQg2KvZiNin2YYnLCAnJWQg2KvYp9mG2YrYqScsICclZCDYq9in2YbZitipJ10sXHJcbiAgICBtIDogWyfYo9mC2YQg2YXZhiDYr9mC2YrZgtipJywgJ9iv2YLZitmC2Kkg2YjYp9it2K/YqScsIFsn2K/ZgtmK2YLYqtin2YYnLCAn2K/ZgtmK2YLYqtmK2YYnXSwgJyVkINiv2YLYp9im2YInLCAnJWQg2K/ZgtmK2YLYqScsICclZCDYr9mC2YrZgtipJ10sXHJcbiAgICBoIDogWyfYo9mC2YQg2YXZhiDYs9in2LnYqScsICfYs9in2LnYqSDZiNin2K3Yr9ipJywgWyfYs9in2LnYqtin2YYnLCAn2LPYp9i52KrZitmGJ10sICclZCDYs9in2LnYp9iqJywgJyVkINiz2KfYudipJywgJyVkINiz2KfYudipJ10sXHJcbiAgICBkIDogWyfYo9mC2YQg2YXZhiDZitmI2YUnLCAn2YrZiNmFINmI2KfYrdivJywgWyfZitmI2YXYp9mGJywgJ9mK2YjZhdmK2YYnXSwgJyVkINij2YrYp9mFJywgJyVkINmK2YjZhdmL2KcnLCAnJWQg2YrZiNmFJ10sXHJcbiAgICBNIDogWyfYo9mC2YQg2YXZhiDYtNmH2LEnLCAn2LTZh9ixINmI2KfYrdivJywgWyfYtNmH2LHYp9mGJywgJ9i02YfYsdmK2YYnXSwgJyVkINij2LTZh9ixJywgJyVkINi02YfYsdinJywgJyVkINi02YfYsSddLFxyXG4gICAgeSA6IFsn2KPZgtmEINmF2YYg2LnYp9mFJywgJ9i52KfZhSDZiNin2K3YrycsIFsn2LnYp9mF2KfZhicsICfYudin2YXZitmGJ10sICclZCDYo9i52YjYp9mFJywgJyVkINi52KfZhdmL2KcnLCAnJWQg2LnYp9mFJ11cclxufTtcclxudmFyIHBsdXJhbGl6ZSA9IGZ1bmN0aW9uICh1KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xyXG4gICAgICAgIHZhciBmID0gcGx1cmFsRm9ybShudW1iZXIpLFxyXG4gICAgICAgICAgICBzdHIgPSBwbHVyYWxzW3VdW3BsdXJhbEZvcm0obnVtYmVyKV07XHJcbiAgICAgICAgaWYgKGYgPT09IDIpIHtcclxuICAgICAgICAgICAgc3RyID0gc3RyW3dpdGhvdXRTdWZmaXggPyAwIDogMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBtb250aHMgPSBbXHJcbiAgICAn2YPYp9mG2YjZhiDYp9mE2KvYp9mG2Yog2YrZhtin2YrYsScsXHJcbiAgICAn2LTYqNin2Lcg2YHYqNix2KfZitixJyxcclxuICAgICfYotiw2KfYsSDZhdin2LHYsycsXHJcbiAgICAn2YbZitiz2KfZhiDYo9io2LHZitmEJyxcclxuICAgICfYo9mK2KfYsSDZhdin2YrZiCcsXHJcbiAgICAn2K3YstmK2LHYp9mGINmK2YjZhtmK2YgnLFxyXG4gICAgJ9iq2YXZiNiyINmK2YjZhNmK2YgnLFxyXG4gICAgJ9ii2Kgg2KPYutiz2LfYsycsXHJcbiAgICAn2KPZitmE2YjZhCDYs9io2KrZhdio2LEnLFxyXG4gICAgJ9iq2LTYsdmK2YYg2KfZhNij2YjZhCDYo9mD2KrZiNio2LEnLFxyXG4gICAgJ9iq2LTYsdmK2YYg2KfZhNir2KfZhtmKINmG2YjZgdmF2KjYsScsXHJcbiAgICAn2YPYp9mG2YjZhiDYp9mE2KPZiNmEINiv2YrYs9mF2KjYsSdcclxuXTtcclxuXHJcbnZhciBhciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyJywge1xyXG4gICAgbW9udGhzIDogbW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQgOiBtb250aHMsXHJcbiAgICB3ZWVrZGF5cyA6ICfYp9mE2KPYrdivX9in2YTYpdir2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9ij2K3Yr1/Ypdir2YbZitmGX9ir2YTYp9ir2KfYoV/Yo9ix2KjYudin2KFf2K7ZhdmK2LNf2KzZhdi52Klf2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdEL1xcdTIwMEZNL1xcdTIwMEZZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9i1fNmFLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJ9mFJyA9PT0gaW5wdXQ7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9i1JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9mFJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vYp9mE2YrZiNmFINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9i62K/Zi9inINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmG2K8g2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn2KjYudivICVzJyxcclxuICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXHJcbiAgICAgICAgcyA6IHBsdXJhbGl6ZSgncycpLFxyXG4gICAgICAgIG0gOiBwbHVyYWxpemUoJ20nKSxcclxuICAgICAgICBtbSA6IHBsdXJhbGl6ZSgnbScpLFxyXG4gICAgICAgIGggOiBwbHVyYWxpemUoJ2gnKSxcclxuICAgICAgICBoaCA6IHBsdXJhbGl6ZSgnaCcpLFxyXG4gICAgICAgIGQgOiBwbHVyYWxpemUoJ2QnKSxcclxuICAgICAgICBkZCA6IHBsdXJhbGl6ZSgnZCcpLFxyXG4gICAgICAgIE0gOiBwbHVyYWxpemUoJ00nKSxcclxuICAgICAgICBNTSA6IHBsdXJhbGl6ZSgnTScpLFxyXG4gICAgICAgIHkgOiBwbHVyYWxpemUoJ3knKSxcclxuICAgICAgICB5eSA6IHBsdXJhbGl6ZSgneScpXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vZodmi2aPZpNml2abZp9mo2anZoF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KS5yZXBsYWNlKC8sL2csICfYjCcpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhcjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBemVyYmFpamFuaSBbYXpdXHJcbi8vISBhdXRob3IgOiB0b3BjaGl5ZXYgOiBodHRwczovL2dpdGh1Yi5jb20vdG9wY2hpeWV2XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3VmZml4ZXMgPSB7XHJcbiAgICAxOiAnLWluY2knLFxyXG4gICAgNTogJy1pbmNpJyxcclxuICAgIDg6ICctaW5jaScsXHJcbiAgICA3MDogJy1pbmNpJyxcclxuICAgIDgwOiAnLWluY2knLFxyXG4gICAgMjogJy1uY2knLFxyXG4gICAgNzogJy1uY2knLFxyXG4gICAgMjA6ICctbmNpJyxcclxuICAgIDUwOiAnLW5jaScsXHJcbiAgICAzOiAnLcO8bmPDvCcsXHJcbiAgICA0OiAnLcO8bmPDvCcsXHJcbiAgICAxMDA6ICctw7xuY8O8JyxcclxuICAgIDY6ICctbmPEsScsXHJcbiAgICA5OiAnLXVuY3UnLFxyXG4gICAgMTA6ICctdW5jdScsXHJcbiAgICAzMDogJy11bmN1JyxcclxuICAgIDYwOiAnLcSxbmPEsScsXHJcbiAgICA5MDogJy3EsW5jxLEnXHJcbn07XHJcblxyXG52YXIgYXogPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdheicsIHtcclxuICAgIG1vbnRocyA6ICd5YW52YXJfZmV2cmFsX21hcnRfYXByZWxfbWF5X2l5dW5faXl1bF9hdnF1c3Rfc2VudHlhYnJfb2t0eWFicl9ub3lhYnJfZGVrYWJyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAneWFuX2Zldl9tYXJfYXByX21heV9peW5faXlsX2F2cV9zZW5fb2t0X25veV9kZWsnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdCYXphcl9CYXphciBlcnTJmXNpX8OHyZlyxZ/JmW5iyZkgYXjFn2FtxLFfw4fJmXLFn8mZbmLJmV9Dw7xtyZkgYXjFn2FtxLFfQ8O8bcmZX8WeyZluYsmZJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdCYXpfQnpFX8OHQXhfw4fJmXJfQ0F4X0PDvG1fxZ7JmW4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdCel9CRV/Dh0Ffw4fJmV9DQV9Dw7xfxZ7JmScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbYnVnw7xuIHNhYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tzYWJhaCBzYWF0XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW2fJmWzJmW4gaMmZZnTJmV0gZGRkZCBbc2FhdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW2TDvG7JmW5dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdba2XDp8mZbiBoyZlmdMmZXSBkZGRkIFtzYWF0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIHNvbnJhJyxcclxuICAgICAgICBwYXN0IDogJyVzIMmZdnbJmWwnLFxyXG4gICAgICAgIHMgOiAnYmlybmXDp8mZIHNhbml5ecmZJyxcclxuICAgICAgICBtIDogJ2JpciBkyZlxaXHJmScsXHJcbiAgICAgICAgbW0gOiAnJWQgZMmZcWlxyZknLFxyXG4gICAgICAgIGggOiAnYmlyIHNhYXQnLFxyXG4gICAgICAgIGhoIDogJyVkIHNhYXQnLFxyXG4gICAgICAgIGQgOiAnYmlyIGfDvG4nLFxyXG4gICAgICAgIGRkIDogJyVkIGfDvG4nLFxyXG4gICAgICAgIE0gOiAnYmlyIGF5JyxcclxuICAgICAgICBNTSA6ICclZCBheScsXHJcbiAgICAgICAgeSA6ICdiaXIgaWwnLFxyXG4gICAgICAgIHl5IDogJyVkIGlsJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC9nZWPJmXxzyZloyZlyfGfDvG5kw7x6fGF4xZ9hbS8sXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIC9eKGfDvG5kw7x6fGF4xZ9hbSkkLy50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdnZWPJmSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzyZloyZlyJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2fDvG5kw7x6JztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2F4xZ9hbSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0oxLFuY8SxfGluY2l8bmNpfMO8bmPDvHxuY8SxfHVuY3UpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKG51bWJlciA9PT0gMCkgeyAgLy8gc3BlY2lhbCBjYXNlIGZvciB6ZXJvXHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLcSxbmPEsSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIGIgPSBudW1iZXIgJSAxMDAgLSBhLFxyXG4gICAgICAgICAgICBjID0gbnVtYmVyID49IDEwMCA/IDEwMCA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSB8fCBzdWZmaXhlc1tjXSk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGF6O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEJlbGFydXNpYW4gW2JlXVxyXG4vLyEgYXV0aG9yIDogRG1pdHJ5IERlbWlkb3YgOiBodHRwczovL2dpdGh1Yi5jb20vZGVtaWRvdjkxXHJcbi8vISBhdXRob3I6IFByYWxlc2thOiBodHRwOi8vcHJhbGVza2EucHJvL1xyXG4vLyEgQXV0aG9yIDogTWVuZWxpb24gRWxlbnPDumxlIDogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHBsdXJhbCh3b3JkLCBudW0pIHtcclxuICAgIHZhciBmb3JtcyA9IHdvcmQuc3BsaXQoJ18nKTtcclxuICAgIHJldHVybiBudW0gJSAxMCA9PT0gMSAmJiBudW0gJSAxMDAgIT09IDExID8gZm9ybXNbMF0gOiAobnVtICUgMTAgPj0gMiAmJiBudW0gJSAxMCA8PSA0ICYmIChudW0gJSAxMDAgPCAxMCB8fCBudW0gJSAxMDAgPj0gMjApID8gZm9ybXNbMV0gOiBmb3Jtc1syXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAnbW0nOiB3aXRob3V0U3VmZml4ID8gJ9GF0LLRltC70ZbQvdCwX9GF0LLRltC70ZbQvdGLX9GF0LLRltC70ZbQvScgOiAn0YXQstGW0LvRltC90YNf0YXQstGW0LvRltC90Ytf0YXQstGW0LvRltC9JyxcclxuICAgICAgICAnaGgnOiB3aXRob3V0U3VmZml4ID8gJ9Cz0LDQtNC30ZbQvdCwX9Cz0LDQtNC30ZbQvdGLX9Cz0LDQtNC30ZbQvScgOiAn0LPQsNC00LfRltC90YNf0LPQsNC00LfRltC90Ytf0LPQsNC00LfRltC9JyxcclxuICAgICAgICAnZGQnOiAn0LTQt9C10L3RjF/QtNC90ZZf0LTQt9GR0L0nLFxyXG4gICAgICAgICdNTSc6ICfQvNC10YHRj9GGX9C80LXRgdGP0YbRi1/QvNC10YHRj9GG0LDRnicsXHJcbiAgICAgICAgJ3l5JzogJ9Cz0L7QtF/Qs9Cw0LTRi1/Qs9Cw0LTQvtGeJ1xyXG4gICAgfTtcclxuICAgIGlmIChrZXkgPT09ICdtJykge1xyXG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9GF0LLRltC70ZbQvdCwJyA6ICfRhdCy0ZbQu9GW0L3Rgyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdoJykge1xyXG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9Cz0LDQtNC30ZbQvdCwJyA6ICfQs9Cw0LTQt9GW0L3Rgyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgcGx1cmFsKGZvcm1hdFtrZXldLCArbnVtYmVyKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGJlID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYmUnLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgZm9ybWF0OiAn0YHRgtGD0LTQt9C10L3Rj1/Qu9GO0YLQsNCz0LBf0YHQsNC60LDQstGW0LrQsF/QutGA0LDRgdCw0LLRltC60LBf0YLRgNCw0Z7QvdGPX9GH0Y3RgNCy0LXQvdGPX9C70ZbQv9C10L3Rj1/QttC90ZbRntC90Y9f0LLQtdGA0LDRgdC90Y9f0LrQsNGB0YLRgNGL0YfQvdGW0LrQsF/Qu9GW0YHRgtCw0L/QsNC00LBf0YHQvdC10LbQvdGPJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHN0YW5kYWxvbmU6ICfRgdGC0YPQtNC30LXQvdGMX9C70Y7RgtGLX9GB0LDQutCw0LLRltC6X9C60YDQsNGB0LDQstGW0Lpf0YLRgNCw0LLQtdC90Yxf0YfRjdGA0LLQtdC90Yxf0LvRltC/0LXQvdGMX9C20L3RltCy0LXQvdGMX9Cy0LXRgNCw0YHQtdC90Yxf0LrQsNGB0YLRgNGL0YfQvdGW0Lpf0LvRltGB0YLQsNC/0LDQtF/RgdC90LXQttCw0L3RjCcuc3BsaXQoJ18nKVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9GB0YLRg9C0X9C70Y7Rgl/RgdCw0Lpf0LrRgNCw0YFf0YLRgNCw0LJf0YfRjdGA0LJf0LvRltC/X9C20L3RltCyX9Cy0LXRgF/QutCw0YHRgl/Qu9GW0YHRgl/RgdC90LXQticuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDoge1xyXG4gICAgICAgIGZvcm1hdDogJ9C90Y/QtNC30LXQu9GOX9C/0LDQvdGP0LTQt9C10LvQsNC6X9Cw0Z7RgtC+0YDQsNC6X9GB0LXRgNCw0LTRg1/Rh9Cw0YbQstC10YBf0L/Rj9GC0L3RltGG0YNf0YHRg9Cx0L7RgtGDJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHN0YW5kYWxvbmU6ICfQvdGP0LTQt9C10LvRj1/Qv9Cw0L3Rj9C00LfQtdC70LDQul/QsNGe0YLQvtGA0LDQul/RgdC10YDQsNC00LBf0YfQsNGG0LLQtdGAX9C/0Y/RgtC90ZbRhtCwX9GB0YPQsdC+0YLQsCcuc3BsaXQoJ18nKSxcclxuICAgICAgICBpc0Zvcm1hdDogL1xcWyA/W9CS0LJdID8oPzrQvNGW0L3Rg9C70YPRjnzQvdCw0YHRgtGD0L/QvdGD0Y4pPyA/XFxdID9kZGRkL1xyXG4gICAgfSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn0L3QtF/Qv9C9X9Cw0YJf0YHRgF/Rh9GGX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9C90LRf0L/QvV/QsNGCX9GB0YBf0YfRhl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZINCzLicsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINCzLiwgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkg0LMuLCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9Ch0ZHQvdC90Y8g0Z5dIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9CX0LDRntGC0YDQsCDRnl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb0KPRh9C+0YDQsCDRnl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW9CjXSBkZGRkIFvRnl0gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0KMg0LzRltC90YPQu9GD0Y5dIGRkZGQgW9GeXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0KMg0LzRltC90YPQu9GLXSBkZGRkIFvRnl0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfQv9GA0LDQtyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDRgtCw0LzRgycsXHJcbiAgICAgICAgcyA6ICfQvdC10LrQsNC70YzQutGWINGB0LXQutGD0L3QtCcsXHJcbiAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBkIDogJ9C00LfQtdC90YwnLFxyXG4gICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBNIDogJ9C80LXRgdGP0YYnLFxyXG4gICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICB5IDogJ9Cz0L7QtCcsXHJcbiAgICAgICAgeXkgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9C90L7Rh9GLfNGA0LDQvdGW0YbRi3zQtNC90Y980LLQtdGH0LDRgNCwLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9Cw0YDQsCkkLy50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQvdC+0YfRiyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfRgNCw0L3RltGG0YsnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn0LTQvdGPJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9Cy0LXRh9Cw0YDQsCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0ZZ80Yt80LPQsCkvLFxyXG4gICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgY2FzZSAnVyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG51bWJlciAlIDEwID09PSAyIHx8IG51bWJlciAlIDEwID09PSAzKSAmJiAobnVtYmVyICUgMTAwICE9PSAxMiAmJiBudW1iZXIgJSAxMDAgIT09IDEzKSA/IG51bWJlciArICct0ZYnIDogbnVtYmVyICsgJy3Riyc7XHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LPQsCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYmU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQnVsZ2FyaWFuIFtiZ11cclxuLy8hIGF1dGhvciA6IEtyYXNlbiBCb3Jpc292IDogaHR0cHM6Ly9naXRodWIuY29tL2tyYXpcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBiZyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JnJywge1xyXG4gICAgbW9udGhzIDogJ9GP0L3Rg9Cw0YDQuF/RhNC10LLRgNGD0LDRgNC4X9C80LDRgNGCX9Cw0L/RgNC40Ltf0LzQsNC5X9GO0L3QuF/RjtC70Lhf0LDQstCz0YPRgdGCX9GB0LXQv9GC0LXQvNCy0YDQuF/QvtC60YLQvtC80LLRgNC4X9C90L7QtdC80LLRgNC4X9C00LXQutC10LzQstGA0LgnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfRj9C90YBf0YTQtdCyX9C80LDRgF/QsNC/0YBf0LzQsNC5X9GO0L3QuF/RjtC70Lhf0LDQstCzX9GB0LXQv1/QvtC60YJf0L3QvtC1X9C00LXQuicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9C90LXQtNC10LvRj1/Qv9C+0L3QtdC00LXQu9C90LjQul/QstGC0L7RgNC90LjQul/RgdGA0Y/QtNCwX9GH0LXRgtCy0YrRgNGC0YrQul/Qv9C10YLRitC6X9GB0YrQsdC+0YLQsCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn0L3QtdC0X9C/0L7QvV/QstGC0L5f0YHRgNGPX9GH0LXRgl/Qv9C10YJf0YHRitCxJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn0L3QtF/Qv9C9X9Cy0YJf0YHRgF/Rh9GCX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0QuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb0JTQvdC10YEg0LJdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vQo9GC0YDQtSDQsl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW9CyXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb0JLRh9C10YDQsCDQsl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDQuNC30LzQuNC90LDQu9Cw0YLQsF0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDQuNC30LzQuNC90LDQu9C40Y9dIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfRgdC70LXQtCAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfQv9GA0LXQtNC4ICVzJyxcclxuICAgICAgICBzIDogJ9C90Y/QutC+0LvQutC+INGB0LXQutGD0L3QtNC4JyxcclxuICAgICAgICBtIDogJ9C80LjQvdGD0YLQsCcsXHJcbiAgICAgICAgbW0gOiAnJWQg0LzQuNC90YPRgtC4JyxcclxuICAgICAgICBoIDogJ9GH0LDRgScsXHJcbiAgICAgICAgaGggOiAnJWQg0YfQsNGB0LAnLFxyXG4gICAgICAgIGQgOiAn0LTQtdC9JyxcclxuICAgICAgICBkZCA6ICclZCDQtNC90LgnLFxyXG4gICAgICAgIE0gOiAn0LzQtdGB0LXRhicsXHJcbiAgICAgICAgTU0gOiAnJWQg0LzQtdGB0LXRhtCwJyxcclxuICAgICAgICB5IDogJ9Cz0L7QtNC40L3QsCcsXHJcbiAgICAgICAgeXkgOiAnJWQg0LPQvtC00LjQvdC4J1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0LXQsnzQtdC9fNGC0Lh80LLQuHzRgNC4fNC80LgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGxhc3REaWdpdCA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBsYXN0MkRpZ2l0cyA9IG51bWJlciAlIDEwMDtcclxuICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC10LInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdDJEaWdpdHMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQvSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0MkRpZ2l0cyA+IDEwICYmIGxhc3QyRGlnaXRzIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LLQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YDQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDcgfHwgbGFzdERpZ2l0ID09PSA4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC80LgnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGC0LgnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYmc7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQmFtYmFyYSBbYm1dXHJcbi8vISBhdXRob3IgOiBFc3RlbGxlIENvbW1lbnQgOiBodHRwczovL2dpdGh1Yi5jb20vZXN0ZWxsZWNvbW1lbnRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gTGFuZ3VhZ2UgY29udGFjdCBwZXJzb24gOiBBYmRvdWZhdGEgS2FuZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hYmRvdWZhdGFcclxuXHJcbnZhciBibSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JtJywge1xyXG4gICAgbW9udGhzIDogJ1phbnd1eWVrYWxvX0Zld3VydXlla2Fsb19NYXJpc2lrYWxvX0F3aXJpbGlrYWxvX03Jm2thbG9fWnV3yZtua2Fsb19adWx1eWVrYWxvX1V0aWthbG9fU8mbdGFuYnVydWthbG9fyZRrdXTJlGJ1cnVrYWxvX05vd2FuYnVydWthbG9fRGVzYW5idXJ1a2Fsbycuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ1phbl9GZXdfTWFyX0F3aV9NyZtfWnV3X1p1bF9VdGlfU8mbdF/JlGt1X05vd19EZXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdLYXJpX050yZtuyZtuX1RhcmF0YV9BcmFiYV9BbGFtaXNhX0p1bWFfU2liaXJpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdLYXJfTnTJm19UYXJfQXJhX0FsYV9KdW1fU2liJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnS2FfTnRfVGFfQXJfQWxfSnVfU2knLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ01NTU0gW3RpbGVdIEQgW3Nhbl0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ01NTU0gW3RpbGVdIEQgW3Nhbl0gWVlZWSBbbMmbcsmbXSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIE1NTU0gW3RpbGVdIEQgW3Nhbl0gWVlZWSBbbMmbcsmbXSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tCaSBsyZtyyZtdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tTaW5pIGzJm3LJm10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2RvbiBsyZtyyZtdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tLdW51IGzJm3LJm10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW3TJm23Jm25lbiBsyZtyyZtdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMga8mUbsmUJyxcclxuICAgICAgICBwYXN0IDogJ2EgYsmbICVzIGLJlCcsXHJcbiAgICAgICAgcyA6ICdzYW5nYSBkYW1hIGRhbWEnLFxyXG4gICAgICAgIG0gOiAnbWluaXRpIGtlbGVuJyxcclxuICAgICAgICBtbSA6ICdtaW5pdGkgJWQnLFxyXG4gICAgICAgIGggOiAnbMmbcsmbIGtlbGVuJyxcclxuICAgICAgICBoaCA6ICdsyZtyyZsgJWQnLFxyXG4gICAgICAgIGQgOiAndGlsZSBrZWxlbicsXHJcbiAgICAgICAgZGQgOiAndGlsZSAlZCcsXHJcbiAgICAgICAgTSA6ICdrYWxvIGtlbGVuJyxcclxuICAgICAgICBNTSA6ICdrYWxvICVkJyxcclxuICAgICAgICB5IDogJ3NhbiBrZWxlbicsXHJcbiAgICAgICAgeXkgOiAnc2FuICVkJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBibTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm0uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm0uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBCZW5nYWxpIFtibl1cclxuLy8hIGF1dGhvciA6IEthdXNoaWsgR2FuZGhpIDogaHR0cHM6Ly9naXRodWIuY29tL2thdXNoaWtnYW5kaGlcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgp6cnLFxyXG4gICAgJzInOiAn4KeoJyxcclxuICAgICczJzogJ+CnqScsXHJcbiAgICAnNCc6ICfgp6onLFxyXG4gICAgJzUnOiAn4KerJyxcclxuICAgICc2JzogJ+CnrCcsXHJcbiAgICAnNyc6ICfgp60nLFxyXG4gICAgJzgnOiAn4KeuJyxcclxuICAgICc5JzogJ+CnrycsXHJcbiAgICAnMCc6ICfgp6YnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4KenJzogJzEnLFxyXG4gICAgJ+CnqCc6ICcyJyxcclxuICAgICfgp6knOiAnMycsXHJcbiAgICAn4KeqJzogJzQnLFxyXG4gICAgJ+Cnqyc6ICc1JyxcclxuICAgICfgp6wnOiAnNicsXHJcbiAgICAn4KetJzogJzcnLFxyXG4gICAgJ+Cnric6ICc4JyxcclxuICAgICfgp68nOiAnOScsXHJcbiAgICAn4KemJzogJzAnXHJcbn07XHJcblxyXG52YXIgYm4gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdibicsIHtcclxuICAgIG1vbnRocyA6ICfgppzgpr7gpqjgp4Hgp5/gpr7gprDgp4Bf4Kar4KeH4Kas4KeN4Kaw4KeB4Kef4Ka+4Kaw4Ka/X+CmruCmvuCmsOCnjeCmml/gpo/gpqrgp43gprDgpr/gprJf4Kau4KeHX+CmnOCngeCmqF/gppzgp4HgprLgpr7gpodf4KaG4KaX4Ka44KeN4KafX+CmuOCnh+CmquCnjeCmn+Cnh+CmruCnjeCmrOCmsF/gpoXgppXgp43gpp/gp4vgpqzgprBf4Kao4Kat4KeH4Kau4KeN4Kas4KawX+CmoeCmv+CmuOCnh+CmruCnjeCmrOCmsCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+CmnOCmvuCmqOCngV/gpqvgp4fgpqxf4Kau4Ka+4Kaw4KeN4KaaX+Cmj+CmquCnjeCmsF/gpq7gp4df4Kac4KeB4KaoX+CmnOCngeCmsl/gpobgppdf4Ka44KeH4Kaq4KeN4KafX+CmheCmleCnjeCmn+Cni1/gpqjgpq3gp4df4Kah4Ka/4Ka44KeHJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn4Kaw4Kas4Ka/4Kas4Ka+4KawX+CmuOCni+CmruCmrOCmvuCmsF/gpq7gppngp43gppfgprLgpqzgpr7gprBf4Kas4KeB4Kan4Kas4Ka+4KawX+CmrOCng+CmueCmuOCnjeCmquCmpOCmv+CmrOCmvuCmsF/gprbgp4HgppXgp43gprDgpqzgpr7gprBf4Ka24Kao4Ka/4Kas4Ka+4KawJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgprDgpqzgpr9f4Ka44KeL4KauX+CmruCmmeCnjeCml+Cmsl/gpqzgp4Hgpqdf4Kas4KeD4Ka54Ka44KeN4Kaq4Kak4Ka/X+CmtuCngeCmleCnjeCmsF/gprbgpqjgpr8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgprDgpqzgpr9f4Ka44KeL4KauX+CmruCmmeCnjeCml1/gpqzgp4Hgpqdf4Kas4KeD4Ka54KaDX+CmtuCngeCmleCnjeCmsF/gprbgpqjgpr8nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0g4Ka44Kau4KefJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIOCmuOCmruCnnycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0g4Ka44Kau4KefJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0g4Ka44Kau4KefJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+CmhuCmnF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+CmhuCml+CmvuCmruCngOCmleCmvuCmsl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgppfgpqTgppXgpr7gprJdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4KaX4KakXSBkZGRkLCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIOCmquCmsOCnhycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDgpobgppfgp4cnLFxyXG4gICAgICAgIHMgOiAn4KaV4Kef4KeH4KaVIOCmuOCnh+CmleCnh+CmqOCnjeCmoScsXHJcbiAgICAgICAgbSA6ICfgpo/gppUg4Kau4Ka/4Kao4Ka/4KafJyxcclxuICAgICAgICBtbSA6ICclZCDgpq7gpr/gpqjgpr/gpp8nLFxyXG4gICAgICAgIGggOiAn4KaP4KaVIOCmmOCmqOCnjeCmn+CmvicsXHJcbiAgICAgICAgaGggOiAnJWQg4KaY4Kao4KeN4Kaf4Ka+JyxcclxuICAgICAgICBkIDogJ+Cmj+CmlSDgpqbgpr/gpqgnLFxyXG4gICAgICAgIGRkIDogJyVkIOCmpuCmv+CmqCcsXHJcbiAgICAgICAgTSA6ICfgpo/gppUg4Kau4Ka+4Ka4JyxcclxuICAgICAgICBNTSA6ICclZCDgpq7gpr7gprgnLFxyXG4gICAgICAgIHkgOiAn4KaP4KaVIOCmrOCmm+CmsCcsXHJcbiAgICAgICAgeXkgOiAnJWQg4Kas4Kab4KawJ1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4Ken4Keo4Kep4Keq4Ker4Kes4Ket4Keu4Kev4KemXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4Kaw4Ka+4KakfOCmuOCmleCmvuCmsnzgpqbgp4Hgpqrgp4HgprB84Kas4Ka/4KaV4Ka+4KayfOCmsOCmvuCmpC8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgobWVyaWRpZW0gPT09ICfgprDgpr7gpqQnICYmIGhvdXIgPj0gNCkgfHxcclxuICAgICAgICAgICAgICAgIChtZXJpZGllbSA9PT0gJ+CmpuCngeCmquCngeCmsCcgJiYgaG91ciA8IDUpIHx8XHJcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+CmrOCmv+CmleCmvuCmsicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kaw4Ka+4KakJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CmuOCmleCmvuCmsic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpqbgp4Hgpqrgp4HgprAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kas4Ka/4KaV4Ka+4KayJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CmsOCmvuCmpCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBibjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUaWJldGFuIFtib11cclxuLy8hIGF1dGhvciA6IFRodXB0ZW4gTi4gQ2hha3Jpc2hhciA6IGh0dHBzOi8vZ2l0aHViLmNvbS92YWpyYWRvZ1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+C8oScsXHJcbiAgICAnMic6ICfgvKInLFxyXG4gICAgJzMnOiAn4LyjJyxcclxuICAgICc0JzogJ+C8pCcsXHJcbiAgICAnNSc6ICfgvKUnLFxyXG4gICAgJzYnOiAn4LymJyxcclxuICAgICc3JzogJ+C8pycsXHJcbiAgICAnOCc6ICfgvKgnLFxyXG4gICAgJzknOiAn4LypJyxcclxuICAgICcwJzogJ+C8oCdcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfgvKEnOiAnMScsXHJcbiAgICAn4LyiJzogJzInLFxyXG4gICAgJ+C8oyc6ICczJyxcclxuICAgICfgvKQnOiAnNCcsXHJcbiAgICAn4LylJzogJzUnLFxyXG4gICAgJ+C8pic6ICc2JyxcclxuICAgICfgvKcnOiAnNycsXHJcbiAgICAn4LyoJzogJzgnLFxyXG4gICAgJ+C8qSc6ICc5JyxcclxuICAgICfgvKAnOiAnMCdcclxufTtcclxuXHJcbnZhciBibyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JvJywge1xyXG4gICAgbW9udGhzIDogJ+C9n+C+s+C8i+C9luC8i+C9keC9hOC8i+C9lOC9vF/gvZ/gvrPgvIvgvZbgvIvgvYLgvYngvbLgvabgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2C4L2m4L204L2Y4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9nuC9suC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvaPgvpTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2R4L6y4L204L2C4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9keC9tOC9k+C8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvaLgvpLgvrHgvZHgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2R4L2C4L204LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvYLgvYXgvbLgvYLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2C4L2J4L2y4L2m4LyL4L2UJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4L2f4L6z4LyL4L2W4LyL4L2R4L2E4LyL4L2U4L28X+C9n+C+s+C8i+C9luC8i+C9guC9ieC9suC9puC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvYLgvabgvbTgvZjgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2e4L2y4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9o+C+lOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZHgvrLgvbTgvYLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2R4L204L2T4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9ouC+kuC+seC9keC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZHgvYLgvbTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9guC9heC9suC9guC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvYLgvYngvbLgvabgvIvgvZQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfgvYLgvZ/gvaDgvIvgvYngvbLgvIvgvZjgvItf4L2C4L2f4L2g4LyL4L2f4L6z4LyL4L2W4LyLX+C9guC9n+C9oOC8i+C9mOC9suC9guC8i+C9keC9mOC9ouC8i1/gvYLgvZ/gvaDgvIvgvaPgvrfgvYLgvIvgvZTgvItf4L2C4L2f4L2g4LyL4L2V4L204L2i4LyL4L2W4L20X+C9guC9n+C9oOC8i+C9lOC8i+C9puC9hOC9puC8i1/gvYLgvZ/gvaDgvIvgvabgvqTgvbrgvZPgvIvgvZTgvIsnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+C9ieC9suC8i+C9mOC8i1/gvZ/gvrPgvIvgvZbgvItf4L2Y4L2y4L2C4LyL4L2R4L2Y4L2i4LyLX+C9o+C+t+C9guC8i+C9lOC8i1/gvZXgvbTgvaLgvIvgvZbgvbRf4L2U4LyL4L2m4L2E4L2m4LyLX+C9puC+pOC9uuC9k+C8i+C9lOC8iycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+C9ieC9suC8i+C9mOC8i1/gvZ/gvrPgvIvgvZbgvItf4L2Y4L2y4L2C4LyL4L2R4L2Y4L2i4LyLX+C9o+C+t+C9guC8i+C9lOC8i1/gvZXgvbTgvaLgvIvgvZbgvbRf4L2U4LyL4L2m4L2E4L2m4LyLX+C9puC+pOC9uuC9k+C8i+C9lOC8iycuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbScsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgvZHgvbLgvIvgvaLgvbLgvYRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgvabgvYTgvIvgvYngvbLgvZNdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdb4L2W4L2R4L204L2T4LyL4L2V4L6y4L2C4LyL4L2i4L6X4L264L2m4LyL4L2YXSwgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+C9geC8i+C9puC9hF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgvZbgvZHgvbTgvZPgvIvgvZXgvrLgvYLgvIvgvZjgvZDgvaDgvIvgvZhdIGRkZGQsIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg4L2j4LyLJyxcclxuICAgICAgICBwYXN0IDogJyVzIOC9puC+lOC9k+C8i+C9oycsXHJcbiAgICAgICAgcyA6ICfgvaPgvZjgvIvgvabgvYQnLFxyXG4gICAgICAgIG0gOiAn4L2m4L6Q4L2i4LyL4L2Y4LyL4L2C4L2F4L2y4L2CJyxcclxuICAgICAgICBtbSA6ICclZCDgvabgvpDgvaLgvIvgvZgnLFxyXG4gICAgICAgIGggOiAn4L2G4L204LyL4L2a4L284L2R4LyL4L2C4L2F4L2y4L2CJyxcclxuICAgICAgICBoaCA6ICclZCDgvYbgvbTgvIvgvZrgvbzgvZEnLFxyXG4gICAgICAgIGQgOiAn4L2J4L2y4L2T4LyL4L2C4L2F4L2y4L2CJyxcclxuICAgICAgICBkZCA6ICclZCDgvYngvbLgvZPgvIsnLFxyXG4gICAgICAgIE0gOiAn4L2f4L6z4LyL4L2W4LyL4L2C4L2F4L2y4L2CJyxcclxuICAgICAgICBNTSA6ICclZCDgvZ/gvrPgvIvgvZYnLFxyXG4gICAgICAgIHkgOiAn4L2j4L284LyL4L2C4L2F4L2y4L2CJyxcclxuICAgICAgICB5eSA6ICclZCDgvaPgvbwnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgvKHgvKLgvKPgvKTgvKXgvKbgvKfgvKjgvKngvKBdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gvZjgvZrgvZPgvIvgvZjgvbx84L2e4L284L2C4L2m4LyL4L2A4L2mfOC9ieC9suC9k+C8i+C9guC9tOC9hHzgvZHgvYLgvbzgvYTgvIvgvZHgvYJ84L2Y4L2a4L2T4LyL4L2Y4L28LyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChtZXJpZGllbSA9PT0gJ+C9mOC9muC9k+C8i+C9mOC9vCcgJiYgaG91ciA+PSA0KSB8fFxyXG4gICAgICAgICAgICAgICAgKG1lcmlkaWVtID09PSAn4L2J4L2y4L2T4LyL4L2C4L204L2EJyAmJiBob3VyIDwgNSkgfHxcclxuICAgICAgICAgICAgICAgIG1lcmlkaWVtID09PSAn4L2R4L2C4L284L2E4LyL4L2R4L2CJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgvZjgvZrgvZPgvIvgvZjgvbwnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4L2e4L284L2C4L2m4LyL4L2A4L2mJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C9ieC9suC9k+C8i+C9guC9tOC9hCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgvZHgvYLgvbzgvYTgvIvgvZHgvYInO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4L2Y4L2a4L2T4LyL4L2Y4L28JztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGJvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iby5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iby5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEJyZXRvbiBbYnJdXHJcbi8vISBhdXRob3IgOiBKZWFuLUJhcHRpc3RlIExlIER1aWdvdSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYmxlZHVpZ291XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoTXV0YXRpb24obnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ21tJzogJ211bnV0ZW5uJyxcclxuICAgICAgICAnTU0nOiAnbWl6JyxcclxuICAgICAgICAnZGQnOiAnZGV2ZXpoJ1xyXG4gICAgfTtcclxuICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBtdXRhdGlvbihmb3JtYXRba2V5XSwgbnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBzcGVjaWFsTXV0YXRpb25Gb3JZZWFycyhudW1iZXIpIHtcclxuICAgIHN3aXRjaCAobGFzdE51bWJlcihudW1iZXIpKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgYmxvYXonO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnIHZsb2F6JztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBsYXN0TnVtYmVyKG51bWJlcikge1xyXG4gICAgaWYgKG51bWJlciA+IDkpIHtcclxuICAgICAgICByZXR1cm4gbGFzdE51bWJlcihudW1iZXIgJSAxMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtYmVyO1xyXG59XHJcbmZ1bmN0aW9uIG11dGF0aW9uKHRleHQsIG51bWJlcikge1xyXG4gICAgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiBzb2Z0TXV0YXRpb24odGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5mdW5jdGlvbiBzb2Z0TXV0YXRpb24odGV4dCkge1xyXG4gICAgdmFyIG11dGF0aW9uVGFibGUgPSB7XHJcbiAgICAgICAgJ20nOiAndicsXHJcbiAgICAgICAgJ2InOiAndicsXHJcbiAgICAgICAgJ2QnOiAneidcclxuICAgIH07XHJcbiAgICBpZiAobXV0YXRpb25UYWJsZVt0ZXh0LmNoYXJBdCgwKV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0aW9uVGFibGVbdGV4dC5jaGFyQXQoMCldICsgdGV4dC5zdWJzdHJpbmcoMSk7XHJcbn1cclxuXHJcbnZhciBiciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JyJywge1xyXG4gICAgbW9udGhzIDogJ0dlbnZlcl9DXFwnaHdldnJlcl9NZXVyemhfRWJyZWxfTWFlX01lemhldmVuX0dvdWVyZV9Fb3N0X0d3ZW5nb2xvX0hlcmVfRHVfS2VyenUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdHZW5fQ1xcJ2h3ZV9NZXVfRWJyX01hZV9FdmVfR291X0Vvc19Hd2VfSGVyX0R1X0tlcicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1N1bF9MdW5fTWV1cnpoX01lcmNcXCdoZXJfWWFvdV9Hd2VuZXJfU2Fkb3JuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTdWxfTHVuX01ldV9NZXJfWWFvX0d3ZV9TYWQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9MdV9NZV9NZXJfWWFfR3dfU2EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnaFtlXW1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoW2VdbW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIFthIHZpel0gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBbYSB2aXpdIE1NTU0gWVlZWSBoW2VdbW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIFthIHZpel0gTU1NTSBZWVlZIGhbZV1tbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0hpeml2IGRhXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbV2FyY1xcJ2hvYXpoIGRhXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbZGFdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tEZWNcXCdoIGRhXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbcGFzZXQgZGFdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnYS1iZW5uICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIFxcJ3pvJyxcclxuICAgICAgICBzIDogJ3VuIG5lYmV1ZCBzZWdvbmRlbm5vw7knLFxyXG4gICAgICAgIG0gOiAndXIgdnVudXRlbm4nLFxyXG4gICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aE11dGF0aW9uLFxyXG4gICAgICAgIGggOiAndW4gZXVyJyxcclxuICAgICAgICBoaCA6ICclZCBldXInLFxyXG4gICAgICAgIGQgOiAndW4gZGV2ZXpoJyxcclxuICAgICAgICBkZCA6IHJlbGF0aXZlVGltZVdpdGhNdXRhdGlvbixcclxuICAgICAgICBNIDogJ3VyIG1peicsXHJcbiAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoTXV0YXRpb24sXHJcbiAgICAgICAgeSA6ICd1ciBibG9heicsXHJcbiAgICAgICAgeXkgOiBzcGVjaWFsTXV0YXRpb25Gb3JZZWFyc1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShhw7F8dmV0KS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSAobnVtYmVyID09PSAxKSA/ICdhw7EnIDogJ3ZldCc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYnI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQm9zbmlhbiBbYnNdXHJcbi8vISBhdXRob3IgOiBOZWRpbSBDaG9saWNoIDogaHR0cHM6Ly9naXRodWIuY29tL2Zyb250eWFyZFxyXG4vLyEgYmFzZWQgb24gKGhyKSB0cmFuc2xhdGlvbiBieSBCb2phbiBNYXJrb3ZpxIdcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2plZG5hIG1pbnV0YScgOiAnamVkbmUgbWludXRlJztcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRhJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGUnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGEnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2plZGFuIHNhdCcgOiAnamVkbm9nIHNhdGEnO1xyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXQnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdGEnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXRpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ2RkJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdkYW4nO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdkYW5hJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWMnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2EnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWNpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ3l5JzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmEnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluZSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluYSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGJzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYnMnLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFydF9hcHJpbF9tYWpfanVuaV9qdWxpX2F1Z3VzdF9zZXB0ZW1iYXJfb2t0b2Jhcl9ub3ZlbWJhcl9kZWNlbWJhcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbi5fZmViLl9tYXIuX2Fwci5fbWFqLl9qdW4uX2p1bC5fYXVnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ25lZGplbGphX3BvbmVkamVsamFrX3V0b3Jha19zcmlqZWRhX8SNZXR2cnRha19wZXRha19zdWJvdGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ25lZC5fcG9uLl91dG8uX3NyaS5fxI1ldC5fcGV0Ll9zdWIuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnbmVfcG9fdXRfc3JfxI1lX3BlX3N1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgIDogJ1tkYW5hcyB1XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSAgOiAnW3N1dHJhIHVdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGplbGp1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmlqZWR1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWVyIHVdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsdV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Byb8WhbGVdIFtzdWJvdGVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsaV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxyXG4gICAgICAgIHBhc3QgICA6ICdwcmlqZSAlcycsXHJcbiAgICAgICAgcyAgICAgIDogJ3BhciBzZWt1bmRpJyxcclxuICAgICAgICBtICAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGggICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZCAgICAgIDogJ2RhbicsXHJcbiAgICAgICAgZGQgICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gICAgICA6ICdtamVzZWMnLFxyXG4gICAgICAgIE1NICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5ICAgICAgOiAnZ29kaW51JyxcclxuICAgICAgICB5eSAgICAgOiB0cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGJzO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9icy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9icy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IENhdGFsYW4gW2NhXVxyXG4vLyEgYXV0aG9yIDogSnVhbiBHLiBIdXJ0YWRvIDogaHR0cHM6Ly9naXRodWIuY29tL2p1YW5naHVydGFkb1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnY2EnLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ2dlbmVyX2ZlYnJlcl9tYXLDp19hYnJpbF9tYWlnX2p1bnlfanVsaW9sX2Fnb3N0X3NldGVtYnJlX29jdHVicmVfbm92ZW1icmVfZGVzZW1icmUnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgZm9ybWF0OiAnZGUgZ2VuZXJfZGUgZmVicmVyX2RlIG1hcsOnX2RcXCdhYnJpbF9kZSBtYWlnX2RlIGp1bnlfZGUganVsaW9sX2RcXCdhZ29zdF9kZSBzZXRlbWJyZV9kXFwnb2N0dWJyZV9kZSBub3ZlbWJyZV9kZSBkZXNlbWJyZScuc3BsaXQoJ18nKSxcclxuICAgICAgICBpc0Zvcm1hdDogL0Rbb0RdPyhcXHMpK01NTU0vXHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiAnZ2VuLl9mZWJyLl9tYXLDp19hYnIuX21haWdfanVueV9qdWwuX2FnLl9zZXQuX29jdC5fbm92Ll9kZXMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdkaXVtZW5nZV9kaWxsdW5zX2RpbWFydHNfZGltZWNyZXNfZGlqb3VzX2RpdmVuZHJlc19kaXNzYWJ0ZScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZGcuX2RsLl9kdC5fZGMuX2RqLl9kdi5fZHMuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnZGdfZGxfZHRfZGNfZGpfZHZfZHMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFtkZV0gWVlZWScsXHJcbiAgICAgICAgbGwgOiAnRCBNTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBbZGVdIFlZWVkgW2EgbGVzXSBIOm1tJyxcclxuICAgICAgICBsbGwgOiAnRCBNTU0gWVlZWSwgSDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBbZGVdIFlZWVkgW2EgbGVzXSBIOm1tJyxcclxuICAgICAgICBsbGxsIDogJ2RkZCBEIE1NTSBZWVlZLCBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2F2dWkgYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2RlbcOgIGEgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkIFthICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnbGVzJyA6ICdsYScpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbYWhpciBhICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnbGVzJyA6ICdsYScpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2VsXSBkZGRkIFtwYXNzYXQgYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdkXFwnYXF1w60gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnZmEgJXMnLFxyXG4gICAgICAgIHMgOiAndW5zIHNlZ29ucycsXHJcbiAgICAgICAgbSA6ICd1biBtaW51dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRzJyxcclxuICAgICAgICBoIDogJ3VuYSBob3JhJyxcclxuICAgICAgICBoaCA6ICclZCBob3JlcycsXHJcbiAgICAgICAgZCA6ICd1biBkaWEnLFxyXG4gICAgICAgIGRkIDogJyVkIGRpZXMnLFxyXG4gICAgICAgIE0gOiAndW4gbWVzJyxcclxuICAgICAgICBNTSA6ICclZCBtZXNvcycsXHJcbiAgICAgICAgeSA6ICd1biBhbnknLFxyXG4gICAgICAgIHl5IDogJyVkIGFueXMnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHJ8bnx0fMOofGEpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gKG51bWJlciA9PT0gMSkgPyAncicgOlxyXG4gICAgICAgICAgICAobnVtYmVyID09PSAyKSA/ICduJyA6XHJcbiAgICAgICAgICAgIChudW1iZXIgPT09IDMpID8gJ3InIDpcclxuICAgICAgICAgICAgKG51bWJlciA9PT0gNCkgPyAndCcgOiAnw6gnO1xyXG4gICAgICAgIGlmIChwZXJpb2QgPT09ICd3JyB8fCBwZXJpb2QgPT09ICdXJykge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSAnYSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGNhO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEN6ZWNoIFtjc11cclxuLy8hIGF1dGhvciA6IHBldHJiZWxhIDogaHR0cHM6Ly9naXRodWIuY29tL3BldHJiZWxhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzID0gJ2xlZGVuX8O6bm9yX2LFmWV6ZW5fZHViZW5fa3bEm3Rlbl/EjWVydmVuX8SNZXJ2ZW5lY19zcnBlbl96w6HFmcOtX8WZw61qZW5fbGlzdG9wYWRfcHJvc2luZWMnLnNwbGl0KCdfJyk7XHJcbnZhciBtb250aHNTaG9ydCA9ICdsZWRfw7pub19ixZllX2R1Yl9rdsSbX8SNdm5fxI12Y19zcnBfesOhxZlfxZnDrWpfbGlzX3Bybycuc3BsaXQoJ18nKTtcclxuZnVuY3Rpb24gcGx1cmFsKG4pIHtcclxuICAgIHJldHVybiAobiA+IDEpICYmIChuIDwgNSkgJiYgKH5+KG4gLyAxMCkgIT09IDEpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ3MnOiAgLy8gYSBmZXcgc2Vjb25kcyAvIGluIGEgZmV3IHNlY29uZHMgLyBhIGZldyBzZWNvbmRzIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3DDoXIgc2VrdW5kJyA6ICdww6FyIHNla3VuZGFtaSc7XHJcbiAgICAgICAgY2FzZSAnbSc6ICAvLyBhIG1pbnV0ZSAvIGluIGEgbWludXRlIC8gYSBtaW51dGUgYWdvXHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ21pbnV0YScgOiAoaXNGdXR1cmUgPyAnbWludXR1JyA6ICdtaW51dG91Jyk7XHJcbiAgICAgICAgY2FzZSAnbW0nOiAvLyA5IG1pbnV0ZXMgLyBpbiA5IG1pbnV0ZXMgLyA5IG1pbnV0ZXMgYWdvXHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pbnV0eScgOiAnbWludXQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbWludXRhbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2gnOiAgLy8gYW4gaG91ciAvIGluIGFuIGhvdXIgLyBhbiBob3VyIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdob2RpbmEnIDogKGlzRnV0dXJlID8gJ2hvZGludScgOiAnaG9kaW5vdScpO1xyXG4gICAgICAgIGNhc2UgJ2hoJzogLy8gOSBob3VycyAvIGluIDkgaG91cnMgLyA5IGhvdXJzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdob2RpbnknIDogJ2hvZGluJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2hvZGluYW1pJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkJzogIC8vIGEgZGF5IC8gaW4gYSBkYXkgLyBhIGRheSBhZ29cclxuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdkZW4nIDogJ2RuZW0nO1xyXG4gICAgICAgIGNhc2UgJ2RkJzogLy8gOSBkYXlzIC8gaW4gOSBkYXlzIC8gOSBkYXlzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdkbnknIDogJ2Ruw60nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZG55JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdNJzogIC8vIGEgbW9udGggLyBpbiBhIG1vbnRoIC8gYSBtb250aCBhZ29cclxuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdtxJtzw61jJyA6ICdtxJtzw61jZW0nO1xyXG4gICAgICAgIGNhc2UgJ01NJzogLy8gOSBtb250aHMgLyBpbiA5IG1vbnRocyAvIDkgbW9udGhzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtxJtzw61jZScgOiAnbcSbc8OtY8WvJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ23Em3PDrWNpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd5JzogIC8vIGEgeWVhciAvIGluIGEgeWVhciAvIGEgeWVhciBhZ29cclxuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdyb2snIDogJ3Jva2VtJztcclxuICAgICAgICBjYXNlICd5eSc6IC8vIDkgeWVhcnMgLyBpbiA5IHllYXJzIC8gOSB5ZWFycyBhZ29cclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAncm9reScgOiAnbGV0Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2xldHknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgY3MgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdjcycsIHtcclxuICAgIG1vbnRocyA6IG1vbnRocyxcclxuICAgIG1vbnRoc1Nob3J0IDogbW9udGhzU2hvcnQsXHJcbiAgICBtb250aHNQYXJzZSA6IChmdW5jdGlvbiAobW9udGhzLCBtb250aHNTaG9ydCkge1xyXG4gICAgICAgIHZhciBpLCBfbW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB1c2UgY3VzdG9tIHBhcnNlciB0byBzb2x2ZSBwcm9ibGVtIHdpdGggSnVseSAoxI1lcnZlbmVjKVxyXG4gICAgICAgICAgICBfbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIG1vbnRoc1tpXSArICckfF4nICsgbW9udGhzU2hvcnRbaV0gKyAnJCcsICdpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfbW9udGhzUGFyc2U7XHJcbiAgICB9KG1vbnRocywgbW9udGhzU2hvcnQpKSxcclxuICAgIHNob3J0TW9udGhzUGFyc2UgOiAoZnVuY3Rpb24gKG1vbnRoc1Nob3J0KSB7XHJcbiAgICAgICAgdmFyIGksIF9zaG9ydE1vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIG1vbnRoc1Nob3J0W2ldICsgJyQnLCAnaScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3Nob3J0TW9udGhzUGFyc2U7XHJcbiAgICB9KG1vbnRoc1Nob3J0KSksXHJcbiAgICBsb25nTW9udGhzUGFyc2UgOiAoZnVuY3Rpb24gKG1vbnRocykge1xyXG4gICAgICAgIHZhciBpLCBfbG9uZ01vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgbW9udGhzW2ldICsgJyQnLCAnaScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2xvbmdNb250aHNQYXJzZTtcclxuICAgIH0obW9udGhzKSksXHJcbiAgICB3ZWVrZGF5cyA6ICduZWTEm2xlX3BvbmTEm2zDrV/DunRlcsO9X3N0xZllZGFfxI10dnJ0ZWtfcMOhdGVrX3NvYm90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVfcG9fw7p0X3N0X8SNdF9ww6Ffc28nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICduZV9wb1/DunRfc3RfxI10X3DDoV9zbycuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgbCA6ICdELiBNLiBZWVlZJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbZG5lcyB2XSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1t6w610cmEgdl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3YgbmVkxJtsaSB2XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gZGRkZCBbdl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZlIHN0xZllZHUgdl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZlIMSNdHZydGVrIHZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2IHDDoXRlayB2XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBzb2JvdHUgdl0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5OiAnW3bEjWVyYSB2XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWxvdSBuZWTEm2xpIHZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMOpXSBkZGRkIFt2XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWxvdSBzdMWZZWR1IHZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFt2XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWxvdSBzb2JvdHUgdl0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdwxZllZCAlcycsXHJcbiAgICAgICAgcyA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG1tIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGggOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaGggOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE1NIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeXkgOiB0cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBjcztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3MuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3MuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBDaHV2YXNoIFtjdl1cclxuLy8hIGF1dGhvciA6IEFuYXRvbHkgTWlyb25vdiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taXJvbnRvbGlcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBjdiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2N2Jywge1xyXG4gICAgbW9udGhzIDogJ9C605HRgNC70LDRh1/QvdCw0YDTkdGBX9C/0YPRiF/QsNC60LBf0LzQsNC5X9Kr05fRgNGC0LzQtV/Rg9GC05Ff0qvRg9GA0LvQsF/QsNCy05HQvV/RjtC/0LBf0YfTs9C6X9GA0LDRiNGC0LDQsicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9C605HRgF/QvdCw0YBf0L/Rg9GIX9Cw0LrQsF/QvNCw0Llf0qvTl9GAX9GD0YLTkV/Sq9GD0YBf0LDQstC9X9GO0L/QsF/Rh9Oz0Lpf0YDQsNGIJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn0LLRi9GA0YHQsNGA0L3QuNC60YPQvV/RgtGD0L3RgtC40LrRg9C9X9GL0YLQu9Cw0YDQuNC60YPQvV/RjtC90LrRg9C9X9C605fSq9C90LXRgNC90LjQutGD0L1f0Y3RgNC90LXQutGD0L1f0YjTkdC80LDRgtC60YPQvScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn0LLRi9GAX9GC0YPQvV/Ri9GC0Ltf0Y7QvV/QutOX0qtf0Y3RgNC9X9GI05HQvCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9Cy0YBf0YLQvV/Ri9GCX9GO0L1f0LrSq1/RjdGAX9GI0LwnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELU1NLVlZWVknLFxyXG4gICAgICAgIExMIDogJ1lZWVkgW9Kr0YPQu9GF0LhdIE1NTU0gW9GD0LnTkdGF05fQvV0gRFst0LzTl9GI05ddJyxcclxuICAgICAgICBMTEwgOiAnWVlZWSBb0qvRg9C70YXQuF0gTU1NTSBb0YPQudOR0YXTl9C9XSBEWy3QvNOX0YjTl10sIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIFlZWVkgW9Kr0YPQu9GF0LhdIE1NTU0gW9GD0LnTkdGF05fQvV0gRFst0LzTl9GI05ddLCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9Cf0LDRj9C9XSBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9Cr0YDQsNC9XSBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9OW0L3QtdGAXSBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcclxuICAgICAgICBuZXh0V2VlazogJ1vSqtC40YLQtdGBXSBkZGRkIExUIFvRgdC10YXQtdGC0YDQtV0nLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW9CY0YDRgtC905ddIGRkZGQgTFQgW9GB0LXRhdC10YLRgNC1XScsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBhZmZpeCA9IC/RgdC10YXQtdGCJC9pLmV4ZWMob3V0cHV0KSA/ICfRgNC10L0nIDogL9Kr0YPQuyQvaS5leGVjKG91dHB1dCkgPyAn0YLQsNC9JyA6ICfRgNCw0L0nO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0ICsgYWZmaXg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXN0IDogJyVzINC60LDRj9C70LvQsCcsXHJcbiAgICAgICAgcyA6ICfQv9OX0YAt0LjQuiDSq9C10LrQutGD0L3RgicsXHJcbiAgICAgICAgbSA6ICfQv9OX0YAg0LzQuNC90YPRgicsXHJcbiAgICAgICAgbW0gOiAnJWQg0LzQuNC90YPRgicsXHJcbiAgICAgICAgaCA6ICfQv9OX0YAg0YHQtdGF0LXRgicsXHJcbiAgICAgICAgaGggOiAnJWQg0YHQtdGF0LXRgicsXHJcbiAgICAgICAgZCA6ICfQv9OX0YAg0LrRg9C9JyxcclxuICAgICAgICBkZCA6ICclZCDQutGD0L0nLFxyXG4gICAgICAgIE0gOiAn0L/Tl9GAINGD0LnTkdGFJyxcclxuICAgICAgICBNTSA6ICclZCDRg9C505HRhScsXHJcbiAgICAgICAgeSA6ICfQv9OX0YAg0qvRg9C7JyxcclxuICAgICAgICB5eSA6ICclZCDSq9GD0LsnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LdC805fRiC8sXHJcbiAgICBvcmRpbmFsIDogJyVkLdC805fRiCcsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gY3Y7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogV2Vsc2ggW2N5XVxyXG4vLyEgYXV0aG9yIDogUm9iZXJ0IEFsbGVuIDogaHR0cHM6Ly9naXRodWIuY29tL3JvYmdhbGxlblxyXG4vLyEgYXV0aG9yIDogaHR0cHM6Ly9naXRodWIuY29tL3J5YW5ncmVhdmVzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgY3kgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdjeScsIHtcclxuICAgIG1vbnRoczogJ0lvbmF3cl9DaHdlZnJvcl9NYXdydGhfRWJyaWxsX01haV9NZWhlZmluX0dvcmZmZW5uYWZfQXdzdF9NZWRpX0h5ZHJlZl9UYWNod2VkZF9SaGFnZnlyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICdJb25fQ2h3ZV9NYXdfRWJyX01haV9NZWhfR29yX0F3c19NZWRfSHlkX1RhY2hfUmhhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzOiAnRHlkZCBTdWxfRHlkZCBMbHVuX0R5ZGQgTWF3cnRoX0R5ZGQgTWVyY2hlcl9EeWRkIElhdV9EeWRkIEd3ZW5lcl9EeWRkIFNhZHdybicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICdTdWxfTGx1bl9NYXdfTWVyX0lhdV9Hd2VfU2FkJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW46ICdTdV9MbF9NYV9NZV9JYV9Hd19TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICAvLyB0aW1lIGZvcm1hdHMgYXJlIHRoZSBzYW1lIGFzIGVuLWdiXHJcbiAgICBsb25nRGF0ZUZvcm1hdDoge1xyXG4gICAgICAgIExUOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXI6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0hlZGRpdyBhbV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbWWZvcnkgYW1dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2FtXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tEZG9lIGFtXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFtkaXdldGhhZiBhbV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWU6IHtcclxuICAgICAgICBmdXR1cmU6ICdtZXduICVzJyxcclxuICAgICAgICBwYXN0OiAnJXMgeW4gw7RsJyxcclxuICAgICAgICBzOiAneWNoeWRpZyBlaWxpYWRhdScsXHJcbiAgICAgICAgbTogJ211bnVkJyxcclxuICAgICAgICBtbTogJyVkIG11bnVkJyxcclxuICAgICAgICBoOiAnYXdyJyxcclxuICAgICAgICBoaDogJyVkIGF3cicsXHJcbiAgICAgICAgZDogJ2Rpd3Jub2QnLFxyXG4gICAgICAgIGRkOiAnJWQgZGl3cm5vZCcsXHJcbiAgICAgICAgTTogJ21pcycsXHJcbiAgICAgICAgTU06ICclZCBtaXMnLFxyXG4gICAgICAgIHk6ICdibHd5ZGR5bicsXHJcbiAgICAgICAgeXk6ICclZCBmbHluZWRkJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShmZWR8YWlufGFmfGlsfHlkZHxlZHxlZykvLFxyXG4gICAgLy8gdHJhZGl0aW9uYWwgb3JkaW5hbCBudW1iZXJzIGFib3ZlIDMxIGFyZSBub3QgY29tbW9ubHkgdXNlZCBpbiBjb2xsb3F1aWFsIFdlbHNoXHJcbiAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIsXHJcbiAgICAgICAgICAgIG91dHB1dCA9ICcnLFxyXG4gICAgICAgICAgICBsb29rdXAgPSBbXHJcbiAgICAgICAgICAgICAgICAnJywgJ2FmJywgJ2lsJywgJ3lkZCcsICd5ZGQnLCAnZWQnLCAnZWQnLCAnZWQnLCAnZmVkJywgJ2ZlZCcsICdmZWQnLCAvLyAxYWYgdG8gMTBmZWRcclxuICAgICAgICAgICAgICAgICdlZycsICdmZWQnLCAnZWcnLCAnZWcnLCAnZmVkJywgJ2VnJywgJ2VnJywgJ2ZlZCcsICdlZycsICdmZWQnIC8vIDExZWcgdG8gMjBmZWRcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICBpZiAoYiA+IDIwKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSA0MCB8fCBiID09PSA1MCB8fCBiID09PSA2MCB8fCBiID09PSA4MCB8fCBiID09PSAxMDApIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICdmZWQnOyAvLyBub3QgMzBhaW4sIDcwYWluIG9yIDkwYWluXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAnYWluJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA+IDApIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gbG9va3VwW2JdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBjeTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3kuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3kuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBEYW5pc2ggW2RhXVxyXG4vLyEgYXV0aG9yIDogVWxyaWsgTmllbHNlbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmJhc2VcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBkYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RhJywge1xyXG4gICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnRzX2FwcmlsX21hal9qdW5pX2p1bGlfYXVndXN0X3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdzw7huZGFnX21hbmRhZ190aXJzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7hyZGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdzw7huX21hbl90aXJfb25zX3Rvcl9mcmVfbMO4cicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3PDuF9tYV90aV9vbl90b19mcl9sw7gnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIFtkLl0gRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW2kgZGFnIGtsLl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW2kgbW9yZ2VuIGtsLl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ3DDpSBkZGRkIFtrbC5dIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tpIGfDpXIga2wuXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW2ldIGRkZGRbcyBrbC5dIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb20gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgc2lkZW4nLFxyXG4gICAgICAgIHMgOiAnZsOlIHNla3VuZGVyJyxcclxuICAgICAgICBtIDogJ2V0IG1pbnV0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dHRlcicsXHJcbiAgICAgICAgaCA6ICdlbiB0aW1lJyxcclxuICAgICAgICBoaCA6ICclZCB0aW1lcicsXHJcbiAgICAgICAgZCA6ICdlbiBkYWcnLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2UnLFxyXG4gICAgICAgIE0gOiAnZW4gbcOlbmVkJyxcclxuICAgICAgICBNTSA6ICclZCBtw6VuZWRlcicsXHJcbiAgICAgICAgeSA6ICdldCDDpXInLFxyXG4gICAgICAgIHl5IDogJyVkIMOlcidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGRhO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEdlcm1hbiAoQXVzdHJpYSkgW2RlLWF0XVxyXG4vLyEgYXV0aG9yIDogbGx1Y2hzIDogaHR0cHM6Ly9naXRodWIuY29tL2xsdWNoc1xyXG4vLyEgYXV0aG9yOiBNZW5lbGlvbiBFbGVuc8O6bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9PaXJlXHJcbi8vISBhdXRob3IgOiBNYXJ0aW4gR3JvbGxlciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYWRNR1xyXG4vLyEgYXV0aG9yIDogTWlrb2xhaiBEYWRlbGEgOiBodHRwczovL2dpdGh1Yi5jb20vbWlrMDFhalxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ20nOiBbJ2VpbmUgTWludXRlJywgJ2VpbmVyIE1pbnV0ZSddLFxyXG4gICAgICAgICdoJzogWydlaW5lIFN0dW5kZScsICdlaW5lciBTdHVuZGUnXSxcclxuICAgICAgICAnZCc6IFsnZWluIFRhZycsICdlaW5lbSBUYWcnXSxcclxuICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBUYWdlJywgbnVtYmVyICsgJyBUYWdlbiddLFxyXG4gICAgICAgICdNJzogWydlaW4gTW9uYXQnLCAnZWluZW0gTW9uYXQnXSxcclxuICAgICAgICAnTU0nOiBbbnVtYmVyICsgJyBNb25hdGUnLCBudW1iZXIgKyAnIE1vbmF0ZW4nXSxcclxuICAgICAgICAneSc6IFsnZWluIEphaHInLCAnZWluZW0gSmFociddLFxyXG4gICAgICAgICd5eSc6IFtudW1iZXIgKyAnIEphaHJlJywgbnVtYmVyICsgJyBKYWhyZW4nXVxyXG4gICAgfTtcclxuICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcclxufVxyXG5cclxudmFyIGRlQXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdkZS1hdCcsIHtcclxuICAgIG1vbnRocyA6ICdKw6RubmVyX0ZlYnJ1YXJfTcOkcnpfQXByaWxfTWFpX0p1bmlfSnVsaV9BdWd1c3RfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGV6ZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKw6RuLl9GZWIuX03DpHJ6X0Fwci5fTWFpX0p1bmlfSnVsaV9BdWcuX1NlcC5fT2t0Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ1Nvbm50YWdfTW9udGFnX0RpZW5zdGFnX01pdHR3b2NoX0Rvbm5lcnN0YWdfRnJlaXRhZ19TYW1zdGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTby5fTW8uX0RpLl9NaS5fRG8uX0ZyLl9TYS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTb19Nb19EaV9NaV9Eb19Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVDogJ0hIOm1tJyxcclxuICAgICAgICBMVFM6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbaGV1dGUgdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxyXG4gICAgICAgIG5leHREYXk6ICdbbW9yZ2VuIHVtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIGxhc3REYXk6ICdbZ2VzdGVybiB1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW2xldHp0ZW5dIGRkZGQgW3VtXSBMVCBbVWhyXSdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJ3ZvciAlcycsXHJcbiAgICAgICAgcyA6ICdlaW4gcGFhciBTZWt1bmRlbicsXHJcbiAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXHJcbiAgICAgICAgaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaGggOiAnJWQgU3R1bmRlbicsXHJcbiAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5eSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGRlQXQ7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWF0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWF0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogR2VybWFuIChTd2l0emVybGFuZCkgW2RlLWNoXVxyXG4vLyEgYXV0aG9yIDogc3NjaHVlbGxlciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zc2NodWVsbGVyXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG4vLyBiYXNlZCBvbjogaHR0cHM6Ly93d3cuYmsuYWRtaW4uY2gvZG9rdW1lbnRhdGlvbi9zcHJhY2hlbi8wNDkxNS8wNTAxNi9pbmRleC5odG1sP2xhbmc9ZGUjXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAnbSc6IFsnZWluZSBNaW51dGUnLCAnZWluZXIgTWludXRlJ10sXHJcbiAgICAgICAgJ2gnOiBbJ2VpbmUgU3R1bmRlJywgJ2VpbmVyIFN0dW5kZSddLFxyXG4gICAgICAgICdkJzogWydlaW4gVGFnJywgJ2VpbmVtIFRhZyddLFxyXG4gICAgICAgICdkZCc6IFtudW1iZXIgKyAnIFRhZ2UnLCBudW1iZXIgKyAnIFRhZ2VuJ10sXHJcbiAgICAgICAgJ00nOiBbJ2VpbiBNb25hdCcsICdlaW5lbSBNb25hdCddLFxyXG4gICAgICAgICdNTSc6IFtudW1iZXIgKyAnIE1vbmF0ZScsIG51bWJlciArICcgTW9uYXRlbiddLFxyXG4gICAgICAgICd5JzogWydlaW4gSmFocicsICdlaW5lbSBKYWhyJ10sXHJcbiAgICAgICAgJ3l5JzogW251bWJlciArICcgSmFocmUnLCBudW1iZXIgKyAnIEphaHJlbiddXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xyXG59XHJcblxyXG52YXIgZGVDaCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RlLWNoJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcl9GZWJydWFyX03DpHJ6X0FwcmlsX01haV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuLl9GZWIuX03DpHJ6X0Fwci5fTWFpX0p1bmlfSnVsaV9BdWcuX1NlcC5fT2t0Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ1Nvbm50YWdfTW9udGFnX0RpZW5zdGFnX01pdHR3b2NoX0Rvbm5lcnN0YWdfRnJlaXRhZ19TYW1zdGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTb19Nb19EaV9NaV9Eb19Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUOiAnSEgubW0nLFxyXG4gICAgICAgIExUUzogJ0hILm1tLnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBISC5tbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBELiBNTU1NIFlZWVkgSEgubW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1toZXV0ZSB1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXHJcbiAgICAgICAgbmV4dERheTogJ1ttb3JnZW4gdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3VtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgbGFzdERheTogJ1tnZXN0ZXJuIHVtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbbGV0enRlbl0gZGRkZCBbdW1dIExUIFtVaHJdJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAndm9yICVzJyxcclxuICAgICAgICBzIDogJ2VpbiBwYWFyIFNla3VuZGVuJyxcclxuICAgICAgICBtIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtbSA6ICclZCBNaW51dGVuJyxcclxuICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoaCA6ICclZCBTdHVuZGVuJyxcclxuICAgICAgICBkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTU0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHl5IDogcHJvY2Vzc1JlbGF0aXZlVGltZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZGVDaDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtY2guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtY2guanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBHZXJtYW4gW2RlXVxyXG4vLyEgYXV0aG9yIDogbGx1Y2hzIDogaHR0cHM6Ly9naXRodWIuY29tL2xsdWNoc1xyXG4vLyEgYXV0aG9yOiBNZW5lbGlvbiBFbGVuc8O6bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9PaXJlXHJcbi8vISBhdXRob3IgOiBNaWtvbGFqIERhZGVsYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWswMWFqXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAnbSc6IFsnZWluZSBNaW51dGUnLCAnZWluZXIgTWludXRlJ10sXHJcbiAgICAgICAgJ2gnOiBbJ2VpbmUgU3R1bmRlJywgJ2VpbmVyIFN0dW5kZSddLFxyXG4gICAgICAgICdkJzogWydlaW4gVGFnJywgJ2VpbmVtIFRhZyddLFxyXG4gICAgICAgICdkZCc6IFtudW1iZXIgKyAnIFRhZ2UnLCBudW1iZXIgKyAnIFRhZ2VuJ10sXHJcbiAgICAgICAgJ00nOiBbJ2VpbiBNb25hdCcsICdlaW5lbSBNb25hdCddLFxyXG4gICAgICAgICdNTSc6IFtudW1iZXIgKyAnIE1vbmF0ZScsIG51bWJlciArICcgTW9uYXRlbiddLFxyXG4gICAgICAgICd5JzogWydlaW4gSmFocicsICdlaW5lbSBKYWhyJ10sXHJcbiAgICAgICAgJ3l5JzogW251bWJlciArICcgSmFocmUnLCBudW1iZXIgKyAnIEphaHJlbiddXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xyXG59XHJcblxyXG52YXIgZGUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdkZScsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJfRmVicnVhcl9Nw6Ryel9BcHJpbF9NYWlfSnVuaV9KdWxpX0F1Z3VzdF9TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXplbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbi5fRmViLl9Nw6Ryel9BcHIuX01haV9KdW5pX0p1bGlfQXVnLl9TZXAuX09rdC5fTm92Ll9EZXouJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdTb25udGFnX01vbnRhZ19EaWVuc3RhZ19NaXR0d29jaF9Eb25uZXJzdGFnX0ZyZWl0YWdfU2Ftc3RhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU28uX01vLl9EaS5fTWkuX0RvLl9Gci5fU2EuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU29fTW9fRGlfTWlfRG9fRnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQ6ICdISDptbScsXHJcbiAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW2hldXRlIHVtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJyxcclxuICAgICAgICBuZXh0RGF5OiAnW21vcmdlbiB1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBsYXN0RGF5OiAnW2dlc3Rlcm4gdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBsYXN0V2VlazogJ1tsZXR6dGVuXSBkZGRkIFt1bV0gTFQgW1Vocl0nXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICd2b3IgJXMnLFxyXG4gICAgICAgIHMgOiAnZWluIHBhYXIgU2VrdW5kZW4nLFxyXG4gICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG1tIDogJyVkIE1pbnV0ZW4nLFxyXG4gICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGhoIDogJyVkIFN0dW5kZW4nLFxyXG4gICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGRkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBkZTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNYWxkaXZpYW4gW2R2XVxyXG4vLyEgYXV0aG9yIDogSmF3aXNoIEhhbWVlZCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXdpc2hcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHMgPSBbXHJcbiAgICAn3pberN6C3qreh96m3oPeqScsXHJcbiAgICAn3orerN6E3rDeg96q3ofept6D3qknLFxyXG4gICAgJ96J3qfeg96o3pfeqicsXHJcbiAgICAn3oferd6V3rDeg96p3o3eqicsXHJcbiAgICAn3onerScsXHJcbiAgICAn3pbeq96C3rAnLFxyXG4gICAgJ96W3qrejd6m3ofeqCcsXHJcbiAgICAn3ofer96O3qbekN6w3pPeqicsXHJcbiAgICAn3pDerN6V3rDek96s3onesN6E3qbeg96qJyxcclxuICAgICfeh96u3obesN6T3q/ehN6m3oPeqicsXHJcbiAgICAn3oLert6I3qzeid6w3oTept6D3qonLFxyXG4gICAgJ96R3qjekN6s3onesN6E3qbeg96qJ1xyXG5dO1xyXG52YXIgd2Vla2RheXMgPSBbXHJcbiAgICAn3ofep96L3qjeh96w3ozepicsXHJcbiAgICAn3oDer96J3qYnLFxyXG4gICAgJ96H3qbegt6w3o7ep96D3qYnLFxyXG4gICAgJ96E3qrei96mJyxcclxuICAgICfehN6q3oPep96Q3rDeit6m3ozeqCcsXHJcbiAgICAn3oDeqt6G3qreg96qJyxcclxuICAgICfegN6u3oLeqN6A3qjeg96qJ1xyXG5dO1xyXG5cclxudmFyIGR2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZHYnLCB7XHJcbiAgICBtb250aHMgOiBtb250aHMsXHJcbiAgICBtb250aHNTaG9ydCA6IG1vbnRocyxcclxuICAgIHdlZWtkYXlzIDogd2Vla2RheXMsXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogd2Vla2RheXMsXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfeh96n3oveqF/egN6v3onepl/eh96m3oLesF/ehN6q3ovepl/ehN6q3oPep1/egN6q3obeql/egN6u3oLeqCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG5cclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0QvTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL96J3oZ83oneii8sXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICfeid6KJyA9PT0gaW5wdXQ7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ96J3oYnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn3oneiic7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW96J3qjeh96m3oveql0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW96J3qfei96m3onep10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW96H3qjeh96w3pTerF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1veit6n3ofeqN6M3qreiN6oXSBkZGRkIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn3ozerN6D3q3ejt6m3ofeqCAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfeht6q3oPeqN6C3rAgJXMnLFxyXG4gICAgICAgIHMgOiAn3pDeqN6G3qregt6w3ozeqt6G3q7ehd6s3ofesCcsXHJcbiAgICAgICAgbSA6ICfeid6o3oLeqN6T3qzeh96wJyxcclxuICAgICAgICBtbSA6ICfeid6o3oLeqN6T3qogJWQnLFxyXG4gICAgICAgIGggOiAn3o7ept6R3qjeh96o3oPerN6H3rAnLFxyXG4gICAgICAgIGhoIDogJ96O3qbekd6o3ofeqN6D3qogJWQnLFxyXG4gICAgICAgIGQgOiAn3oveqt6I3qbegN6s3ofesCcsXHJcbiAgICAgICAgZGQgOiAn3oveqt6I3qbekN6wICVkJyxcclxuICAgICAgICBNIDogJ96J3qbegN6s3ofesCcsXHJcbiAgICAgICAgTU0gOiAn3onept6Q3rAgJWQnLFxyXG4gICAgICAgIHkgOiAn3ofept6A3qbeg96s3ofesCcsXHJcbiAgICAgICAgeXkgOiAn3ofept6A3qbeg96qICVkJ1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC/YjC9nLCAnLCcpO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLywvZywgJ9iMJyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiA3LCAgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZHY7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2R2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2R2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogR3JlZWsgW2VsXVxyXG4vLyEgYXV0aG9yIDogQWdnZWxvcyBLYXJhbGlhcyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWhpZWxcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcclxufVxyXG5cclxuXHJcbnZhciBlbCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VsJywge1xyXG4gICAgbW9udGhzTm9taW5hdGl2ZUVsIDogJ86ZzrHOvc6/z4XOrM+BzrnOv8+CX86mzrXOss+Bzr/Phc6sz4HOuc6/z4JfzpzOrM+Bz4TOuc6/z4JfzpHPgM+Bzq/Ou865zr/Pgl/OnM6szrnOv8+CX86Zzr/Pjc69zrnOv8+CX86Zzr/Pjc67zrnOv8+CX86Rz43Os86/z4XPg8+Ezr/Pgl/Oo861z4DPhM6tzrzOss+BzrnOv8+CX86fzrrPhM+OzrLPgc65zr/Pgl/Onc6/zq3OvM6yz4HOuc6/z4JfzpTOtc66zq3OvM6yz4HOuc6/z4InLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNHZW5pdGl2ZUVsIDogJ86ZzrHOvc6/z4XOsc+Bzq/Ov8+FX86mzrXOss+Bzr/Phc6xz4HOr86/z4VfzpzOsc+Bz4TOr86/z4VfzpHPgM+BzrnOu86vzr/PhV/OnM6xzpDOv8+FX86Zzr/Phc69zq/Ov8+FX86Zzr/Phc67zq/Ov8+FX86Rz4XOs86/z43Pg8+Ezr/PhV/Oo861z4DPhM61zrzOss+Bzq/Ov8+FX86fzrrPhM+JzrLPgc6vzr/PhV/Onc6/zrXOvM6yz4HOr86/z4VfzpTOtc66zrXOvM6yz4HOr86/z4UnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHMgOiBmdW5jdGlvbiAobW9tZW50VG9Gb3JtYXQsIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbW9tZW50VG9Gb3JtYXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc05vbWluYXRpdmVFbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnICYmIC9ELy50ZXN0KGZvcm1hdC5zdWJzdHJpbmcoMCwgZm9ybWF0LmluZGV4T2YoJ01NTU0nKSkpKSB7IC8vIGlmIHRoZXJlIGlzIGEgZGF5IG51bWJlciBiZWZvcmUgJ01NTU0nXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNHZW5pdGl2ZUVsW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNOb21pbmF0aXZlRWxbbW9tZW50VG9Gb3JtYXQubW9udGgoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ86ZzrHOvV/Ops61zrJfzpzOsc+BX86Rz4DPgV/OnM6xz4pfzpnOv8+Fzr1fzpnOv8+FzrtfzpHPhc6zX86jzrXPgF/On866z4Rfzp3Ov861X86UzrXOuicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ86az4XPgc65zrHOus6uX86UzrXPhc+Ezq3Pgc6xX86kz4HOr8+EzrdfzqTOtc+EzqzPgc+EzrdfzqDOrc68z4DPhM63X86gzrHPgc6xz4POus61z4XOrl/Oo86szrLOss6xz4TOvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnzprPhc+BX86UzrXPhV/OpM+BzrlfzqTOtc+EX86gzrXOvF/OoM6xz4FfzqPOsc6yJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnzprPhV/OlM61X86kz4FfzqTOtV/OoM61X86gzrFfzqPOsScuc3BsaXQoJ18nKSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnzrzOvCcgOiAnzpzOnCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnz4DOvCcgOiAnzqDOnCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpWzBdID09PSAnzrwnKTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlIDogL1vOoM6cXVxcLj/OnD9cXC4/L2ksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyRWwgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbzqPOrs68zrXPgc6xIHt9XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbzpHPjc+BzrnOvyB7fV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3t9XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbzqfOuM61z4Ige31dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbz4TOvyDPgM+Bzr/Ot86zzr/Pjc68zrXOvc6/XSBkZGRkIFt7fV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vPhM63zr0gz4DPgc6/zrfOs86/z43OvM61zr3Ot10gZGRkZCBbe31dIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IGZ1bmN0aW9uIChrZXksIG1vbSkge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhckVsW2tleV0sXHJcbiAgICAgICAgICAgIGhvdXJzID0gbW9tICYmIG1vbS5ob3VycygpO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG91dHB1dCkpIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmFwcGx5KG1vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQucmVwbGFjZSgne30nLCAoaG91cnMgJSAxMiA9PT0gMSA/ICfPg8+EzrcnIDogJ8+Dz4TOuc+CJykpO1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnz4POtSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDPgM+BzrnOvScsXHJcbiAgICAgICAgcyA6ICfOu86vzrPOsSDOtM61z4XPhM61z4HPjM67zrXPgM+EzrEnLFxyXG4gICAgICAgIG0gOiAnzq3Ovc6xIM67zrXPgM+Ez4wnLFxyXG4gICAgICAgIG1tIDogJyVkIM67zrXPgM+EzqwnLFxyXG4gICAgICAgIGggOiAnzrzOr86xIM+Oz4HOsScsXHJcbiAgICAgICAgaGggOiAnJWQgz47Pgc61z4InLFxyXG4gICAgICAgIGQgOiAnzrzOr86xIM68zq3Pgc6xJyxcclxuICAgICAgICBkZCA6ICclZCDOvM6tz4HOtc+CJyxcclxuICAgICAgICBNIDogJ86tzr3Osc+CIM68zq7Ovc6xz4InLFxyXG4gICAgICAgIE1NIDogJyVkIM68zq7Ovc61z4InLFxyXG4gICAgICAgIHkgOiAnzq3Ovc6xz4Igz4fPgc+Mzr3Ov8+CJyxcclxuICAgICAgICB5eSA6ICclZCDPh8+Bz4zOvc65zrEnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9zrcvLFxyXG4gICAgb3JkaW5hbDogJyVkzrcnLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0c3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVsO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEVuZ2xpc2ggKEF1c3RyYWxpYSkgW2VuLWF1XVxyXG4vLyEgYXV0aG9yIDogSmFyZWQgTW9yc2UgOiBodHRwczovL2dpdGh1Yi5jb20vamFyY29hbFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGVuQXUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlbi1hdScsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBhZ28nLFxyXG4gICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXHJcbiAgICAgICAgbSA6ICdhIG1pbnV0ZScsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXHJcbiAgICAgICAgaCA6ICdhbiBob3VyJyxcclxuICAgICAgICBoaCA6ICclZCBob3VycycsXHJcbiAgICAgICAgZCA6ICdhIGRheScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXHJcbiAgICAgICAgTSA6ICdhIG1vbnRoJyxcclxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxyXG4gICAgICAgIHkgOiAnYSB5ZWFyJyxcclxuICAgICAgICB5eSA6ICclZCB5ZWFycydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBlbkF1O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1hdS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1hdS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEVuZ2xpc2ggKENhbmFkYSkgW2VuLWNhXVxyXG4vLyEgYXV0aG9yIDogSm9uYXRoYW4gQWJvdXJiaWggOiBodHRwczovL2dpdGh1Yi5jb20vam9uYmNhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZW5DYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWNhJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcclxuICAgICAgICBMTCA6ICdNTU1NIEQsIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGFnbycsXHJcbiAgICAgICAgcyA6ICdhIGZldyBzZWNvbmRzJyxcclxuICAgICAgICBtIDogJ2EgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ2FuIGhvdXInLFxyXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkIDogJ2EgZGF5JyxcclxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcclxuICAgICAgICBNIDogJ2EgbW9udGgnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXHJcbiAgICAgICAgeSA6ICdhIHllYXInLFxyXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcclxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVuQ2E7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWNhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWNhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRW5nbGlzaCAoVW5pdGVkIEtpbmdkb20pIFtlbi1nYl1cclxuLy8hIGF1dGhvciA6IENocmlzIEdlZHJpbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJpc2dlZHJpbVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGVuR2IgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlbi1nYicsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGFnbycsXHJcbiAgICAgICAgcyA6ICdhIGZldyBzZWNvbmRzJyxcclxuICAgICAgICBtIDogJ2EgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ2FuIGhvdXInLFxyXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkIDogJ2EgZGF5JyxcclxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcclxuICAgICAgICBNIDogJ2EgbW9udGgnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXHJcbiAgICAgICAgeSA6ICdhIHllYXInLFxyXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcclxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVuR2I7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRW5nbGlzaCAoSXJlbGFuZCkgW2VuLWllXVxyXG4vLyEgYXV0aG9yIDogQ2hyaXMgQ2FydGxpZGdlIDogaHR0cHM6Ly9naXRodWIuY29tL2NocmlzY2FydGxpZGdlXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZW5JZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWllJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQtTU0tWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBhZ28nLFxyXG4gICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXHJcbiAgICAgICAgbSA6ICdhIG1pbnV0ZScsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXHJcbiAgICAgICAgaCA6ICdhbiBob3VyJyxcclxuICAgICAgICBoaCA6ICclZCBob3VycycsXHJcbiAgICAgICAgZCA6ICdhIGRheScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXHJcbiAgICAgICAgTSA6ICdhIG1vbnRoJyxcclxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxyXG4gICAgICAgIHkgOiAnYSB5ZWFyJyxcclxuICAgICAgICB5eSA6ICclZCB5ZWFycydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBlbkllO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEVuZ2xpc2ggKE5ldyBaZWFsYW5kKSBbZW4tbnpdXHJcbi8vISBhdXRob3IgOiBMdWtlIE1jR3JlZ29yIDogaHR0cHM6Ly9naXRodWIuY29tL2x1a2VtY2dyZWdvclxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGVuTnogPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlbi1ueicsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBhZ28nLFxyXG4gICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXHJcbiAgICAgICAgbSA6ICdhIG1pbnV0ZScsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXHJcbiAgICAgICAgaCA6ICdhbiBob3VyJyxcclxuICAgICAgICBoaCA6ICclZCBob3VycycsXHJcbiAgICAgICAgZCA6ICdhIGRheScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXHJcbiAgICAgICAgTSA6ICdhIG1vbnRoJyxcclxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxyXG4gICAgICAgIHkgOiAnYSB5ZWFyJyxcclxuICAgICAgICB5eSA6ICclZCB5ZWFycydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBlbk56O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1uei5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1uei5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEVzcGVyYW50byBbZW9dXHJcbi8vISBhdXRob3IgOiBDb2xpbiBEZWFuIDogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluZGVhblxyXG4vLyEgYXV0aG9yIDogTWlhIE5vcmRlbnRvZnQgSW1wZXJhdG9yaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWVzdGFzbWlhXHJcbi8vISBjb21tZW50IDogbWllc3Rhc21pYSBjb3JyZWN0ZWQgdGhlIHRyYW5zbGF0aW9uIGJ5IGNvbGluZGVhblxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGVvID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZW8nLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyb19mZWJydWFyb19tYXJ0b19hcHJpbG9fbWFqb19qdW5pb19qdWxpb19hxa1ndXN0b19zZXB0ZW1icm9fb2t0b2Jyb19ub3ZlbWJyb19kZWNlbWJybycuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWpfanVuX2p1bF9hxa1nX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ2RpbWFuxIlvX2x1bmRvX21hcmRvX21lcmtyZWRvX8S1YcWtZG9fdmVuZHJlZG9fc2FiYXRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkaW1fbHVuX21hcmRfbWVya1/EtWHFrV92ZW5fc2FiJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnZGlfbHVfbWFfbWVfxLVhX3ZlX3NhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcclxuICAgICAgICBMTCA6ICdEWy1hIGRlXSBNTU1NLCBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRFstYSBkZV0gTU1NTSwgWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBbbGFdIERbLWEgZGVdIE1NTU0sIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL1thcF1cXC50XFwubS9pLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpID09PSAncCc7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwLnQubS4nIDogJ1AuVC5NLic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYS50Lm0uJyA6ICdBLlQuTS4nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tIb2RpYcWtIGplXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbTW9yZ2HFrSBqZV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2plXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbSGllcmHFrSBqZV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1twYXNpbnRhXSBkZGRkIFtqZV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdwb3N0ICVzJyxcclxuICAgICAgICBwYXN0IDogJ2FudGHFrSAlcycsXHJcbiAgICAgICAgcyA6ICdzZWt1bmRvaicsXHJcbiAgICAgICAgbSA6ICdtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b2onLFxyXG4gICAgICAgIGggOiAnaG9ybycsXHJcbiAgICAgICAgaGggOiAnJWQgaG9yb2onLFxyXG4gICAgICAgIGQgOiAndGFnbycsLy9uZSAnZGl1cm5vJywgxIlhciBlc3RhcyB1eml0YSBwb3IgcHJva3NpbXVtb1xyXG4gICAgICAgIGRkIDogJyVkIHRhZ29qJyxcclxuICAgICAgICBNIDogJ21vbmF0bycsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9uYXRvaicsXHJcbiAgICAgICAgeSA6ICdqYXJvJyxcclxuICAgICAgICB5eSA6ICclZCBqYXJvaidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1hLyxcclxuICAgIG9yZGluYWwgOiAnJWRhJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBlbztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTcGFuaXNoIChEb21pbmljYW4gUmVwdWJsaWMpIFtlcy1kb11cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHNTaG9ydERvdCA9ICdlbmUuX2ZlYi5fbWFyLl9hYnIuX21heS5fanVuLl9qdWwuX2Fnby5fc2VwLl9vY3QuX25vdi5fZGljLicuc3BsaXQoJ18nKTtcclxudmFyIG1vbnRoc1Nob3J0ID0gJ2VuZV9mZWJfbWFyX2Ficl9tYXlfanVuX2p1bF9hZ29fc2VwX29jdF9ub3ZfZGljJy5zcGxpdCgnXycpO1xyXG5cclxudmFyIG1vbnRoc1BhcnNlID0gWy9eZW5lL2ksIC9eZmViL2ksIC9ebWFyL2ksIC9eYWJyL2ksIC9ebWF5L2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYWdvL2ksIC9ec2VwL2ksIC9eb2N0L2ksIC9ebm92L2ksIC9eZGljL2ldO1xyXG52YXIgbW9udGhzUmVnZXggPSAvXihlbmVyb3xmZWJyZXJvfG1hcnpvfGFicmlsfG1heW98anVuaW98anVsaW98YWdvc3RvfHNlcHRpZW1icmV8b2N0dWJyZXxub3ZpZW1icmV8ZGljaWVtYnJlfGVuZVxcLj98ZmViXFwuP3xtYXJcXC4/fGFiclxcLj98bWF5XFwuP3xqdW5cXC4/fGp1bFxcLj98YWdvXFwuP3xzZXBcXC4/fG9jdFxcLj98bm92XFwuP3xkaWNcXC4/KS9pO1xyXG5cclxudmFyIGVzRG8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlcy1kbycsIHtcclxuICAgIG1vbnRocyA6ICdlbmVyb19mZWJyZXJvX21hcnpvX2FicmlsX21heW9fanVuaW9fanVsaW9fYWdvc3RvX3NlcHRpZW1icmVfb2N0dWJyZV9ub3ZpZW1icmVfZGljaWVtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdDtcclxuICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFttLm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdFttLm1vbnRoKCldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb250aHNSZWdleDogbW9udGhzUmVnZXgsXHJcbiAgICBtb250aHNTaG9ydFJlZ2V4OiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1N0cmljdFJlZ2V4OiAvXihlbmVyb3xmZWJyZXJvfG1hcnpvfGFicmlsfG1heW98anVuaW98anVsaW98YWdvc3RvfHNlcHRpZW1icmV8b2N0dWJyZXxub3ZpZW1icmV8ZGljaWVtYnJlKS9pLFxyXG4gICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleDogL14oZW5lXFwuP3xmZWJcXC4/fG1hclxcLj98YWJyXFwuP3xtYXlcXC4/fGp1blxcLj98anVsXFwuP3xhZ29cXC4/fHNlcFxcLj98b2N0XFwuP3xub3ZcXC4/fGRpY1xcLj8pL2ksXHJcbiAgICBtb250aHNQYXJzZTogbW9udGhzUGFyc2UsXHJcbiAgICBsb25nTW9udGhzUGFyc2U6IG1vbnRoc1BhcnNlLFxyXG4gICAgc2hvcnRNb250aHNQYXJzZTogbW9udGhzUGFyc2UsXHJcbiAgICB3ZWVrZGF5cyA6ICdkb21pbmdvX2x1bmVzX21hcnRlc19tacOpcmNvbGVzX2p1ZXZlc192aWVybmVzX3PDoWJhZG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2RvbS5fbHVuLl9tYXIuX21pw6kuX2p1ZS5fdmllLl9zw6FiLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ2RvX2x1X21hX21pX2p1X3ZpX3PDoScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZIGg6bW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIFtkZV0gTU1NTSBbZGVdIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2hveSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW21hw7FhbmEgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkIFthIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2F5ZXIgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbZWxdIGRkZGQgW3Bhc2FkbyBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdlbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdoYWNlICVzJyxcclxuICAgICAgICBzIDogJ3Vub3Mgc2VndW5kb3MnLFxyXG4gICAgICAgIG0gOiAndW4gbWludXRvJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcclxuICAgICAgICBoIDogJ3VuYSBob3JhJyxcclxuICAgICAgICBoaCA6ICclZCBob3JhcycsXHJcbiAgICAgICAgZCA6ICd1biBkw61hJyxcclxuICAgICAgICBkZCA6ICclZCBkw61hcycsXHJcbiAgICAgICAgTSA6ICd1biBtZXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2VzJyxcclxuICAgICAgICB5IDogJ3VuIGHDsW8nLFxyXG4gICAgICAgIHl5IDogJyVkIGHDsW9zJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXHJcbiAgICBvcmRpbmFsIDogJyVkwronLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVzRG87XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU3BhbmlzaChVbml0ZWQgU3RhdGUpIFtlcy11c11cclxuLy8hIGF1dGhvciA6IGJ1c3R0YSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9idXN0dGFcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHNTaG9ydERvdCA9ICdlbmUuX2ZlYi5fbWFyLl9hYnIuX21heS5fanVuLl9qdWwuX2Fnby5fc2VwLl9vY3QuX25vdi5fZGljLicuc3BsaXQoJ18nKTtcclxudmFyIG1vbnRoc1Nob3J0ID0gJ2VuZV9mZWJfbWFyX2Ficl9tYXlfanVuX2p1bF9hZ29fc2VwX29jdF9ub3ZfZGljJy5zcGxpdCgnXycpO1xyXG5cclxudmFyIGVzVXMgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlcy11cycsIHtcclxuICAgIG1vbnRocyA6ICdlbmVyb19mZWJyZXJvX21hcnpvX2FicmlsX21heW9fanVuaW9fanVsaW9fYWdvc3RvX3NlcHRpZW1icmVfb2N0dWJyZV9ub3ZpZW1icmVfZGljaWVtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdDtcclxuICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFttLm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdFttLm1vbnRoKCldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2RvbWluZ29fbHVuZXNfbWFydGVzX21pw6lyY29sZXNfanVldmVzX3ZpZXJuZXNfc8OhYmFkbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZG9tLl9sdW4uX21hci5fbWnDqS5fanVlLl92aWUuX3PDoWIuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnZG9fbHVfbWFfbWlfanVfdmlfc8OhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ01NL0REL1lZWVknLFxyXG4gICAgICAgIExMIDogJ01NTU0gW2RlXSBEIFtkZV0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ01NTU0gW2RlXSBEIFtkZV0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gW2RlXSBEIFtkZV0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2hveSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW21hw7FhbmEgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkIFthIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2F5ZXIgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbZWxdIGRkZGQgW3Bhc2FkbyBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdlbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdoYWNlICVzJyxcclxuICAgICAgICBzIDogJ3Vub3Mgc2VndW5kb3MnLFxyXG4gICAgICAgIG0gOiAndW4gbWludXRvJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcclxuICAgICAgICBoIDogJ3VuYSBob3JhJyxcclxuICAgICAgICBoaCA6ICclZCBob3JhcycsXHJcbiAgICAgICAgZCA6ICd1biBkw61hJyxcclxuICAgICAgICBkZCA6ICclZCBkw61hcycsXHJcbiAgICAgICAgTSA6ICd1biBtZXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2VzJyxcclxuICAgICAgICB5IDogJ3VuIGHDsW8nLFxyXG4gICAgICAgIHl5IDogJyVkIGHDsW9zJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXHJcbiAgICBvcmRpbmFsIDogJyVkwronLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVzVXM7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLXVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLXVzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU3BhbmlzaCBbZXNdXHJcbi8vISBhdXRob3IgOiBKdWxpbyBOYXB1csOtIDogaHR0cHM6Ly9naXRodWIuY29tL2p1bGlvbmNcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHNTaG9ydERvdCA9ICdlbmUuX2ZlYi5fbWFyLl9hYnIuX21heS5fanVuLl9qdWwuX2Fnby5fc2VwLl9vY3QuX25vdi5fZGljLicuc3BsaXQoJ18nKTtcclxudmFyIG1vbnRoc1Nob3J0ID0gJ2VuZV9mZWJfbWFyX2Ficl9tYXlfanVuX2p1bF9hZ29fc2VwX29jdF9ub3ZfZGljJy5zcGxpdCgnXycpO1xyXG5cclxudmFyIG1vbnRoc1BhcnNlID0gWy9eZW5lL2ksIC9eZmViL2ksIC9ebWFyL2ksIC9eYWJyL2ksIC9ebWF5L2ksIC9eanVuL2ksIC9eanVsL2ksIC9eYWdvL2ksIC9ec2VwL2ksIC9eb2N0L2ksIC9ebm92L2ksIC9eZGljL2ldO1xyXG52YXIgbW9udGhzUmVnZXggPSAvXihlbmVyb3xmZWJyZXJvfG1hcnpvfGFicmlsfG1heW98anVuaW98anVsaW98YWdvc3RvfHNlcHRpZW1icmV8b2N0dWJyZXxub3ZpZW1icmV8ZGljaWVtYnJlfGVuZVxcLj98ZmViXFwuP3xtYXJcXC4/fGFiclxcLj98bWF5XFwuP3xqdW5cXC4/fGp1bFxcLj98YWdvXFwuP3xzZXBcXC4/fG9jdFxcLj98bm92XFwuP3xkaWNcXC4/KS9pO1xyXG5cclxudmFyIGVzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZXMnLCB7XHJcbiAgICBtb250aHMgOiAnZW5lcm9fZmVicmVyb19tYXJ6b19hYnJpbF9tYXlvX2p1bmlvX2p1bGlvX2Fnb3N0b19zZXB0aWVtYnJlX29jdHVicmVfbm92aWVtYnJlX2RpY2llbWJyZScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0sIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnREb3Q7XHJcbiAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRbbS5tb250aCgpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnREb3RbbS5tb250aCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW9udGhzUmVnZXggOiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1Nob3J0UmVnZXggOiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1N0cmljdFJlZ2V4IDogL14oZW5lcm98ZmVicmVyb3xtYXJ6b3xhYnJpbHxtYXlvfGp1bmlvfGp1bGlvfGFnb3N0b3xzZXB0aWVtYnJlfG9jdHVicmV8bm92aWVtYnJlfGRpY2llbWJyZSkvaSxcclxuICAgIG1vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiAvXihlbmVcXC4/fGZlYlxcLj98bWFyXFwuP3xhYnJcXC4/fG1heVxcLj98anVuXFwuP3xqdWxcXC4/fGFnb1xcLj98c2VwXFwuP3xvY3RcXC4/fG5vdlxcLj98ZGljXFwuPykvaSxcclxuICAgIG1vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXHJcbiAgICBsb25nTW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIHNob3J0TW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIHdlZWtkYXlzIDogJ2RvbWluZ29fbHVuZXNfbWFydGVzX21pw6lyY29sZXNfanVldmVzX3ZpZXJuZXNfc8OhYmFkbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZG9tLl9sdW4uX21hci5fbWnDqS5fanVlLl92aWUuX3PDoWIuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnZG9fbHVfbWFfbWlfanVfdmlfc8OhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2hveSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW21hw7FhbmEgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkIFthIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2F5ZXIgYSBsYScgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAncycgOiAnJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbZWxdIGRkZGQgW3Bhc2FkbyBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdlbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdoYWNlICVzJyxcclxuICAgICAgICBzIDogJ3Vub3Mgc2VndW5kb3MnLFxyXG4gICAgICAgIG0gOiAndW4gbWludXRvJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcclxuICAgICAgICBoIDogJ3VuYSBob3JhJyxcclxuICAgICAgICBoaCA6ICclZCBob3JhcycsXHJcbiAgICAgICAgZCA6ICd1biBkw61hJyxcclxuICAgICAgICBkZCA6ICclZCBkw61hcycsXHJcbiAgICAgICAgTSA6ICd1biBtZXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2VzJyxcclxuICAgICAgICB5IDogJ3VuIGHDsW8nLFxyXG4gICAgICAgIHl5IDogJyVkIGHDsW9zJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXHJcbiAgICBvcmRpbmFsIDogJyVkwronLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVzO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEVzdG9uaWFuIFtldF1cclxuLy8hIGF1dGhvciA6IEhlbnJ5IEtlaGxtYW5uIDogaHR0cHM6Ly9naXRodWIuY29tL21hZGhlbnJ5XHJcbi8vISBpbXByb3ZlbWVudHMgOiBJbGxpbWFyIFRhbWJlayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWd1bGthXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAncycgOiBbJ23DtW5lIHNla3VuZGknLCAnbcO1bmkgc2VrdW5kJywgJ3BhYXIgc2VrdW5kaXQnXSxcclxuICAgICAgICAnbScgOiBbJ8O8aGUgbWludXRpJywgJ8O8a3MgbWludXQnXSxcclxuICAgICAgICAnbW0nOiBbbnVtYmVyICsgJyBtaW51dGknLCBudW1iZXIgKyAnIG1pbnV0aXQnXSxcclxuICAgICAgICAnaCcgOiBbJ8O8aGUgdHVubmknLCAndHVuZCBhZWdhJywgJ8O8a3MgdHVuZCddLFxyXG4gICAgICAgICdoaCc6IFtudW1iZXIgKyAnIHR1bm5pJywgbnVtYmVyICsgJyB0dW5kaSddLFxyXG4gICAgICAgICdkJyA6IFsnw7xoZSBww6RldmEnLCAnw7xrcyBww6RldiddLFxyXG4gICAgICAgICdNJyA6IFsna3V1IGFqYScsICdrdXUgYWVnYScsICfDvGtzIGt1dSddLFxyXG4gICAgICAgICdNTSc6IFtudW1iZXIgKyAnIGt1dScsIG51bWJlciArICcga3V1ZCddLFxyXG4gICAgICAgICd5JyA6IFsnw7xoZSBhYXN0YScsICdhYXN0YScsICfDvGtzIGFhc3RhJ10sXHJcbiAgICAgICAgJ3l5JzogW251bWJlciArICcgYWFzdGEnLCBudW1iZXIgKyAnIGFhc3RhdCddXHJcbiAgICB9O1xyXG4gICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICByZXR1cm4gZm9ybWF0W2tleV1bMl0gPyBmb3JtYXRba2V5XVsyXSA6IGZvcm1hdFtrZXldWzFdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzRnV0dXJlID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcclxufVxyXG5cclxudmFyIGV0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZXQnLCB7XHJcbiAgICBtb250aHMgICAgICAgIDogJ2phYW51YXJfdmVlYnJ1YXJfbcOkcnRzX2FwcmlsbF9tYWlfanV1bmlfanV1bGlfYXVndXN0X3NlcHRlbWJlcl9va3Rvb2Jlcl9ub3ZlbWJlcl9kZXRzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCAgIDogJ2phYW5fdmVlYnJfbcOkcnRzX2Fwcl9tYWlfanV1bmlfanV1bGlfYXVnX3NlcHRfb2t0X25vdl9kZXRzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgICAgICA6ICdww7xoYXDDpGV2X2VzbWFzcMOkZXZfdGVpc2lww6Rldl9rb2xtYXDDpGV2X25lbGphcMOkZXZfcmVlZGVfbGF1cMOkZXYnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1BfRV9UX0tfTl9SX0wnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiAgIDogJ1BfRV9UX0tfTl9SX0wnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCAgIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMICAgIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMICAgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgIDogJ1tUw6RuYSxdIExUJyxcclxuICAgICAgICBuZXh0RGF5ICA6ICdbSG9tbWUsXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW0rDpHJnbWluZV0gZGRkZCBMVCcsXHJcbiAgICAgICAgbGFzdERheSAgOiAnW0VpbGUsXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0VlbG1pbmVdIGRkZGQgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyBww6RyYXN0JyxcclxuICAgICAgICBwYXN0ICAgOiAnJXMgdGFnYXNpJyxcclxuICAgICAgICBzICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG0gICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbW0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGhoICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkZCAgICAgOiAnJWQgcMOkZXZhJyxcclxuICAgICAgICBNICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE1NICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeSAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5eSAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBldDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBCYXNxdWUgW2V1XVxyXG4vLyEgYXV0aG9yIDogRW5la28gSWxsYXJyYW1lbmRpIDogaHR0cHM6Ly9naXRodWIuY29tL2VpbGxhcnJhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZXUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdldScsIHtcclxuICAgIG1vbnRocyA6ICd1cnRhcnJpbGFfb3RzYWlsYV9tYXJ0eG9hX2FwaXJpbGFfbWFpYXR6YV9la2FpbmFfdXp0YWlsYV9hYnV6dHVhX2lyYWlsYV91cnJpYV9hemFyb2FfYWJlbmR1YScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ3VydC5fb3RzLl9tYXIuX2FwaS5fbWFpLl9la2EuX3V6dC5fYWJ1Ll9pcmEuX3Vyci5fYXphLl9hYmUuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdpZ2FuZGVhX2FzdGVsZWhlbmFfYXN0ZWFydGVhX2FzdGVhemtlbmFfb3N0ZWd1bmFfb3N0aXJhbGFfbGFydW5iYXRhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdpZy5fYWwuX2FyLl9hei5fb2cuX29sLl9sci4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdpZ19hbF9hcl9hel9vZ19vbF9scicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxyXG4gICAgICAgIExMIDogJ1lZWVlba29dIE1NTU1bcmVuXSBEW2FdJyxcclxuICAgICAgICBMTEwgOiAnWVlZWVtrb10gTU1NTVtyZW5dIERbYV0gSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgWVlZWVtrb10gTU1NTVtyZW5dIERbYV0gSEg6bW0nLFxyXG4gICAgICAgIGwgOiAnWVlZWS1NLUQnLFxyXG4gICAgICAgIGxsIDogJ1lZWVlba29dIE1NTSBEW2FdJyxcclxuICAgICAgICBsbGwgOiAnWVlZWVtrb10gTU1NIERbYV0gSEg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnZGRkLCBZWVlZW2tvXSBNTU0gRFthXSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tnYXVyXSBMVFtldGFuXScsXHJcbiAgICAgICAgbmV4dERheSA6ICdbYmloYXJdIExUW2V0YW5dJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIExUW2V0YW5dJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1thdHpvXSBMVFtldGFuXScsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW2F1cnJla29dIGRkZGQgTFRbZXRhbl0nLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyBiYXJydScsXHJcbiAgICAgICAgcGFzdCA6ICdkdWVsYSAlcycsXHJcbiAgICAgICAgcyA6ICdzZWd1bmRvIGJhdHp1aycsXHJcbiAgICAgICAgbSA6ICdtaW51dHUgYmF0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dHUnLFxyXG4gICAgICAgIGggOiAnb3JkdSBiYXQnLFxyXG4gICAgICAgIGhoIDogJyVkIG9yZHUnLFxyXG4gICAgICAgIGQgOiAnZWd1biBiYXQnLFxyXG4gICAgICAgIGRkIDogJyVkIGVndW4nLFxyXG4gICAgICAgIE0gOiAnaGlsYWJldGUgYmF0JyxcclxuICAgICAgICBNTSA6ICclZCBoaWxhYmV0ZScsXHJcbiAgICAgICAgeSA6ICd1cnRlIGJhdCcsXHJcbiAgICAgICAgeXkgOiAnJWQgdXJ0ZSdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGV1O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFBlcnNpYW4gW2ZhXVxyXG4vLyEgYXV0aG9yIDogRWJyYWhpbSBCeWFnb3dpIDogaHR0cHM6Ly9naXRodWIuY29tL2VicmFtaW5pb1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ9uxJyxcclxuICAgICcyJzogJ9uyJyxcclxuICAgICczJzogJ9uzJyxcclxuICAgICc0JzogJ9u0JyxcclxuICAgICc1JzogJ9u1JyxcclxuICAgICc2JzogJ9u2JyxcclxuICAgICc3JzogJ9u3JyxcclxuICAgICc4JzogJ9u4JyxcclxuICAgICc5JzogJ9u5JyxcclxuICAgICcwJzogJ9uwJ1xyXG59O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgJ9uxJzogJzEnLFxyXG4gICAgJ9uyJzogJzInLFxyXG4gICAgJ9uzJzogJzMnLFxyXG4gICAgJ9u0JzogJzQnLFxyXG4gICAgJ9u1JzogJzUnLFxyXG4gICAgJ9u2JzogJzYnLFxyXG4gICAgJ9u3JzogJzcnLFxyXG4gICAgJ9u4JzogJzgnLFxyXG4gICAgJ9u5JzogJzknLFxyXG4gICAgJ9uwJzogJzAnXHJcbn07XHJcblxyXG52YXIgZmEgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmYScsIHtcclxuICAgIG1vbnRocyA6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn2pjYp9mG2YjbjNmHX9mB2YjYsduM2Ydf2YXYp9ix2LNf2KLZiNix24zZhF/ZhdmHX9qY2YjYptmGX9qY2YjYptuM2Ydf2KfZiNiqX9iz2b7Yqtin2YXYqNixX9in2qnYqtio2LFf2YbZiNin2YXYqNixX9iv2LPYp9mF2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9uM2qlcXHUyMDBj2LTZhtio2Ydf2K/ZiNi02YbYqNmHX9iz2YdcXHUyMDBj2LTZhtio2Ydf2obZh9in2LHYtNmG2KjZh1/ZvtmG2KxcXHUyMDBj2LTZhtio2Ydf2KzZhdi52Ydf2LTZhtio2YcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9uM2qlcXHUyMDBj2LTZhtio2Ydf2K/ZiNi02YbYqNmHX9iz2YdcXHUyMDBj2LTZhtio2Ydf2obZh9in2LHYtNmG2KjZh1/ZvtmG2KxcXHUyMDBj2LTZhtio2Ydf2KzZhdi52Ydf2LTZhtio2YcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfbjF/Yr1/Ys1/ahl/Zvl/YrF/YtCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9mC2KjZhCDYp9iyINi42YfYsXzYqNi52K8g2KfYsiDYuNmH2LEvLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIC/YqNi52K8g2KfYsiDYuNmH2LEvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfZgtio2YQg2KfYsiDYuNmH2LEnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2KjYudivINin2LIg2LjZh9ixJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb2KfZhdix2YjYsiDYs9in2LnYql0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9mB2LHYr9inINiz2KfYudiqXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb2LPYp9i52KpdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vYr9uM2LHZiNiyINiz2KfYudiqXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBb2b7bjNi0XSBb2LPYp9i52KpdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn2K/YsSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDZvtuM2LQnLFxyXG4gICAgICAgIHMgOiAn2obZhtivINir2KfZhtuM2YcnLFxyXG4gICAgICAgIG0gOiAn24zaqSDYr9mC24zZgtmHJyxcclxuICAgICAgICBtbSA6ICclZCDYr9mC24zZgtmHJyxcclxuICAgICAgICBoIDogJ9uM2qkg2LPYp9i52KonLFxyXG4gICAgICAgIGhoIDogJyVkINiz2KfYudiqJyxcclxuICAgICAgICBkIDogJ9uM2qkg2LHZiNiyJyxcclxuICAgICAgICBkZCA6ICclZCDYsdmI2LInLFxyXG4gICAgICAgIE0gOiAn24zaqSDZhdin2YcnLFxyXG4gICAgICAgIE1NIDogJyVkINmF2KfZhycsXHJcbiAgICAgICAgeSA6ICfbjNqpINiz2KfZhCcsXHJcbiAgICAgICAgeXkgOiAnJWQg2LPYp9mEJ1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b27At27ldL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KS5yZXBsYWNlKC/YjC9nLCAnLCcpO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSkucmVwbGFjZSgvLC9nLCAn2IwnKTtcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn3ZhS8sXHJcbiAgICBvcmRpbmFsIDogJyVk2YUnLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDEyIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZmE7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRmlubmlzaCBbZmldXHJcbi8vISBhdXRob3IgOiBUYXJtbyBBaWRhbnRhdXN0YSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ibGVhZG9mXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbnVtYmVyc1Bhc3QgPSAnbm9sbGEgeWtzaSBrYWtzaSBrb2xtZSBuZWxqw6Qgdmlpc2kga3V1c2kgc2VpdHNlbcOkbiBrYWhkZWtzYW4geWhkZWtzw6RuJy5zcGxpdCgnICcpO1xyXG52YXIgbnVtYmVyc0Z1dHVyZSA9IFtcclxuICAgICAgICAnbm9sbGEnLCAneWhkZW4nLCAna2FoZGVuJywgJ2tvbG1lbicsICduZWxqw6RuJywgJ3ZpaWRlbicsICdrdXVkZW4nLFxyXG4gICAgICAgIG51bWJlcnNQYXN0WzddLCBudW1iZXJzUGFzdFs4XSwgbnVtYmVyc1Bhc3RbOV1cclxuICAgIF07XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdtdXV0YW1hbiBzZWt1bm5pbicgOiAnbXV1dGFtYSBzZWt1bnRpJztcclxuICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ21pbnV1dGluJyA6ICdtaW51dXR0aSc7XHJcbiAgICAgICAgY2FzZSAnbW0nOlxyXG4gICAgICAgICAgICByZXN1bHQgPSBpc0Z1dHVyZSA/ICdtaW51dXRpbicgOiAnbWludXV0dGlhJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICd0dW5uaW4nIDogJ3R1bnRpJztcclxuICAgICAgICBjYXNlICdoaCc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ3R1bm5pbicgOiAndHVudGlhJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdww6RpdsOkbicgOiAncMOkaXbDpCc7XHJcbiAgICAgICAgY2FzZSAnZGQnOlxyXG4gICAgICAgICAgICByZXN1bHQgPSBpc0Z1dHVyZSA/ICdww6RpdsOkbicgOiAncMOkaXbDpMOkJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdrdXVrYXVkZW4nIDogJ2t1dWthdXNpJztcclxuICAgICAgICBjYXNlICdNTSc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ2t1dWthdWRlbicgOiAna3V1a2F1dHRhJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAneSc6XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICd2dW9kZW4nIDogJ3Z1b3NpJztcclxuICAgICAgICBjYXNlICd5eSc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ3Z1b2RlbicgOiAndnVvdHRhJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXN1bHQgPSB2ZXJiYWxOdW1iZXIobnVtYmVyLCBpc0Z1dHVyZSkgKyAnICcgKyByZXN1bHQ7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHZlcmJhbE51bWJlcihudW1iZXIsIGlzRnV0dXJlKSB7XHJcbiAgICByZXR1cm4gbnVtYmVyIDwgMTAgPyAoaXNGdXR1cmUgPyBudW1iZXJzRnV0dXJlW251bWJlcl0gOiBudW1iZXJzUGFzdFtudW1iZXJdKSA6IG51bWJlcjtcclxufVxyXG5cclxudmFyIGZpID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZmknLCB7XHJcbiAgICBtb250aHMgOiAndGFtbWlrdXVfaGVsbWlrdXVfbWFhbGlza3V1X2h1aHRpa3V1X3RvdWtva3V1X2tlc8Oka3V1X2hlaW7DpGt1dV9lbG9rdXVfc3l5c2t1dV9sb2tha3V1X21hcnJhc2t1dV9qb3VsdWt1dScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ3RhbW1pX2hlbG1pX21hYWxpc19odWh0aV90b3Vrb19rZXPDpF9oZWluw6RfZWxvX3N5eXNfbG9rYV9tYXJyYXNfam91bHUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdzdW5udW50YWlfbWFhbmFudGFpX3RpaXN0YWlfa2Vza2l2aWlra29fdG9yc3RhaV9wZXJqYW50YWlfbGF1YW50YWknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3N1X21hX3RpX2tlX3RvX3BlX2xhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnc3VfbWFfdGlfa2VfdG9fcGVfbGEnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISC5tbScsXHJcbiAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0RvIE1NTU1bdGFdIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEbyBNTU1NW3RhXSBZWVlZLCBba2xvXSBISC5tbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEbyBNTU1NW3RhXSBZWVlZLCBba2xvXSBISC5tbScsXHJcbiAgICAgICAgbCA6ICdELk0uWVlZWScsXHJcbiAgICAgICAgbGwgOiAnRG8gTU1NIFlZWVknLFxyXG4gICAgICAgIGxsbCA6ICdEbyBNTU0gWVlZWSwgW2tsb10gSEgubW0nLFxyXG4gICAgICAgIGxsbGwgOiAnZGRkLCBEbyBNTU0gWVlZWSwgW2tsb10gSEgubW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbdMOkbsOkw6RuXSBba2xvXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbaHVvbWVubmFdIFtrbG9dIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtrbG9dIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tlaWxlbl0gW2tsb10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1t2aWltZV0gZGRkZFtuYV0gW2tsb10gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyBww6TDpHN0w6QnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgc2l0dGVuJyxcclxuICAgICAgICBzIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGRkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTU0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZmk7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZpLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRmFyb2VzZSBbZm9dXHJcbi8vISBhdXRob3IgOiBSYWduYXIgSm9oYW5uZXNlbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWduYXIxMjNcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBmbyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZvJywge1xyXG4gICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnNfYXByw61sX21haV9qdW5pX2p1bGlfYXVndXN0X3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2Rlc2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21haV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdzdW5udWRhZ3VyX23DoW5hZGFndXJfdMO9c2RhZ3VyX21pa3VkYWd1cl9ow7NzZGFndXJfZnLDrWdnamFkYWd1cl9sZXlnYXJkYWd1cicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc3VuX23DoW5fdMO9c19taWtfaMOzc19mcsOtX2xleScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3N1X23DoV90w71fbWlfaMOzX2ZyX2xlJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSwgWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vDjSBkYWcga2wuXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbw40gbW9yZ2luIGtsLl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2tsLl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW8ONIGdqw6FyIGtsLl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tzw63DsHN0dV0gZGRkZCBba2xdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAndW0gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgc8Otw7BhbmknLFxyXG4gICAgICAgIHMgOiAnZsOhIHNla3VuZCcsXHJcbiAgICAgICAgbSA6ICdlaW4gbWludXR0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dHRpcicsXHJcbiAgICAgICAgaCA6ICdlaW4gdMOtbWknLFxyXG4gICAgICAgIGhoIDogJyVkIHTDrW1hcicsXHJcbiAgICAgICAgZCA6ICdlaW4gZGFndXInLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2FyJyxcclxuICAgICAgICBNIDogJ2VpbiBtw6FuYcOwaScsXHJcbiAgICAgICAgTU0gOiAnJWQgbcOhbmHDsGlyJyxcclxuICAgICAgICB5IDogJ2VpdHQgw6FyJyxcclxuICAgICAgICB5eSA6ICclZCDDoXInXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBmbztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZm8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZm8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBGcmVuY2ggKENhbmFkYSkgW2ZyLWNhXVxyXG4vLyEgYXV0aG9yIDogSm9uYXRoYW4gQWJvdXJiaWggOiBodHRwczovL2dpdGh1Yi5jb20vam9uYmNhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZnJDYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZyLWNhJywge1xyXG4gICAgbW9udGhzIDogJ2phbnZpZXJfZsOpdnJpZXJfbWFyc19hdnJpbF9tYWlfanVpbl9qdWlsbGV0X2Fvw7t0X3NlcHRlbWJyZV9vY3RvYnJlX25vdmVtYnJlX2TDqWNlbWJyZScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbnYuX2bDqXZyLl9tYXJzX2F2ci5fbWFpX2p1aW5fanVpbC5fYW/Du3Rfc2VwdC5fb2N0Ll9ub3YuX2TDqWMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdkaW1hbmNoZV9sdW5kaV9tYXJkaV9tZXJjcmVkaV9qZXVkaV92ZW5kcmVkaV9zYW1lZGknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2RpbS5fbHVuLl9tYXIuX21lci5famV1Ll92ZW4uX3NhbS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdEaV9MdV9NYV9NZV9KZV9WZV9TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tBdWpvdXJk4oCZaHVpIMOgXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbRGVtYWluIMOgXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbw6BdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tIaWVyIMOgXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbZGVybmllciDDoF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdkYW5zICVzJyxcclxuICAgICAgICBwYXN0IDogJ2lsIHkgYSAlcycsXHJcbiAgICAgICAgcyA6ICdxdWVscXVlcyBzZWNvbmRlcycsXHJcbiAgICAgICAgbSA6ICd1bmUgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ3VuZSBoZXVyZScsXHJcbiAgICAgICAgaGggOiAnJWQgaGV1cmVzJyxcclxuICAgICAgICBkIDogJ3VuIGpvdXInLFxyXG4gICAgICAgIGRkIDogJyVkIGpvdXJzJyxcclxuICAgICAgICBNIDogJ3VuIG1vaXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vaXMnLFxyXG4gICAgICAgIHkgOiAndW4gYW4nLFxyXG4gICAgICAgIHl5IDogJyVkIGFucydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oZXJ8ZSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggbWFzY3VsaW5lIGdyYW1tYXRpY2FsIGdlbmRlcjogbW9pcywgdHJpbWVzdHJlLCBqb3VyXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAnZXInIDogJ2UnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggZmVtaW5pbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBzZW1haW5lXHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ3JlJyA6ICdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBmckNhO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEZyZW5jaCAoU3dpdHplcmxhbmQpIFtmci1jaF1cclxuLy8hIGF1dGhvciA6IEdhc3BhcmQgQnVjaGVyIDogaHR0cHM6Ly9naXRodWIuY29tL2dhc3BhcmRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBmckNoID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnItY2gnLCB7XHJcbiAgICBtb250aHMgOiAnamFudmllcl9mw6l2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW/Du3Rfc2VwdGVtYnJlX29jdG9icmVfbm92ZW1icmVfZMOpY2VtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFudi5fZsOpdnIuX21hcnNfYXZyLl9tYWlfanVpbl9qdWlsLl9hb8O7dF9zZXB0Ll9vY3QuX25vdi5fZMOpYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2RpbWFuY2hlX2x1bmRpX21hcmRpX21lcmNyZWRpX2pldWRpX3ZlbmRyZWRpX3NhbWVkaScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZGltLl9sdW4uX21hci5fbWVyLl9qZXUuX3Zlbi5fc2FtLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0RpX0x1X01hX01lX0plX1ZlX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0F1am91cmTigJlodWkgw6BdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tEZW1haW4gw6BdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvDoF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0hpZXIgw6BdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtkZXJuaWVyIMOgXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhbnMgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnaWwgeSBhICVzJyxcclxuICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcclxuICAgICAgICBtIDogJ3VuZSBtaW51dGUnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGggOiAndW5lIGhldXJlJyxcclxuICAgICAgICBoaCA6ICclZCBoZXVyZXMnLFxyXG4gICAgICAgIGQgOiAndW4gam91cicsXHJcbiAgICAgICAgZGQgOiAnJWQgam91cnMnLFxyXG4gICAgICAgIE0gOiAndW4gbW9pcycsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9pcycsXHJcbiAgICAgICAgeSA6ICd1biBhbicsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5zJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShlcnxlKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBtYXNjdWxpbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBtb2lzLCB0cmltZXN0cmUsIGpvdXJcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdlcicgOiAnZScpO1xyXG5cclxuICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBmZW1pbmluZSBncmFtbWF0aWNhbCBnZW5kZXI6IHNlbWFpbmVcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAncmUnIDogJ2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGZyQ2g7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRnJlbmNoIFtmcl1cclxuLy8hIGF1dGhvciA6IEpvaG4gRmlzY2hlciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qZnJvZmZpY2VcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBmciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZyJywge1xyXG4gICAgbW9udGhzIDogJ2phbnZpZXJfZsOpdnJpZXJfbWFyc19hdnJpbF9tYWlfanVpbl9qdWlsbGV0X2Fvw7t0X3NlcHRlbWJyZV9vY3RvYnJlX25vdmVtYnJlX2TDqWNlbWJyZScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbnYuX2bDqXZyLl9tYXJzX2F2ci5fbWFpX2p1aW5fanVpbC5fYW/Du3Rfc2VwdC5fb2N0Ll9ub3YuX2TDqWMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdkaW1hbmNoZV9sdW5kaV9tYXJkaV9tZXJjcmVkaV9qZXVkaV92ZW5kcmVkaV9zYW1lZGknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2RpbS5fbHVuLl9tYXIuX21lci5famV1Ll92ZW4uX3NhbS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdEaV9MdV9NYV9NZV9KZV9WZV9TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tBdWpvdXJk4oCZaHVpIMOgXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbRGVtYWluIMOgXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbw6BdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tIaWVyIMOgXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbZGVybmllciDDoF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdkYW5zICVzJyxcclxuICAgICAgICBwYXN0IDogJ2lsIHkgYSAlcycsXHJcbiAgICAgICAgcyA6ICdxdWVscXVlcyBzZWNvbmRlcycsXHJcbiAgICAgICAgbSA6ICd1bmUgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ3VuZSBoZXVyZScsXHJcbiAgICAgICAgaGggOiAnJWQgaGV1cmVzJyxcclxuICAgICAgICBkIDogJ3VuIGpvdXInLFxyXG4gICAgICAgIGRkIDogJyVkIGpvdXJzJyxcclxuICAgICAgICBNIDogJ3VuIG1vaXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vaXMnLFxyXG4gICAgICAgIHkgOiAndW4gYW4nLFxyXG4gICAgICAgIHl5IDogJyVkIGFucydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oZXJ8KS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogUmV0dXJuICdlJyB3aGVuIGRheSBvZiBtb250aCA+IDEuIE1vdmUgdGhpcyBjYXNlIGluc2lkZVxyXG4gICAgICAgICAgICAvLyBibG9jayBmb3IgbWFzY3VsaW5lIHdvcmRzIGJlbG93LlxyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzMzNzVcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdlcicgOiAnJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBXb3JkcyB3aXRoIG1hc2N1bGluZSBncmFtbWF0aWNhbCBnZW5kZXI6IG1vaXMsIHRyaW1lc3RyZSwgam91clxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAnZXInIDogJ2UnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggZmVtaW5pbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBzZW1haW5lXHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ3JlJyA6ICdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBmcjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBGcmlzaWFuIFtmeV1cclxuLy8hIGF1dGhvciA6IFJvYmluIHZhbiBkZXIgVmxpZXQgOiBodHRwczovL2dpdGh1Yi5jb20vcm9iaW4wdmFuMGRlcjB2XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzU2hvcnRXaXRoRG90cyA9ICdqYW4uX2ZlYi5fbXJ0Ll9hcHIuX21haV9qdW4uX2p1bC5fYXVnLl9zZXAuX29rdC5fbm92Ll9kZXMuJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnRXaXRob3V0RG90cyA9ICdqYW5fZmViX21ydF9hcHJfbWFpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2Rlcycuc3BsaXQoJ18nKTtcclxuXHJcbnZhciBmeSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2Z5Jywge1xyXG4gICAgbW9udGhzIDogJ2phbm5ld2FyaXNfZmVicmV3YXJpc19tYWFydF9hcHJpbF9tYWFpZV9qdW55X2p1bHlfYXVndXN0dXNfc2VwdGltYmVyX29rdG9iZXJfbm92aW1iZXJfZGVzaW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHM7XHJcbiAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRob3V0RG90c1ttLm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzW20ubW9udGgoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnc25laW5fbW9hbmRlaV90aWlzZGVpX3dvYW5zZGVpX3RvbmdlcnNkZWlfZnJlZWRfc25lb24nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3NpLl9tby5fdGkuX3dvLl90by5fZnIuX3NvLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1NpX01vX1RpX1dvX1RvX0ZyX1NvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQtTU0tWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbaGpvZWQgb21dIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW21vYXJuIG9tXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtvbV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbanVzdGVyIG9tXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbw7RmcsO7bmVdIGRkZGQgW29tXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb2VyICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGx5bicsXHJcbiAgICAgICAgcyA6ICdpbiBwZWFyIHNla29uZGVuJyxcclxuICAgICAgICBtIDogJ2llbiBtaW7DunQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZW4nLFxyXG4gICAgICAgIGggOiAnaWVuIG9lcmUnLFxyXG4gICAgICAgIGhoIDogJyVkIG9lcmVuJyxcclxuICAgICAgICBkIDogJ2llbiBkZWknLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2VuJyxcclxuICAgICAgICBNIDogJ2llbiBtb2FubmUnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vYW5uZW4nLFxyXG4gICAgICAgIHkgOiAnaWVuIGppZXInLFxyXG4gICAgICAgIHl5IDogJyVkIGppZXJyZW4nXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0ZXxkZSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgKChudW1iZXIgPT09IDEgfHwgbnVtYmVyID09PSA4IHx8IG51bWJlciA+PSAyMCkgPyAnc3RlJyA6ICdkZScpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBmeTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTY290dGlzaCBHYWVsaWMgW2dkXVxyXG4vLyEgYXV0aG9yIDogSm9uIEFzaGRvd24gOiBodHRwczovL2dpdGh1Yi5jb20vam9uYXNoZG93blxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRocyA9IFtcclxuICAgICdBbSBGYW9pbGxlYWNoJywgJ0FuIEdlYXJyYW4nLCAnQW0gTcOgcnQnLCAnQW4gR2libGVhbicsICdBbiBDw6hpdGVhbicsICdBbiB0LcOSZ21oaW9zJywgJ0FuIHQtSXVjaGFyJywgJ0FuIEzDuW5hc3RhbCcsICdBbiB0LVN1bHRhaW4nLCAnQW4gRMOgbWhhaXInLCAnQW4gdC1TYW1oYWluJywgJ0FuIETDuWJobGFjaGQnXHJcbl07XHJcblxyXG52YXIgbW9udGhzU2hvcnQgPSBbJ0Zhb2knLCAnR2VhcicsICdNw6BydCcsICdHaWJsJywgJ0PDqGl0JywgJ8OSZ21oJywgJ0l1Y2gnLCAnTMO5bicsICdTdWx0JywgJ0TDoG1oJywgJ1NhbWgnLCAnRMO5YmgnXTtcclxuXHJcbnZhciB3ZWVrZGF5cyA9IFsnRGlkw7JtaG5haWNoJywgJ0RpbHVhaW4nLCAnRGltw6BpcnQnLCAnRGljaWFkYWluJywgJ0RpYXJkYW9pbicsICdEaWhhb2luZScsICdEaXNhdGhhaXJuZSddO1xyXG5cclxudmFyIHdlZWtkYXlzU2hvcnQgPSBbJ0RpZCcsICdEaWwnLCAnRGltJywgJ0RpYycsICdEaWEnLCAnRGloJywgJ0RpcyddO1xyXG5cclxudmFyIHdlZWtkYXlzTWluID0gWydEw7InLCAnTHUnLCAnTcOgJywgJ0NpJywgJ0FyJywgJ0hhJywgJ1NhJ107XHJcblxyXG52YXIgZ2QgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdnZCcsIHtcclxuICAgIG1vbnRocyA6IG1vbnRocyxcclxuICAgIG1vbnRoc1Nob3J0IDogbW9udGhzU2hvcnQsXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogd2Vla2RheXMsXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogd2Vla2RheXNTaG9ydCxcclxuICAgIHdlZWtkYXlzTWluIDogd2Vla2RheXNNaW4sXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbQW4tZGl1Z2ggYWlnXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbQS1tw6BpcmVhY2ggYWlnXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYWlnXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbQW4tZMOoIGFpZ10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW3NlbyBjaGFpZGhdIFthaWddIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnYW5uIGFuICVzJyxcclxuICAgICAgICBwYXN0IDogJ2JobyBjaGlvbm4gJXMnLFxyXG4gICAgICAgIHMgOiAnYmVhZ2FuIGRpb2dhbicsXHJcbiAgICAgICAgbSA6ICdtaW9uYWlkJyxcclxuICAgICAgICBtbSA6ICclZCBtaW9uYWlkZWFuJyxcclxuICAgICAgICBoIDogJ3VhaXInLFxyXG4gICAgICAgIGhoIDogJyVkIHVhaXJlYW4nLFxyXG4gICAgICAgIGQgOiAnbGF0aGEnLFxyXG4gICAgICAgIGRkIDogJyVkIGxhdGhhJyxcclxuICAgICAgICBNIDogJ23DrG9zJyxcclxuICAgICAgICBNTSA6ICclZCBtw6xvc2FuJyxcclxuICAgICAgICB5IDogJ2JsaWFkaG5hJyxcclxuICAgICAgICB5eSA6ICclZCBibGlhZGhuYSdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9KGR8bmF8bWgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IG51bWJlciA9PT0gMSA/ICdkJyA6IG51bWJlciAlIDEwID09PSAyID8gJ25hJyA6ICdtaCc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZ2Q7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dkLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogR2FsaWNpYW4gW2dsXVxyXG4vLyEgYXV0aG9yIDogSnVhbiBHLiBIdXJ0YWRvIDogaHR0cHM6Ly9naXRodWIuY29tL2p1YW5naHVydGFkb1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGdsID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZ2wnLCB7XHJcbiAgICBtb250aHMgOiAneGFuZWlyb19mZWJyZWlyb19tYXJ6b19hYnJpbF9tYWlvX3h1w7FvX3h1bGxvX2Fnb3N0b19zZXRlbWJyb19vdXR1YnJvX25vdmVtYnJvX2RlY2VtYnJvJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAneGFuLl9mZWIuX21hci5fYWJyLl9tYWkuX3h1w7EuX3h1bC5fYWdvLl9zZXQuX291dC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2RvbWluZ29fbHVuc19tYXJ0ZXNfbcOpcmNvcmVzX3hvdmVzX3ZlbnJlc19zw6FiYWRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkb20uX2x1bi5fbWFyLl9tw6lyLl94b3YuX3Zlbi5fc8OhYi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdkb19sdV9tYV9tw6lfeG9fdmVfc8OhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW2hveGUgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICfDoXMnIDogJ8OhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0RGF5IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1ttYcOxw6EgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICfDoXMnIDogJ8OhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdkZGRkIFsnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhcycgOiAnYScpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbb250ZSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhJyA6ICdhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbb10gZGRkZCBbcGFzYWRvICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6FzJyA6ICdhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZigndW4nKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICduJyArIHN0cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ2VuICcgKyBzdHI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXN0IDogJ2hhaSAlcycsXHJcbiAgICAgICAgcyA6ICd1bnMgc2VndW5kb3MnLFxyXG4gICAgICAgIG0gOiAndW4gbWludXRvJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dG9zJyxcclxuICAgICAgICBoIDogJ3VuaGEgaG9yYScsXHJcbiAgICAgICAgaGggOiAnJWQgaG9yYXMnLFxyXG4gICAgICAgIGQgOiAndW4gZMOtYScsXHJcbiAgICAgICAgZGQgOiAnJWQgZMOtYXMnLFxyXG4gICAgICAgIE0gOiAndW4gbWVzJyxcclxuICAgICAgICBNTSA6ICclZCBtZXNlcycsXHJcbiAgICAgICAgeSA6ICd1biBhbm8nLFxyXG4gICAgICAgIHl5IDogJyVkIGFub3MnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcclxuICAgIG9yZGluYWwgOiAnJWTCuicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZ2w7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogS29ua2FuaSBMYXRpbiBzY3JpcHQgW2dvbS1sYXRuXVxyXG4vLyEgYXV0aG9yIDogVGhlIERpc2NvdmVyZXIgOiBodHRwczovL2dpdGh1Yi5jb20vV2lraURpc2NvdmVyZXJcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdzJzogWyd0aG9kZGUgc2Vjb25kYW5pbScsICd0aG9kZGUgc2Vjb25kJ10sXHJcbiAgICAgICAgJ20nOiBbJ2VrYSBtaW50YW4nLCAnZWsgbWludXRlJ10sXHJcbiAgICAgICAgJ21tJzogW251bWJlciArICcgbWludGFuaW0nLCBudW1iZXIgKyAnIG1pbnRhbSddLFxyXG4gICAgICAgICdoJzogWydla2EgaG9yYW4nLCAnZWsgaG9yJ10sXHJcbiAgICAgICAgJ2hoJzogW251bWJlciArICcgaG9yYW5pbScsIG51bWJlciArICcgaG9yJ10sXHJcbiAgICAgICAgJ2QnOiBbJ2VrYSBkaXNhbicsICdlayBkaXMnXSxcclxuICAgICAgICAnZGQnOiBbbnVtYmVyICsgJyBkaXNhbmltJywgbnVtYmVyICsgJyBkaXMnXSxcclxuICAgICAgICAnTSc6IFsnZWthIG1ob2luZWFuJywgJ2VrIG1ob2lubyddLFxyXG4gICAgICAgICdNTSc6IFtudW1iZXIgKyAnIG1ob2luZWFuaW0nLCBudW1iZXIgKyAnIG1ob2luZSddLFxyXG4gICAgICAgICd5JzogWydla2Egdm9yc2FuJywgJ2VrIHZvcm9zJ10sXHJcbiAgICAgICAgJ3l5JzogW251bWJlciArICcgdm9yc2FuaW0nLCBudW1iZXIgKyAnIHZvcnNhbSddXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xyXG59XHJcblxyXG52YXIgZ29tTGF0biA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2dvbS1sYXRuJywge1xyXG4gICAgbW9udGhzIDogJ0phbmVyX0ZlYnJlcl9NYXJzX0FicmlsX01haV9KdW5fSnVsYWlfQWdvc3RfU2V0ZW1icl9PdHVicl9Ob3ZlbWJyX0RlemVtYnInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW4uX0ZlYi5fTWFyc19BYnIuX01haV9KdW5fSnVsLl9BZ28uX1NldC5fT3R1Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ0FpdGFyX1NvbWFyX01vbmdsbGFyX0J1ZHZhcl9CcmVzdGFyX1N1a3Jhcl9Tb25cXCd2YXInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0FpdC5fU29tLl9Nb24uX0J1ZC5fQnJlLl9TdWsuX1Nvbi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdBaV9TbV9Nb19CdV9Ccl9TdV9Tbicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0gW3ZhenRhXScsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcyBbdmF6dGFdJyxcclxuICAgICAgICBMIDogJ0RELU1NLVlZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgQSBoOm1tIFt2YXp0YV0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTVthY2hlYV0gRG8sIFlZWVksIEEgaDptbSBbdmF6dGFdJyxcclxuICAgICAgICBsbGxsOiAnZGRkLCBEIE1NTSBZWVlZLCBBIGg6bW0gW3ZhenRhXSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0Fpel0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbRmFsZWFtXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdbSWV0YSB0b10gZGRkZFssXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tLYWxdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1tGYXRsb10gZGRkZFssXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgYWRpbScsXHJcbiAgICAgICAgcyA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbW0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGhoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTU0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHl5IDogcHJvY2Vzc1JlbGF0aXZlVGltZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn0oZXIpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgb3JkaW5hbCAnZXInIG9ubHkgYXBwbGllcyB0byBkYXkgb2YgdGhlIG1vbnRoXHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICdlcic7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC9yYXRpfHNva2FsbGl8ZG9ucGFyYW18c2FuamUvLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdyYXRpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA8IDQgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdzb2thbGxpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnZG9ucGFyYW0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID4gMTIgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdzYW5qZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncmF0aSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzb2thbGxpJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RvbnBhcmFtJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3NhbmplJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3JhdGknO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZ29tTGF0bjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ29tLWxhdG4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ29tLWxhdG4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBHdWphcmF0aSBbZ3VdXHJcbi8vISBhdXRob3IgOiBLYXVzaGlrIFRoYW5raSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9LYXVzaGlrMTk4N1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICAgICAnMSc6ICfgq6cnLFxyXG4gICAgICAgICcyJzogJ+CrqCcsXHJcbiAgICAgICAgJzMnOiAn4KupJyxcclxuICAgICAgICAnNCc6ICfgq6onLFxyXG4gICAgICAgICc1JzogJ+CrqycsXHJcbiAgICAgICAgJzYnOiAn4KusJyxcclxuICAgICAgICAnNyc6ICfgq60nLFxyXG4gICAgICAgICc4JzogJ+CrricsXHJcbiAgICAgICAgJzknOiAn4KuvJyxcclxuICAgICAgICAnMCc6ICfgq6YnXHJcbiAgICB9O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgICAgICfgq6cnOiAnMScsXHJcbiAgICAgICAgJ+CrqCc6ICcyJyxcclxuICAgICAgICAn4KupJzogJzMnLFxyXG4gICAgICAgICfgq6onOiAnNCcsXHJcbiAgICAgICAgJ+Crqyc6ICc1JyxcclxuICAgICAgICAn4KusJzogJzYnLFxyXG4gICAgICAgICfgq60nOiAnNycsXHJcbiAgICAgICAgJ+Crric6ICc4JyxcclxuICAgICAgICAn4KuvJzogJzknLFxyXG4gICAgICAgICfgq6YnOiAnMCdcclxuICAgIH07XHJcblxyXG52YXIgZ3UgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdndScsIHtcclxuICAgIG1vbnRoczogJ+CqnOCqvuCqqOCrjeCqr+CrgeCqhuCqsOCrgF/gqqvgq4fgqqzgq43gqrDgq4HgqobgqrDgq4Bf4Kqu4Kq+4Kqw4KuN4KqaX+Cqj+CqquCrjeCqsOCqv+Cqsl/gqq7gq4df4Kqc4KuC4KqoX+CqnOCrgeCqsuCqvuCqiF/gqpHgqpfgqrjgq43gqp9f4Kq44Kqq4KuN4Kqf4KuH4Kqu4KuN4Kqs4KqwX+CqkeCqleCrjeCqn+CrjeCqrOCqsF/gqqjgqrXgq4fgqq7gq43gqqzgqrBf4Kqh4Kq/4Kq44KuH4Kqu4KuN4Kqs4KqwJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICfgqpzgqr7gqqjgq43gqq/gq4EuX+Cqq+Crh+CqrOCrjeCqsOCrgS5f4Kqu4Kq+4Kqw4KuN4KqaX+Cqj+CqquCrjeCqsOCqvy5f4Kqu4KuHX+CqnOCrguCqqF/gqpzgq4HgqrLgqr4uX+CqkeCqly5f4Kq44Kqq4KuN4Kqf4KuHLl/gqpHgqpXgq43gqp/gq40uX+CqqOCqteCrhy5f4Kqh4Kq/4Kq44KuHLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5czogJ+CqsOCqteCqv+CqteCqvuCqsF/gqrjgq4vgqq7gqrXgqr7gqrBf4Kqu4KqC4KqX4Kqz4Kq14Kq+4KqwX+CqrOCrgeCqp+CrjeCqteCqvuCqsF/gqpfgq4HgqrDgq4HgqrXgqr7gqrBf4Kq24KuB4KqV4KuN4Kqw4Kq14Kq+4KqwX+CqtuCqqOCqv+CqteCqvuCqsCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICfgqrDgqrXgqr9f4Kq44KuL4KquX+CqruCqguCql+Cqs1/gqqzgq4Hgqqfgq41f4KqX4KuB4Kqw4KuBX+CqtuCrgeCqleCrjeCqsF/gqrbgqqjgqr8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ+CqsF/gqrjgq4tf4Kqu4KqCX+CqrOCrgV/gqpfgq4Ff4Kq24KuBX+Cqticuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdBIGg6bW0g4Kq14Kq+4KqX4KuN4Kqv4KuHJyxcclxuICAgICAgICBMVFM6ICdBIGg6bW06c3Mg4Kq14Kq+4KqX4KuN4Kqv4KuHJyxcclxuICAgICAgICBMOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgqrXgqr7gqpfgq43gqq/gq4cnLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCqteCqvuCql+CrjeCqr+CrhydcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb4KqG4KqcXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vgqpXgqr7gqrLgq4ddIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQsIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW+Cql+Cqh+CqleCqvuCqsuCrh10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW+CqquCqvuCqm+CqsuCqvl0gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWU6IHtcclxuICAgICAgICBmdXR1cmU6ICclcyDgqq7gqr4nLFxyXG4gICAgICAgIHBhc3Q6ICclcyDgqqrgq4fgqrngqrLgqr4nLFxyXG4gICAgICAgIHM6ICfgqoXgqq7gq4HgqpUg4Kqq4Kqz4KuLJyxcclxuICAgICAgICBtOiAn4KqP4KqVIOCqruCqv+CqqOCqv+CqnycsXHJcbiAgICAgICAgbW06ICclZCDgqq7gqr/gqqjgqr/gqp8nLFxyXG4gICAgICAgIGg6ICfgqo/gqpUg4KqV4Kqy4Kq+4KqVJyxcclxuICAgICAgICBoaDogJyVkIOCqleCqsuCqvuCqlScsXHJcbiAgICAgICAgZDogJ+Cqj+CqlSDgqqbgqr/gqrXgqrgnLFxyXG4gICAgICAgIGRkOiAnJWQg4Kqm4Kq/4Kq14Kq4JyxcclxuICAgICAgICBNOiAn4KqP4KqVIOCqruCqueCqv+CqqOCriycsXHJcbiAgICAgICAgTU06ICclZCDgqq7gqrngqr/gqqjgq4snLFxyXG4gICAgICAgIHk6ICfgqo/gqpUg4Kq14Kqw4KuN4Kq3JyxcclxuICAgICAgICB5eTogJyVkIOCqteCqsOCrjeCqtydcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Crp+CrqOCrqeCrquCrq+CrrOCrreCrruCrr+Crpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gR3VqYXJhdGkgbm90YXRpb24gZm9yIG1lcmlkaWVtcyBhcmUgcXVpdGUgZnV6enkgaW4gcHJhY3RpY2UuIFdoaWxlIHRoZXJlIGV4aXN0c1xyXG4gICAgLy8gYSByaWdpZCBub3Rpb24gb2YgYSAnUGFoYXInIGl0IGlzIG5vdCB1c2VkIGFzIHJpZ2lkbHkgaW4gbW9kZXJuIEd1amFyYXRpLlxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+CqsOCqvuCqpHzgqqzgqqrgq4vgqrB84Kq44Kq14Kq+4KqwfOCquOCqvuCqguCqnC8sXHJcbiAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4Kqw4Kq+4KqkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA8IDQgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqrjgqrXgqr7gqrAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqqzgqqrgq4vgqrAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4Kq44Kq+4KqC4KqcJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbTogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CqsOCqvuCqpCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqrjgqrXgqr7gqrAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kqs4Kqq4KuL4KqwJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CquOCqvuCqguCqnCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqrDgqr7gqqQnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrOiB7XHJcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3k6IDYgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBndTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ3UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ3UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBIZWJyZXcgW2hlXVxyXG4vLyEgYXV0aG9yIDogVG9tZXIgQ29oZW4gOiBodHRwczovL2dpdGh1Yi5jb20vdG9tZXJcclxuLy8hIGF1dGhvciA6IE1vc2hlIFNpbWFudG92IDogaHR0cHM6Ly9naXRodWIuY29tL0RldmVsb3BtZW50SUxcclxuLy8hIGF1dGhvciA6IFRhbCBBdGVyIDogaHR0cHM6Ly9naXRodWIuY29tL1RhbEF0ZXJcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBoZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2hlJywge1xyXG4gICAgbW9udGhzIDogJ9eZ16DXldeQ16hf16TXkdeo15XXkNeoX9ee16jXpV/XkNek16jXmdecX9ee15DXmV/XmdeV16DXmV/XmdeV15zXmV/XkNeV15LXldeh15hf16HXpNeY157XkdeoX9eQ15XXp9eY15XXkdeoX9eg15XXkdee15HXqF/Xk9em157XkdeoJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn15nXoNeV17Nf16TXkdeo17Nf157XqNelX9eQ16TXqNezX9ee15DXmV/XmdeV16DXmV/XmdeV15zXmV/XkNeV15LXs1/Xodek15jXs1/XkNeV16fXs1/XoNeV15HXs1/Xk9em157Xsycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9eo15DXqdeV159f16nXoNeZX9ep15zXmdep15lf16jXkdeZ16LXmV/Xl9ee15nXqdeZX9ep15nXqdeZX9ep15HXqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn15DXs1/XkdezX9eS17Nf15PXs1/XlNezX9eV17Nf16nXsycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9eQX9eRX9eSX9eTX9eUX9eVX9epJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIFvXkV1NTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIFvXkV1NTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBb15FdTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBsIDogJ0QvTS9ZWVlZJyxcclxuICAgICAgICBsbCA6ICdEIE1NTSBZWVlZJyxcclxuICAgICAgICBsbGwgOiAnRCBNTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdkZGQsIEQgTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb15TXmdeV150g15HWvl1MVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb157Xl9eoINeR1r5dTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW9eR16nXoteUXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb15DXqtee15XXnCDXkda+XUxUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb15HXmdeV151dIGRkZGQgW9eU15DXl9eo15XXnyDXkdep16LXlF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfXkdei15XXkyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfXnNek16DXmSAlcycsXHJcbiAgICAgICAgcyA6ICfXnteh16TXqCDXqdeg15nXldeqJyxcclxuICAgICAgICBtIDogJ9eT16fXlCcsXHJcbiAgICAgICAgbW0gOiAnJWQg15PXp9eV16onLFxyXG4gICAgICAgIGggOiAn16nXoteUJyxcclxuICAgICAgICBoaCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICfXqdei16rXmdeZ150nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnINep16LXldeqJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGQgOiAn15nXldedJyxcclxuICAgICAgICBkZCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICfXmdeV157XmdeZ150nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnINeZ157XmdedJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIE0gOiAn15fXldeT16knLFxyXG4gICAgICAgIE1NIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9eX15XXk9ep15nXmdedJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXl9eV15PXqdeZ150nO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeSA6ICfXqdeg15QnLFxyXG4gICAgICAgIHl5IDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9ep16DXqteZ15nXnSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyICUgMTAgPT09IDAgJiYgbnVtYmVyICE9PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg16nXoNeUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXqdeg15nXnSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/XkNeX15RcItemfNec16TXoNeUXCLXpnzXkNeX16jXmSDXlNem15TXqNeZ15nXnXzXnNek16DXmSDXlNem15TXqNeZ15nXnXzXnNek16DXldeqINeR15XXp9eofNeR15HXlden16h815HXoteo15EvaSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL14o15DXl9eUXCLXpnzXkNeX16jXmSDXlNem15TXqNeZ15nXnXzXkdei16jXkSkkLy50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfXnNek16DXldeqINeR15XXp9eoJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9eR15HXlden16gnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ9ec16TXoNeUXCLXpicgOiAn15zXpNeg15kg15TXpteU16jXmdeZ150nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ9eQ15fXlFwi16YnIDogJ9eQ15fXqNeZINeU16bXlNeo15nXmdedJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9eR16LXqNeRJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGhlO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEhpbmRpIFtoaV1cclxuLy8hIGF1dGhvciA6IE1heWFuayBTaW5naGFsIDogaHR0cHM6Ly9naXRodWIuY29tL21heWFua3NpbmdoYWxcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgpacnLFxyXG4gICAgJzInOiAn4KWoJyxcclxuICAgICczJzogJ+ClqScsXHJcbiAgICAnNCc6ICfgpaonLFxyXG4gICAgJzUnOiAn4KWrJyxcclxuICAgICc2JzogJ+ClrCcsXHJcbiAgICAnNyc6ICfgpa0nLFxyXG4gICAgJzgnOiAn4KWuJyxcclxuICAgICc5JzogJ+ClrycsXHJcbiAgICAnMCc6ICfgpaYnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4KWnJzogJzEnLFxyXG4gICAgJ+ClqCc6ICcyJyxcclxuICAgICfgpaknOiAnMycsXHJcbiAgICAn4KWqJzogJzQnLFxyXG4gICAgJ+Clqyc6ICc1JyxcclxuICAgICfgpawnOiAnNicsXHJcbiAgICAn4KWtJzogJzcnLFxyXG4gICAgJ+Clric6ICc4JyxcclxuICAgICfgpa8nOiAnOScsXHJcbiAgICAn4KWmJzogJzAnXHJcbn07XHJcblxyXG52YXIgaGkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdoaScsIHtcclxuICAgIG1vbnRocyA6ICfgpJzgpKjgpLXgpLDgpYBf4KSr4KS84KSw4KS14KSw4KWAX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpYjgpLJf4KSu4KSIX+CknOClguCkqF/gpJzgpYHgpLLgpL7gpIhf4KSF4KSX4KS44KWN4KSkX+CkuOCkv+CkpOCkruCljeCkrOCksF/gpIXgpJXgpY3gpJ/gpYLgpKzgpLBf4KSo4KS14KSu4KWN4KSs4KSwX+CkpuCkv+CkuOCkruCljeCkrOCksCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+CknOCkqC5f4KSr4KS84KSwLl/gpK7gpL7gpLDgpY3gpJpf4KSF4KSq4KWN4KSw4KWILl/gpK7gpIhf4KSc4KWC4KSoX+CknOClgeCksi5f4KSF4KSXLl/gpLjgpL/gpKQuX+CkheCkleCljeCkn+Clgi5f4KSo4KS1Ll/gpKbgpL/gpLguJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ+CksOCkteCkv+CkteCkvuCksF/gpLjgpYvgpK7gpLXgpL7gpLBf4KSu4KSC4KSX4KSy4KS14KS+4KSwX+CkrOClgeCkp+CkteCkvuCksF/gpJfgpYHgpLDgpYLgpLXgpL7gpLBf4KS24KWB4KSV4KWN4KSw4KS14KS+4KSwX+CktuCkqOCkv+CkteCkvuCksCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4KSw4KS14KS/X+CkuOCli+Ckrl/gpK7gpILgpJfgpLJf4KSs4KWB4KSnX+Ckl+ClgeCksOClgl/gpLbgpYHgpJXgpY3gpLBf4KS24KSo4KS/Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn4KSwX+CkuOCli1/gpK7gpIJf4KSs4KWBX+Ckl+ClgV/gpLbgpYFf4KS2Jy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnQSBoOm1tIOCkrOCknOClhycsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcyDgpKzgpJzgpYcnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tIOCkrOCknOClhycsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCkrOCknOClhydcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgpIbgpJxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgpJXgpLJdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4KSV4KSyXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+CkquCkv+Ckm+CksuClh10gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDgpK7gpYfgpIInLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4KSq4KS54KSy4KWHJyxcclxuICAgICAgICBzIDogJ+CkleClgeCkmyDgpLngpYAg4KSV4KWN4KS34KSjJyxcclxuICAgICAgICBtIDogJ+Ckj+CklSDgpK7gpL/gpKjgpJ8nLFxyXG4gICAgICAgIG1tIDogJyVkIOCkruCkv+CkqOCknycsXHJcbiAgICAgICAgaCA6ICfgpI/gpJUg4KSY4KSC4KSf4KS+JyxcclxuICAgICAgICBoaCA6ICclZCDgpJjgpILgpJ/gpYcnLFxyXG4gICAgICAgIGQgOiAn4KSP4KSVIOCkpuCkv+CkqCcsXHJcbiAgICAgICAgZGQgOiAnJWQg4KSm4KS/4KSoJyxcclxuICAgICAgICBNIDogJ+Ckj+CklSDgpK7gpLngpYDgpKjgpYcnLFxyXG4gICAgICAgIE1NIDogJyVkIOCkruCkueClgOCkqOClhycsXHJcbiAgICAgICAgeSA6ICfgpI/gpJUg4KS14KSw4KWN4KS3JyxcclxuICAgICAgICB5eSA6ICclZCDgpLXgpLDgpY3gpLcnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgpafgpajgpangpargpavgpazgpa3gpa7gpa/gpaZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIEhpbmRpIG5vdGF0aW9uIGZvciBtZXJpZGllbXMgYXJlIHF1aXRlIGZ1enp5IGluIHByYWN0aWNlLiBXaGlsZSB0aGVyZSBleGlzdHNcclxuICAgIC8vIGEgcmlnaWQgbm90aW9uIG9mIGEgJ1BhaGFyJyBpdCBpcyBub3QgdXNlZCBhcyByaWdpZGx5IGluIG1vZGVybiBIaW5kaS5cclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gpLDgpL7gpKR84KS44KWB4KSs4KS5fOCkpuCli+CkquCkueCksHzgpLbgpL7gpK4vLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgpLDgpL7gpKQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkuOClgeCkrOCkuScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkpuCli+CkquCkueCksCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLbgpL7gpK4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpLjgpYHgpKzgpLknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KSm4KWL4KSq4KS54KSwJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CktuCkvuCkric7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKQnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaGk7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ3JvYXRpYW4gW2hyXVxyXG4vLyEgYXV0aG9yIDogQm9qYW4gTWFya292acSHIDogaHR0cHM6Ly9naXRodWIuY29tL2JtYXJrb3ZpY1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnamVkbmEgbWludXRhJyA6ICdqZWRuZSBtaW51dGUnO1xyXG4gICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGEnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0ZSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0YSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnamVkYW4gc2F0JyA6ICdqZWRub2cgc2F0YSc7XHJcbiAgICAgICAgY2FzZSAnaGgnOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0YSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdGknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnZGQnOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2Rhbic7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2RhbmEnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnTU0nOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlYyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWplc2VjYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2knO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5lJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5hJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgaHIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdocicsIHtcclxuICAgIG1vbnRocyA6IHtcclxuICAgICAgICBmb3JtYXQ6ICdzaWplxI1uamFfdmVsamHEjWVfb8W+dWprYV90cmF2bmphX3N2aWJuamFfbGlwbmphX3NycG5qYV9rb2xvdm96YV9ydWpuYV9saXN0b3BhZGFfc3R1ZGVub2dhX3Byb3NpbmNhJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHN0YW5kYWxvbmU6ICdzaWplxI1hbmpfdmVsamHEjWFfb8W+dWpha190cmF2YW5qX3N2aWJhbmpfbGlwYW5qX3NycGFual9rb2xvdm96X3J1amFuX2xpc3RvcGFkX3N0dWRlbmlfcHJvc2luYWMnLnNwbGl0KCdfJylcclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6ICdzaWouX3ZlbGouX2/FvnUuX3RyYS5fc3ZpLl9saXAuX3NycC5fa29sLl9ydWouX2xpcy5fc3R1Ll9wcm8uJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ25lZGplbGphX3BvbmVkamVsamFrX3V0b3Jha19zcmlqZWRhX8SNZXR2cnRha19wZXRha19zdWJvdGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ25lZC5fcG9uLl91dG8uX3NyaS5fxI1ldC5fcGV0Ll9zdWIuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnbmVfcG9fdXRfc3JfxI1lX3BlX3N1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgIDogJ1tkYW5hcyB1XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSAgOiAnW3N1dHJhIHVdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGplbGp1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmlqZWR1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWVyIHVdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsdV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Byb8WhbGVdIFtzdWJvdGVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsaV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxyXG4gICAgICAgIHBhc3QgICA6ICdwcmlqZSAlcycsXHJcbiAgICAgICAgcyAgICAgIDogJ3BhciBzZWt1bmRpJyxcclxuICAgICAgICBtICAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGggICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZCAgICAgIDogJ2RhbicsXHJcbiAgICAgICAgZGQgICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gICAgICA6ICdtamVzZWMnLFxyXG4gICAgICAgIE1NICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5ICAgICAgOiAnZ29kaW51JyxcclxuICAgICAgICB5eSAgICAgOiB0cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGhyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEh1bmdhcmlhbiBbaHVdXHJcbi8vISBhdXRob3IgOiBBZGFtIEJydW5uZXIgOiBodHRwczovL2dpdGh1Yi5jb20vYWRhbWJydW5uZXJcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB3ZWVrRW5kaW5ncyA9ICd2YXPDoXJuYXAgaMOpdGbFkW4ga2VkZGVuIHN6ZXJkw6FuIGNzw7x0w7ZydMO2a8O2biBww6ludGVrZW4gc3pvbWJhdG9uJy5zcGxpdCgnICcpO1xyXG5mdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgbnVtID0gbnVtYmVyLFxyXG4gICAgICAgIHN1ZmZpeDtcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgIHJldHVybiAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCkgPyAnbsOpaMOhbnkgbcOhc29kcGVyYycgOiAnbsOpaMOhbnkgbcOhc29kcGVyY2UnO1xyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgcGVyYycgOiAnIHBlcmNlJyk7XHJcbiAgICAgICAgY2FzZSAnbW0nOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIHBlcmMnIDogJyBwZXJjZScpO1xyXG4gICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw7NyYScgOiAnIMOzcsOhamEnKTtcclxuICAgICAgICBjYXNlICdoaCc6XHJcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw7NyYScgOiAnIMOzcsOhamEnKTtcclxuICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgcmV0dXJuICdlZ3knICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIG5hcCcgOiAnIG5hcGphJyk7XHJcbiAgICAgICAgY2FzZSAnZGQnOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIG5hcCcgOiAnIG5hcGphJyk7XHJcbiAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnZWd5JyArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyBow7NuYXAnIDogJyBow7NuYXBqYScpO1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bSArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyBow7NuYXAnIDogJyBow7NuYXBqYScpO1xyXG4gICAgICAgIGNhc2UgJ3knOlxyXG4gICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgw6l2JyA6ICcgw6l2ZScpO1xyXG4gICAgICAgIGNhc2UgJ3l5JzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bSArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyDDqXYnIDogJyDDqXZlJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuZnVuY3Rpb24gd2Vlayhpc0Z1dHVyZSkge1xyXG4gICAgcmV0dXJuIChpc0Z1dHVyZSA/ICcnIDogJ1ttw7psdF0gJykgKyAnWycgKyB3ZWVrRW5kaW5nc1t0aGlzLmRheSgpXSArICddIExUWy1rb3JdJztcclxufVxyXG5cclxudmFyIGh1ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaHUnLCB7XHJcbiAgICBtb250aHMgOiAnamFudcOhcl9mZWJydcOhcl9tw6FyY2l1c1/DoXByaWxpc19tw6FqdXNfasO6bml1c19qw7psaXVzX2F1Z3VzenR1c19zemVwdGVtYmVyX29rdMOzYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tw6FyY1/DoXByX23DoWpfasO6bl9qw7psX2F1Z19zemVwdF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3Zhc8Ohcm5hcF9ow6l0ZsWRX2tlZGRfc3plcmRhX2Nzw7x0w7ZydMO2a19ww6ludGVrX3N6b21iYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3Zhc19ow6l0X2tlZGRfc3plX2Nzw7x0X3DDqW5fc3pvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAndl9oX2tfc3plX2NzX3Bfc3pvJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS5NTS5ERC4nLFxyXG4gICAgICAgIExMIDogJ1lZWVkuIE1NTU0gRC4nLFxyXG4gICAgICAgIExMTCA6ICdZWVlZLiBNTU1NIEQuIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnWVlZWS4gTU1NTSBELiwgZGRkZCBIOm1tJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC9kZXxkdS9pLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAndSc7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA9PT0gdHJ1ZSA/ICdkZScgOiAnREUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID09PSB0cnVlID8gJ2R1JyA6ICdEVSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW21hXSBMVFsta29yXScsXHJcbiAgICAgICAgbmV4dERheSA6ICdbaG9sbmFwXSBMVFsta29yXScsXHJcbiAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrLmNhbGwodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5IDogJ1t0ZWduYXBdIExUWy1rb3JdJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdlZWsuY2FsbCh0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMgbcO6bHZhJyxcclxuICAgICAgICBwYXN0IDogJyVzJyxcclxuICAgICAgICBzIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGRkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTU0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaHU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h1LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h1LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQXJtZW5pYW4gW2h5LWFtXVxyXG4vLyEgYXV0aG9yIDogQXJtZW5kYXJhYnlhbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcm1lbmRhcmFieWFuXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgaHlBbSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2h5LWFtJywge1xyXG4gICAgbW9udGhzIDoge1xyXG4gICAgICAgIGZvcm1hdDogJ9Ww1bjWgtW21b7VodaA1atf1oPVpdW/1oDVvtWh1oDVq1/VtNWh1oDVv9WrX9Wh1brWgNWr1azVq1/VtNWh1bXVq9W91atf1bDVuNaC1bbVq9W91atf1bDVuNaC1azVq9W91atf1oXVo9W41b3Vv9W41b3Vq1/VvdWl1brVv9Wl1bTVotWl1oDVq1/VsNW41a/Vv9Wl1bTVotWl1oDVq1/VttW41bXVpdW01aLVpdaA1atf1aTVpdWv1b/VpdW01aLVpdaA1asnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ9Ww1bjWgtW21b7VodaAX9aD1aXVv9aA1b7VodaAX9W01aHWgNW/X9Wh1brWgNWr1axf1bTVodW11avVvV/VsNW41oLVttWr1b1f1bDVuNaC1azVq9W9X9aF1aPVuNW91b/VuNW9X9W91aXVutW/1aXVtNWi1aXWgF/VsNW41a/Vv9Wl1bTVotWl1oBf1bbVuNW11aXVtNWi1aXWgF/VpNWl1a/Vv9Wl1bTVotWl1oAnLnNwbGl0KCdfJylcclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6ICfVsNW21b5f1oPVv9aAX9W01oDVv1/VodW61oBf1bTVtdW9X9Ww1bbVvV/VsNWs1b1f1oXVo9W9X9W91brVv1/VsNWv1b9f1bbVtNWiX9Wk1a/Vvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9Wv1avWgNWh1a/Vq1/VpdaA1a/VuNaC1bfVodWi1anVq1/VpdaA1aXWhNW31aHVotWp1atf1bnVuNaA1aXWhNW31aHVotWp1atf1bDVq9W21aPVt9Wh1aLVqdWrX9W41oLWgNWi1aHVqV/Vt9Wh1aLVodWpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfVr9aA1a9f1aXWgNWvX9Wl1oDWhF/VudaA1oRf1bDVttWjX9W41oLWgNWiX9W31aLVqScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9Wv1oDVr1/VpdaA1a9f1aXWgNaEX9W51oDWhF/VsNW21aNf1bjWgtaA1aJf1bfVotWpJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWSDVqS4nLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSDVqS4sIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZINWpLiwgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vVodW11b3WhdaAXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vVvtWh1bLVqF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb1aXWgNWl1a9dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQgW9aF1oDVqCDVqtWh1bTVqF0gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdb1aHVttaB1aHVrl0gZGRkZCBb1oXWgNWoINWq1aHVtNWoXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDVsNWl1b/VuCcsXHJcbiAgICAgICAgcGFzdCA6ICclcyDVodW81aHVuycsXHJcbiAgICAgICAgcyA6ICfVtNWrINaE1aHVttWrINW+1aHVtdaA1a/VtdWh1bYnLFxyXG4gICAgICAgIG0gOiAn1oDVuNW61aUnLFxyXG4gICAgICAgIG1tIDogJyVkINaA1bjVutWlJyxcclxuICAgICAgICBoIDogJ9Wq1aHVtCcsXHJcbiAgICAgICAgaGggOiAnJWQg1arVodW0JyxcclxuICAgICAgICBkIDogJ9aF1oAnLFxyXG4gICAgICAgIGRkIDogJyVkINaF1oAnLFxyXG4gICAgICAgIE0gOiAn1aHVtNWr1b0nLFxyXG4gICAgICAgIE1NIDogJyVkINWh1bTVq9W9JyxcclxuICAgICAgICB5IDogJ9W/1aHWgNWrJyxcclxuICAgICAgICB5eSA6ICclZCDVv9Wh1oDVqydcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv1aPVq9W31aXWgNW+1aF81aHVvNWh1b7VuNW/1b7VoXzWgdWl1oDVpdWv1b7VoXzVpdaA1aXVr9W41bXVodW2LyxcclxuICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAvXijWgdWl1oDVpdWv1b7VoXzVpdaA1aXVr9W41bXVodW2KSQvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfVo9Wr1bfVpdaA1b7VoSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfVodW81aHVvtW41b/VvtWhJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9aB1aXWgNWl1a/VvtWhJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9Wl1oDVpdWv1bjVtdWh1bYnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn18XFxkezEsMn0tKNWr1bZ81oDVpCkvLFxyXG4gICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICBjYXNlICdERERvJzpcclxuICAgICAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Vq9W2JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdaA1aQnO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGh5QW07XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogSW5kb25lc2lhbiBbaWRdXHJcbi8vISBhdXRob3IgOiBNb2hhbW1hZCBTYXRyaW8gVXRvbW8gOiBodHRwczovL2dpdGh1Yi5jb20vdHlva1xyXG4vLyEgcmVmZXJlbmNlOiBodHRwOi8vaWQud2lraXNvdXJjZS5vcmcvd2lraS9QZWRvbWFuX1VtdW1fRWphYW5fQmFoYXNhX0luZG9uZXNpYV95YW5nX0Rpc2VtcHVybmFrYW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBpZCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2lkJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcmlfRmVicnVhcmlfTWFyZXRfQXByaWxfTWVpX0p1bmlfSnVsaV9BZ3VzdHVzX1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0Rlc2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01laV9KdW5fSnVsX0Fnc19TZXBfT2t0X05vdl9EZXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdNaW5nZ3VfU2VuaW5fU2VsYXNhX1JhYnVfS2FtaXNfSnVtYXRfU2FidHUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ01pbl9TZW5fU2VsX1JhYl9LYW1fSnVtX1NhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ01nX1NuX1NsX1JiX0ttX0ptX1NiJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEgubW0nLFxyXG4gICAgICAgIExUUyA6ICdISC5tbS5zcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvcGFnaXxzaWFuZ3xzb3JlfG1hbGFtLyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAncGFnaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NpYW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NvcmUnIHx8IG1lcmlkaWVtID09PSAnbWFsYW0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzIDwgMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdwYWdpJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzaWFuZyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc29yZSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtYWxhbSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0hhcmkgaW5pIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbQmVzb2sgcHVrdWxdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtwdWt1bF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0tlbWFyaW4gcHVrdWxdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtsYWx1IHB1a3VsXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhbGFtICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIHlhbmcgbGFsdScsXHJcbiAgICAgICAgcyA6ICdiZWJlcmFwYSBkZXRpaycsXHJcbiAgICAgICAgbSA6ICdzZW1lbml0JyxcclxuICAgICAgICBtbSA6ICclZCBtZW5pdCcsXHJcbiAgICAgICAgaCA6ICdzZWphbScsXHJcbiAgICAgICAgaGggOiAnJWQgamFtJyxcclxuICAgICAgICBkIDogJ3NlaGFyaScsXHJcbiAgICAgICAgZGQgOiAnJWQgaGFyaScsXHJcbiAgICAgICAgTSA6ICdzZWJ1bGFuJyxcclxuICAgICAgICBNTSA6ICclZCBidWxhbicsXHJcbiAgICAgICAgeSA6ICdzZXRhaHVuJyxcclxuICAgICAgICB5eSA6ICclZCB0YWh1bidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaWQ7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogSWNlbGFuZGljIFtpc11cclxuLy8hIGF1dGhvciA6IEhpbnJpayDDlnJuIFNpZ3Vyw7Bzc29uIDogaHR0cHM6Ly9naXRodWIuY29tL2hpbnJpa1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcGx1cmFsKG4pIHtcclxuICAgIGlmIChuICUgMTAwID09PSAxMSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChuICUgMTAgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbm9ra3JhciBzZWvDum5kdXInIDogJ25va2tydW0gc2Vrw7puZHVtJztcclxuICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnbcOtbsO6dGEnIDogJ23DrW7DunR1JztcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ23DrW7DunR1cicgOiAnbcOtbsO6dHVtJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw61uw7p0YSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw61uw7p0dSc7XHJcbiAgICAgICAgY2FzZSAnaGgnOlxyXG4gICAgICAgICAgICBpZiAocGx1cmFsKG51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdrbHVra3VzdHVuZGlyJyA6ICdrbHVra3VzdHVuZHVtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdrbHVra3VzdHVuZCc7XHJcbiAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RhZ3VyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAnZGFnJyA6ICdkZWdpJztcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2RhZ2FyJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnZGFnYScgOiAnZMO2Z3VtJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdkYWd1cic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChpc0Z1dHVyZSA/ICdkYWcnIDogJ2RlZ2knKTtcclxuICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnbcOhbnXDsHVyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAnbcOhbnXDsCcgOiAnbcOhbnXDsGknO1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICAgICAgaWYgKHBsdXJhbChudW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcOhbnXDsGlyJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnbcOhbnXDsGknIDogJ23DoW51w7B1bScpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcOhbnXDsHVyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGlzRnV0dXJlID8gJ23DoW51w7AnIDogJ23DoW51w7BpJyk7XHJcbiAgICAgICAgY2FzZSAneSc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ8OhcicgOiAnw6FyaSc7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICBpZiAocGx1cmFsKG51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICfDoXInIDogJ8OhcnVtJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ8OhcicgOiAnw6FyaScpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgaXMgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdpcycsIHtcclxuICAgIG1vbnRocyA6ICdqYW7DumFyX2ZlYnLDumFyX21hcnNfYXByw61sX21hw61fasO6bsOtX2rDumzDrV/DoWfDunN0X3NlcHRlbWJlcl9va3TDs2Jlcl9uw7N2ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWHDrV9qw7puX2rDumxfw6Fnw7pfc2VwX29rdF9uw7N2X2Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3N1bm51ZGFndXJfbcOhbnVkYWd1cl/DvnJpw7BqdWRhZ3VyX21pw7B2aWt1ZGFndXJfZmltbXR1ZGFndXJfZsO2c3R1ZGFndXJfbGF1Z2FyZGFndXInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3N1bl9tw6FuX8O+cmlfbWnDsF9maW1fZsO2c19sYXUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nw6Ffw55yX01pX0ZpX0bDtl9MYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBba2wuXSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBba2wuXSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW8OtIGRhZyBrbC5dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vDoSBtb3JndW4ga2wuXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBba2wuXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbw60gZ8OmciBrbC5dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbc8Otw7Bhc3RhXSBkZGRkIFtrbC5dIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnZWZ0aXIgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnZnlyaXIgJXMgc8Otw7BhbicsXHJcbiAgICAgICAgcyA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG1tIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGggOiAna2x1a2t1c3R1bmQnLFxyXG4gICAgICAgIGhoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5IDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHl5IDogdHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBpcztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBJdGFsaWFuIFtpdF1cclxuLy8hIGF1dGhvciA6IExvcmVuem8gOiBodHRwczovL2dpdGh1Yi5jb20vYWxpZW1cclxuLy8hIGF1dGhvcjogTWF0dGlhIExhcmVudGlzOiBodHRwczovL2dpdGh1Yi5jb20vbm9zdGFsZ2lhelxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGl0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaXQnLCB7XHJcbiAgICBtb250aHMgOiAnZ2VubmFpb19mZWJicmFpb19tYXJ6b19hcHJpbGVfbWFnZ2lvX2dpdWdub19sdWdsaW9fYWdvc3RvX3NldHRlbWJyZV9vdHRvYnJlX25vdmVtYnJlX2RpY2VtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnZ2VuX2ZlYl9tYXJfYXByX21hZ19naXVfbHVnX2Fnb19zZXRfb3R0X25vdl9kaWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdkb21lbmljYV9sdW5lZMOsX21hcnRlZMOsX21lcmNvbGVkw6xfZ2lvdmVkw6xfdmVuZXJkw6xfc2FiYXRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkb21fbHVuX21hcl9tZXJfZ2lvX3Zlbl9zYWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdkb19sdV9tYV9tZV9naV92ZV9zYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW09nZ2kgYWxsZV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbRG9tYW5pIGFsbGVdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2FsbGVdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW0llcmkgYWxsZV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2xhIHNjb3JzYV0gZGRkZCBbYWxsZV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tsbyBzY29yc29dIGRkZGQgW2FsbGVdIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCgvXlswLTldLiskLykudGVzdChzKSA/ICd0cmEnIDogJ2luJykgKyAnICcgKyBzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFzdCA6ICclcyBmYScsXHJcbiAgICAgICAgcyA6ICdhbGN1bmkgc2Vjb25kaScsXHJcbiAgICAgICAgbSA6ICd1biBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0aScsXHJcbiAgICAgICAgaCA6ICd1blxcJ29yYScsXHJcbiAgICAgICAgaGggOiAnJWQgb3JlJyxcclxuICAgICAgICBkIDogJ3VuIGdpb3JubycsXHJcbiAgICAgICAgZGQgOiAnJWQgZ2lvcm5pJyxcclxuICAgICAgICBNIDogJ3VuIG1lc2UnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2knLFxyXG4gICAgICAgIHkgOiAndW4gYW5ubycsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5uaSdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9wrovLFxyXG4gICAgb3JkaW5hbDogJyVkwronLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGl0O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEphcGFuZXNlIFtqYV1cclxuLy8hIGF1dGhvciA6IExJIExvbmcgOiBodHRwczovL2dpdGh1Yi5jb20vYmFyeW9uXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgamEgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdqYScsIHtcclxuICAgIG1vbnRocyA6ICcx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn5pel5puc5pelX+aciOabnOaXpV/ngavmm5zml6Vf5rC05puc5pelX+acqOabnOaXpV/ph5Hmm5zml6Vf5Zyf5puc5pelJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfml6Vf5pyIX+eBq1/msLRf5pyoX+mHkV/lnJ8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfml6Vf5pyIX+eBq1/msLRf5pyoX+mHkV/lnJ8nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVkvTU0vREQnLFxyXG4gICAgICAgIExMIDogJ1lZWVnlubRN5pyIROaXpScsXHJcbiAgICAgICAgTExMIDogJ1lZWVnlubRN5pyIROaXpSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdZWVlZ5bm0TeaciETml6UgSEg6bW0gZGRkZCcsXHJcbiAgICAgICAgbCA6ICdZWVlZL01NL0REJyxcclxuICAgICAgICBsbCA6ICdZWVlZ5bm0TeaciETml6UnLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZ5bm0TeaciETml6UgSEg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tIGRkZGQnXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+WNiOWJjXzljYjlvowvaSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfljYjlvownO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfljYjliY0nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5Y2I5b6MJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb5LuK5pelXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb5piO5pelXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW+adpemAsV1kZGRkIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vmmKjml6VdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb5YmN6YCxXWRkZGQgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfeaXpS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfml6UnO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclc+W+jCcsXHJcbiAgICAgICAgcGFzdCA6ICclc+WJjScsXHJcbiAgICAgICAgcyA6ICfmlbDnp5InLFxyXG4gICAgICAgIG0gOiAnMeWIhicsXHJcbiAgICAgICAgbW0gOiAnJWTliIYnLFxyXG4gICAgICAgIGggOiAnMeaZgumWkycsXHJcbiAgICAgICAgaGggOiAnJWTmmYLplpMnLFxyXG4gICAgICAgIGQgOiAnMeaXpScsXHJcbiAgICAgICAgZGQgOiAnJWTml6UnLFxyXG4gICAgICAgIE0gOiAnMeODtuaciCcsXHJcbiAgICAgICAgTU0gOiAnJWTjg7bmnIgnLFxyXG4gICAgICAgIHkgOiAnMeW5tCcsXHJcbiAgICAgICAgeXkgOiAnJWTlubQnXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGphO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEphdmFuZXNlIFtqdl1cclxuLy8hIGF1dGhvciA6IFJvbnkgTGFudGlwIDogaHR0cHM6Ly9naXRodWIuY29tL2xhbnRpcFxyXG4vLyEgcmVmZXJlbmNlOiBodHRwOi8vanYud2lraXBlZGlhLm9yZy93aWtpL0Jhc2FfSmF3YVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGp2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnanYnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYXJldF9BcHJpbF9NZWlfSnVuaV9KdWxpX0FndXN0dXNfU2VwdGVtYmVyX09rdG9iZXJfTm9wZW1iZXJfRGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWVpX0p1bl9KdWxfQWdzX1NlcF9Pa3RfTm9wX0Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ01pbmdndV9TZW5lbl9TZWxvc29fUmVidV9LZW1pc19KZW11d2FoX1NlcHR1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdNaW5fU2VuX1NlbF9SZWJfS2VtX0plbV9TZXAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdNZ19Tbl9TbF9SYl9LbV9KbV9TcCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hILm1tJyxcclxuICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL2VuamluZ3xzaXlhbmd8c29udGVufG5kYWx1LyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAnZW5qaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc2l5YW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NvbnRlbicgfHwgbWVyaWRpZW0gPT09ICduZGFsdScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VuamluZyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc2l5YW5nJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzb250ZW4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbmRhbHUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tEaW50ZW4gcHVuaWtvIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbTWJlbmphbmcgcHVrdWxdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtwdWt1bF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0thbGEgd2luZ2kgcHVrdWxdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtrZXBlbmdrZXIgcHVrdWxdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnd29udGVuIGluZyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBpbmdrYW5nIGtlcGVuZ2tlcicsXHJcbiAgICAgICAgcyA6ICdzYXdldGF3aXMgZGV0aWsnLFxyXG4gICAgICAgIG0gOiAnc2V0dW5nZ2FsIG1lbml0JyxcclxuICAgICAgICBtbSA6ICclZCBtZW5pdCcsXHJcbiAgICAgICAgaCA6ICdzZXR1bmdnYWwgamFtJyxcclxuICAgICAgICBoaCA6ICclZCBqYW0nLFxyXG4gICAgICAgIGQgOiAnc2VkaW50ZW4nLFxyXG4gICAgICAgIGRkIDogJyVkIGRpbnRlbicsXHJcbiAgICAgICAgTSA6ICdzZXd1bGFuJyxcclxuICAgICAgICBNTSA6ICclZCB3dWxhbicsXHJcbiAgICAgICAgeSA6ICdzZXRhdW4nLFxyXG4gICAgICAgIHl5IDogJyVkIHRhdW4nXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGp2O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qdi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qdi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEdlb3JnaWFuIFtrYV1cclxuLy8hIGF1dGhvciA6IElyYWtsaSBKYW5pYXNodmlsaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9pcmFrbGktamFuaWFzaHZpbGlcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBrYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2thJywge1xyXG4gICAgbW9udGhzIDoge1xyXG4gICAgICAgIHN0YW5kYWxvbmU6ICfhg5jhg5Dhg5zhg5Xhg5Dhg6Dhg5hf4YOX4YOU4YOR4YOU4YOg4YOV4YOQ4YOa4YOYX+GDm+GDkOGDoOGDouGDmF/hg5Dhg57hg6Dhg5jhg5rhg5hf4YOb4YOQ4YOY4YOh4YOYX+GDmOGDleGDnOGDmOGDoeGDmF/hg5jhg5Xhg5rhg5jhg6Hhg5hf4YOQ4YOS4YOV4YOY4YOh4YOi4YOdX+GDoeGDlOGDpeGDouGDlOGDm+GDkeGDlOGDoOGDmF/hg53hg6Xhg6Lhg53hg5vhg5Hhg5Thg6Dhg5hf4YOc4YOd4YOU4YOb4YOR4YOU4YOg4YOYX+GDk+GDlOGDmeGDlOGDm+GDkeGDlOGDoOGDmCcuc3BsaXQoJ18nKSxcclxuICAgICAgICBmb3JtYXQ6ICfhg5jhg5Dhg5zhg5Xhg5Dhg6Dhg6Ff4YOX4YOU4YOR4YOU4YOg4YOV4YOQ4YOa4YOhX+GDm+GDkOGDoOGDouGDoV/hg5Dhg57hg6Dhg5jhg5rhg5jhg6Ff4YOb4YOQ4YOY4YOh4YOhX+GDmOGDleGDnOGDmOGDoeGDoV/hg5jhg5Xhg5rhg5jhg6Hhg6Ff4YOQ4YOS4YOV4YOY4YOh4YOi4YOhX+GDoeGDlOGDpeGDouGDlOGDm+GDkeGDlOGDoOGDoV/hg53hg6Xhg6Lhg53hg5vhg5Hhg5Thg6Dhg6Ff4YOc4YOd4YOU4YOb4YOR4YOU4YOg4YOhX+GDk+GDlOGDmeGDlOGDm+GDkeGDlOGDoOGDoScuc3BsaXQoJ18nKVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+GDmOGDkOGDnF/hg5fhg5Thg5Ff4YOb4YOQ4YOgX+GDkOGDnuGDoF/hg5vhg5Dhg5hf4YOY4YOV4YOcX+GDmOGDleGDml/hg5Dhg5Lhg5Vf4YOh4YOU4YOlX+GDneGDpeGDol/hg5zhg53hg5Rf4YOT4YOU4YOZJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiB7XHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ+GDmeGDleGDmOGDoOGDkF/hg53hg6Dhg6jhg5Dhg5Hhg5Dhg5fhg5hf4YOh4YOQ4YOb4YOo4YOQ4YOR4YOQ4YOX4YOYX+GDneGDl+GDruGDqOGDkOGDkeGDkOGDl+GDmF/hg67hg6Phg5fhg6jhg5Dhg5Hhg5Dhg5fhg5hf4YOe4YOQ4YOg4YOQ4YOh4YOZ4YOU4YOV4YOYX+GDqOGDkOGDkeGDkOGDl+GDmCcuc3BsaXQoJ18nKSxcclxuICAgICAgICBmb3JtYXQ6ICfhg5nhg5Xhg5jhg6Dhg5Dhg6Ff4YOd4YOg4YOo4YOQ4YOR4YOQ4YOX4YOhX+GDoeGDkOGDm+GDqOGDkOGDkeGDkOGDl+GDoV/hg53hg5fhg67hg6jhg5Dhg5Hhg5Dhg5fhg6Ff4YOu4YOj4YOX4YOo4YOQ4YOR4YOQ4YOX4YOhX+GDnuGDkOGDoOGDkOGDoeGDmeGDlOGDleGDoV/hg6jhg5Dhg5Hhg5Dhg5fhg6EnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgaXNGb3JtYXQ6IC8o4YOs4YOY4YOc4YOQfOGDqOGDlOGDm+GDk+GDlOGDkikvXHJcbiAgICB9LFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfhg5nhg5Xhg5hf4YOd4YOg4YOoX+GDoeGDkOGDm1/hg53hg5fhg65f4YOu4YOj4YOXX+GDnuGDkOGDoF/hg6jhg5Dhg5EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfhg5nhg5Vf4YOd4YOgX+GDoeGDkF/hg53hg5df4YOu4YOjX+GDnuGDkF/hg6jhg5AnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+GDk+GDpuGDlOGDoV0gTFRbLeGDluGDlF0nLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+GDruGDleGDkOGDml0gTFRbLeGDluGDlF0nLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+GDkuGDo+GDqOGDmOGDnF0gTFRbLeGDluGDlF0nLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vhg6jhg5Thg5vhg5Phg5Thg5JdIGRkZGQgTFRbLeGDluGDlF0nLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vhg6zhg5jhg5zhg5BdIGRkZGQgTFQt4YOW4YOUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICByZXR1cm4gKC8o4YOs4YOQ4YOb4YOYfOGDrOGDo+GDl+GDmHzhg6Hhg5Dhg5Dhg5fhg5h84YOs4YOU4YOa4YOYKS8pLnRlc3QocykgP1xyXG4gICAgICAgICAgICAgICAgcy5yZXBsYWNlKC/hg5gkLywgJ+GDqOGDmCcpIDpcclxuICAgICAgICAgICAgICAgIHMgKyAn4YOo4YOYJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhc3QgOiBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICBpZiAoKC8o4YOs4YOQ4YOb4YOYfOGDrOGDo+GDl+GDmHzhg6Hhg5Dhg5Dhg5fhg5h84YOT4YOm4YOUfOGDl+GDleGDlCkvKS50ZXN0KHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC8o4YOYfOGDlCkkLywgJ+GDmOGDoSDhg6Phg5nhg5Dhg5wnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKC/hg6zhg5Thg5rhg5gvKS50ZXN0KHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC/hg6zhg5Thg5rhg5gkLywgJ+GDrOGDmuGDmOGDoSDhg6Phg5nhg5Dhg5wnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcyA6ICfhg6Dhg5Dhg5vhg5Phg5Thg5zhg5jhg5vhg5Qg4YOs4YOQ4YOb4YOYJyxcclxuICAgICAgICBtIDogJ+GDrOGDo+GDl+GDmCcsXHJcbiAgICAgICAgbW0gOiAnJWQg4YOs4YOj4YOX4YOYJyxcclxuICAgICAgICBoIDogJ+GDoeGDkOGDkOGDl+GDmCcsXHJcbiAgICAgICAgaGggOiAnJWQg4YOh4YOQ4YOQ4YOX4YOYJyxcclxuICAgICAgICBkIDogJ+GDk+GDpuGDlCcsXHJcbiAgICAgICAgZGQgOiAnJWQg4YOT4YOm4YOUJyxcclxuICAgICAgICBNIDogJ+GDl+GDleGDlCcsXHJcbiAgICAgICAgTU0gOiAnJWQg4YOX4YOV4YOUJyxcclxuICAgICAgICB5IDogJ+GDrOGDlOGDmuGDmCcsXHJcbiAgICAgICAgeXkgOiAnJWQg4YOs4YOU4YOa4YOYJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC8wfDEt4YOa4YOYfOGDm+GDlC1cXGR7MSwyfXxcXGR7MSwyfS3hg5QvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct4YOa4YOYJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChudW1iZXIgPCAyMCkgfHwgKG51bWJlciA8PSAxMDAgJiYgKG51bWJlciAlIDIwID09PSAwKSkgfHwgKG51bWJlciAlIDEwMCA9PT0gMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfhg5vhg5QtJyArIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICct4YOUJztcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsXHJcbiAgICAgICAgZG95IDogN1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBrYTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva2EuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva2EuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBLYXpha2ggW2trXVxyXG4vLyEgYXV0aG9ycyA6IE51cmxhbiBSYWtoaW16aGFub3YgOiBodHRwczovL2dpdGh1Yi5jb20vbnVybGFuXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3VmZml4ZXMgPSB7XHJcbiAgICAwOiAnLdGI0ZYnLFxyXG4gICAgMTogJy3RiNGWJyxcclxuICAgIDI6ICct0YjRlicsXHJcbiAgICAzOiAnLdGI0ZYnLFxyXG4gICAgNDogJy3RiNGWJyxcclxuICAgIDU6ICct0YjRlicsXHJcbiAgICA2OiAnLdGI0YsnLFxyXG4gICAgNzogJy3RiNGWJyxcclxuICAgIDg6ICct0YjRlicsXHJcbiAgICA5OiAnLdGI0YsnLFxyXG4gICAgMTA6ICct0YjRiycsXHJcbiAgICAyMDogJy3RiNGLJyxcclxuICAgIDMwOiAnLdGI0YsnLFxyXG4gICAgNDA6ICct0YjRiycsXHJcbiAgICA1MDogJy3RiNGWJyxcclxuICAgIDYwOiAnLdGI0YsnLFxyXG4gICAgNzA6ICct0YjRlicsXHJcbiAgICA4MDogJy3RiNGWJyxcclxuICAgIDkwOiAnLdGI0YsnLFxyXG4gICAgMTAwOiAnLdGI0ZYnXHJcbn07XHJcblxyXG52YXIga2sgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdraycsIHtcclxuICAgIG1vbnRocyA6ICfSm9Cw0qPRgtCw0YBf0LDSm9C/0LDQvV/QvdCw0YPRgNGL0Ldf0YHTmdGD0ZbRgF/QvNCw0LzRi9GAX9C80LDRg9GB0YvQvF/RiNGW0LvQtNC1X9GC0LDQvNGL0Ldf0pvRi9GA0LrSr9C50LXQul/Sm9Cw0LfQsNC9X9Kb0LDRgNCw0YjQsF/QttC10LvRgtC+0pvRgdCw0L0nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfSm9Cw0qNf0LDSm9C/X9C90LDRg1/RgdOZ0YNf0LzQsNC8X9C80LDRg1/RiNGW0Ltf0YLQsNC8X9Kb0YvRgF/Sm9Cw0Ldf0pvQsNGAX9C20LXQuycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9C20LXQutGB0LXQvdCx0ZZf0LTSr9C50YHQtdC90LHRll/RgdC10LnRgdC10L3QsdGWX9GB05nRgNGB0LXQvdCx0ZZf0LHQtdC50YHQtdC90LHRll/QttKx0LzQsF/RgdC10L3QsdGWJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQttC10Lpf0LTSr9C5X9GB0LXQuV/RgdOZ0YBf0LHQtdC5X9C20rHQvF/RgdC10L0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQttC6X9C00Llf0YHQuV/RgdGAX9Cx0Llf0LbQvF/RgdC9Jy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW9CR0q/Qs9GW0L0g0YHQsNKT0LDRgl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9CV0YDRgtC10qMg0YHQsNKT0LDRgl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW9GB0LDSk9Cw0YJdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vQmtC10YjQtSDRgdCw0pPQsNGCXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW9Oo0YLQutC10L0g0LDQv9GC0LDQvdGL0qNdIGRkZGQgW9GB0LDSk9Cw0YJdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg0ZbRiNGW0L3QtNC1JyxcclxuICAgICAgICBwYXN0IDogJyVzINCx0rHRgNGL0L0nLFxyXG4gICAgICAgIHMgOiAn0LHRltGA0L3QtdGI0LUg0YHQtdC60YPQvdC0JyxcclxuICAgICAgICBtIDogJ9Cx0ZbRgCDQvNC40L3Rg9GCJyxcclxuICAgICAgICBtbSA6ICclZCDQvNC40L3Rg9GCJyxcclxuICAgICAgICBoIDogJ9Cx0ZbRgCDRgdCw0pPQsNGCJyxcclxuICAgICAgICBoaCA6ICclZCDRgdCw0pPQsNGCJyxcclxuICAgICAgICBkIDogJ9Cx0ZbRgCDQutKv0L0nLFxyXG4gICAgICAgIGRkIDogJyVkINC60q/QvScsXHJcbiAgICAgICAgTSA6ICfQsdGW0YAg0LDQuScsXHJcbiAgICAgICAgTU0gOiAnJWQg0LDQuScsXHJcbiAgICAgICAgeSA6ICfQsdGW0YAg0LbRi9C7JyxcclxuICAgICAgICB5eSA6ICclZCDQttGL0LsnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjRiNGWfNGI0YspLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGEgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgYiA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAoc3VmZml4ZXNbbnVtYmVyXSB8fCBzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGtrO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ray5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ray5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IENhbWJvZGlhbiBba21dXHJcbi8vISBhdXRob3IgOiBLcnV5IFZhbm5hIDogaHR0cHM6Ly9naXRodWIuY29tL2tydXl2YW5uYVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGttID0gbW9tZW50LmRlZmluZUxvY2FsZSgna20nLCB7XHJcbiAgICBtb250aHM6ICfhnpjhnoDhnprhnrZf4Z6A4Z674Z6Y4Z+S4Z6X4Z+IX+GemOGeuOGek+Getl/hnpjhn4Hhnp/hnrZf4Z6n4Z6f4Z6X4Z62X+GemOGet+GekOGeu+Gek+Getl/hnoDhnoDhn5LhnoDhnorhnrZf4Z6f4Z644Z6g4Z62X+GegOGeieGfkuGeieGetl/hno/hnrvhnpvhnrZf4Z6c4Z634Z6F4Z+S4Z6G4Z634Z6A4Z62X+GekuGfkuGek+GevCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0OiAn4Z6Y4Z6A4Z6a4Z62X+GegOGeu+GemOGfkuGel+GfiF/hnpjhnrjhnpPhnrZf4Z6Y4Z+B4Z6f4Z62X+Gep+Gen+Gel+Getl/hnpjhnrfhnpDhnrvhnpPhnrZf4Z6A4Z6A4Z+S4Z6A4Z6K4Z62X+Gen+GeuOGeoOGetl/hnoDhnonhn5LhnonhnrZf4Z6P4Z674Z6b4Z62X+GenOGet+GeheGfkuGehuGet+GegOGetl/hnpLhn5LhnpPhnrwnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5czogJ+GeouGetuGekeGet+Gej+GfkuGemV/hnoXhn5DhnpPhn5LhnpFf4Z6i4Z6E4Z+S4Z6C4Z624Z6aX+GeluGeu+Gekl/hnpbhn5LhnprhnqDhnp/hn5LhnpThno/hnrfhn41f4Z6f4Z674Z6A4Z+S4Z6aX+Gen+GfheGemuGfjScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICfhnqLhnrbhnpHhnrfhno/hn5Lhnplf4Z6F4Z+Q4Z6T4Z+S4Z6RX+GeouGehOGfkuGeguGetuGeml/hnpbhnrvhnpJf4Z6W4Z+S4Z6a4Z6g4Z6f4Z+S4Z6U4Z6P4Z634Z+NX+Gen+Geu+GegOGfkuGeml/hnp/hn4Xhnprhn40nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ+GeouGetuGekeGet+Gej+GfkuGemV/hnoXhn5DhnpPhn5LhnpFf4Z6i4Z6E4Z+S4Z6C4Z624Z6aX+GeluGeu+Gekl/hnpbhn5LhnprhnqDhnp/hn5LhnpThno/hnrfhn41f4Z6f4Z674Z6A4Z+S4Z6aX+Gen+GfheGemuGfjScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb4Z6Q4Z+S4Z6E4Z+D4Z6T4Z+B4Z+HIOGemOGfieGfhOGehF0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb4Z6f4Z+S4Z6i4Z+C4Z6AIOGemOGfieGfhOGehF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1vhnpjhn5Lhnp/hnrfhnpvhnpjhnrfhnokg4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvhnp/hnpThn5Lhno/hnrbhnqDhn43hnpjhnrvhnpNdIFvhnpjhn4nhn4ThnoRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lOiB7XHJcbiAgICAgICAgZnV0dXJlOiAnJXPhnpHhn4Dhno8nLFxyXG4gICAgICAgIHBhc3Q6ICclc+GemOGeu+GekycsXHJcbiAgICAgICAgczogJ+GelOGfieGeu+Gek+GfkuGemOGetuGek+GenOGet+Gek+GetuGekeGeuCcsXHJcbiAgICAgICAgbTogJ+GemOGeveGemeGek+GetuGekeGeuCcsXHJcbiAgICAgICAgbW06ICclZCDhnpPhnrbhnpHhnrgnLFxyXG4gICAgICAgIGg6ICfhnpjhnr3hnpnhnpjhn4nhn4ThnoQnLFxyXG4gICAgICAgIGhoOiAnJWQg4Z6Y4Z+J4Z+E4Z6EJyxcclxuICAgICAgICBkOiAn4Z6Y4Z694Z6Z4Z6Q4Z+S4Z6E4Z+DJyxcclxuICAgICAgICBkZDogJyVkIOGekOGfkuGehOGfgycsXHJcbiAgICAgICAgTTogJ+GemOGeveGemeGegeGfgicsXHJcbiAgICAgICAgTU06ICclZCDhnoHhn4InLFxyXG4gICAgICAgIHk6ICfhnpjhnr3hnpnhnobhn5LhnpPhnrbhn4YnLFxyXG4gICAgICAgIHl5OiAnJWQg4Z6G4Z+S4Z6T4Z624Z+GJ1xyXG4gICAgfSxcclxuICAgIHdlZWs6IHtcclxuICAgICAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveTogNCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGttO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEthbm5hZGEgW2tuXVxyXG4vLyEgYXV0aG9yIDogUmFqZWV2IE5haWsgOiBodHRwczovL2dpdGh1Yi5jb20vcmFqZWV2bmFpa3RlXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAn4LOnJyxcclxuICAgICcyJzogJ+CzqCcsXHJcbiAgICAnMyc6ICfgs6knLFxyXG4gICAgJzQnOiAn4LOqJyxcclxuICAgICc1JzogJ+CzqycsXHJcbiAgICAnNic6ICfgs6wnLFxyXG4gICAgJzcnOiAn4LOtJyxcclxuICAgICc4JzogJ+CzricsXHJcbiAgICAnOSc6ICfgs68nLFxyXG4gICAgJzAnOiAn4LOmJ1xyXG59O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgJ+Czpyc6ICcxJyxcclxuICAgICfgs6gnOiAnMicsXHJcbiAgICAn4LOpJzogJzMnLFxyXG4gICAgJ+Czqic6ICc0JyxcclxuICAgICfgs6snOiAnNScsXHJcbiAgICAn4LOsJzogJzYnLFxyXG4gICAgJ+CzrSc6ICc3JyxcclxuICAgICfgs64nOiAnOCcsXHJcbiAgICAn4LOvJzogJzknLFxyXG4gICAgJ+Czpic6ICcwJ1xyXG59O1xyXG5cclxudmFyIGtuID0gbW9tZW50LmRlZmluZUxvY2FsZSgna24nLCB7XHJcbiAgICBtb250aHMgOiAn4LKc4LKo4LK14LKw4LK/X+Cyq+CzhuCyrOCzjeCysOCyteCysOCyv1/gsq7gsr7gsrDgs43gsprgs41f4LKP4LKq4LON4LKw4LK/4LKy4LONX+CyruCzhuCzlV/gspzgs4Lgsqjgs41f4LKc4LOB4LKy4LOG4LOWX+CyhuCyl+CyuOCzjeCyn+CzjV/gsrjgs4bgsqrgs43gsp/gs4bgsoLgsqzgsrDgs41f4LKF4LKV4LON4LKf4LOG4LOC4LOV4LKs4LKw4LONX+CyqOCyteCzhuCyguCyrOCysOCzjV/gsqHgsr/gsrjgs4bgsoLgsqzgsrDgs40nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfgspzgsqhf4LKr4LOG4LKs4LON4LKwX+CyruCyvuCysOCzjeCymuCzjV/gso/gsqrgs43gsrDgsr/gsrLgs41f4LKu4LOG4LOVX+CynOCzguCyqOCzjV/gspzgs4HgsrLgs4bgs5Zf4LKG4LKX4LK44LON4LKf4LONX+CyuOCzhuCyquCzjeCyn+CzhuCyguCyrF/gsoXgspXgs43gsp/gs4bgs4Lgs5Xgsqxf4LKo4LK14LOG4LKC4LKsX+CyoeCyv+CyuOCzhuCyguCyrCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICfgsq3gsr7gsqjgs4HgsrXgsr7gsrBf4LK44LOG4LOC4LOV4LKu4LK14LK+4LKwX+CyruCyguCyl+Cys+CyteCyvuCysF/gsqzgs4HgsqfgsrXgsr7gsrBf4LKX4LOB4LKw4LOB4LK14LK+4LKwX+CytuCzgeCyleCzjeCysOCyteCyvuCysF/gsrbgsqjgsr/gsrXgsr7gsrAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+CyreCyvuCyqOCzgV/gsrjgs4bgs4Lgs5Xgsq5f4LKu4LKC4LKX4LKzX+CyrOCzgeCyp1/gspfgs4HgsrDgs4Ff4LK24LOB4LKV4LON4LKwX+CytuCyqOCyvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+CyreCyvl/gsrjgs4bgs4Lgs5Vf4LKu4LKCX+CyrOCzgV/gspfgs4Ff4LK24LOBX+Cyticuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbScsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgsofgsoLgsqbgs4FdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgsqjgsr7gsrPgs4ZdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4LKo4LK/4LKo4LON4LKo4LOGXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+CyleCzhuCzguCyqOCzhuCyr10gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDgsqjgsoLgsqTgsrAnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4LK54LK/4LKC4LKm4LOGJyxcclxuICAgICAgICBzIDogJ+CyleCzhuCysuCyteCzgSDgspXgs43gsrfgsqPgspfgsrPgs4EnLFxyXG4gICAgICAgIG0gOiAn4LKS4LKC4LKm4LOBIOCyqOCyv+CyruCyv+CytycsXHJcbiAgICAgICAgbW0gOiAnJWQg4LKo4LK/4LKu4LK/4LK3JyxcclxuICAgICAgICBoIDogJ+CykuCyguCypuCzgSDgspfgsoLgsp/gs4YnLFxyXG4gICAgICAgIGhoIDogJyVkIOCyl+CyguCyn+CzhicsXHJcbiAgICAgICAgZCA6ICfgspLgsoLgsqbgs4Eg4LKm4LK/4LKoJyxcclxuICAgICAgICBkZCA6ICclZCDgsqbgsr/gsqgnLFxyXG4gICAgICAgIE0gOiAn4LKS4LKC4LKm4LOBIOCypOCyv+CyguCyl+Cys+CzgScsXHJcbiAgICAgICAgTU0gOiAnJWQg4LKk4LK/4LKC4LKX4LKz4LOBJyxcclxuICAgICAgICB5IDogJ+CykuCyguCypuCzgSDgsrXgsrDgs43gsrcnLFxyXG4gICAgICAgIHl5IDogJyVkIOCyteCysOCzjeCytydcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Czp+CzqOCzqeCzquCzq+CzrOCzreCzruCzr+Czpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+CysOCyvuCypOCzjeCysOCyv3zgsqzgs4bgsrPgsr/gspfgs43gspfgs4Z84LKu4LKn4LON4LKv4LK+4LK54LON4LKofOCyuOCyguCynOCzhi8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CysOCyvuCypOCzjeCysOCyvycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4LKs4LOG4LKz4LK/4LKX4LON4LKX4LOGJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4LKu4LKn4LON4LKv4LK+4LK54LON4LKoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CyuOCyguCynOCzhicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LKw4LK+4LKk4LON4LKw4LK/JztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CyrOCzhuCys+Cyv+Cyl+CzjeCyl+Czhic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgsq7gsqfgs43gsq/gsr7gsrngs43gsqgnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LK44LKC4LKc4LOGJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CysOCyvuCypOCzjeCysOCyvyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjgsqjgs4bgs5UpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICfgsqjgs4bgs5UnO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBrbjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva24uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva24uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBLb3JlYW4gW2tvXVxyXG4vLyEgYXV0aG9yIDogS3l1bmd3b29rLCBQYXJrIDogaHR0cHM6Ly9naXRodWIuY29tL2t5dW5ndzAwa1xyXG4vLyEgYXV0aG9yIDogSmVlZXl1bCBMZWUgPGplZWV5dWxAZ21haWwuY29tPlxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGtvID0gbW9tZW50LmRlZmluZUxvY2FsZSgna28nLCB7XHJcbiAgICBtb250aHMgOiAnMeyblF8y7JuUXzPsm5RfNOyblF817JuUXzbsm5RfN+yblF847JuUXznsm5RfMTDsm5RfMTHsm5RfMTLsm5QnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICcx7JuUXzLsm5RfM+yblF807JuUXzXsm5RfNuyblF837JuUXzjsm5RfOeyblF8xMOyblF8xMeyblF8xMuyblCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ+ydvOyalOydvF/sm5TsmpTsnbxf7ZmU7JqU7J28X+yImOyalOydvF/rqqnsmpTsnbxf6riI7JqU7J28X+2GoOyalOydvCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn7J28X+yblF/tmZRf7IiYX+uqqV/quIhf7YagJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn7J28X+yblF/tmZRf7IiYX+uqqV/quIhf7YagJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnQSBoOm1tJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVkuTU0uREQnLFxyXG4gICAgICAgIExMIDogJ1lZWVnrhYQgTU1NTSBE7J28JyxcclxuICAgICAgICBMTEwgOiAnWVlZWeuFhCBNTU1NIETsnbwgQSBoOm1tJyxcclxuICAgICAgICBMTExMIDogJ1lZWVnrhYQgTU1NTSBE7J28IGRkZGQgQSBoOm1tJyxcclxuICAgICAgICBsIDogJ1lZWVkuTU0uREQnLFxyXG4gICAgICAgIGxsIDogJ1lZWVnrhYQgTU1NTSBE7J28JyxcclxuICAgICAgICBsbGwgOiAnWVlZWeuFhCBNTU1NIETsnbwgQSBoOm1tJyxcclxuICAgICAgICBsbGxsIDogJ1lZWVnrhYQgTU1NTSBE7J28IGRkZGQgQSBoOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAn7Jik64qYIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ+uCtOydvCBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICfslrTsoJwgTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ+yngOuCnOyjvCBkZGRkIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg7ZuEJyxcclxuICAgICAgICBwYXN0IDogJyVzIOyghCcsXHJcbiAgICAgICAgcyA6ICfrqocg7LSIJyxcclxuICAgICAgICBzcyA6ICclZOy0iCcsXHJcbiAgICAgICAgbSA6ICcx67aEJyxcclxuICAgICAgICBtbSA6ICclZOu2hCcsXHJcbiAgICAgICAgaCA6ICftlZwg7Iuc6rCEJyxcclxuICAgICAgICBoaCA6ICclZOyLnOqwhCcsXHJcbiAgICAgICAgZCA6ICftlZjro6gnLFxyXG4gICAgICAgIGRkIDogJyVk7J28JyxcclxuICAgICAgICBNIDogJ+2VnCDri6wnLFxyXG4gICAgICAgIE1NIDogJyVk64usJyxcclxuICAgICAgICB5IDogJ+ydvCDrhYQnLFxyXG4gICAgICAgIHl5IDogJyVk64WEJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn0o7J28fOyblHzso7wpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+ydvCc7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfsm5QnO1xyXG4gICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgY2FzZSAnVyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+yjvCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlIDogL+yYpOyghHzsmKTtm4QvLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgIHJldHVybiB0b2tlbiA9PT0gJ+yYpO2bhCc7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc1VwcGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGhvdXIgPCAxMiA/ICfsmKTsoIQnIDogJ+yYpO2bhCc7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGtvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rby5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rby5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEt5cmd5eiBba3ldXHJcbi8vISBhdXRob3IgOiBDaHluZ3l6IEFyeXN0YW4gdXVsdSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaHluZ3l6XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5cclxudmFyIHN1ZmZpeGVzID0ge1xyXG4gICAgMDogJy3Rh9KvJyxcclxuICAgIDE6ICct0YfQuCcsXHJcbiAgICAyOiAnLdGH0LgnLFxyXG4gICAgMzogJy3Rh9KvJyxcclxuICAgIDQ6ICct0YfSrycsXHJcbiAgICA1OiAnLdGH0LgnLFxyXG4gICAgNjogJy3Rh9GLJyxcclxuICAgIDc6ICct0YfQuCcsXHJcbiAgICA4OiAnLdGH0LgnLFxyXG4gICAgOTogJy3Rh9GDJyxcclxuICAgIDEwOiAnLdGH0YMnLFxyXG4gICAgMjA6ICct0YfRiycsXHJcbiAgICAzMDogJy3Rh9GDJyxcclxuICAgIDQwOiAnLdGH0YsnLFxyXG4gICAgNTA6ICct0YfSrycsXHJcbiAgICA2MDogJy3Rh9GLJyxcclxuICAgIDcwOiAnLdGH0LgnLFxyXG4gICAgODA6ICct0YfQuCcsXHJcbiAgICA5MDogJy3Rh9GDJyxcclxuICAgIDEwMDogJy3Rh9KvJ1xyXG59O1xyXG5cclxudmFyIGt5ID0gbW9tZW50LmRlZmluZUxvY2FsZSgna3knLCB7XHJcbiAgICBtb250aHMgOiAn0Y/QvdCy0LDRgNGMX9GE0LXQstGA0LDQu9GMX9C80LDRgNGCX9Cw0L/RgNC10LvRjF/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCz0YPRgdGCX9GB0LXQvdGC0Y/QsdGA0Yxf0L7QutGC0Y/QsdGA0Yxf0L3QvtGP0LHRgNGMX9C00LXQutCw0LHRgNGMJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn0Y/QvdCyX9GE0LXQsl/QvNCw0YDRgl/QsNC/0YBf0LzQsNC5X9C40Y7QvdGMX9C40Y7Qu9GMX9Cw0LLQs1/RgdC10L1f0L7QutGCX9C90L7Rj1/QtNC10LonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfQltC10LrRiNC10LzQsdC4X9CU0q/QudGI06nQvNCx0q9f0KjQtdC50YjQtdC80LHQuF/QqNCw0YDRiNC10LzQsdC4X9CR0LXQudGI0LXQvNCx0Lhf0JbRg9C80LBf0JjRiNC10LzQsdC4Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQltC10Lpf0JTSr9C5X9Co0LXQuV/QqNCw0YBf0JHQtdC5X9CW0YPQvF/QmNGI0LUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQltC6X9CU0Llf0KjQuV/QqNGAX9CR0Llf0JbQvF/QmNGIJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW9CR0q/Qs9Kv0L0g0YHQsNCw0YJdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vQrdGA0YLQtdKjINGB0LDQsNGCXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0YHQsNCw0YJdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vQmtC10YfQtSDRgdCw0LDRgl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vTqNGC0LrQtdC9INCw0L/RgtCw0L3Ri9C9XSBkZGRkIFvQutKv0L3Sr10gW9GB0LDQsNGCXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzINC40YfQuNC90LTQtScsXHJcbiAgICAgICAgcGFzdCA6ICclcyDQvNGD0YDRg9C9JyxcclxuICAgICAgICBzIDogJ9Cx0LjRgNC90LXRh9C1INGB0LXQutGD0L3QtCcsXHJcbiAgICAgICAgbSA6ICfQsdC40YAg0LzSr9C906nRgicsXHJcbiAgICAgICAgbW0gOiAnJWQg0LzSr9C906nRgicsXHJcbiAgICAgICAgaCA6ICfQsdC40YAg0YHQsNCw0YInLFxyXG4gICAgICAgIGhoIDogJyVkINGB0LDQsNGCJyxcclxuICAgICAgICBkIDogJ9Cx0LjRgCDQutKv0L0nLFxyXG4gICAgICAgIGRkIDogJyVkINC60q/QvScsXHJcbiAgICAgICAgTSA6ICfQsdC40YAg0LDQuScsXHJcbiAgICAgICAgTU0gOiAnJWQg0LDQuScsXHJcbiAgICAgICAgeSA6ICfQsdC40YAg0LbRi9C7JyxcclxuICAgICAgICB5eSA6ICclZCDQttGL0LsnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjRh9C4fNGH0Yt80YfSr3zRh9GDKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHZhciBhID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIGIgPSBudW1iZXIgPj0gMTAwID8gMTAwIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgKHN1ZmZpeGVzW251bWJlcl0gfHwgc3VmZml4ZXNbYV0gfHwgc3VmZml4ZXNbYl0pO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBreTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva3kuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva3kuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBMdXhlbWJvdXJnaXNoIFtsYl1cclxuLy8hIGF1dGhvciA6IG13ZWltZXJza2lyY2ggOiBodHRwczovL2dpdGh1Yi5jb20vbXdlaW1lcnNraXJjaFxyXG4vLyEgYXV0aG9yIDogRGF2aWQgUmFpc29uIDogaHR0cHM6Ly9naXRodWIuY29tL2t3aXNhdHpcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdtJzogWydlbmcgTWludXR0JywgJ2VuZ2VyIE1pbnV0dCddLFxyXG4gICAgICAgICdoJzogWydlbmcgU3Rvbm4nLCAnZW5nZXIgU3Rvbm4nXSxcclxuICAgICAgICAnZCc6IFsnZWVuIERhZycsICdlbmdlbSBEYWcnXSxcclxuICAgICAgICAnTSc6IFsnZWUgTW91bnQnLCAnZW5nZW0gTW91bnQnXSxcclxuICAgICAgICAneSc6IFsnZWUgSm9lcicsICdlbmdlbSBKb2VyJ11cclxuICAgIH07XHJcbiAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc0Z1dHVyZVRpbWUoc3RyaW5nKSB7XHJcbiAgICB2YXIgbnVtYmVyID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZignICcpKTtcclxuICAgIGlmIChlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIobnVtYmVyKSkge1xyXG4gICAgICAgIHJldHVybiAnYSAnICsgc3RyaW5nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICdhbiAnICsgc3RyaW5nO1xyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NQYXN0VGltZShzdHJpbmcpIHtcclxuICAgIHZhciBudW1iZXIgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKCcgJykpO1xyXG4gICAgaWYgKGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuICd2aXJ1ICcgKyBzdHJpbmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3ZpcnVuICcgKyBzdHJpbmc7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd29yZCBiZWZvcmUgdGhlIGdpdmVuIG51bWJlciBsb3NlcyB0aGUgJy1uJyBlbmRpbmcuXHJcbiAqIGUuZy4gJ2FuIDEwIERlZWcnIGJ1dCAnYSA1IERlZWcnXHJcbiAqXHJcbiAqIEBwYXJhbSBudW1iZXIge2ludGVnZXJ9XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcikge1xyXG4gICAgbnVtYmVyID0gcGFyc2VJbnQobnVtYmVyLCAxMCk7XHJcbiAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChudW1iZXIgPCAwKSB7XHJcbiAgICAgICAgLy8gTmVnYXRpdmUgTnVtYmVyIC0tPiBhbHdheXMgdHJ1ZVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAxMCkge1xyXG4gICAgICAgIC8vIE9ubHkgMSBkaWdpdFxyXG4gICAgICAgIGlmICg0IDw9IG51bWJlciAmJiBudW1iZXIgPD0gNykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAxMDApIHtcclxuICAgICAgICAvLyAyIGRpZ2l0c1xyXG4gICAgICAgIHZhciBsYXN0RGlnaXQgPSBudW1iZXIgJSAxMCwgZmlyc3REaWdpdCA9IG51bWJlciAvIDEwO1xyXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihmaXJzdERpZ2l0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihsYXN0RGlnaXQpO1xyXG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAxMDAwMCkge1xyXG4gICAgICAgIC8vIDMgb3IgNCBkaWdpdHMgLS0+IHJlY3Vyc2l2ZWx5IGNoZWNrIGZpcnN0IGRpZ2l0XHJcbiAgICAgICAgd2hpbGUgKG51bWJlciA+PSAxMCkge1xyXG4gICAgICAgICAgICBudW1iZXIgPSBudW1iZXIgLyAxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBBbnl0aGluZyBsYXJnZXIgdGhhbiA0IGRpZ2l0czogcmVjdXJzaXZlbHkgY2hlY2sgZmlyc3Qgbi0zIGRpZ2l0c1xyXG4gICAgICAgIG51bWJlciA9IG51bWJlciAvIDEwMDA7XHJcbiAgICAgICAgcmV0dXJuIGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgbGIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdsYicsIHtcclxuICAgIG1vbnRoczogJ0phbnVhcl9GZWJydWFyX03DpGVyel9BYnLDq2xsX01lZV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICdKYW4uX0ZlYnIuX01yei5fQWJyLl9NZWVfSnVuLl9KdWwuX0F1Zy5fU2VwdC5fT2t0Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzOiAnU29ubmRlZ19Nw6lpbmRlZ19Ew6tuc2NoZGVnX03Dq3R0d29jaF9Eb25uZXNjaGRlZ19GcmVpZGVnX1NhbXNjaGRlZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICdTby5fTcOpLl9Ew6suX03Dqy5fRG8uX0ZyLl9TYS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ1NvX03DqV9Ew6tfTcOrX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdIOm1tIFtBdWVyXScsXHJcbiAgICAgICAgTFRTOiAnSDptbTpzcyBbQXVlcl0nLFxyXG4gICAgICAgIEw6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0gW0F1ZXJdJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0gW0F1ZXJdJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tIYXV0IHVtXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJyxcclxuICAgICAgICBuZXh0RGF5OiAnW011ZXIgdW1dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3VtXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tHw6tzY2h0ZXIgdW1dIExUJyxcclxuICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBEaWZmZXJlbnQgZGF0ZSBzdHJpbmcgZm9yICdEw6tuc2NoZGVnJyAoVHVlc2RheSkgYW5kICdEb25uZXNjaGRlZycgKFRodXJzZGF5KSBkdWUgdG8gcGhvbm9sb2dpY2FsIHJ1bGVcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbTGVzY2h0ZW5dIGRkZGQgW3VtXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW0xlc2NodGVdIGRkZGQgW3VtXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6IHByb2Nlc3NGdXR1cmVUaW1lLFxyXG4gICAgICAgIHBhc3QgOiBwcm9jZXNzUGFzdFRpbWUsXHJcbiAgICAgICAgcyA6ICdlIHB1ZXIgU2Vrb25uZW4nLFxyXG4gICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG1tIDogJyVkIE1pbnV0dGVuJyxcclxuICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoaCA6ICclZCBTdG9ubmVuJyxcclxuICAgICAgICBkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkZCA6ICclZCBEZWVnJyxcclxuICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNTSA6ICclZCBNw6lpbnQnLFxyXG4gICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHl5IDogJyVkIEpvZXInXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWw6ICclZC4nLFxyXG4gICAgd2Vlazoge1xyXG4gICAgICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95OiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGxiO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sYi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sYi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IExhbyBbbG9dXHJcbi8vISBhdXRob3IgOiBSeWFuIEhhcnQgOiBodHRwczovL2dpdGh1Yi5jb20vcnlhbmhhcnQyXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbG8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdsbycsIHtcclxuICAgIG1vbnRocyA6ICfguqHgurHguofguoHguq3guplf4LqB4Lq44Lqh4Lqe4LqyX+C6oeC6teC6meC6sl/gu4DguqHguqrgurJf4Lqe4Lq24LqU4Lqq4Lqw4Lqe4LqyX+C6oeC6tOC6luC6uOC6meC6sl/guoHgu43guqXgurDguoHgurvgupRf4Lqq4Lq04LqH4Lqr4LqyX+C6geC6seC6meC6jeC6sl/gupXgurjguqXgurJf4Lqe4Lqw4LqI4Lq04LqBX+C6l+C6seC6meC6p+C6sicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+C6oeC6seC6h+C6geC6reC6mV/guoHgurjguqHgup7gurJf4Lqh4Lq14LqZ4LqyX+C7gOC6oeC6quC6sl/gup7gurbgupTguqrgurDgup7gurJf4Lqh4Lq04LqW4Lq44LqZ4LqyX+C6geC7jeC6peC6sOC6geC6u+C6lF/guqrgurTguofguqvgurJf4LqB4Lqx4LqZ4LqN4LqyX+C6leC6uOC6peC6sl/gup7gurDguojgurTguoFf4LqX4Lqx4LqZ4Lqn4LqyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn4Lqt4Lqy4LqX4Lq04LqUX+C6iOC6seC6mV/guq3gurHguofguoTgurLguplf4Lqe4Lq44LqUX+C6nuC6sOC6q+C6seC6lF/guqrgurjguoFf4LuA4Lqq4Lq74LqyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgupfgurTgupRf4LqI4Lqx4LqZX+C6reC6seC6h+C6hOC6suC6mV/gup7gurjgupRf4Lqe4Lqw4Lqr4Lqx4LqUX+C6quC6uOC6gV/gu4DguqrgurvgurInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgupdf4LqIX+C6reC6hF/gup5f4Lqe4LqrX+C6quC6gV/guqonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ+C6p+C6seC6mWRkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+C6leC6reC6meC7gOC6iuC6u+C7ieC6snzgupXguq3gupngu4HguqXguocvLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSAn4LqV4Lqt4LqZ4LuB4Lql4LqHJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LqV4Lqt4LqZ4LuA4LqK4Lq74LuJ4LqyJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C6leC6reC6meC7geC6peC6hyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+C6oeC6t+C7ieC6meC6teC7ieC7gOC6p+C6peC6sl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+C6oeC6t+C7ieC6reC6t+C7iOC6meC7gOC6p+C6peC6sl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vguqfgurHgupldZGRkZFvgu5zgu4ngurLgu4DguqfguqXgurJdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vguqHgurfgu4nguqfgurLgupngupngurXgu4ngu4DguqfguqXgurJdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4Lqn4Lqx4LqZXWRkZGRb4LuB4Lql4LuJ4Lqn4LqZ4Lq14LuJ4LuA4Lqn4Lql4LqyXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ+C6reC6teC6gSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclc+C6nOC7iOC6suC6meC6oeC6sicsXHJcbiAgICAgICAgcyA6ICfguprgu43gu4jgu4Dgupfgurvgu4jgurLgu4PgupTguqfgurTgupngurLgupfgurUnLFxyXG4gICAgICAgIG0gOiAnMSDgupngurLgupfgurUnLFxyXG4gICAgICAgIG1tIDogJyVkIOC6meC6suC6l+C6tScsXHJcbiAgICAgICAgaCA6ICcxIOC6iuC6u+C7iOC6p+C7guC6oeC6hycsXHJcbiAgICAgICAgaGggOiAnJWQg4LqK4Lq74LuI4Lqn4LuC4Lqh4LqHJyxcclxuICAgICAgICBkIDogJzEg4Lqh4Lq34LuJJyxcclxuICAgICAgICBkZCA6ICclZCDguqHgurfgu4knLFxyXG4gICAgICAgIE0gOiAnMSDgu4DgupTgurfguq3gupknLFxyXG4gICAgICAgIE1NIDogJyVkIOC7gOC6lOC6t+C6reC6mScsXHJcbiAgICAgICAgeSA6ICcxIOC6m+C6tScsXHJcbiAgICAgICAgeXkgOiAnJWQg4Lqb4Lq1J1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC8o4LqX4Lq14LuIKVxcZHsxLDJ9LyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuICfgupfgurXgu4gnICsgbnVtYmVyO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBsbztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbG8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbG8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBMaXRodWFuaWFuIFtsdF1cclxuLy8hIGF1dGhvciA6IE1pbmRhdWdhcyBNb3rFq3JhcyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tbW96dXJhc1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHVuaXRzID0ge1xyXG4gICAgJ20nIDogJ21pbnV0xJdfbWludXTEl3NfbWludXTEmScsXHJcbiAgICAnbW0nOiAnbWludXTEl3NfbWludcSNacWzX21pbnV0ZXMnLFxyXG4gICAgJ2gnIDogJ3ZhbGFuZGFfdmFsYW5kb3NfdmFsYW5kxIUnLFxyXG4gICAgJ2hoJzogJ3ZhbGFuZG9zX3ZhbGFuZMWzX3ZhbGFuZGFzJyxcclxuICAgICdkJyA6ICdkaWVuYV9kaWVub3NfZGllbsSFJyxcclxuICAgICdkZCc6ICdkaWVub3NfZGllbsWzX2RpZW5hcycsXHJcbiAgICAnTScgOiAnbcSXbnVvX23El25lc2lvX23El25lc8SvJyxcclxuICAgICdNTSc6ICdtxJduZXNpYWlfbcSXbmVzacWzX23El25lc2l1cycsXHJcbiAgICAneScgOiAnbWV0YWlfbWV0xbNfbWV0dXMnLFxyXG4gICAgJ3l5JzogJ21ldGFpX21ldMWzX21ldHVzJ1xyXG59O1xyXG5mdW5jdGlvbiB0cmFuc2xhdGVTZWNvbmRzKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICByZXR1cm4gJ2tlbGlvcyBzZWt1bmTEl3MnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAna2VsacWzIHNla3VuZMW+acWzJyA6ICdrZWxpYXMgc2VrdW5kZXMnO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZVNpbmd1bGFyKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtcyhrZXkpWzBdIDogKGlzRnV0dXJlID8gZm9ybXMoa2V5KVsxXSA6IGZvcm1zKGtleSlbMl0pO1xyXG59XHJcbmZ1bmN0aW9uIHNwZWNpYWwobnVtYmVyKSB7XHJcbiAgICByZXR1cm4gbnVtYmVyICUgMTAgPT09IDAgfHwgKG51bWJlciA+IDEwICYmIG51bWJlciA8IDIwKTtcclxufVxyXG5mdW5jdGlvbiBmb3JtcyhrZXkpIHtcclxuICAgIHJldHVybiB1bml0c1trZXldLnNwbGl0KCdfJyk7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcclxuICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgdHJhbnNsYXRlU2luZ3VsYXIobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXlbMF0sIGlzRnV0dXJlKTtcclxuICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgKyAoc3BlY2lhbChudW1iZXIpID8gZm9ybXMoa2V5KVsxXSA6IGZvcm1zKGtleSlbMF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIGZvcm1zKGtleSlbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChzcGVjaWFsKG51bWJlcikgPyBmb3JtcyhrZXkpWzFdIDogZm9ybXMoa2V5KVsyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBsdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2x0Jywge1xyXG4gICAgbW9udGhzIDoge1xyXG4gICAgICAgIGZvcm1hdDogJ3NhdXNpb192YXNhcmlvX2tvdm9fYmFsYW5kxb5pb19nZWd1xb7El3NfYmlyxb5lbGlvX2xpZXBvc19ydWdwasWrxI1pb19ydWdzxJdqb19zcGFsaW9fbGFwa3JpxI1pb19ncnVvZMW+aW8nLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ3NhdXNpc192YXNhcmlzX2tvdmFzX2JhbGFuZGlzX2dlZ3XFvsSXX2JpcsW+ZWxpc19saWVwYV9ydWdwasWrdGlzX3J1Z3PEl2ppc19zcGFsaXNfbGFwa3JpdGlzX2dydW9kaXMnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgaXNGb3JtYXQ6IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/fE1NTU0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStEW29EXT8vXHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiAnc2F1X3Zhc19rb3ZfYmFsX2dlZ19iaXJfbGllX3JncF9yZ3Nfc3BhX2xhcF9ncmQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6IHtcclxuICAgICAgICBmb3JtYXQ6ICdzZWttYWRpZW7Er19waXJtYWRpZW7Er19hbnRyYWRpZW7Er190cmXEjWlhZGllbsSvX2tldHZpcnRhZGllbsSvX3Blbmt0YWRpZW7Er1/FoWXFoXRhZGllbsSvJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHN0YW5kYWxvbmU6ICdzZWttYWRpZW5pc19waXJtYWRpZW5pc19hbnRyYWRpZW5pc190cmXEjWlhZGllbmlzX2tldHZpcnRhZGllbmlzX3Blbmt0YWRpZW5pc1/FoWXFoXRhZGllbmlzJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIGlzRm9ybWF0OiAvZGRkZCBISDptbS9cclxuICAgIH0sXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1Nla19QaXJfQW50X1RyZV9LZXRfUGVuX8WgZcWhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU19QX0FfVF9LX1BuX8WgJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXHJcbiAgICAgICAgTEwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dJyxcclxuICAgICAgICBMTEwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBISDptbSBbdmFsLl0nLFxyXG4gICAgICAgIExMTEwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBkZGRkLCBISDptbSBbdmFsLl0nLFxyXG4gICAgICAgIGwgOiAnWVlZWS1NTS1ERCcsXHJcbiAgICAgICAgbGwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dJyxcclxuICAgICAgICBsbGwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBISDptbSBbdmFsLl0nLFxyXG4gICAgICAgIGxsbGwgOiAnWVlZWSBbbS5dIE1NTU0gRCBbZC5dLCBkZGQsIEhIOm1tIFt2YWwuXSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vFoGlhbmRpZW5dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tSeXRval0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW1Zha2FyXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW1ByYcSXanVzxK9dIGRkZGQgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdwbyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdwcmllxaEgJXMnLFxyXG4gICAgICAgIHMgOiB0cmFuc2xhdGVTZWNvbmRzLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGVTaW5ndWxhcixcclxuICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoIDogdHJhbnNsYXRlU2luZ3VsYXIsXHJcbiAgICAgICAgaGggOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZCA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxyXG4gICAgICAgIGRkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gOiB0cmFuc2xhdGVTaW5ndWxhcixcclxuICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5IDogdHJhbnNsYXRlU2luZ3VsYXIsXHJcbiAgICAgICAgeXkgOiB0cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tb2ppLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICctb2ppJztcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbHQ7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTGF0dmlhbiBbbHZdXHJcbi8vISBhdXRob3IgOiBLcmlzdGFwcyBLYXJsc29ucyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9za2FrcmlcclxuLy8hIGF1dGhvciA6IErEgW5pcyBFbG1lcmlzIDogaHR0cHM6Ly9naXRodWIuY29tL0phbmlzRVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHVuaXRzID0ge1xyXG4gICAgJ20nOiAnbWluxat0ZXNfbWluxat0xJNtX21pbsWrdGVfbWluxat0ZXMnLnNwbGl0KCdfJyksXHJcbiAgICAnbW0nOiAnbWluxat0ZXNfbWluxat0xJNtX21pbsWrdGVfbWluxat0ZXMnLnNwbGl0KCdfJyksXHJcbiAgICAnaCc6ICdzdHVuZGFzX3N0dW5kxIFtX3N0dW5kYV9zdHVuZGFzJy5zcGxpdCgnXycpLFxyXG4gICAgJ2hoJzogJ3N0dW5kYXNfc3R1bmTEgW1fc3R1bmRhX3N0dW5kYXMnLnNwbGl0KCdfJyksXHJcbiAgICAnZCc6ICdkaWVuYXNfZGllbsSBbV9kaWVuYV9kaWVuYXMnLnNwbGl0KCdfJyksXHJcbiAgICAnZGQnOiAnZGllbmFzX2RpZW7EgW1fZGllbmFfZGllbmFzJy5zcGxpdCgnXycpLFxyXG4gICAgJ00nOiAnbcSTbmXFoWFfbcSTbmXFoWllbV9txJNuZXNpc19txJNuZcWhaScuc3BsaXQoJ18nKSxcclxuICAgICdNTSc6ICdtxJNuZcWhYV9txJNuZcWhaWVtX23Ek25lc2lzX23Ek25lxaFpJy5zcGxpdCgnXycpLFxyXG4gICAgJ3knOiAnZ2FkYV9nYWRpZW1fZ2Fkc19nYWRpJy5zcGxpdCgnXycpLFxyXG4gICAgJ3l5JzogJ2dhZGFfZ2FkaWVtX2dhZHNfZ2FkaScuc3BsaXQoJ18nKVxyXG59O1xyXG4vKipcclxuICogQHBhcmFtIHdpdGhvdXRTdWZmaXggYm9vbGVhbiB0cnVlID0gYSBsZW5ndGggb2YgdGltZTsgZmFsc2UgPSBiZWZvcmUvYWZ0ZXIgYSBwZXJpb2Qgb2YgdGltZS5cclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdChmb3JtcywgbnVtYmVyLCB3aXRob3V0U3VmZml4KSB7XHJcbiAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIC8vIEUuZy4gXCIyMSBtaW7Fq3RlXCIsIFwiMyBtaW7Fq3Rlc1wiLlxyXG4gICAgICAgIHJldHVybiBudW1iZXIgJSAxMCA9PT0gMSAmJiBudW1iZXIgJSAxMDAgIT09IDExID8gZm9ybXNbMl0gOiBmb3Jtc1szXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRS5nLiBcIjIxIG1pbsWrdGVzXCIgYXMgaW4gXCJwxJNjIDIxIG1pbsWrdGVzXCIuXHJcbiAgICAgICAgLy8gRS5nLiBcIjMgbWluxat0xJNtXCIgYXMgaW4gXCJwxJNjIDMgbWluxat0xJNtXCIuXHJcbiAgICAgICAgcmV0dXJuIG51bWJlciAlIDEwID09PSAxICYmIG51bWJlciAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IGZvcm1zWzFdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBmb3JtYXQodW5pdHNba2V5XSwgbnVtYmVyLCB3aXRob3V0U3VmZml4KTtcclxufVxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHJldHVybiBmb3JtYXQodW5pdHNba2V5XSwgbnVtYmVyLCB3aXRob3V0U3VmZml4KTtcclxufVxyXG5mdW5jdGlvbiByZWxhdGl2ZVNlY29uZHMobnVtYmVyLCB3aXRob3V0U3VmZml4KSB7XHJcbiAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdkYcW+YXMgc2VrdW5kZXMnIDogJ2Rhxb7EgW0gc2VrdW5kxJNtJztcclxufVxyXG5cclxudmFyIGx2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbHYnLCB7XHJcbiAgICBtb250aHMgOiAnamFudsSBcmlzX2ZlYnJ1xIFyaXNfbWFydHNfYXByxKtsaXNfbWFpanNfasWrbmlqc19qxatsaWpzX2F1Z3VzdHNfc2VwdGVtYnJpc19va3RvYnJpc19ub3ZlbWJyaXNfZGVjZW1icmlzJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21haV9qxatuX2rFq2xfYXVnX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3N2xJN0ZGllbmFfcGlybWRpZW5hX290cmRpZW5hX3RyZcWhZGllbmFfY2V0dXJ0ZGllbmFfcGlla3RkaWVuYV9zZXN0ZGllbmEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1N2X1BfT19UX0NfUGtfUycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1N2X1BfT19UX0NfUGtfUycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVkuJyxcclxuICAgICAgICBMTCA6ICdZWVlZLiBbZ2FkYV0gRC4gTU1NTScsXHJcbiAgICAgICAgTExMIDogJ1lZWVkuIFtnYWRhXSBELiBNTU1NLCBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdZWVlZLiBbZ2FkYV0gRC4gTU1NTSwgZGRkZCwgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbxaBvZGllbiBwdWxrc3Rlbl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1LEq3QgcHVsa3N0ZW5dIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtwdWxrc3Rlbl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW1Zha2FyIHB1bGtzdGVuXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW1BhZ8SBanXFocSBXSBkZGRkIFtwdWxrc3Rlbl0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdwxJNjICVzJyxcclxuICAgICAgICBwYXN0IDogJ3Bpcm1zICVzJyxcclxuICAgICAgICBzIDogcmVsYXRpdmVTZWNvbmRzLFxyXG4gICAgICAgIG0gOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXHJcbiAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGggOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXHJcbiAgICAgICAgaGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGQgOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXHJcbiAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIE0gOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXHJcbiAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIHkgOiByZWxhdGl2ZVRpbWVXaXRoU2luZ3VsYXIsXHJcbiAgICAgICAgeXkgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBsdjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHYuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNb250ZW5lZ3JpbiBbbWVdXHJcbi8vISBhdXRob3IgOiBNaW9kcmFnIE5pa2HEjSA8bWlvZHJhZ0ByZXN0YXJ0aXQubWU+IDogaHR0cHM6Ly9naXRodWIuY29tL21pb2RyYWduaWthY1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHRyYW5zbGF0b3IgPSB7XHJcbiAgICB3b3JkczogeyAvL0RpZmZlcmVudCBncmFtbWF0aWNhbCBjYXNlc1xyXG4gICAgICAgIG06IFsnamVkYW4gbWludXQnLCAnamVkbm9nIG1pbnV0YSddLFxyXG4gICAgICAgIG1tOiBbJ21pbnV0JywgJ21pbnV0YScsICdtaW51dGEnXSxcclxuICAgICAgICBoOiBbJ2plZGFuIHNhdCcsICdqZWRub2cgc2F0YSddLFxyXG4gICAgICAgIGhoOiBbJ3NhdCcsICdzYXRhJywgJ3NhdGknXSxcclxuICAgICAgICBkZDogWydkYW4nLCAnZGFuYScsICdkYW5hJ10sXHJcbiAgICAgICAgTU06IFsnbWplc2VjJywgJ21qZXNlY2EnLCAnbWplc2VjaSddLFxyXG4gICAgICAgIHl5OiBbJ2dvZGluYScsICdnb2RpbmUnLCAnZ29kaW5hJ11cclxuICAgIH0sXHJcbiAgICBjb3JyZWN0R3JhbW1hdGljYWxDYXNlOiBmdW5jdGlvbiAobnVtYmVyLCB3b3JkS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IHdvcmRLZXlbMF0gOiAobnVtYmVyID49IDIgJiYgbnVtYmVyIDw9IDQgPyB3b3JkS2V5WzFdIDogd29yZEtleVsyXSk7XHJcbiAgICB9LFxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgICAgICB2YXIgd29yZEtleSA9IHRyYW5zbGF0b3Iud29yZHNba2V5XTtcclxuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IHdvcmRLZXlbMF0gOiB3b3JkS2V5WzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyB0cmFuc2xhdG9yLmNvcnJlY3RHcmFtbWF0aWNhbENhc2UobnVtYmVyLCB3b3JkS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgbWUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtZScsIHtcclxuICAgIG1vbnRoczogJ2phbnVhcl9mZWJydWFyX21hcnRfYXByaWxfbWFqX2p1bl9qdWxfYXZndXN0X3NlcHRlbWJhcl9va3RvYmFyX25vdmVtYmFyX2RlY2VtYmFyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICdqYW4uX2ZlYi5fbWFyLl9hcHIuX21hal9qdW5fanVsX2F2Zy5fc2VwLl9va3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXM6ICduZWRqZWxqYV9wb25lZGplbGpha191dG9yYWtfc3JpamVkYV/EjWV0dnJ0YWtfcGV0YWtfc3Vib3RhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ25lZC5fcG9uLl91dG8uX3NyaS5fxI1ldC5fcGV0Ll9zdWIuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW46ICduZV9wb191dF9zcl/EjWVfcGVfc3UnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEw6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXI6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW2RhbmFzIHVdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW3NqdXRyYSB1XSBMVCcsXHJcblxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtuZWRqZWxqdV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3JpamVkdV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3Vib3R1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIGRkZGQgW3VdIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSAgOiAnW2p1xI1lIHVdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RXZWVrRGF5cyA9IFtcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW25lZGplbGplXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3BvbmVkamVsamthXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3V0b3JrYV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW3NyaWplZGVdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbxI1ldHZydGthXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3BldGthXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbc3Vib3RlXSBbdV0gTFQnXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHJldHVybiBsYXN0V2Vla0RheXNbdGhpcy5kYXkoKV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxyXG4gICAgICAgIHBhc3QgICA6ICdwcmlqZSAlcycsXHJcbiAgICAgICAgcyAgICAgIDogJ25la29saWtvIHNla3VuZGknLFxyXG4gICAgICAgIG0gICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIG1tICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGggICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGhoICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGQgICAgICA6ICdkYW4nLFxyXG4gICAgICAgIGRkICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIE0gICAgICA6ICdtamVzZWMnLFxyXG4gICAgICAgIE1NICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxyXG4gICAgICAgIHl5ICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBtZTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNYW9yaSBbbWldXHJcbi8vISBhdXRob3IgOiBKb2huIENvcnJpZ2FuIDxyb2JiaWVjbG9zZXRAZ21haWwuY29tPiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb2huaWRlYWxcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtaSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21pJywge1xyXG4gICAgbW9udGhzOiAnS29oaS10xIF0ZV9IdWktdGFuZ3VydV9Qb3V0xastdGUtcmFuZ2lfUGFlbmdhLXdoxIF3aMSBX0hhcmF0dWFfUGlwaXJpX0jFjW5nb2luZ29pX0hlcmUtdHVyaS1rxY1rxIFfTWFodXJ1X1doaXJpbmdhLcSBLW51a3VfV2hpcmluZ2EtxIEtcmFuZ2lfSGFraWhlYScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0OiAnS29oaV9IdWlfUG91X1BhZV9IYXJhX1BpcGlfSMWNbmdvaV9IZXJlX01haHVfV2hpLW51X1doaS1yYV9IYWtpJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUmVnZXg6IC8oPzpbJ2EtelxcdTAxMDFcXHUwMTREXFx1MDE2Ql0rXFwtPyl7MSwzfS9pLFxyXG4gICAgbW9udGhzU3RyaWN0UmVnZXg6IC8oPzpbJ2EtelxcdTAxMDFcXHUwMTREXFx1MDE2Ql0rXFwtPyl7MSwzfS9pLFxyXG4gICAgbW9udGhzU2hvcnRSZWdleDogLyg/OlsnYS16XFx1MDEwMVxcdTAxNERcXHUwMTZCXStcXC0/KXsxLDN9L2ksXHJcbiAgICBtb250aHNTaG9ydFN0cmljdFJlZ2V4OiAvKD86WydhLXpcXHUwMTAxXFx1MDE0RFxcdTAxNkJdK1xcLT8pezEsMn0vaSxcclxuICAgIHdlZWtkYXlzOiAnUsSBdGFwdV9NYW5lX1TFq3JlaV9XZW5lcmVpX1TEgWl0ZV9QYXJhaXJlX0jEgXRhcmVpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ1RhX01hX1TFq19XZV9UxIFpX1BhX0jEgScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluOiAnVGFfTWFfVMWrX1dlX1TEgWlfUGFfSMSBJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0hIOm1tJyxcclxuICAgICAgICBMVFM6ICdISDptbTpzcycsXHJcbiAgICAgICAgTDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIFtpXSBISDptbScsXHJcbiAgICAgICAgTExMTDogJ2RkZGQsIEQgTU1NTSBZWVlZIFtpXSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbaSB0ZWllIG1haGFuYSwgaV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbYXBvcG8gaV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbaV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbaW5hbmFoaSBpXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFt3aGFrYW11dHVuZ2EgaV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWU6IHtcclxuICAgICAgICBmdXR1cmU6ICdpIHJvdG8gaSAlcycsXHJcbiAgICAgICAgcGFzdDogJyVzIGkgbXVhJyxcclxuICAgICAgICBzOiAndGUgaMSTa29uYSBydWFydWEnLFxyXG4gICAgICAgIG06ICdoZSBtZW5ldGknLFxyXG4gICAgICAgIG1tOiAnJWQgbWVuZXRpJyxcclxuICAgICAgICBoOiAndGUgaGFvcmEnLFxyXG4gICAgICAgIGhoOiAnJWQgaGFvcmEnLFxyXG4gICAgICAgIGQ6ICdoZSByYScsXHJcbiAgICAgICAgZGQ6ICclZCByYScsXHJcbiAgICAgICAgTTogJ2hlIG1hcmFtYScsXHJcbiAgICAgICAgTU06ICclZCBtYXJhbWEnLFxyXG4gICAgICAgIHk6ICdoZSB0YXUnLFxyXG4gICAgICAgIHl5OiAnJWQgdGF1J1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfcK6LyxcclxuICAgIG9yZGluYWw6ICclZMK6JyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBtaTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNYWNlZG9uaWFuIFtta11cclxuLy8hIGF1dGhvciA6IEJvcmlzbGF2IE1pY2tvdiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9CMGswXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbWsgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtaycsIHtcclxuICAgIG1vbnRocyA6ICfRmNCw0L3Rg9Cw0YDQuF/RhNC10LLRgNGD0LDRgNC4X9C80LDRgNGCX9Cw0L/RgNC40Ltf0LzQsNGYX9GY0YPQvdC4X9GY0YPQu9C4X9Cw0LLQs9GD0YHRgl/RgdC10L/RgtC10LzQstGA0Lhf0L7QutGC0L7QvNCy0YDQuF/QvdC+0LXQvNCy0YDQuF/QtNC10LrQtdC80LLRgNC4Jy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn0ZjQsNC9X9GE0LXQsl/QvNCw0YBf0LDQv9GAX9C80LDRmF/RmNGD0L1f0ZjRg9C7X9Cw0LLQs1/RgdC10L9f0L7QutGCX9C90L7QtV/QtNC10LonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfQvdC10LTQtdC70LBf0L/QvtC90LXQtNC10LvQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTQsF/Rh9C10YLQstGA0YLQvtC6X9C/0LXRgtC+0Lpf0YHQsNCx0L7RgtCwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQvdC10LRf0L/QvtC9X9Cy0YLQvl/RgdGA0LVf0YfQtdGCX9C/0LXRgl/RgdCw0LEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQvWVf0L9vX9Cy0YJf0YHRgF/Rh9C1X9C/0LVf0YFhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnRC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vQlNC10L3QtdGBINCy0L5dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vQo9GC0YDQtSDQstC+XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW9CS0L5dIGRkZGQgW9Cy0L5dIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vQktGH0LXRgNCwINCy0L5dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JjQt9C80LjQvdCw0YLQsNGC0LBdIGRkZGQgW9Cy0L5dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQmNC30LzQuNC90LDRgtC40L7Rgl0gZGRkZCBb0LLQvl0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn0L/QvtGB0LvQtSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfQv9GA0LXQtCAlcycsXHJcbiAgICAgICAgcyA6ICfQvdC10LrQvtC70LrRgyDRgdC10LrRg9C90LTQuCcsXHJcbiAgICAgICAgbSA6ICfQvNC40L3Rg9GC0LAnLFxyXG4gICAgICAgIG1tIDogJyVkINC80LjQvdGD0YLQuCcsXHJcbiAgICAgICAgaCA6ICfRh9Cw0YEnLFxyXG4gICAgICAgIGhoIDogJyVkINGH0LDRgdCwJyxcclxuICAgICAgICBkIDogJ9C00LXQvScsXHJcbiAgICAgICAgZGQgOiAnJWQg0LTQtdC90LAnLFxyXG4gICAgICAgIE0gOiAn0LzQtdGB0LXRhicsXHJcbiAgICAgICAgTU0gOiAnJWQg0LzQtdGB0LXRhtC4JyxcclxuICAgICAgICB5IDogJ9Cz0L7QtNC40L3QsCcsXHJcbiAgICAgICAgeXkgOiAnJWQg0LPQvtC00LjQvdC4J1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0LXQsnzQtdC9fNGC0Lh80LLQuHzRgNC4fNC80LgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGxhc3REaWdpdCA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBsYXN0MkRpZ2l0cyA9IG51bWJlciAlIDEwMDtcclxuICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC10LInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGFzdDJEaWdpdHMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQvSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0MkRpZ2l0cyA+IDEwICYmIGxhc3QyRGlnaXRzIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LLQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YDQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDcgfHwgbGFzdERpZ2l0ID09PSA4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC80LgnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGC0LgnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbWs7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21rLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21rLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTWFsYXlhbGFtIFttbF1cclxuLy8hIGF1dGhvciA6IEZsb3lkIFBpbmsgOiBodHRwczovL2dpdGh1Yi5jb20vZmxveWRwaW5rXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbWwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdtbCcsIHtcclxuICAgIG1vbnRocyA6ICfgtJzgtKjgtYHgtLXgtLDgtL9f4LSr4LWG4LSs4LWN4LSw4LWB4LS14LSw4LS/X+C0ruC0vuC1vOC0muC1jeC0muC1jV/gtI/gtKrgtY3gtLDgtL/gtb1f4LSu4LWH4LSv4LWNX+C0nOC1guC1ul/gtJzgtYLgtLLgtYhf4LST4LSX4LS44LWN4LSx4LWN4LSx4LWNX+C0uOC1huC0quC1jeC0seC1jeC0seC0guC0rOC1vF/gtJLgtJXgtY3gtJ/gtYvgtKzgtbxf4LSo4LS14LSC4LSs4LW8X+C0oeC0v+C0uOC0guC0rOC1vCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+C0nOC0qOC1gS5f4LSr4LWG4LSs4LWN4LSw4LWBLl/gtK7gtL7gtbwuX+C0j+C0quC1jeC0sOC0vy5f4LSu4LWH4LSv4LWNX+C0nOC1guC1ul/gtJzgtYLgtLLgtYguX+C0k+C0ly5f4LS44LWG4LSq4LWN4LSx4LWN4LSxLl/gtJLgtJXgtY3gtJ/gtYsuX+C0qOC0teC0gi5f4LSh4LS/4LS44LSCLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAn4LSe4LS+4LSv4LSx4LS+4LS04LWN4LSaX+C0pOC0v+C0meC1jeC0leC0s+C0vuC0tOC1jeC0ml/gtJrgtYrgtLXgtY3gtLXgtL7gtLTgtY3gtJpf4LSs4LWB4LSn4LSo4LS+4LS04LWN4LSaX+C0teC1jeC0r+C0vuC0tOC0vuC0tOC1jeC0ml/gtLXgtYbgtLPgtY3gtLPgtL/gtK/gtL7gtLTgtY3gtJpf4LS24LSo4LS/4LSv4LS+4LS04LWN4LSaJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgtJ7gtL7gtK/gtbxf4LSk4LS/4LSZ4LWN4LSV4LW+X+C0muC1iuC0teC1jeC0tV/gtKzgtYHgtKfgtbtf4LS14LWN4LSv4LS+4LS04LSCX+C0teC1huC0s+C1jeC0s+C0v1/gtLbgtKjgtL8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgtJ7gtL5f4LSk4LS/X+C0muC1il/gtKzgtYFf4LS14LWN4LSv4LS+X+C0teC1hl/gtLYnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0gLeC0qOC1gScsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcyAt4LSo4LWBJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSAt4LSo4LWBJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0gLeC0qOC1gSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgtIfgtKjgtY3gtKjgtY1dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgtKjgtL7gtLPgtYZdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4LSH4LSo4LWN4LSo4LSy4LWGXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+C0leC0tOC0v+C0nuC1jeC0nl0gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDgtJXgtLTgtL/gtJ7gtY3gtJ7gtY0nLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4LSu4LWB4LW74LSq4LWNJyxcclxuICAgICAgICBzIDogJ+C0heC1veC0qiDgtKjgtL/gtK7gtL/gtLfgtJngtY3gtJngtb4nLFxyXG4gICAgICAgIG0gOiAn4LSS4LSw4LWBIOC0ruC0v+C0qOC0v+C0seC1jeC0seC1jScsXHJcbiAgICAgICAgbW0gOiAnJWQg4LSu4LS/4LSo4LS/4LSx4LWN4LSx4LWNJyxcclxuICAgICAgICBoIDogJ+C0kuC0sOC1gSDgtK7gtKPgtL/gtJXgtY3gtJXgtYLgtbwnLFxyXG4gICAgICAgIGhoIDogJyVkIOC0ruC0o+C0v+C0leC1jeC0leC1guC1vCcsXHJcbiAgICAgICAgZCA6ICfgtJLgtLDgtYEg4LSm4LS/4LS14LS44LSCJyxcclxuICAgICAgICBkZCA6ICclZCDgtKbgtL/gtLXgtLjgtIInLFxyXG4gICAgICAgIE0gOiAn4LSS4LSw4LWBIOC0ruC0vuC0uOC0gicsXHJcbiAgICAgICAgTU0gOiAnJWQg4LSu4LS+4LS44LSCJyxcclxuICAgICAgICB5IDogJ+C0kuC0sOC1gSDgtLXgtbzgtLfgtIInLFxyXG4gICAgICAgIHl5IDogJyVkIOC0teC1vOC0t+C0gidcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4LSw4LS+4LSk4LWN4LSw4LS/fOC0sOC0vuC0teC0v+C0suC1hnzgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNfOC0teC1iOC0leC1geC0qOC1jeC0qOC1h+C0sOC0gnzgtLDgtL7gtKTgtY3gtLDgtL8vaSxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChtZXJpZGllbSA9PT0gJ+C0sOC0vuC0pOC1jeC0sOC0vycgJiYgaG91ciA+PSA0KSB8fFxyXG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNJyB8fFxyXG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfgtLXgtYjgtJXgtYHgtKjgtY3gtKjgtYfgtLDgtIInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C0sOC0vuC0pOC1jeC0sOC0vyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgtLDgtL7gtLXgtL/gtLLgtYYnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LSJ4LSa4LWN4LSaIOC0leC0tOC0v+C0nuC1jeC0nuC1jSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgtLXgtYjgtJXgtYHgtKjgtY3gtKjgtYfgtLDgtIInO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LSw4LS+4LSk4LWN4LSw4LS/JztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG1sO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE1hcmF0aGkgW21yXVxyXG4vLyEgYXV0aG9yIDogSGFyc2hhZCBLYWxlIDogaHR0cHM6Ly9naXRodWIuY29tL2thbGVodlxyXG4vLyEgYXV0aG9yIDogVml2ZWsgQXRoYWx5ZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS92bmF0aGFseWVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgpacnLFxyXG4gICAgJzInOiAn4KWoJyxcclxuICAgICczJzogJ+ClqScsXHJcbiAgICAnNCc6ICfgpaonLFxyXG4gICAgJzUnOiAn4KWrJyxcclxuICAgICc2JzogJ+ClrCcsXHJcbiAgICAnNyc6ICfgpa0nLFxyXG4gICAgJzgnOiAn4KWuJyxcclxuICAgICc5JzogJ+ClrycsXHJcbiAgICAnMCc6ICfgpaYnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4KWnJzogJzEnLFxyXG4gICAgJ+ClqCc6ICcyJyxcclxuICAgICfgpaknOiAnMycsXHJcbiAgICAn4KWqJzogJzQnLFxyXG4gICAgJ+Clqyc6ICc1JyxcclxuICAgICfgpawnOiAnNicsXHJcbiAgICAn4KWtJzogJzcnLFxyXG4gICAgJ+Clric6ICc4JyxcclxuICAgICfgpa8nOiAnOScsXHJcbiAgICAn4KWmJzogJzAnXHJcbn07XHJcblxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWVNcihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpXHJcbntcclxuICAgIHZhciBvdXRwdXQgPSAnJztcclxuICAgIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHJpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSAncyc6IG91dHB1dCA9ICfgpJXgpL7gpLngpYAg4KS44KWH4KSV4KSC4KSmJzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ20nOiBvdXRwdXQgPSAn4KSP4KSVIOCkruCkv+CkqOCkv+Cknyc7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtbSc6IG91dHB1dCA9ICclZCDgpK7gpL/gpKjgpL/gpJ/gpYcnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaCc6IG91dHB1dCA9ICfgpI/gpJUg4KSk4KS+4KS4JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hoJzogb3V0cHV0ID0gJyVkIOCkpOCkvuCkuCc7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkJzogb3V0cHV0ID0gJ+Ckj+CklSDgpKbgpL/gpLXgpLgnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGQnOiBvdXRwdXQgPSAnJWQg4KSm4KS/4KS14KS4JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOiBvdXRwdXQgPSAn4KSP4KSVIOCkruCkueCkv+CkqOCkvic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdNTSc6IG91dHB1dCA9ICclZCDgpK7gpLngpL/gpKjgpYcnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAneSc6IG91dHB1dCA9ICfgpI/gpJUg4KS14KSw4KWN4KS3JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3l5Jzogb3V0cHV0ID0gJyVkIOCkteCksOCljeCkt+Clhyc7IGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3MnOiBvdXRwdXQgPSAn4KSV4KS+4KS54KWAIOCkuOClh+CkleCkguCkpuCkvuCkgic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpK7gpL/gpKjgpL/gpJ/gpL4nOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbW0nOiBvdXRwdXQgPSAnJWQg4KSu4KS/4KSo4KS/4KSf4KS+4KSCJzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2gnOiBvdXRwdXQgPSAn4KSP4KSV4KS+IOCkpOCkvuCkuOCkvic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdoaCc6IG91dHB1dCA9ICclZCDgpKTgpL7gpLjgpL7gpIInOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZCc6IG91dHB1dCA9ICfgpI/gpJXgpL4g4KSm4KS/4KS14KS44KS+JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RkJzogb3V0cHV0ID0gJyVkIOCkpuCkv+CkteCkuOCkvuCkgic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdNJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpK7gpLngpL/gpKjgpY3gpK/gpL4nOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnTU0nOiBvdXRwdXQgPSAnJWQg4KSu4KS54KS/4KSo4KWN4KSv4KS+4KSCJzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3knOiBvdXRwdXQgPSAn4KSP4KSV4KS+IOCkteCksOCljeCkt+Ckvic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd5eSc6IG91dHB1dCA9ICclZCDgpLXgpLDgpY3gpLfgpL7gpIInOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XHJcbn1cclxuXHJcbnZhciBtciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21yJywge1xyXG4gICAgbW9udGhzIDogJ+CknOCkvuCkqOClh+CkteCkvuCksOClgF/gpKvgpYfgpKzgpY3gpLDgpYHgpLXgpL7gpLDgpYBf4KSu4KS+4KSw4KWN4KSaX+Ckj+CkquCljeCksOCkv+Cksl/gpK7gpYdf4KSc4KWC4KSoX+CknOClgeCksuCliF/gpJHgpJfgpLjgpY3gpJ9f4KS44KSq4KWN4KSf4KWH4KSC4KSs4KSwX+CkkeCkleCljeCkn+Cli+CkrOCksF/gpKjgpYvgpLXgpY3gpLngpYfgpILgpKzgpLBf4KSh4KS/4KS44KWH4KSC4KSs4KSwJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICfgpJzgpL7gpKjgpYcuX+Ckq+Clh+CkrOCljeCksOClgS5f4KSu4KS+4KSw4KWN4KSaLl/gpI/gpKrgpY3gpLDgpL8uX+CkruClhy5f4KSc4KWC4KSoLl/gpJzgpYHgpLLgpYguX+CkkeCkly5f4KS44KSq4KWN4KSf4KWH4KSCLl/gpJHgpJXgpY3gpJ/gpYsuX+CkqOCli+CkteCljeCkueClh+Ckgi5f4KSh4KS/4KS44KWH4KSCLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAn4KSw4KS14KS/4KS14KS+4KSwX+CkuOCli+CkruCkteCkvuCksF/gpK7gpILgpJfgpLPgpLXgpL7gpLBf4KSs4KWB4KSn4KS14KS+4KSwX+Ckl+ClgeCksOClguCkteCkvuCksF/gpLbgpYHgpJXgpY3gpLDgpLXgpL7gpLBf4KS24KSo4KS/4KS14KS+4KSwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgpLDgpLXgpL9f4KS44KWL4KSuX+CkruCkguCkl+Cks1/gpKzgpYHgpKdf4KSX4KWB4KSw4KWCX+CktuClgeCkleCljeCksF/gpLbgpKjgpL8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgpLBf4KS44KWLX+CkruCkgl/gpKzgpYFf4KSX4KWBX+CktuClgV/gpLYnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0g4KS14KS+4KSc4KSk4KS+JyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIOCkteCkvuCknOCkpOCkvicsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0g4KS14KS+4KSc4KSk4KS+JyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0g4KS14KS+4KSc4KSk4KS+J1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+CkhuCknF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+CkieCkpuCljeCkr+Ckvl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgpJXgpL7gpLJdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1vgpK7gpL7gpJfgpYDgpLJdIGRkZGQsIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmU6ICclc+CkruCkp+CljeCkr+ClhycsXHJcbiAgICAgICAgcGFzdDogJyVz4KSq4KWC4KSw4KWN4KS14KWAJyxcclxuICAgICAgICBzOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICBtOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICBtbTogcmVsYXRpdmVUaW1lTXIsXHJcbiAgICAgICAgaDogcmVsYXRpdmVUaW1lTXIsXHJcbiAgICAgICAgaGg6IHJlbGF0aXZlVGltZU1yLFxyXG4gICAgICAgIGQ6IHJlbGF0aXZlVGltZU1yLFxyXG4gICAgICAgIGRkOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICBNOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICBNTTogcmVsYXRpdmVUaW1lTXIsXHJcbiAgICAgICAgeTogcmVsYXRpdmVUaW1lTXIsXHJcbiAgICAgICAgeXk6IHJlbGF0aXZlVGltZU1yXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgpafgpajgpangpargpavgpazgpa3gpa7gpa/gpaZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gpLDgpL7gpKTgpY3gpLDgpYB84KS44KSV4KS+4KSz4KWAfOCkpuClgeCkquCkvuCksOClgHzgpLjgpL7gpK/gpILgpJXgpL7gpLPgpYAvLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgpLDgpL7gpKTgpY3gpLDgpYAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkuOCkleCkvuCks+ClgCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkpuClgeCkquCkvuCksOClgCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpL7gpK/gpILgpJXgpL7gpLPgpYAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSk4KWN4KSw4KWAJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CkuOCkleCkvuCks+ClgCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpKbgpYHgpKrgpL7gpLDgpYAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KS44KS+4KSv4KSC4KSV4KS+4KSz4KWAJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpOCljeCksOClgCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBtcjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNYWxheSBbbXMtbXldXHJcbi8vISBub3RlIDogREVQUkVDQVRFRCwgdGhlIGNvcnJlY3Qgb25lIGlzIFttc11cclxuLy8hIGF1dGhvciA6IFdlbGRhbiBKYW1pbGkgOiBodHRwczovL2dpdGh1Yi5jb20vd2VsZGFuXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbXNNeSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21zLW15Jywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcmlfRmVicnVhcmlfTWFjX0FwcmlsX01laV9KdW5fSnVsYWlfT2dvc19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EaXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFjX0Fwcl9NZWlfSnVuX0p1bF9PZ3NfU2VwX09rdF9Ob3ZfRGlzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnQWhhZF9Jc25pbl9TZWxhc2FfUmFidV9LaGFtaXNfSnVtYWF0X1NhYnR1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdBaGRfSXNuX1NlbF9SYWJfS2hhX0p1bV9TYWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdBaF9Jc19TbF9SYl9LbV9KbV9TYicuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hILm1tJyxcclxuICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL3BhZ2l8dGVuZ2FoYXJpfHBldGFuZ3xtYWxhbS8sXHJcbiAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAncGFnaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3RlbmdhaGFyaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdwZXRhbmcnIHx8IG1lcmlkaWVtID09PSAnbWFsYW0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzIDwgMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdwYWdpJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0ZW5nYWhhcmknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BldGFuZyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtYWxhbSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0hhcmkgaW5pIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbRXNvayBwdWt1bF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbS2VsbWFyaW4gcHVrdWxdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtsZXBhcyBwdWt1bF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdkYWxhbSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyB5YW5nIGxlcGFzJyxcclxuICAgICAgICBzIDogJ2JlYmVyYXBhIHNhYXQnLFxyXG4gICAgICAgIG0gOiAnc2VtaW5pdCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWluaXQnLFxyXG4gICAgICAgIGggOiAnc2VqYW0nLFxyXG4gICAgICAgIGhoIDogJyVkIGphbScsXHJcbiAgICAgICAgZCA6ICdzZWhhcmknLFxyXG4gICAgICAgIGRkIDogJyVkIGhhcmknLFxyXG4gICAgICAgIE0gOiAnc2VidWxhbicsXHJcbiAgICAgICAgTU0gOiAnJWQgYnVsYW4nLFxyXG4gICAgICAgIHkgOiAnc2V0YWh1bicsXHJcbiAgICAgICAgeXkgOiAnJWQgdGFodW4nXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG1zTXk7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLW15LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLW15LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTWFsYXkgW21zXVxyXG4vLyEgYXV0aG9yIDogV2VsZGFuIEphbWlsaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWxkYW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21zJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcmlfRmVicnVhcmlfTWFjX0FwcmlsX01laV9KdW5fSnVsYWlfT2dvc19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EaXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFjX0Fwcl9NZWlfSnVuX0p1bF9PZ3NfU2VwX09rdF9Ob3ZfRGlzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnQWhhZF9Jc25pbl9TZWxhc2FfUmFidV9LaGFtaXNfSnVtYWF0X1NhYnR1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdBaGRfSXNuX1NlbF9SYWJfS2hhX0p1bV9TYWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdBaF9Jc19TbF9SYl9LbV9KbV9TYicuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hILm1tJyxcclxuICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL3BhZ2l8dGVuZ2FoYXJpfHBldGFuZ3xtYWxhbS8sXHJcbiAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAncGFnaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3RlbmdhaGFyaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdwZXRhbmcnIHx8IG1lcmlkaWVtID09PSAnbWFsYW0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzIDwgMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdwYWdpJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd0ZW5nYWhhcmknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BldGFuZyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtYWxhbSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0hhcmkgaW5pIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbRXNvayBwdWt1bF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbS2VsbWFyaW4gcHVrdWxdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtsZXBhcyBwdWt1bF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdkYWxhbSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyB5YW5nIGxlcGFzJyxcclxuICAgICAgICBzIDogJ2JlYmVyYXBhIHNhYXQnLFxyXG4gICAgICAgIG0gOiAnc2VtaW5pdCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWluaXQnLFxyXG4gICAgICAgIGggOiAnc2VqYW0nLFxyXG4gICAgICAgIGhoIDogJyVkIGphbScsXHJcbiAgICAgICAgZCA6ICdzZWhhcmknLFxyXG4gICAgICAgIGRkIDogJyVkIGhhcmknLFxyXG4gICAgICAgIE0gOiAnc2VidWxhbicsXHJcbiAgICAgICAgTU0gOiAnJWQgYnVsYW4nLFxyXG4gICAgICAgIHkgOiAnc2V0YWh1bicsXHJcbiAgICAgICAgeXkgOiAnJWQgdGFodW4nXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG1zO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEJ1cm1lc2UgW215XVxyXG4vLyEgYXV0aG9yIDogU3F1YXIgdGVhbSwgbXlzcXVhci5jb21cclxuLy8hIGF1dGhvciA6IERhdmlkIFJvc3NlbGxhdCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9naG9sYWRyXHJcbi8vISBhdXRob3IgOiBUaW4gQXVuZyBMaW4gOiBodHRwczovL2dpdGh1Yi5jb20vdGhhbnlhd3ppbm1pblxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+GBgScsXHJcbiAgICAnMic6ICfhgYInLFxyXG4gICAgJzMnOiAn4YGDJyxcclxuICAgICc0JzogJ+GBhCcsXHJcbiAgICAnNSc6ICfhgYUnLFxyXG4gICAgJzYnOiAn4YGGJyxcclxuICAgICc3JzogJ+GBhycsXHJcbiAgICAnOCc6ICfhgYgnLFxyXG4gICAgJzknOiAn4YGJJyxcclxuICAgICcwJzogJ+GBgCdcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfhgYEnOiAnMScsXHJcbiAgICAn4YGCJzogJzInLFxyXG4gICAgJ+GBgyc6ICczJyxcclxuICAgICfhgYQnOiAnNCcsXHJcbiAgICAn4YGFJzogJzUnLFxyXG4gICAgJ+GBhic6ICc2JyxcclxuICAgICfhgYcnOiAnNycsXHJcbiAgICAn4YGIJzogJzgnLFxyXG4gICAgJ+GBiSc6ICc5JyxcclxuICAgICfhgYAnOiAnMCdcclxufTtcclxuXHJcbnZhciBteSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ215Jywge1xyXG4gICAgbW9udGhzOiAn4YCH4YCU4YC64YCU4YCd4YCr4YCb4YCuX+GAluGAseGAluGAseGArOGAuuGAneGAq+GAm+GArl/hgJnhgJDhgLpf4YCn4YCV4YC84YCuX+GAmeGAsV/hgIfhgL3hgJThgLpf4YCH4YCw4YCc4YCt4YCv4YCE4YC6X+GAnuGAvOGAguGAr+GAkOGAul/hgIXhgIDhgLrhgJDhgIThgLrhgJjhgKxf4YCh4YCx4YCs4YCA4YC64YCQ4YCt4YCv4YCY4YCsX+GAlOGAreGAr+GAneGAhOGAuuGAmOGArF/hgJLhgK7hgIfhgIThgLrhgJjhgKwnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ+GAh+GAlOGAul/hgJbhgLFf4YCZ4YCQ4YC6X+GAleGAvOGArl/hgJnhgLFf4YCH4YC94YCU4YC6X+GAnOGAreGAr+GAhOGAul/hgJ7hgLxf4YCF4YCA4YC6X+GAoeGAseGArOGAgOGAul/hgJThgK3hgK9f4YCS4YCuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXM6ICfhgJDhgJThgIThgLrhgLnhgILhgJThgL3hgLFf4YCQ4YCU4YCE4YC64YC54YCc4YCsX+GAoeGAhOGAuuGAueGAguGAq1/hgJfhgK/hgJLhgLnhgJPhgJ/hgLDhgLhf4YCA4YC84YCs4YCe4YCV4YCQ4YCx4YC4X+GAnuGAseGArOGAgOGAvOGArF/hgIXhgJThgLEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0OiAn4YCU4YC94YCxX+GAnOGArF/hgILhgKtf4YCf4YCw4YC4X+GAgOGAvOGArF/hgJ7hgLHhgKxf4YCU4YCxJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW46ICfhgJThgL3hgLFf4YCc4YCsX+GAguGAq1/hgJ/hgLDhgLhf4YCA4YC84YCsX+GAnuGAseGArF/hgJThgLEnLnNwbGl0KCdfJyksXHJcblxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0hIOm1tJyxcclxuICAgICAgICBMVFM6ICdISDptbTpzcycsXHJcbiAgICAgICAgTDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb4YCa4YCU4YCxLl0gTFQgW+GAmeGAvuGArF0nLFxyXG4gICAgICAgIG5leHREYXk6ICdb4YCZ4YCU4YCA4YC64YCW4YC84YCU4YC6XSBMVCBb4YCZ4YC+4YCsXScsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIExUIFvhgJnhgL7hgKxdJyxcclxuICAgICAgICBsYXN0RGF5OiAnW+GAmeGAlOGAsS7hgIBdIExUIFvhgJnhgL7hgKxdJyxcclxuICAgICAgICBsYXN0V2VlazogJ1vhgJXhgLzhgK7hgLjhgIHhgLLhgLfhgJ7hgLHhgKxdIGRkZGQgTFQgW+GAmeGAvuGArF0nLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWU6IHtcclxuICAgICAgICBmdXR1cmU6ICfhgJzhgKzhgJnhgIrhgLrhgLcgJXMg4YCZ4YC+4YCsJyxcclxuICAgICAgICBwYXN0OiAn4YCc4YC94YCU4YC64YCB4YCy4YC34YCe4YCx4YCsICVzIOGAgCcsXHJcbiAgICAgICAgczogJ+GAheGAgOGAueGAgOGAlOGAui7hgKHhgJThgIrhgLrhgLjhgIThgJrhgLonLFxyXG4gICAgICAgIG06ICfhgJDhgIXhgLrhgJnhgK3hgJThgIXhgLonLFxyXG4gICAgICAgIG1tOiAnJWQg4YCZ4YCt4YCU4YCF4YC6JyxcclxuICAgICAgICBoOiAn4YCQ4YCF4YC64YCU4YCs4YCb4YCuJyxcclxuICAgICAgICBoaDogJyVkIOGAlOGArOGAm+GAricsXHJcbiAgICAgICAgZDogJ+GAkOGAheGAuuGAm+GAgOGAuicsXHJcbiAgICAgICAgZGQ6ICclZCDhgJvhgIDhgLonLFxyXG4gICAgICAgIE06ICfhgJDhgIXhgLrhgJwnLFxyXG4gICAgICAgIE1NOiAnJWQg4YCcJyxcclxuICAgICAgICB5OiAn4YCQ4YCF4YC64YCU4YC+4YCF4YC6JyxcclxuICAgICAgICB5eTogJyVkIOGAlOGAvuGAheGAuidcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+GBgeGBguGBg+GBhOGBheGBhuGBh+GBiOGBieGBgF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgd2Vlazoge1xyXG4gICAgICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95OiA0IC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbXk7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL215LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL215LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTm9yd2VnaWFuIEJva23DpWwgW25iXVxyXG4vLyEgYXV0aG9ycyA6IEVzcGVuIEhvdmxhbmRzZGFsIDogaHR0cHM6Ly9naXRodWIuY29tL3JleHhhcnNcclxuLy8hICAgICAgICAgICBTaWd1cmQgR2FydG1hbm4gOiBodHRwczovL2dpdGh1Yi5jb20vc2lndXJkZ2FcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBuYiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25iJywge1xyXG4gICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnNfYXByaWxfbWFpX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW4uX2ZlYi5fbWFyc19hcHJpbF9tYWlfanVuaV9qdWxpX2F1Zy5fc2VwLl9va3QuX25vdi5fZGVzLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnc8O4bmRhZ19tYW5kYWdfdGlyc2RhZ19vbnNkYWdfdG9yc2RhZ19mcmVkYWdfbMO4cmRhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc8O4Ll9tYS5fdGkuX29uLl90by5fZnIuX2zDuC4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdzw7hfbWFfdGlfb25fdG9fZnJfbMO4Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbaSBkYWcga2wuXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tpIG1vcmdlbiBrbC5dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2tsLl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbaSBnw6VyIGtsLl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW2ZvcnJpZ2VdIGRkZGQgW2tsLl0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ29tICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIHNpZGVuJyxcclxuICAgICAgICBzIDogJ25vZW4gc2VrdW5kZXInLFxyXG4gICAgICAgIG0gOiAnZXR0IG1pbnV0dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXR0ZXInLFxyXG4gICAgICAgIGggOiAnZW4gdGltZScsXHJcbiAgICAgICAgaGggOiAnJWQgdGltZXInLFxyXG4gICAgICAgIGQgOiAnZW4gZGFnJyxcclxuICAgICAgICBkZCA6ICclZCBkYWdlcicsXHJcbiAgICAgICAgTSA6ICdlbiBtw6VuZWQnLFxyXG4gICAgICAgIE1NIDogJyVkIG3DpW5lZGVyJyxcclxuICAgICAgICB5IDogJ2V0dCDDpXInLFxyXG4gICAgICAgIHl5IDogJyVkIMOlcidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG5iO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uYi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uYi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE5lcGFsZXNlIFtuZV1cclxuLy8hIGF1dGhvciA6IHN1dmFzaCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zdXZhc2hcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgpacnLFxyXG4gICAgJzInOiAn4KWoJyxcclxuICAgICczJzogJ+ClqScsXHJcbiAgICAnNCc6ICfgpaonLFxyXG4gICAgJzUnOiAn4KWrJyxcclxuICAgICc2JzogJ+ClrCcsXHJcbiAgICAnNyc6ICfgpa0nLFxyXG4gICAgJzgnOiAn4KWuJyxcclxuICAgICc5JzogJ+ClrycsXHJcbiAgICAnMCc6ICfgpaYnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4KWnJzogJzEnLFxyXG4gICAgJ+ClqCc6ICcyJyxcclxuICAgICfgpaknOiAnMycsXHJcbiAgICAn4KWqJzogJzQnLFxyXG4gICAgJ+Clqyc6ICc1JyxcclxuICAgICfgpawnOiAnNicsXHJcbiAgICAn4KWtJzogJzcnLFxyXG4gICAgJ+Clric6ICc4JyxcclxuICAgICfgpa8nOiAnOScsXHJcbiAgICAn4KWmJzogJzAnXHJcbn07XHJcblxyXG52YXIgbmUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCduZScsIHtcclxuICAgIG1vbnRocyA6ICfgpJzgpKjgpLXgpLDgpYBf4KSr4KWH4KSs4KWN4KSw4KWB4KS14KSw4KWAX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpL/gpLJf4KSu4KSIX+CknOClgeCkqF/gpJzgpYHgpLLgpL7gpIhf4KSF4KSX4KS34KWN4KSfX+CkuOClh+CkquCljeCkn+Clh+CkruCljeCkrOCksF/gpIXgpJXgpY3gpJ/gpYvgpKzgpLBf4KSo4KWL4KSt4KWH4KSu4KWN4KSs4KSwX+CkoeCkv+CkuOClh+CkruCljeCkrOCksCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+CknOCkqC5f4KSr4KWH4KSs4KWN4KSw4KWBLl/gpK7gpL7gpLDgpY3gpJpf4KSF4KSq4KWN4KSw4KS/Ll/gpK7gpIhf4KSc4KWB4KSoX+CknOClgeCksuCkvuCkiC5f4KSF4KSXLl/gpLjgpYfgpKrgpY3gpJ8uX+CkheCkleCljeCkn+Cliy5f4KSo4KWL4KSt4KWHLl/gpKHgpL/gpLjgpYcuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICfgpIbgpIfgpKTgpKzgpL7gpLBf4KS44KWL4KSu4KSs4KS+4KSwX+CkruCkmeCljeCkl+CksuCkrOCkvuCksF/gpKzgpYHgpKfgpKzgpL7gpLBf4KSs4KS/4KS54KS/4KSs4KS+4KSwX+CktuClgeCkleCljeCksOCkrOCkvuCksF/gpLbgpKjgpL/gpKzgpL7gpLAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+CkhuCkh+CkpC5f4KS44KWL4KSuLl/gpK7gpJngpY3gpJfgpLIuX+CkrOClgeCkpy5f4KSs4KS/4KS54KS/Ll/gpLbgpYHgpJXgpY3gpLAuX+CktuCkqOCkvy4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgpIYuX+CkuOCliy5f4KSu4KSCLl/gpKzgpYEuX+CkrOCkvy5f4KS24KWBLl/gpLYuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0HgpJXgpYsgaDptbSDgpKzgpJzgpYcnLFxyXG4gICAgICAgIExUUyA6ICdB4KSV4KWLIGg6bW06c3Mg4KSs4KSc4KWHJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEHgpJXgpYsgaDptbSDgpKzgpJzgpYcnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEHgpJXgpYsgaDptbSDgpKzgpJzgpYcnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgpafgpajgpangpargpavgpazgpa3gpa7gpa/gpaZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gpLDgpL7gpKTgpL984KSs4KS/4KS54KS+4KSofOCkpuCkv+CkieCkgeCkuOCli3zgpLjgpL7gpIHgpJ0vLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgpLDgpL7gpKTgpL8nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkrOCkv+CkueCkvuCkqCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkpuCkv+CkieCkgeCkuOCliycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgpLjgpL7gpIHgpJ0nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgMykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpOCkvyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpKzgpL/gpLngpL7gpKgnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KSm4KS/4KSJ4KSB4KS44KWLJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CkuOCkvuCkgeCknSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKTgpL8nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgpIbgpJxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgpK3gpYvgpLLgpL9dIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdb4KSG4KSJ4KSB4KSm4KWLXSBkZGRkWyxdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgpLngpL/gpJzgpYtdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4KSX4KSP4KSV4KWLXSBkZGRkWyxdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXPgpK7gpL4nLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4KSF4KSX4KS+4KSh4KS/JyxcclxuICAgICAgICBzIDogJ+CkleClh+CkueClgCDgpJXgpY3gpLfgpKMnLFxyXG4gICAgICAgIG0gOiAn4KSP4KSVIOCkruCkv+CkqOClh+CknycsXHJcbiAgICAgICAgbW0gOiAnJWQg4KSu4KS/4KSo4KWH4KSfJyxcclxuICAgICAgICBoIDogJ+Ckj+CklSDgpJjgpKPgpY3gpJ/gpL4nLFxyXG4gICAgICAgIGhoIDogJyVkIOCkmOCko+CljeCkn+CkvicsXHJcbiAgICAgICAgZCA6ICfgpI/gpJUg4KSm4KS/4KSoJyxcclxuICAgICAgICBkZCA6ICclZCDgpKbgpL/gpKgnLFxyXG4gICAgICAgIE0gOiAn4KSP4KSVIOCkruCkueCkv+CkqOCkvicsXHJcbiAgICAgICAgTU0gOiAnJWQg4KSu4KS54KS/4KSo4KS+JyxcclxuICAgICAgICB5IDogJ+Ckj+CklSDgpKzgpLDgpY3gpLcnLFxyXG4gICAgICAgIHl5IDogJyVkIOCkrOCksOCljeCktydcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbmU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25lLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25lLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRHV0Y2ggKEJlbGdpdW0pIFtubC1iZV1cclxuLy8hIGF1dGhvciA6IEpvcmlzIFLDtmxpbmcgOiBodHRwczovL2dpdGh1Yi5jb20vam9yaXNyb2xpbmdcclxuLy8hIGF1dGhvciA6IEphY29iIE1pZGRhZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWRkYWdqXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzU2hvcnRXaXRoRG90cyA9ICdqYW4uX2ZlYi5fbXJ0Ll9hcHIuX21laV9qdW4uX2p1bC5fYXVnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnRXaXRob3V0RG90cyA9ICdqYW5fZmViX21ydF9hcHJfbWVpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKTtcclxuXHJcbnZhciBtb250aHNQYXJzZSA9IFsvXmphbi9pLCAvXmZlYi9pLCAvXm1hYXJ0fG1ydC4/JC9pLCAvXmFwci9pLCAvXm1laSQvaSwgL15qdW5baS5dPyQvaSwgL15qdWxbaS5dPyQvaSwgL15hdWcvaSwgL15zZXAvaSwgL15va3QvaSwgL15ub3YvaSwgL15kZWMvaV07XHJcbnZhciBtb250aHNSZWdleCA9IC9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8YXByaWx8bWVpfGFwcmlsfGp1W25sXWl8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXJ8amFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xqdVtubF1cXC4/fGF1Z1xcLj98c2VwXFwuP3xva3RcXC4/fG5vdlxcLj98ZGVjXFwuPykvaTtcclxuXHJcbnZhciBubEJlID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbmwtYmUnLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyaV9mZWJydWFyaV9tYWFydF9hcHJpbF9tZWlfanVuaV9qdWxpX2F1Z3VzdHVzX3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoLy1NTU0tLy50ZXN0KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aG91dERvdHNbbS5tb250aCgpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRoRG90c1ttLm1vbnRoKCldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbW9udGhzUmVnZXg6IG1vbnRoc1JlZ2V4LFxyXG4gICAgbW9udGhzU2hvcnRSZWdleDogbW9udGhzUmVnZXgsXHJcbiAgICBtb250aHNTdHJpY3RSZWdleDogL14oamFudWFyaXxmZWJydWFyaXxtYWFydHxtZWl8anVbbmxdaXxhcHJpbHxhdWd1c3R1c3xzZXB0ZW1iZXJ8b2t0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcikvaSxcclxuICAgIG1vbnRoc1Nob3J0U3RyaWN0UmVnZXg6IC9eKGphblxcLj98ZmViXFwuP3xtcnRcXC4/fGFwclxcLj98bWVpfGp1W25sXVxcLj98YXVnXFwuP3xzZXBcXC4/fG9rdFxcLj98bm92XFwuP3xkZWNcXC4/KS9pLFxyXG5cclxuICAgIG1vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXHJcbiAgICBsb25nTW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIHNob3J0TW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuXHJcbiAgICB3ZWVrZGF5cyA6ICd6b25kYWdfbWFhbmRhZ19kaW5zZGFnX3dvZW5zZGFnX2RvbmRlcmRhZ192cmlqZGFnX3phdGVyZGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICd6by5fbWEuX2RpLl93by5fZG8uX3ZyLl96YS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICd6b19tYV9kaV93b19kb192cl96YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW3ZhbmRhYWcgb21dIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW21vcmdlbiBvbV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbb21dIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW2dpc3RlcmVuIG9tXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbYWZnZWxvcGVuXSBkZGRkIFtvbV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ292ZXIgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgZ2VsZWRlbicsXHJcbiAgICAgICAgcyA6ICdlZW4gcGFhciBzZWNvbmRlbicsXHJcbiAgICAgICAgbSA6ICfDqcOpbiBtaW51dXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZW4nLFxyXG4gICAgICAgIGggOiAnw6nDqW4gdXVyJyxcclxuICAgICAgICBoaCA6ICclZCB1dXInLFxyXG4gICAgICAgIGQgOiAnw6nDqW4gZGFnJyxcclxuICAgICAgICBkZCA6ICclZCBkYWdlbicsXHJcbiAgICAgICAgTSA6ICfDqcOpbiBtYWFuZCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbWFhbmRlbicsXHJcbiAgICAgICAgeSA6ICfDqcOpbiBqYWFyJyxcclxuICAgICAgICB5eSA6ICclZCBqYWFyJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdGV8ZGUpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICgobnVtYmVyID09PSAxIHx8IG51bWJlciA9PT0gOCB8fCBudW1iZXIgPj0gMjApID8gJ3N0ZScgOiAnZGUnKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbmxCZTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwtYmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwtYmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBEdXRjaCBbbmxdXHJcbi8vISBhdXRob3IgOiBKb3JpcyBSw7ZsaW5nIDogaHR0cHM6Ly9naXRodWIuY29tL2pvcmlzcm9saW5nXHJcbi8vISBhdXRob3IgOiBKYWNvYiBNaWRkYWcgOiBodHRwczovL2dpdGh1Yi5jb20vbWlkZGFnalxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRoc1Nob3J0V2l0aERvdHMgPSAnamFuLl9mZWIuX21ydC5fYXByLl9tZWlfanVuLl9qdWwuX2F1Zy5fc2VwLl9va3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKTtcclxudmFyIG1vbnRoc1Nob3J0V2l0aG91dERvdHMgPSAnamFuX2ZlYl9tcnRfYXByX21laV9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyk7XHJcblxyXG52YXIgbW9udGhzUGFyc2UgPSBbL15qYW4vaSwgL15mZWIvaSwgL15tYWFydHxtcnQuPyQvaSwgL15hcHIvaSwgL15tZWkkL2ksIC9eanVuW2kuXT8kL2ksIC9eanVsW2kuXT8kL2ksIC9eYXVnL2ksIC9ec2VwL2ksIC9eb2t0L2ksIC9ebm92L2ksIC9eZGVjL2ldO1xyXG52YXIgbW9udGhzUmVnZXggPSAvXihqYW51YXJpfGZlYnJ1YXJpfG1hYXJ0fGFwcmlsfG1laXxhcHJpbHxqdVtubF1pfGF1Z3VzdHVzfHNlcHRlbWJlcnxva3RvYmVyfG5vdmVtYmVyfGRlY2VtYmVyfGphblxcLj98ZmViXFwuP3xtcnRcXC4/fGFwclxcLj98anVbbmxdXFwuP3xhdWdcXC4/fHNlcFxcLj98b2t0XFwuP3xub3ZcXC4/fGRlY1xcLj8pL2k7XHJcblxyXG52YXIgbmwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdubCcsIHtcclxuICAgIG1vbnRocyA6ICdqYW51YXJpX2ZlYnJ1YXJpX21hYXJ0X2FwcmlsX21laV9qdW5pX2p1bGlfYXVndXN0dXNfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHM7XHJcbiAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRob3V0RG90c1ttLm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzW20ubW9udGgoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtb250aHNSZWdleDogbW9udGhzUmVnZXgsXHJcbiAgICBtb250aHNTaG9ydFJlZ2V4OiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1N0cmljdFJlZ2V4OiAvXihqYW51YXJpfGZlYnJ1YXJpfG1hYXJ0fG1laXxqdVtubF1pfGFwcmlsfGF1Z3VzdHVzfHNlcHRlbWJlcnxva3RvYmVyfG5vdmVtYmVyfGRlY2VtYmVyKS9pLFxyXG4gICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleDogL14oamFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xtZWl8anVbbmxdXFwuP3xhdWdcXC4/fHNlcFxcLj98b2t0XFwuP3xub3ZcXC4/fGRlY1xcLj8pL2ksXHJcblxyXG4gICAgbW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIGxvbmdNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG4gICAgc2hvcnRNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG5cclxuICAgIHdlZWtkYXlzIDogJ3pvbmRhZ19tYWFuZGFnX2RpbnNkYWdfd29lbnNkYWdfZG9uZGVyZGFnX3ZyaWpkYWdfemF0ZXJkYWcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3pvLl9tYS5fZGkuX3dvLl9kby5fdnIuX3phLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3pvX21hX2RpX3dvX2RvX3ZyX3phJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQtTU0tWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbdmFuZGFhZyBvbV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbbW9yZ2VuIG9tXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtvbV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbZ2lzdGVyZW4gb21dIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1thZmdlbG9wZW5dIGRkZGQgW29tXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb3ZlciAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBnZWxlZGVuJyxcclxuICAgICAgICBzIDogJ2VlbiBwYWFyIHNlY29uZGVuJyxcclxuICAgICAgICBtIDogJ8Opw6luIG1pbnV1dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlbicsXHJcbiAgICAgICAgaCA6ICfDqcOpbiB1dXInLFxyXG4gICAgICAgIGhoIDogJyVkIHV1cicsXHJcbiAgICAgICAgZCA6ICfDqcOpbiBkYWcnLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2VuJyxcclxuICAgICAgICBNIDogJ8Opw6luIG1hYW5kJyxcclxuICAgICAgICBNTSA6ICclZCBtYWFuZGVuJyxcclxuICAgICAgICB5IDogJ8Opw6luIGphYXInLFxyXG4gICAgICAgIHl5IDogJyVkIGphYXInXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0ZXxkZSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgKChudW1iZXIgPT09IDEgfHwgbnVtYmVyID09PSA4IHx8IG51bWJlciA+PSAyMCkgPyAnc3RlJyA6ICdkZScpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBubDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBOeW5vcnNrIFtubl1cclxuLy8hIGF1dGhvciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWNodXdpbmRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBubiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25uJywge1xyXG4gICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcnNfYXByaWxfbWFpX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3N1bmRhZ19tw6VuZGFnX3R5c2RhZ19vbnNkYWdfdG9yc2RhZ19mcmVkYWdfbGF1cmRhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc3VuX23DpW5fdHlzX29uc190b3JfZnJlX2xhdScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3N1X23DpV90eV9vbl90b19mcl9sw7gnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBba2wuXSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbSSBkYWcga2xva2thXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tJIG1vcmdvbiBrbG9ra2FdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2tsb2trYV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbSSBnw6VyIGtsb2trYV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW0bDuHJlZ8OlYW5kZV0gZGRkZCBba2xva2thXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb20gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgc2lkYW4nLFxyXG4gICAgICAgIHMgOiAnbm9rcmUgc2VrdW5kJyxcclxuICAgICAgICBtIDogJ2VpdCBtaW51dHQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0dCcsXHJcbiAgICAgICAgaCA6ICdlaW4gdGltZScsXHJcbiAgICAgICAgaGggOiAnJWQgdGltYXInLFxyXG4gICAgICAgIGQgOiAnZWluIGRhZycsXHJcbiAgICAgICAgZGQgOiAnJWQgZGFnYXInLFxyXG4gICAgICAgIE0gOiAnZWluIG3DpW5hZCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbcOlbmFkZXInLFxyXG4gICAgICAgIHkgOiAnZWl0IMOlcicsXHJcbiAgICAgICAgeXkgOiAnJWQgw6VyJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbm47XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25uLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25uLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUHVuamFiaSAoSW5kaWEpIFtwYS1pbl1cclxuLy8hIGF1dGhvciA6IEhhcnByZWV0IFNpbmdoIDogaHR0cHM6Ly9naXRodWIuY29tL2hhcnByZWV0a2hhbHNhZ3RiaXRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgqacnLFxyXG4gICAgJzInOiAn4KmoJyxcclxuICAgICczJzogJ+CpqScsXHJcbiAgICAnNCc6ICfgqaonLFxyXG4gICAgJzUnOiAn4KmrJyxcclxuICAgICc2JzogJ+CprCcsXHJcbiAgICAnNyc6ICfgqa0nLFxyXG4gICAgJzgnOiAn4KmuJyxcclxuICAgICc5JzogJ+CprycsXHJcbiAgICAnMCc6ICfgqaYnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4KmnJzogJzEnLFxyXG4gICAgJ+CpqCc6ICcyJyxcclxuICAgICfgqaknOiAnMycsXHJcbiAgICAn4KmqJzogJzQnLFxyXG4gICAgJ+Cpqyc6ICc1JyxcclxuICAgICfgqawnOiAnNicsXHJcbiAgICAn4KmtJzogJzcnLFxyXG4gICAgJ+Cpric6ICc4JyxcclxuICAgICfgqa8nOiAnOScsXHJcbiAgICAn4KmmJzogJzAnXHJcbn07XHJcblxyXG52YXIgcGFJbiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3BhLWluJywge1xyXG4gICAgLy8gVGhlcmUgYXJlIG1vbnRocyBuYW1lIGFzIHBlciBOYW5ha3NoYWhpIENhbGVuZGVyIGJ1dCB0aGV5IGFyZSBub3QgdXNlZCBhcyByaWdpZGx5IGluIG1vZGVybiBQdW5qYWJpLlxyXG4gICAgbW9udGhzIDogJ+ConOCoqOCoteCosOCpgF/gqKvgqLzgqLDgqLXgqLDgqYBf4Kiu4Ki+4Kiw4KiaX+CoheCoquCpjeCosOCpiOCosl/gqK7gqIhf4Kic4KmC4KioX+ConOCpgeCosuCovuCoiF/gqIXgqJfgqLjgqKRf4Ki44Kik4Kmw4Kis4KiwX+CoheColeCopOCpguCorOCosF/gqKjgqLXgqbDgqKzgqLBf4Kim4Ki44Kmw4Kis4KiwJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4Kic4Kio4Ki14Kiw4KmAX+Coq+CovOCosOCoteCosOCpgF/gqK7gqL7gqLDgqJpf4KiF4Kiq4KmN4Kiw4KmI4KiyX+CoruCoiF/gqJzgqYLgqKhf4Kic4KmB4Kiy4Ki+4KiIX+CoheCol+CouOCopF/gqLjgqKTgqbDgqKzgqLBf4KiF4KiV4Kik4KmC4Kis4KiwX+CoqOCoteCpsOCorOCosF/gqKbgqLjgqbDgqKzgqLAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfgqJDgqKTgqLXgqL7gqLBf4Ki44KmL4Kiu4Ki14Ki+4KiwX+CoruCpsOCol+CosuCoteCovuCosF/gqKzgqYHgqKfgqLXgqL7gqLBf4Ki14KmA4Kiw4Ki14Ki+4KiwX+CouOCovOCpgeCpseColeCosOCoteCovuCosF/gqLjgqLzgqKjgqYDgqJrgqLDgqLXgqL7gqLAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+CokOCopF/gqLjgqYvgqK5f4Kiu4Kmw4KiX4KiyX+CorOCpgeCop1/gqLXgqYDgqLBf4Ki44Ki84KmB4KiV4KiwX+CouOCovOCoqOCpgCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+CokOCopF/gqLjgqYvgqK5f4Kiu4Kmw4KiX4KiyX+CorOCpgeCop1/gqLXgqYDgqLBf4Ki44Ki84KmB4KiV4KiwX+CouOCovOCoqOCpgCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbSDgqLXgqJzgqYcnLFxyXG4gICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4Ki14Kic4KmHJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgqLXgqJzgqYcnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSDgqLXgqJzgqYcnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4KiF4KicXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4KiV4KiyXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+ColeCosl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgqKrgqL/gqJvgqLLgqYddIGRkZGQsIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg4Ki14Ki/4Kmx4KiaJyxcclxuICAgICAgICBwYXN0IDogJyVzIOCoquCov+Com+CosuCphycsXHJcbiAgICAgICAgcyA6ICfgqJXgqYHgqJ0g4Ki44KiV4Ki/4Kmw4KifJyxcclxuICAgICAgICBtIDogJ+Coh+ColSDgqK7gqL/gqbDgqJ8nLFxyXG4gICAgICAgIG1tIDogJyVkIOCoruCov+CpsOConycsXHJcbiAgICAgICAgaCA6ICfgqIfgqbHgqJUg4KiY4Kmw4Kif4Ki+JyxcclxuICAgICAgICBoaCA6ICclZCDgqJjgqbDgqJ/gqYcnLFxyXG4gICAgICAgIGQgOiAn4KiH4Kmx4KiVIOCopuCov+CoqCcsXHJcbiAgICAgICAgZGQgOiAnJWQg4Kim4Ki/4KioJyxcclxuICAgICAgICBNIDogJ+Coh+CpseColSDgqK7gqLngqYDgqKjgqL4nLFxyXG4gICAgICAgIE1NIDogJyVkIOCoruCoueCpgOCoqOCphycsXHJcbiAgICAgICAgeSA6ICfgqIfgqbHgqJUg4Ki44Ki+4KiyJyxcclxuICAgICAgICB5eSA6ICclZCDgqLjgqL7gqLInXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgqafgqajgqangqargqavgqazgqa3gqa7gqa/gqaZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIFB1bmphYmkgbm90YXRpb24gZm9yIG1lcmlkaWVtcyBhcmUgcXVpdGUgZnV6enkgaW4gcHJhY3RpY2UuIFdoaWxlIHRoZXJlIGV4aXN0c1xyXG4gICAgLy8gYSByaWdpZCBub3Rpb24gb2YgYSAnUGFoYXInIGl0IGlzIG5vdCB1c2VkIGFzIHJpZ2lkbHkgaW4gbW9kZXJuIFB1bmphYmkuXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4Kiw4Ki+4KikfOCouOCoteCph+CosHzgqKbgqYHgqKrgqLngqL/gqLB84Ki44Ki84Ki+4KiuLyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4Kiw4Ki+4KikJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA8IDQgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqLjgqLXgqYfgqLAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqKbgqYHgqKrgqLngqL/gqLAnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4Ki44Ki84Ki+4KiuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqLDgqL7gqKQnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Ki44Ki14KmH4KiwJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CopuCpgeCoquCoueCov+CosCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqLjgqLzgqL7gqK4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kiw4Ki+4KikJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHBhSW47XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BhLWluLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BhLWluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUG9saXNoIFtwbF1cclxuLy8hIGF1dGhvciA6IFJhZmFsIEhpcnN6IDogaHR0cHM6Ly9naXRodWIuY29tL2V2b0xcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHNOb21pbmF0aXZlID0gJ3N0eWN6ZcWEX2x1dHlfbWFyemVjX2t3aWVjaWXFhF9tYWpfY3plcndpZWNfbGlwaWVjX3NpZXJwaWXFhF93cnplc2llxYRfcGHFumR6aWVybmlrX2xpc3RvcGFkX2dydWR6aWXFhCcuc3BsaXQoJ18nKTtcclxudmFyIG1vbnRoc1N1YmplY3RpdmUgPSAnc3R5Y3puaWFfbHV0ZWdvX21hcmNhX2t3aWV0bmlhX21hamFfY3plcndjYV9saXBjYV9zaWVycG5pYV93cnplxZtuaWFfcGHFumR6aWVybmlrYV9saXN0b3BhZGFfZ3J1ZG5pYScuc3BsaXQoJ18nKTtcclxuZnVuY3Rpb24gcGx1cmFsKG4pIHtcclxuICAgIHJldHVybiAobiAlIDEwIDwgNSkgJiYgKG4gJSAxMCA+IDEpICYmICgofn4obiAvIDEwKSAlIDEwKSAhPT0gMSk7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnbWludXRhJyA6ICdtaW51dMSZJztcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbWludXR5JyA6ICdtaW51dCcpO1xyXG4gICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCAgPyAnZ29kemluYScgIDogJ2dvZHppbsSZJztcclxuICAgICAgICBjYXNlICdoaCc6XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnZ29kemlueScgOiAnZ29kemluJyk7XHJcbiAgICAgICAgY2FzZSAnTU0nOlxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pZXNpxIVjZScgOiAnbWllc2nEmWN5Jyk7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ2xhdGEnIDogJ2xhdCcpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgcGwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdwbCcsIHtcclxuICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtb21lbnRUb0Zvcm1hdCwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtb21lbnRUb0Zvcm1hdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzTm9taW5hdGl2ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJycpIHtcclxuICAgICAgICAgICAgLy8gSGFjazogaWYgZm9ybWF0IGVtcHR5IHdlIGtub3cgdGhpcyBpcyB1c2VkIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICAgIC8vIFJlZ0V4cCBieSBtb21lbnQuIEdpdmUgdGhlbiBiYWNrIGJvdGggdmFsaWQgZm9ybXMgb2YgbW9udGhzXHJcbiAgICAgICAgICAgIC8vIGluIFJlZ0V4cCByZWFkeSBmb3JtYXQuXHJcbiAgICAgICAgICAgIHJldHVybiAnKCcgKyBtb250aHNTdWJqZWN0aXZlW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldICsgJ3wnICsgbW9udGhzTm9taW5hdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXSArICcpJztcclxuICAgICAgICB9IGVsc2UgaWYgKC9EIE1NTU0vLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU3ViamVjdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzTm9taW5hdGl2ZVttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiAnc3R5X2x1dF9tYXJfa3dpX21hal9jemVfbGlwX3NpZV93cnpfcGHFul9saXNfZ3J1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnbmllZHppZWxhX3BvbmllZHppYcWCZWtfd3RvcmVrX8Wbcm9kYV9jendhcnRla19wacSFdGVrX3NvYm90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbmR6X3Bvbl93dF/Fm3JfY3p3X3B0X3NvYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ05kX1BuX1d0X8Wacl9Del9QdF9Tbycuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0R6acWbIG9dIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW0p1dHJvIG9dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIG5pZWR6aWVsxJkgb10gTFQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXZSB3dG9yZWsgb10gTFQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIMWbcm9kxJkgb10gTFQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHNvYm90xJkgb10gTFQnO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbV10gZGRkZCBbb10gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5OiAnW1djem9yYWogb10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgemVzesWCxIUgbmllZHppZWzEmSBvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbVyB6ZXN6xYLEhSDFm3JvZMSZIG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgsSFIHNvYm90xJkgb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgnldIGRkZGQgW29dIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnemEgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgdGVtdScsXHJcbiAgICAgICAgcyA6ICdraWxrYSBzZWt1bmQnLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogJzEgZHppZcWEJyxcclxuICAgICAgICBkZCA6ICclZCBkbmknLFxyXG4gICAgICAgIE0gOiAnbWllc2nEhWMnLFxyXG4gICAgICAgIE1NIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgOiAncm9rJyxcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gcGw7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUG9ydHVndWVzZSAoQnJhemlsKSBbcHQtYnJdXHJcbi8vISBhdXRob3IgOiBDYWlvIFJpYmVpcm8gUGVyZWlyYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9jYWlvLXJpYmVpcm8tcGVyZWlyYVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHB0QnIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdwdC1icicsIHtcclxuICAgIG1vbnRocyA6ICdqYW5laXJvX2ZldmVyZWlyb19tYXLDp29fYWJyaWxfbWFpb19qdW5ob19qdWxob19hZ29zdG9fc2V0ZW1icm9fb3V0dWJyb19ub3ZlbWJyb19kZXplbWJybycuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZXZfbWFyX2Ficl9tYWlfanVuX2p1bF9hZ29fc2V0X291dF9ub3ZfZGV6Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnRG9taW5nb19TZWd1bmRhLWZlaXJhX1RlcsOnYS1mZWlyYV9RdWFydGEtZmVpcmFfUXVpbnRhLWZlaXJhX1NleHRhLWZlaXJhX1PDoWJhZG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0RvbV9TZWdfVGVyX1F1YV9RdWlfU2V4X1PDoWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdEb18ywqpfM8KqXzTCql81wqpfNsKqX1PDoScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgW2RlXSBNTU1NIFtkZV0gWVlZWSBbw6BzXSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIFtkZV0gTU1NTSBbZGVdIFlZWVkgW8Ogc10gSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tIb2plIMOgc10gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbQW1hbmjDoyDDoHNdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW8Ogc10gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbT250ZW0gw6BzXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRheSgpID09PSAwIHx8IHRoaXMuZGF5KCkgPT09IDYpID9cclxuICAgICAgICAgICAgICAgICdbw5psdGltb10gZGRkZCBbw6BzXSBMVCcgOiAvLyBTYXR1cmRheSArIFN1bmRheVxyXG4gICAgICAgICAgICAgICAgJ1vDmmx0aW1hXSBkZGRkIFvDoHNdIExUJzsgLy8gTW9uZGF5IC0gRnJpZGF5XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdlbSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBhdHLDoXMnLFxyXG4gICAgICAgIHMgOiAncG91Y29zIHNlZ3VuZG9zJyxcclxuICAgICAgICBzcyA6ICclZCBzZWd1bmRvcycsXHJcbiAgICAgICAgbSA6ICd1bSBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxyXG4gICAgICAgIGggOiAndW1hIGhvcmEnLFxyXG4gICAgICAgIGhoIDogJyVkIGhvcmFzJyxcclxuICAgICAgICBkIDogJ3VtIGRpYScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGlhcycsXHJcbiAgICAgICAgTSA6ICd1bSBtw6pzJyxcclxuICAgICAgICBNTSA6ICclZCBtZXNlcycsXHJcbiAgICAgICAgeSA6ICd1bSBhbm8nLFxyXG4gICAgICAgIHl5IDogJyVkIGFub3MnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxyXG4gICAgb3JkaW5hbCA6ICclZMK6J1xyXG59KTtcclxuXHJcbnJldHVybiBwdEJyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC1ici5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC1ici5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFBvcnR1Z3Vlc2UgW3B0XVxyXG4vLyEgYXV0aG9yIDogSmVmZmVyc29uIDogaHR0cHM6Ly9naXRodWIuY29tL2phbGV4NzlcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBwdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3B0Jywge1xyXG4gICAgbW9udGhzIDogJ2phbmVpcm9fZmV2ZXJlaXJvX21hcsOnb19hYnJpbF9tYWlvX2p1bmhvX2p1bGhvX2Fnb3N0b19zZXRlbWJyb19vdXR1YnJvX25vdmVtYnJvX2RlemVtYnJvJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2Zldl9tYXJfYWJyX21haV9qdW5fanVsX2Fnb19zZXRfb3V0X25vdl9kZXonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdEb21pbmdvX1NlZ3VuZGEtZmVpcmFfVGVyw6dhLWZlaXJhX1F1YXJ0YS1mZWlyYV9RdWludGEtZmVpcmFfU2V4dGEtZmVpcmFfU8OhYmFkbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnRG9tX1NlZ19UZXJfUXVhX1F1aV9TZXhfU8OhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0RvXzLCql8zwqpfNMKqXzXCql82wqpfU8OhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0hvamUgw6BzXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tBbWFuaMOjIMOgc10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbw6BzXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tPbnRlbSDDoHNdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZGF5KCkgPT09IDAgfHwgdGhpcy5kYXkoKSA9PT0gNikgP1xyXG4gICAgICAgICAgICAgICAgJ1vDmmx0aW1vXSBkZGRkIFvDoHNdIExUJyA6IC8vIFNhdHVyZGF5ICsgU3VuZGF5XHJcbiAgICAgICAgICAgICAgICAnW8OabHRpbWFdIGRkZGQgW8Ogc10gTFQnOyAvLyBNb25kYXkgLSBGcmlkYXlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2VtICVzJyxcclxuICAgICAgICBwYXN0IDogJ2jDoSAlcycsXHJcbiAgICAgICAgcyA6ICdzZWd1bmRvcycsXHJcbiAgICAgICAgbSA6ICd1bSBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxyXG4gICAgICAgIGggOiAndW1hIGhvcmEnLFxyXG4gICAgICAgIGhoIDogJyVkIGhvcmFzJyxcclxuICAgICAgICBkIDogJ3VtIGRpYScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGlhcycsXHJcbiAgICAgICAgTSA6ICd1bSBtw6pzJyxcclxuICAgICAgICBNTSA6ICclZCBtZXNlcycsXHJcbiAgICAgICAgeSA6ICd1bSBhbm8nLFxyXG4gICAgICAgIHl5IDogJyVkIGFub3MnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxyXG4gICAgb3JkaW5hbCA6ICclZMK6JyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBwdDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBSb21hbmlhbiBbcm9dXHJcbi8vISBhdXRob3IgOiBWbGFkIEd1cmRpZ2EgOiBodHRwczovL2dpdGh1Yi5jb20vZ3VyZGlnYVxyXG4vLyEgYXV0aG9yIDogVmFsZW50aW4gQWdhY2hpIDogaHR0cHM6Ly9naXRodWIuY29tL2F2YWx5XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICAgICAnbW0nOiAnbWludXRlJyxcclxuICAgICAgICAgICAgJ2hoJzogJ29yZScsXHJcbiAgICAgICAgICAgICdkZCc6ICd6aWxlJyxcclxuICAgICAgICAgICAgJ01NJzogJ2x1bmknLFxyXG4gICAgICAgICAgICAneXknOiAnYW5pJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VwYXJhdG9yID0gJyAnO1xyXG4gICAgaWYgKG51bWJlciAlIDEwMCA+PSAyMCB8fCAobnVtYmVyID49IDEwMCAmJiBudW1iZXIgJSAxMDAgPT09IDApKSB7XHJcbiAgICAgICAgc2VwYXJhdG9yID0gJyBkZSAnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bWJlciArIHNlcGFyYXRvciArIGZvcm1hdFtrZXldO1xyXG59XHJcblxyXG52YXIgcm8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdybycsIHtcclxuICAgIG1vbnRocyA6ICdpYW51YXJpZV9mZWJydWFyaWVfbWFydGllX2FwcmlsaWVfbWFpX2l1bmllX2l1bGllX2F1Z3VzdF9zZXB0ZW1icmllX29jdG9tYnJpZV9ub2llbWJyaWVfZGVjZW1icmllJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnaWFuLl9mZWJyLl9tYXJ0Ll9hcHIuX21haV9pdW4uX2l1bC5fYXVnLl9zZXB0Ll9vY3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdkdW1pbmljxINfbHVuaV9tYXLIm2lfbWllcmN1cmlfam9pX3ZpbmVyaV9zw6JtYsSDdMSDJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdEdW1fTHVuX01hcl9NaWVfSm9pX1Zpbl9Tw6JtJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnRHVfTHVfTWFfTWlfSm9fVmlfU8OiJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1themkgbGFdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW23DomluZSBsYV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbbGFdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW2llcmkgbGFdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1tmb3N0YV0gZGRkZCBbbGFdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdwZXN0ZSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDDrm4gdXJtxIMnLFxyXG4gICAgICAgIHMgOiAnY8OidGV2YSBzZWN1bmRlJyxcclxuICAgICAgICBtIDogJ3VuIG1pbnV0JyxcclxuICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgaCA6ICdvIG9yxIMnLFxyXG4gICAgICAgIGhoIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBkIDogJ28gemknLFxyXG4gICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBNIDogJ28gbHVuxIMnLFxyXG4gICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICB5IDogJ3VuIGFuJyxcclxuICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gcm87XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUnVzc2lhbiBbcnVdXHJcbi8vISBhdXRob3IgOiBWaWt0b3JtaW5hdG9yIDogaHR0cHM6Ly9naXRodWIuY29tL1Zpa3Rvcm1pbmF0b3JcclxuLy8hIEF1dGhvciA6IE1lbmVsaW9uIEVsZW5zw7psZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9PaXJlXHJcbi8vISBhdXRob3IgOiDQmtC+0YDQtdC90LHQtdGA0LMg0JzQsNGA0LogOiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0cGFpclxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcGx1cmFsKHdvcmQsIG51bSkge1xyXG4gICAgdmFyIGZvcm1zID0gd29yZC5zcGxpdCgnXycpO1xyXG4gICAgcmV0dXJuIG51bSAlIDEwID09PSAxICYmIG51bSAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IChudW0gJSAxMCA+PSAyICYmIG51bSAlIDEwIDw9IDQgJiYgKG51bSAlIDEwMCA8IDEwIHx8IG51bSAlIDEwMCA+PSAyMCkgPyBmb3Jtc1sxXSA6IGZvcm1zWzJdKTtcclxufVxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdtbSc6IHdpdGhvdXRTdWZmaXggPyAn0LzQuNC90YPRgtCwX9C80LjQvdGD0YLRi1/QvNC40L3Rg9GCJyA6ICfQvNC40L3Rg9GC0YNf0LzQuNC90YPRgtGLX9C80LjQvdGD0YInLFxyXG4gICAgICAgICdoaCc6ICfRh9Cw0YFf0YfQsNGB0LBf0YfQsNGB0L7QsicsXHJcbiAgICAgICAgJ2RkJzogJ9C00LXQvdGMX9C00L3Rj1/QtNC90LXQuScsXHJcbiAgICAgICAgJ01NJzogJ9C80LXRgdGP0YZf0LzQtdGB0Y/RhtCwX9C80LXRgdGP0YbQtdCyJyxcclxuICAgICAgICAneXknOiAn0LPQvtC0X9Cz0L7QtNCwX9C70LXRgidcclxuICAgIH07XHJcbiAgICBpZiAoa2V5ID09PSAnbScpIHtcclxuICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICfQvNC40L3Rg9GC0LAnIDogJ9C80LjQvdGD0YLRgyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgcGx1cmFsKGZvcm1hdFtrZXldLCArbnVtYmVyKTtcclxuICAgIH1cclxufVxyXG52YXIgbW9udGhzUGFyc2UgPSBbL17Rj9C90LIvaSwgL17RhNC10LIvaSwgL17QvNCw0YAvaSwgL17QsNC/0YAvaSwgL17QvNCwW9C50Y9dL2ksIC9e0LjRjtC9L2ksIC9e0LjRjtC7L2ksIC9e0LDQstCzL2ksIC9e0YHQtdC9L2ksIC9e0L7QutGCL2ksIC9e0L3QvtGPL2ksIC9e0LTQtdC6L2ldO1xyXG5cclxuLy8gaHR0cDovL25ldy5ncmFtb3RhLnJ1L3NwcmF2a2EvcnVsZXMvMTM5LXByb3AgOiDCpyAxMDNcclxuLy8g0KHQvtC60YDQsNGJ0LXQvdC40Y8g0LzQtdGB0Y/RhtC10LI6IGh0dHA6Ly9uZXcuZ3JhbW90YS5ydS9zcHJhdmthL2J1cm8vc2VhcmNoLWFuc3dlcj9zPTI0MjYzN1xyXG4vLyBDTERSIGRhdGE6ICAgICAgICAgIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvY2xkci9jaGFydHMvMjgvc3VtbWFyeS9ydS5odG1sIzE3NTNcclxudmFyIHJ1ID0gbW9tZW50LmRlZmluZUxvY2FsZSgncnUnLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgZm9ybWF0OiAn0Y/QvdCy0LDRgNGPX9GE0LXQstGA0LDQu9GPX9C80LDRgNGC0LBf0LDQv9GA0LXQu9GPX9C80LDRj1/QuNGO0L3Rj1/QuNGO0LvRj1/QsNCy0LPRg9GB0YLQsF/RgdC10L3RgtGP0LHRgNGPX9C+0LrRgtGP0LHRgNGPX9C90L7Rj9Cx0YDRj1/QtNC10LrQsNCx0YDRjycuc3BsaXQoJ18nKSxcclxuICAgICAgICBzdGFuZGFsb25lOiAn0Y/QvdCy0LDRgNGMX9GE0LXQstGA0LDQu9GMX9C80LDRgNGCX9Cw0L/RgNC10LvRjF/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCz0YPRgdGCX9GB0LXQvdGC0Y/QsdGA0Yxf0L7QutGC0Y/QsdGA0Yxf0L3QvtGP0LHRgNGMX9C00LXQutCw0LHRgNGMJy5zcGxpdCgnXycpXHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiB7XHJcbiAgICAgICAgLy8g0L/QviBDTERSINC40LzQtdC90L3QviBcItC40Y7Quy5cIiDQuCBcItC40Y7QvS5cIiwg0L3QviDQutCw0LrQvtC5INGB0LzRi9GB0Lsg0LzQtdC90Y/RgtGMINCx0YPQutCy0YMg0L3QsCDRgtC+0YfQutGDID9cclxuICAgICAgICBmb3JtYXQ6ICfRj9C90LIuX9GE0LXQstGALl/QvNCw0YAuX9Cw0L/RgC5f0LzQsNGPX9C40Y7QvdGPX9C40Y7Qu9GPX9Cw0LLQsy5f0YHQtdC90YIuX9C+0LrRgi5f0L3QvtGP0LEuX9C00LXQui4nLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ9GP0L3Qsi5f0YTQtdCy0YAuX9C80LDRgNGCX9Cw0L/RgC5f0LzQsNC5X9C40Y7QvdGMX9C40Y7Qu9GMX9Cw0LLQsy5f0YHQtdC90YIuX9C+0LrRgi5f0L3QvtGP0LEuX9C00LXQui4nLnNwbGl0KCdfJylcclxuICAgIH0sXHJcbiAgICB3ZWVrZGF5cyA6IHtcclxuICAgICAgICBzdGFuZGFsb25lOiAn0LLQvtGB0LrRgNC10YHQtdC90YzQtV/Qv9C+0L3QtdC00LXQu9GM0L3QuNC6X9Cy0YLQvtGA0L3QuNC6X9GB0YDQtdC00LBf0YfQtdGC0LLQtdGA0LNf0L/Rj9GC0L3QuNGG0LBf0YHRg9Cx0LHQvtGC0LAnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgZm9ybWF0OiAn0LLQvtGB0LrRgNC10YHQtdC90YzQtV/Qv9C+0L3QtdC00LXQu9GM0L3QuNC6X9Cy0YLQvtGA0L3QuNC6X9GB0YDQtdC00YNf0YfQtdGC0LLQtdGA0LNf0L/Rj9GC0L3QuNGG0YNf0YHRg9Cx0LHQvtGC0YMnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgaXNGb3JtYXQ6IC9cXFsgP1vQktCyXSA/KD860L/RgNC+0YjQu9GD0Y580YHQu9C10LTRg9GO0YnRg9GOfNGN0YLRgyk/ID9cXF0gP2RkZGQvXHJcbiAgICB9LFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQstGBX9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn0LLRgV/Qv9C9X9Cy0YJf0YHRgF/Rh9GCX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXHJcbiAgICBsb25nTW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIHNob3J0TW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuXHJcbiAgICAvLyDQv9C+0LvQvdGL0LUg0L3QsNC30LLQsNC90LjRjyDRgSDQv9Cw0LTQtdC20LDQvNC4LCDQv9C+INGC0YDQuCDQsdGD0LrQstGLLCDQtNC70Y8g0L3QtdC60L7RgtC+0YDRi9GFLCDQv9C+IDQg0LHRg9C60LLRiywg0YHQvtC60YDQsNGJ0LXQvdC40Y8g0YEg0YLQvtGH0LrQvtC5INC4INCx0LXQtyDRgtC+0YfQutC4XHJcbiAgICBtb250aHNSZWdleDogL14o0Y/QvdCy0LDRgFvRjNGPXXzRj9C90LJcXC4/fNGE0LXQstGA0LDQu1vRjNGPXXzRhNC10LLRgD9cXC4/fNC80LDRgNGC0LA/fNC80LDRgFxcLj980LDQv9GA0LXQu1vRjNGPXXzQsNC/0YBcXC4/fNC80LBb0LnRj1180LjRjtC9W9GM0Y9dfNC40Y7QvVxcLj980LjRjtC7W9GM0Y9dfNC40Y7Qu1xcLj980LDQstCz0YPRgdGC0LA/fNCw0LLQs1xcLj980YHQtdC90YLRj9Cx0YBb0YzRj1180YHQtdC90YI/XFwuP3zQvtC60YLRj9Cx0YBb0YzRj1180L7QutGCXFwuP3zQvdC+0Y/QsdGAW9GM0Y9dfNC90L7Rj9CxP1xcLj980LTQtdC60LDQsdGAW9GM0Y9dfNC00LXQulxcLj8pL2ksXHJcblxyXG4gICAgLy8g0LrQvtC/0LjRjyDQv9GA0LXQtNGL0LTRg9GJ0LXQs9C+XHJcbiAgICBtb250aHNTaG9ydFJlZ2V4OiAvXijRj9C90LLQsNGAW9GM0Y9dfNGP0L3QslxcLj980YTQtdCy0YDQsNC7W9GM0Y9dfNGE0LXQstGAP1xcLj980LzQsNGA0YLQsD980LzQsNGAXFwuP3zQsNC/0YDQtdC7W9GM0Y9dfNCw0L/RgFxcLj980LzQsFvQudGPXXzQuNGO0L1b0YzRj1180LjRjtC9XFwuP3zQuNGO0Ltb0YzRj1180LjRjtC7XFwuP3zQsNCy0LPRg9GB0YLQsD980LDQstCzXFwuP3zRgdC10L3RgtGP0LHRgFvRjNGPXXzRgdC10L3Rgj9cXC4/fNC+0LrRgtGP0LHRgFvRjNGPXXzQvtC60YJcXC4/fNC90L7Rj9Cx0YBb0YzRj1180L3QvtGP0LE/XFwuP3zQtNC10LrQsNCx0YBb0YzRj1180LTQtdC6XFwuPykvaSxcclxuXHJcbiAgICAvLyDQv9C+0LvQvdGL0LUg0L3QsNC30LLQsNC90LjRjyDRgSDQv9Cw0LTQtdC20LDQvNC4XHJcbiAgICBtb250aHNTdHJpY3RSZWdleDogL14o0Y/QvdCy0LDRgFvRj9GMXXzRhNC10LLRgNCw0Ltb0Y/RjF180LzQsNGA0YLQsD980LDQv9GA0LXQu1vRj9GMXXzQvNCwW9GP0LldfNC40Y7QvVvRj9GMXXzQuNGO0Ltb0Y/RjF180LDQstCz0YPRgdGC0LA/fNGB0LXQvdGC0Y/QsdGAW9GP0YxdfNC+0LrRgtGP0LHRgFvRj9GMXXzQvdC+0Y/QsdGAW9GP0YxdfNC00LXQutCw0LHRgFvRj9GMXSkvaSxcclxuXHJcbiAgICAvLyDQktGL0YDQsNC20LXQvdC40LUsINC60L7RgtC+0YDQvtC1INGB0L7QvtGC0LLQtdGB0YLQstGD0LXRgiDRgtC+0LvRjNC60L4g0YHQvtC60YDQsNGJ0ZHQvdC90YvQvCDRhNC+0YDQvNCw0LxcclxuICAgIG1vbnRoc1Nob3J0U3RyaWN0UmVnZXg6IC9eKNGP0L3QslxcLnzRhNC10LLRgD9cXC580LzQsNGAW9GCLl180LDQv9GAXFwufNC80LBb0Y/QuV180LjRjtC9W9GM0Y8uXXzQuNGO0Ltb0YzRjy5dfNCw0LLQs1xcLnzRgdC10L3Rgj9cXC580L7QutGCXFwufNC90L7Rj9CxP1xcLnzQtNC10LpcXC4pL2ksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZINCzLicsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINCzLiwgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkg0LMuLCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9Ch0LXQs9C+0LTQvdGPINCyXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vQl9Cw0LLRgtGA0LAg0LJdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9CS0YfQtdGA0LAg0LJdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKG5vdykge1xyXG4gICAgICAgICAgICBpZiAobm93LndlZWsoKSAhPT0gdGhpcy53ZWVrKCkpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0YHQu9C10LTRg9GO0YnQtdC1XSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDRgdC70LXQtNGD0Y7RidC40LldIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINGB0LvQtdC00YPRjtGJ0YPRjl0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRheSgpID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JLQvl0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JJdIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAobm93KSB7XHJcbiAgICAgICAgICAgIGlmIChub3cud2VlaygpICE9PSB0aGlzLndlZWsoKSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDQv9GA0L7RiNC70L7QtV0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0L/RgNC+0YjQu9GL0LldIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC/0YDQvtGI0LvRg9GOXSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF5KCkgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQktC+XSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkl0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn0YfQtdGA0LXQtyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDQvdCw0LfQsNC0JyxcclxuICAgICAgICBzIDogJ9C90LXRgdC60L7Qu9GM0LrQviDRgdC10LrRg9C90LQnLFxyXG4gICAgICAgIG0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBoIDogJ9GH0LDRgScsXHJcbiAgICAgICAgaGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGQgOiAn0LTQtdC90YwnLFxyXG4gICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBNIDogJ9C80LXRgdGP0YYnLFxyXG4gICAgICAgIE1NIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICB5IDogJ9Cz0L7QtCcsXHJcbiAgICAgICAgeXkgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9C90L7Rh9C4fNGD0YLRgNCwfNC00L3Rj3zQstC10YfQtdGA0LAvaSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9C10YDQsCkkLy50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQvdC+0YfQuCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfRg9GC0YDQsCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQtNC90Y8nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn0LLQtdGH0LXRgNCwJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjQuXzQs9C+fNGPKS8sXHJcbiAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QuSc7XHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LPQvic7XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdGPJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBydTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcnUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcnUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTaW5kaGkgW3NkXVxyXG4vLyEgYXV0aG9yIDogTmFyYWluIFNhZ2FyIDogaHR0cHM6Ly9naXRodWIuY29tL25hcmFpbnNhZ2FyXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzID0gW1xyXG4gICAgJ9is2YbZiNix2YonLFxyXG4gICAgJ9mB2YrYqNix2YjYsdmKJyxcclxuICAgICfZhdin2LHahicsXHJcbiAgICAn2KfZvtix2YrZhCcsXHJcbiAgICAn2YXYptmKJyxcclxuICAgICfYrNmI2YYnLFxyXG4gICAgJ9is2YjZhNin2KHZkCcsXHJcbiAgICAn2KLar9iz2b0nLFxyXG4gICAgJ9iz2YrZvtm92YXYqNixJyxcclxuICAgICfYotqq2b3ZiNio2LEnLFxyXG4gICAgJ9mG2YjZhdio2LEnLFxyXG4gICAgJ9qK2LPZhdio2LEnXHJcbl07XHJcbnZhciBkYXlzID0gW1xyXG4gICAgJ9ii2obYsScsXHJcbiAgICAn2LPZiNmF2LEnLFxyXG4gICAgJ9in2rHYp9ix2YgnLFxyXG4gICAgJ9in2LHYqNi5JyxcclxuICAgICfYrtmF2YrYsycsXHJcbiAgICAn2KzZhdi5JyxcclxuICAgICfah9mG2ofYsSdcclxuXTtcclxuXHJcbnZhciBzZCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NkJywge1xyXG4gICAgbW9udGhzIDogbW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQgOiBtb250aHMsXHJcbiAgICB3ZWVrZGF5cyA6IGRheXMsXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogZGF5cyxcclxuICAgIHdlZWtkYXlzTWluIDogZGF5cyxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRk2IwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9i12KjYrXzYtNin2YUvLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAn2LTYp9mFJyA9PT0gaW5wdXQ7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9i12KjYrSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAn2LTYp9mFJztcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vYp9qEXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb2LPagNin2rvZil0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW9in2rPZitmGINmH2YHYqtmKINiq2YpdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vaqtin2YTZh9mHXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW9qv2LLYsdmK2YQg2YfZgdiq2YpdIGRkZGQgW9iq2YpdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg2b7ZiNihJyxcclxuICAgICAgICBwYXN0IDogJyVzINin2rMnLFxyXG4gICAgICAgIHMgOiAn2obZhtivINiz2YraqtmG2oonLFxyXG4gICAgICAgIG0gOiAn2YfaqiDZhdmG2b0nLFxyXG4gICAgICAgIG1tIDogJyVkINmF2YbZvScsXHJcbiAgICAgICAgaCA6ICfZh9qqINqq2YTYp9qqJyxcclxuICAgICAgICBoaCA6ICclZCDaqtmE2KfaqicsXHJcbiAgICAgICAgZCA6ICfZh9qqINqP2YrZhtmH2YYnLFxyXG4gICAgICAgIGRkIDogJyVkINqP2YrZhtmH2YYnLFxyXG4gICAgICAgIE0gOiAn2YfaqiDZhdmH2YrZhtmIJyxcclxuICAgICAgICBNTSA6ICclZCDZhdmH2YrZhtinJyxcclxuICAgICAgICB5IDogJ9mH2qog2LPYp9mEJyxcclxuICAgICAgICB5eSA6ICclZCDYs9in2YQnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLC9nLCAn2IwnKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc2Q7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NkLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTm9ydGhlcm4gU2FtaSBbc2VdXHJcbi8vISBhdXRob3JzIDogQsOlcmQgUm9sc3RhZCBIZW5yaWtzZW4gOiBodHRwczovL2dpdGh1Yi5jb20va2FyYW1lbGxcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcblxyXG52YXIgc2UgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzZScsIHtcclxuICAgIG1vbnRocyA6ICdvxJHEkWFqYWdlbcOhbm51X2d1b3Z2YW3DoW5udV9uanVrxI1hbcOhbm51X2N1b8WLb23DoW5udV9taWVzc2Vtw6FubnVfZ2Vhc3NlbcOhbm51X3N1b2lkbmVtw6FubnVfYm9yZ2Vtw6FubnVfxI1ha8SNYW3DoW5udV9nb2xnZ290bcOhbm51X3Nrw6FibWFtw6FubnVfanVvdmxhbcOhbm51Jy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnb8SRxJFqX2d1b3Zfbmp1a19jdW9fbWllc19nZWFzX3N1b2lfYm9yZ1/EjWFrxI1fZ29sZ19za8OhYl9qdW92Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnc290bmFiZWFpdmlfdnVvc3PDoXJnYV9tYcWLxYtlYsOhcmdhX2dhc2thdmFoa2t1X2R1b3Jhc3RhdF9iZWFyamFkYXRfbMOhdnZhcmRhdCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc290bl92dW9zX21hxYtfZ2Fza19kdW9yX2JlYXJfbMOhdicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3Nfdl9tX2dfZF9iX0wnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ01NTU0gRC4gW2IuXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnTU1NTSBELiBbYi5dIFlZWVkgW3RpLl0gSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELiBbYi5dIFlZWVkgW3RpLl0gSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tvdG5lIHRpXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tpaHR0aW4gdGldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3RpXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tpa3RlIHRpXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbb3ZkZGl0XSBkZGRkIFt0aV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIGdlYcW+ZXMnLFxyXG4gICAgICAgIHBhc3QgOiAnbWHFi2l0ICVzJyxcclxuICAgICAgICBzIDogJ21vYWRkZSBzZWt1bmRkYXQnLFxyXG4gICAgICAgIG0gOiAnb2t0YSBtaW51aHRhJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51aHRhdCcsXHJcbiAgICAgICAgaCA6ICdva3RhIGRpaW1tdScsXHJcbiAgICAgICAgaGggOiAnJWQgZGlpbW11dCcsXHJcbiAgICAgICAgZCA6ICdva3RhIGJlYWl2aScsXHJcbiAgICAgICAgZGQgOiAnJWQgYmVhaXZ2aXQnLFxyXG4gICAgICAgIE0gOiAnb2t0YSBtw6FubnUnLFxyXG4gICAgICAgIE1NIDogJyVkIG3DoW51dCcsXHJcbiAgICAgICAgeSA6ICdva3RhIGphaGtpJyxcclxuICAgICAgICB5eSA6ICclZCBqYWdpdCdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHNlO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFNpbmhhbGVzZSBbc2ldXHJcbi8vISBhdXRob3IgOiBTYW1wYXRoIFNpdGluYW1hbHV3YSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1wYXRoc3Jpc1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuLypqc2hpbnQgLVcxMDAqL1xyXG52YXIgc2kgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzaScsIHtcclxuICAgIG1vbnRocyA6ICfgtqLgtrHgt4Dgt4/gtrvgt5Jf4La04LeZ4La24La74LeA4LeP4La74LeSX+C2uOC3j+C2u+C3iuC2reC3lF/gtoXgtrTgt4rigI3gtrvgt5rgtr3gt4pf4La44LeQ4La64LeSX+C2ouC3luC2seC3kl/gtqLgt5bgtr3gt5Jf4LaF4Lac4Led4LeD4LeK4Lat4LeUX+C3g+C3kOC2tOC3iuC2reC3kOC2uOC3iuC2tuC2u+C3il/gtpTgtprgt4rgtq3gt53gtrbgtrvgt4pf4Lax4Lec4LeA4LeQ4La44LeK4La24La74LeKX+C2r+C3meC3g+C3kOC2uOC3iuC2tuC2u+C3iicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+C2ouC2sV/gtrTgt5ngtrZf4La44LeP4La74LeKX+C2heC2tOC3il/gtrjgt5Dgtrrgt5Jf4Lai4LeW4Lax4LeSX+C2ouC3luC2veC3kl/gtoXgtpzgt51f4LeD4LeQ4La04LeKX+C2lOC2muC3il/gtrHgt5zgt4Dgt5Bf4Lav4LeZ4LeD4LeQJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn4LaJ4La74LeS4Lav4LePX+C3g+C2s+C3lOC2r+C3j1/gtoXgtp/gt4Tgtrvgt5Tgt4Dgt4/gtq/gt49f4La24Lav4LeP4Lav4LePX+C2tuC3iuKAjeC2u+C3hOC3g+C3iuC2tOC2reC3kuC2seC3iuC2r+C3j1/gt4Pgt5Lgtprgt5Tgtrvgt4/gtq/gt49f4LeD4LeZ4Lax4LeD4LeU4La74LeP4Lav4LePJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgtongtrvgt5Jf4LeD4Laz4LeUX+C2heC2n1/gtrbgtq/gt49f4La24LeK4oCN4La74LeEX+C3g+C3kuC2muC3lF/gt4Pgt5ngtrEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgtolf4LeDX+C2hV/gtrZf4La24LeK4oCN4La7X+C3g+C3kl/gt4Pgt5knLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnYSBoOm1tJyxcclxuICAgICAgICBMVFMgOiAnYSBoOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVkvTU0vREQnLFxyXG4gICAgICAgIExMIDogJ1lZWVkgTU1NTSBEJyxcclxuICAgICAgICBMTEwgOiAnWVlZWSBNTU1NIEQsIGEgaDptbScsXHJcbiAgICAgICAgTExMTCA6ICdZWVlZIE1NTU0gRCBb4LeA4LeQ4Lax4LeSXSBkZGRkLCBhIGg6bW06c3MnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4LaF4LavXSBMVFvgtqddJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgt4Tgt5ngtqddIExUW+C2p10nLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFRb4LanXScsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4LaK4La64LeaXSBMVFvgtqddJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4La04LeD4LeU4Lac4LeS4La6XSBkZGRkIExUW+C2p10nLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclc+C2muC3kuC2seC3iicsXHJcbiAgICAgICAgcGFzdCA6ICclc+C2muC2pyDgtrTgt5ngtrsnLFxyXG4gICAgICAgIHMgOiAn4Lat4Lat4LeK4La04La7IOC2muC3kuC3hOC3kuC2tOC2uicsXHJcbiAgICAgICAgbSA6ICfgtrjgt5LgtrHgt5Lgtq3gt4rgtq3gt5Tgt4AnLFxyXG4gICAgICAgIG1tIDogJ+C2uOC3kuC2seC3kuC2reC3iuC2reC3lCAlZCcsXHJcbiAgICAgICAgaCA6ICfgtrTgt5DgtronLFxyXG4gICAgICAgIGhoIDogJ+C2tOC3kOC2uiAlZCcsXHJcbiAgICAgICAgZCA6ICfgtq/gt5LgtrHgtronLFxyXG4gICAgICAgIGRkIDogJ+C2r+C3kuC2sSAlZCcsXHJcbiAgICAgICAgTSA6ICfgtrjgt4/gt4PgtronLFxyXG4gICAgICAgIE1NIDogJ+C2uOC3j+C3gyAlZCcsXHJcbiAgICAgICAgeSA6ICfgt4Dgt4PgtrsnLFxyXG4gICAgICAgIHl5IDogJ+C3gOC3g+C2uyAlZCdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0g4LeA4LeQ4Lax4LeSLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICcg4LeA4LeQ4Lax4LeSJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlIDogL+C2tOC3meC2uyDgt4Dgtrvgt5R84La04LeD4LeKIOC3gOC2u+C3lHzgtrTgt5ku4LeAfOC2tC7gt4AuLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfgtrQu4LeALicgfHwgaW5wdXQgPT09ICfgtrTgt4Pgt4og4LeA4La74LeUJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ+C2tC7gt4AuJyA6ICfgtrTgt4Pgt4og4LeA4La74LeUJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICfgtrTgt5ku4LeALicgOiAn4La04LeZ4La7IOC3gOC2u+C3lCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzaTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2kuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2kuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTbG92YWsgW3NrXVxyXG4vLyEgYXV0aG9yIDogTWFydGluIE1pbmthIDogaHR0cHM6Ly9naXRodWIuY29tL2syc1xyXG4vLyEgYmFzZWQgb24gd29yayBvZiBwZXRyYmVsYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRyYmVsYVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRocyA9ICdqYW51w6FyX2ZlYnJ1w6FyX21hcmVjX2FwcsOtbF9tw6FqX2rDum5fasO6bF9hdWd1c3Rfc2VwdGVtYmVyX29rdMOzYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnQgPSAnamFuX2ZlYl9tYXJfYXByX23DoWpfasO6bl9qw7psX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyk7XHJcbmZ1bmN0aW9uIHBsdXJhbChuKSB7XHJcbiAgICByZXR1cm4gKG4gPiAxKSAmJiAobiA8IDUpO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ3MnOiAgLy8gYSBmZXcgc2Vjb25kcyAvIGluIGEgZmV3IHNlY29uZHMgLyBhIGZldyBzZWNvbmRzIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3DDoXIgc2Vrw7puZCcgOiAncMOhciBzZWt1bmRhbWknO1xyXG4gICAgICAgIGNhc2UgJ20nOiAgLy8gYSBtaW51dGUgLyBpbiBhIG1pbnV0ZSAvIGEgbWludXRlIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtaW7DunRhJyA6IChpc0Z1dHVyZSA/ICdtaW7DunR1JyA6ICdtaW7DunRvdScpO1xyXG4gICAgICAgIGNhc2UgJ21tJzogLy8gOSBtaW51dGVzIC8gaW4gOSBtaW51dGVzIC8gOSBtaW51dGVzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtaW7DunR5JyA6ICdtaW7DunQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbWluw7p0YW1pJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdoJzogIC8vIGFuIGhvdXIgLyBpbiBhbiBob3VyIC8gYW4gaG91ciBhZ29cclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnaG9kaW5hJyA6IChpc0Z1dHVyZSA/ICdob2RpbnUnIDogJ2hvZGlub3UnKTtcclxuICAgICAgICBjYXNlICdoaCc6IC8vIDkgaG91cnMgLyBpbiA5IGhvdXJzIC8gOSBob3VycyBhZ29cclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnaG9kaW55JyA6ICdob2TDrW4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnaG9kaW5hbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2QnOiAgLy8gYSBkYXkgLyBpbiBhIGRheSAvIGEgZGF5IGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ2RlxYgnIDogJ2TFiG9tJztcclxuICAgICAgICBjYXNlICdkZCc6IC8vIDkgZGF5cyAvIGluIDkgZGF5cyAvIDkgZGF5cyBhZ29cclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnZG5pJyA6ICdkbsOtJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2TFiGFtaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnTSc6ICAvLyBhIG1vbnRoIC8gaW4gYSBtb250aCAvIGEgbW9udGggYWdvXHJcbiAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAnbWVzaWFjJyA6ICdtZXNpYWNvbSc7XHJcbiAgICAgICAgY2FzZSAnTU0nOiAvLyA5IG1vbnRocyAvIGluIDkgbW9udGhzIC8gOSBtb250aHMgYWdvXHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21lc2lhY2UnIDogJ21lc2lhY292Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ21lc2lhY21pJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd5JzogIC8vIGEgeWVhciAvIGluIGEgeWVhciAvIGEgeWVhciBhZ29cclxuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdyb2snIDogJ3Jva29tJztcclxuICAgICAgICBjYXNlICd5eSc6IC8vIDkgeWVhcnMgLyBpbiA5IHllYXJzIC8gOSB5ZWFycyBhZ29cclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAncm9reScgOiAncm9rb3YnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAncm9rbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgc2sgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzaycsIHtcclxuICAgIG1vbnRocyA6IG1vbnRocyxcclxuICAgIG1vbnRoc1Nob3J0IDogbW9udGhzU2hvcnQsXHJcbiAgICB3ZWVrZGF5cyA6ICduZWRlxL5hX3BvbmRlbG9rX3V0b3Jva19zdHJlZGFfxaF0dnJ0b2tfcGlhdG9rX3NvYm90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVfcG9fdXRfc3RfxaF0X3BpX3NvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnbmVfcG9fdXRfc3RfxaF0X3BpX3NvJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQ6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQuIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbZG5lcyBvXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1t6YWp0cmEgb10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3YgbmVkZcS+dSBvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gZGRkZCBbb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Ygc3RyZWR1IG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2byDFoXR2cnRvayBvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBwaWF0b2sgb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3Ygc29ib3R1IG9dIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheTogJ1t2xI1lcmEgb10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw7ogbmVkZcS+dSBvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDvV0gZGRkZCBbb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw7ogc3RyZWR1IG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFtvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDuiBzb2JvdHUgb10gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdwcmVkICVzJyxcclxuICAgICAgICBzIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGRkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTU0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc2s7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NrLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NrLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU2xvdmVuaWFuIFtzbF1cclxuLy8hIGF1dGhvciA6IFJvYmVydCBTZWRvdsWhZWsgOiBodHRwczovL2dpdGh1Yi5jb20vc2Vkb3ZzZWtcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbmVrYWogc2VrdW5kJyA6ICduZWthaiBzZWt1bmRhbWknO1xyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdlbmEgbWludXRhJyA6ICdlbm8gbWludXRvJztcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4ID8gJ21pbnV0YScgOiAnbWludXRvJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21pbnV0aScgOiAnbWludXRhbWEnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ21pbnV0ZScgOiAnbWludXRhbWknO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWludXQnIDogJ21pbnV0YW1pJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdlbmEgdXJhJyA6ICdlbm8gdXJvJztcclxuICAgICAgICBjYXNlICdoaCc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4ID8gJ3VyYScgOiAndXJvJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3VyaScgOiAndXJhbWEnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ3VyZScgOiAndXJhbWknO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAndXInIDogJ3VyYW1pJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbiBkYW4nIDogJ2VuaW0gZG5lbSc7XHJcbiAgICAgICAgY2FzZSAnZGQnOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdkYW4nIDogJ2RuZW0nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnZG5pJyA6ICdkbmV2b21hJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2RuaScgOiAnZG5ldmknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2VuIG1lc2VjJyA6ICdlbmltIG1lc2VjZW0nO1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWVzZWMnIDogJ21lc2VjZW0nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWVzZWNhJyA6ICdtZXNlY2VtYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWVzZWNlJyA6ICdtZXNlY2knO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWVzZWNldicgOiAnbWVzZWNpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ3knOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdlbm8gbGV0bycgOiAnZW5pbSBsZXRvbSc7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdsZXRvJyA6ICdsZXRvbSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdsZXRpJyA6ICdsZXRvbWEnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA8IDUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2xldGEnIDogJ2xldGknO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbGV0JyA6ICdsZXRpJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgc2wgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzbCcsIHtcclxuICAgIG1vbnRocyA6ICdqYW51YXJfZmVicnVhcl9tYXJlY19hcHJpbF9tYWpfanVuaWpfanVsaWpfYXZndXN0X3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuLl9mZWIuX21hci5fYXByLl9tYWouX2p1bi5fanVsLl9hdmcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnbmVkZWxqYV9wb25lZGVsamVrX3RvcmVrX3NyZWRhX8SNZXRydGVrX3BldGVrX3NvYm90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVkLl9wb24uX3Rvci5fc3JlLl/EjWV0Ll9wZXQuX3NvYi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICduZV9wb190b19zcl/EjWVfcGVfc28nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSAgOiAnW2RhbmVzIG9iXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSAgOiAnW2p1dHJpIG9iXSBMVCcsXHJcblxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBbbmVkZWxqb10gW29iXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdl0gW3NyZWRvXSBbb2JdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBbc29ib3RvXSBbb2JdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBkZGRkIFtvYl0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5ICA6ICdbdsSNZXJhaiBvYl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcmVqxaFuam9dIFtuZWRlbGpvXSBbb2JdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcmVqxaFuam9dIFtzcmVkb10gW29iXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJlasWhbmpvXSBbc29ib3RvXSBbb2JdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcmVqxaFuamldIGRkZGQgW29iXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfEjWV6ICVzJyxcclxuICAgICAgICBwYXN0ICAgOiAncHJlZCAlcycsXHJcbiAgICAgICAgcyAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG1tICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoaCAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGQgICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZGQgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE1NICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeSAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5eSAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzbDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2wuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2wuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBbGJhbmlhbiBbc3FdXHJcbi8vISBhdXRob3IgOiBGbGFrw6tyaW0gSXNtYW5pIDogaHR0cHM6Ly9naXRodWIuY29tL2ZsYWtlcmltaVxyXG4vLyEgYXV0aG9yIDogTWVuZWxpb24gRWxlbnPDumxlIDogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcclxuLy8hIGF1dGhvciA6IE9lcmQgQ3VrYWxsYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9vZXJkXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3EgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzcScsIHtcclxuICAgIG1vbnRocyA6ICdKYW5hcl9TaGt1cnRfTWFyc19QcmlsbF9NYWpfUWVyc2hvcl9Lb3JyaWtfR3VzaHRfU2h0YXRvcl9UZXRvcl9Ow6tudG9yX0RoamV0b3InLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fU2hrX01hcl9QcmlfTWFqX1Flcl9Lb3JfR3VzX1NodF9UZXRfTsOrbl9EaGonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdFIERpZWxfRSBIw6tuw6tfRSBNYXJ0w6tfRSBNw6tya3Vyw6tfRSBFbmp0ZV9FIFByZW10ZV9FIFNodHVuw6snLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0RpZV9Iw6tuX01hcl9Nw6tyX0Vual9QcmVfU2h0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnRF9IX01hX03Dq19FX1BfU2gnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL1BEfE1ELyxcclxuICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dC5jaGFyQXQoMCkgPT09ICdNJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIHJldHVybiBob3VycyA8IDEyID8gJ1BEJyA6ICdNRCc7XHJcbiAgICB9LFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1NvdCBuw6tdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tOZXPDq3IgbsOrXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbbsOrXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbRGplIG7Dq10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2Uga2FsdWFyIG7Dq10gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICduw6sgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgbcOrIHBhcsOrJyxcclxuICAgICAgICBzIDogJ2Rpc2Egc2Vrb25kYScsXHJcbiAgICAgICAgbSA6ICduasOrIG1pbnV0w6snLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0YScsXHJcbiAgICAgICAgaCA6ICduasOrIG9yw6snLFxyXG4gICAgICAgIGhoIDogJyVkIG9yw6snLFxyXG4gICAgICAgIGQgOiAnbmrDqyBkaXTDqycsXHJcbiAgICAgICAgZGQgOiAnJWQgZGl0w6snLFxyXG4gICAgICAgIE0gOiAnbmrDqyBtdWFqJyxcclxuICAgICAgICBNTSA6ICclZCBtdWFqJyxcclxuICAgICAgICB5IDogJ25qw6sgdml0JyxcclxuICAgICAgICB5eSA6ICclZCB2aXRlJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc3E7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NxLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NxLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU2VyYmlhbiBDeXJpbGxpYyBbc3ItY3lybF1cclxuLy8hIGF1dGhvciA6IE1pbGFuIEphbmHEjWtvdmnEhzxtaWxhbmphbmFja292aWNAZ21haWwuY29tPiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWxhbi1qXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdHJhbnNsYXRvciA9IHtcclxuICAgIHdvcmRzOiB7IC8vRGlmZmVyZW50IGdyYW1tYXRpY2FsIGNhc2VzXHJcbiAgICAgICAgbTogWyfRmNC10LTQsNC9INC80LjQvdGD0YInLCAn0ZjQtdC00L3QtSDQvNC40L3Rg9GC0LUnXSxcclxuICAgICAgICBtbTogWyfQvNC40L3Rg9GCJywgJ9C80LjQvdGD0YLQtScsICfQvNC40L3Rg9GC0LAnXSxcclxuICAgICAgICBoOiBbJ9GY0LXQtNCw0L0g0YHQsNGCJywgJ9GY0LXQtNC90L7QsyDRgdCw0YLQsCddLFxyXG4gICAgICAgIGhoOiBbJ9GB0LDRgicsICfRgdCw0YLQsCcsICfRgdCw0YLQuCddLFxyXG4gICAgICAgIGRkOiBbJ9C00LDQvScsICfQtNCw0L3QsCcsICfQtNCw0L3QsCddLFxyXG4gICAgICAgIE1NOiBbJ9C80LXRgdC10YYnLCAn0LzQtdGB0LXRhtCwJywgJ9C80LXRgdC10YbQuCddLFxyXG4gICAgICAgIHl5OiBbJ9Cz0L7QtNC40L3QsCcsICfQs9C+0LTQuNC90LUnLCAn0LPQvtC00LjQvdCwJ11cclxuICAgIH0sXHJcbiAgICBjb3JyZWN0R3JhbW1hdGljYWxDYXNlOiBmdW5jdGlvbiAobnVtYmVyLCB3b3JkS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IHdvcmRLZXlbMF0gOiAobnVtYmVyID49IDIgJiYgbnVtYmVyIDw9IDQgPyB3b3JkS2V5WzFdIDogd29yZEtleVsyXSk7XHJcbiAgICB9LFxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgICAgICB2YXIgd29yZEtleSA9IHRyYW5zbGF0b3Iud29yZHNba2V5XTtcclxuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IHdvcmRLZXlbMF0gOiB3b3JkS2V5WzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyB0cmFuc2xhdG9yLmNvcnJlY3RHcmFtbWF0aWNhbENhc2UobnVtYmVyLCB3b3JkS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgc3JDeXJsID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc3ItY3lybCcsIHtcclxuICAgIG1vbnRoczogJ9GY0LDQvdGD0LDRgF/RhNC10LHRgNGD0LDRgF/QvNCw0YDRgl/QsNC/0YDQuNC7X9C80LDRmF/RmNGD0L1f0ZjRg9C7X9Cw0LLQs9GD0YHRgl/RgdC10L/RgtC10LzQsdCw0YBf0L7QutGC0L7QsdCw0YBf0L3QvtCy0LXQvNCx0LDRgF/QtNC10YbQtdC80LHQsNGAJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICfRmNCw0L0uX9GE0LXQsS5f0LzQsNGALl/QsNC/0YAuX9C80LDRmF/RmNGD0L1f0ZjRg9C7X9Cw0LLQsy5f0YHQtdC/Ll/QvtC60YIuX9C90L7Qsi5f0LTQtdGGLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5czogJ9C90LXQtNC10ZnQsF/Qv9C+0L3QtdC00LXRmdCw0Lpf0YPRgtC+0YDQsNC6X9GB0YDQtdC00LBf0YfQtdGC0LLRgNGC0LDQul/Qv9C10YLQsNC6X9GB0YPQsdC+0YLQsCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICfQvdC10LQuX9C/0L7QvS5f0YPRgtC+Ll/RgdGA0LUuX9GH0LXRgi5f0L/QtdGCLl/RgdGD0LEuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW46ICfQvdC1X9C/0L5f0YPRgl/RgdGAX9GH0LVf0L/QtV/RgdGDJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEw6ICdELiBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgTExMTDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vQtNCw0L3QsNGBINGDXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vRgdGD0YLRgNCwINGDXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvQvdC10LTQtdGZ0YNdIFvRg10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9GDXSBb0YHRgNC10LTRg10gW9GDXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvRgdGD0LHQvtGC0YNdIFvRg10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9GDXSBkZGRkIFvRg10gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5ICA6ICdb0ZjRg9GH0LUg0YNdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RXZWVrRGF5cyA9IFtcclxuICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C1XSBb0L3QtdC00LXRmdC1XSBb0YNdIExUJyxcclxuICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C+0LNdIFvQv9C+0L3QtdC00LXRmdC60LBdIFvRg10gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70L7Qs10gW9GD0YLQvtGA0LrQsF0gW9GDXSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQtV0gW9GB0YDQtdC00LVdIFvRg10gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70L7Qs10gW9GH0LXRgtCy0YDRgtC60LBdIFvRg10gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70L7Qs10gW9C/0LXRgtC60LBdIFvRg10gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70LVdIFvRgdGD0LHQvtGC0LVdIFvRg10gTFQnXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHJldHVybiBsYXN0V2Vla0RheXNbdGhpcy5kYXkoKV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn0LfQsCAlcycsXHJcbiAgICAgICAgcGFzdCAgIDogJ9C/0YDQtSAlcycsXHJcbiAgICAgICAgcyAgICAgIDogJ9C90LXQutC+0LvQuNC60L4g0YHQtdC60YPQvdC00LgnLFxyXG4gICAgICAgIG0gICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIG1tICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGggICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGhoICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGQgICAgICA6ICfQtNCw0L0nLFxyXG4gICAgICAgIGRkICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIE0gICAgICA6ICfQvNC10YHQtdGGJyxcclxuICAgICAgICBNTSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcclxuICAgICAgICB5ICAgICAgOiAn0LPQvtC00LjQvdGDJyxcclxuICAgICAgICB5eSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc3JDeXJsO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci1jeXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTZXJiaWFuIFtzcl1cclxuLy8hIGF1dGhvciA6IE1pbGFuIEphbmHEjWtvdmnEhzxtaWxhbmphbmFja292aWNAZ21haWwuY29tPiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWxhbi1qXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdHJhbnNsYXRvciA9IHtcclxuICAgIHdvcmRzOiB7IC8vRGlmZmVyZW50IGdyYW1tYXRpY2FsIGNhc2VzXHJcbiAgICAgICAgbTogWydqZWRhbiBtaW51dCcsICdqZWRuZSBtaW51dGUnXSxcclxuICAgICAgICBtbTogWydtaW51dCcsICdtaW51dGUnLCAnbWludXRhJ10sXHJcbiAgICAgICAgaDogWydqZWRhbiBzYXQnLCAnamVkbm9nIHNhdGEnXSxcclxuICAgICAgICBoaDogWydzYXQnLCAnc2F0YScsICdzYXRpJ10sXHJcbiAgICAgICAgZGQ6IFsnZGFuJywgJ2RhbmEnLCAnZGFuYSddLFxyXG4gICAgICAgIE1NOiBbJ21lc2VjJywgJ21lc2VjYScsICdtZXNlY2knXSxcclxuICAgICAgICB5eTogWydnb2RpbmEnLCAnZ29kaW5lJywgJ2dvZGluYSddXHJcbiAgICB9LFxyXG4gICAgY29ycmVjdEdyYW1tYXRpY2FsQ2FzZTogZnVuY3Rpb24gKG51bWJlciwgd29yZEtleSkge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgPT09IDEgPyB3b3JkS2V5WzBdIDogKG51bWJlciA+PSAyICYmIG51bWJlciA8PSA0ID8gd29yZEtleVsxXSA6IHdvcmRLZXlbMl0pO1xyXG4gICAgfSxcclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICAgICAgdmFyIHdvcmRLZXkgPSB0cmFuc2xhdG9yLndvcmRzW2tleV07XHJcbiAgICAgICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyB3b3JkS2V5WzBdIDogd29yZEtleVsxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgdHJhbnNsYXRvci5jb3JyZWN0R3JhbW1hdGljYWxDYXNlKG51bWJlciwgd29yZEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIHNyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc3InLCB7XHJcbiAgICBtb250aHM6ICdqYW51YXJfZmVicnVhcl9tYXJ0X2FwcmlsX21hal9qdW5fanVsX2F2Z3VzdF9zZXB0ZW1iYXJfb2t0b2Jhcl9ub3ZlbWJhcl9kZWNlbWJhcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0OiAnamFuLl9mZWIuX21hci5fYXByLl9tYWpfanVuX2p1bF9hdmcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxyXG4gICAgd2Vla2RheXM6ICduZWRlbGphX3BvbmVkZWxqYWtfdXRvcmFrX3NyZWRhX8SNZXR2cnRha19wZXRha19zdWJvdGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0OiAnbmVkLl9wb24uX3V0by5fc3JlLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ25lX3BvX3V0X3NyX8SNZV9wZV9zdScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdDoge1xyXG4gICAgICAgIExUOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEw6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbZGFuYXMgdV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbc3V0cmEgdV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtuZWRlbGp1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmVkdV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbc3Vib3R1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIGRkZGQgW3VdIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSAgOiAnW2p1xI1lIHVdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxhc3RXZWVrRGF5cyA9IFtcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW25lZGVsamVdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcG9uZWRlbGprYV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFt1dG9ya2FdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtzcmVkZV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFvEjWV0dnJ0a2FdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcGV0a2FdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtzdWJvdGVdIFt1XSBMVCdcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RXZWVrRGF5c1t0aGlzLmRheSgpXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCAgIDogJ3ByZSAlcycsXHJcbiAgICAgICAgcyAgICAgIDogJ25la29saWtvIHNla3VuZGknLFxyXG4gICAgICAgIG0gICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIG1tICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGggICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGhoICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIGQgICAgICA6ICdkYW4nLFxyXG4gICAgICAgIGRkICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIE0gICAgICA6ICdtZXNlYycsXHJcbiAgICAgICAgTU0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgeSAgICAgIDogJ2dvZGludScsXHJcbiAgICAgICAgeXkgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHNyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IHNpU3dhdGkgW3NzXVxyXG4vLyEgYXV0aG9yIDogTmljb2xhaSBEYXZpZXM8bWFpbEBuaWNvbGFpLmlvPiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9uaWNvbGFpZGF2aWVzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5cclxudmFyIHNzID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc3MnLCB7XHJcbiAgICBtb250aHMgOiBcIkJoaW1iaWR2d2FuZV9JbmRsb3ZhbmFfSW5kbG92J2xlbmtodWx1X01hYmFzYV9Jbmtod2VraHdldGlfSW5obGFiYV9LaG9sd2FuZV9JbmdjaV9JbnlvbmlfSW1waGFsYV9Md2V0aV9JbmdvbmdvbmlcIi5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnQmhpX0luYV9JbnVfTWFiX0lua19JbmhfS2hvX0lnY19JbnlfSW1wX0x3ZV9JZ28nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdMaXNvbnRmb19VbXNvbWJ1bHVrb19MZXNpYmlsaV9MZXNpdHNhdGZ1X0xlc2luZV9MZXNpaGxhbnVfVW1nY2liZWxvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdMaXNfVW1iX0xzYl9MZXNfTHNpX0xzaF9VbWcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdMaV9Vc19MYl9MdF9Mc19MaF9VZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW05hbXVobGEgbmdhXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbS3VzYXNhIG5nYV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW25nYV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0l0b2xvIG5nYV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xlbGlwaGVsaWxlXSBbbmdhXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ25nYSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICd3ZW50ZWthIG5nYSAlcycsXHJcbiAgICAgICAgcyA6ICdlbWl6dXp3YW5hIGxvbWNhbmUnLFxyXG4gICAgICAgIG0gOiAndW16dXp1JyxcclxuICAgICAgICBtbSA6ICclZCBlbWl6dXp1JyxcclxuICAgICAgICBoIDogJ2xpaG9yYScsXHJcbiAgICAgICAgaGggOiAnJWQgZW1haG9yYScsXHJcbiAgICAgICAgZCA6ICdsaWxhbmdhJyxcclxuICAgICAgICBkZCA6ICclZCBlbWFsYW5nYScsXHJcbiAgICAgICAgTSA6ICdpbnlhbmdhJyxcclxuICAgICAgICBNTSA6ICclZCB0aW55YW5nYScsXHJcbiAgICAgICAgeSA6ICd1bW55YWthJyxcclxuICAgICAgICB5eSA6ICclZCBpbWlueWFrYSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvZWt1c2VuaXxlbWluaXxlbnRzYW1iYW1hfGVidXN1a3UvLFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VrdXNlbmknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VtaW5pJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdlbnRzYW1iYW1hJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VidXN1a3UnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ2VrdXNlbmknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdlbWluaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdlbnRzYW1iYW1hJyB8fCBtZXJpZGllbSA9PT0gJ2VidXN1a3UnKSB7XHJcbiAgICAgICAgICAgIGlmIChob3VyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0vLFxyXG4gICAgb3JkaW5hbCA6ICclZCcsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc3M7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU3dlZGlzaCBbc3ZdXHJcbi8vISBhdXRob3IgOiBKZW5zIEFsbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS91bG11c1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc3YnLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyaV9mZWJydWFyaV9tYXJzX2FwcmlsX21hal9qdW5pX2p1bGlfYXVndXN0aV9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWpfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnc8O2bmRhZ19tw6VuZGFnX3Rpc2RhZ19vbnNkYWdfdG9yc2RhZ19mcmVkYWdfbMO2cmRhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc8O2bl9tw6VuX3Rpc19vbnNfdG9yX2ZyZV9sw7ZyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnc8O2X23DpV90aV9vbl90b19mcl9sw7YnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBba2wuXSBISDptbScsXHJcbiAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnZGRkIEQgTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tJZGFnXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tJbW9yZ29uXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tJZ8Olcl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnW1DDpV0gZGRkZCBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbSV0gZGRkZFtzXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb20gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnZsO2ciAlcyBzZWRhbicsXHJcbiAgICAgICAgcyA6ICduw6VncmEgc2VrdW5kZXInLFxyXG4gICAgICAgIG0gOiAnZW4gbWludXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXInLFxyXG4gICAgICAgIGggOiAnZW4gdGltbWUnLFxyXG4gICAgICAgIGhoIDogJyVkIHRpbW1hcicsXHJcbiAgICAgICAgZCA6ICdlbiBkYWcnLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2FyJyxcclxuICAgICAgICBNIDogJ2VuIG3DpW5hZCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbcOlbmFkZXInLFxyXG4gICAgICAgIHkgOiAnZXR0IMOlcicsXHJcbiAgICAgICAgeXkgOiAnJWQgw6VyJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShlfGEpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAnZScgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnYScgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnYScgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAnZScgOiAnZSc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc3Y7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3N2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3N2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU3dhaGlsaSBbc3ddXHJcbi8vISBhdXRob3IgOiBGYWhhZCBLYXNzaW0gOiBodHRwczovL2dpdGh1Yi5jb20vZmFkc2VsXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3cgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzdycsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJpX0ZlYnJ1YXJpX01hY2hpX0FwcmlsaV9NZWlfSnVuaV9KdWxhaV9BZ29zdGlfU2VwdGVtYmFfT2t0b2JhX05vdmVtYmFfRGVzZW1iYScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFjX0Fwcl9NZWlfSnVuX0p1bF9BZ29fU2VwX09rdF9Ob3ZfRGVzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnSnVtYXBpbGlfSnVtYXRhdHVfSnVtYW5uZV9KdW1hdGFub19BbGhhbWlzaV9JanVtYWFfSnVtYW1vc2knLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0pwbF9KdGF0X0pubmVfSnRhbl9BbGhfSWptX0ptb3MnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdKMl9KM19KNF9KNV9BbF9Jal9KMScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbbGVvIHNhYV0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW2tlc2hvIHNhYV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1t3aWtpIGlqYXlvXSBkZGRkIFtzYWF0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbamFuYV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1t3aWtpIGlsaXlvcGl0YV0gZGRkZCBbc2FhdF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyBiYWFkYXllJyxcclxuICAgICAgICBwYXN0IDogJ3Rva2VhICVzJyxcclxuICAgICAgICBzIDogJ2hpdmkgcHVuZGUnLFxyXG4gICAgICAgIG0gOiAnZGFraWthIG1vamEnLFxyXG4gICAgICAgIG1tIDogJ2Rha2lrYSAlZCcsXHJcbiAgICAgICAgaCA6ICdzYWEgbGltb2phJyxcclxuICAgICAgICBoaCA6ICdtYXNhYSAlZCcsXHJcbiAgICAgICAgZCA6ICdzaWt1IG1vamEnLFxyXG4gICAgICAgIGRkIDogJ21hc2lrdSAlZCcsXHJcbiAgICAgICAgTSA6ICdtd2V6aSBtbW9qYScsXHJcbiAgICAgICAgTU0gOiAnbWllemkgJWQnLFxyXG4gICAgICAgIHkgOiAnbXdha2EgbW1vamEnLFxyXG4gICAgICAgIHl5IDogJ21pYWthICVkJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzdztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUYW1pbCBbdGFdXHJcbi8vISBhdXRob3IgOiBBcmp1bmt1bWFyIEtyaXNobmFtb29ydGh5IDogaHR0cHM6Ly9naXRodWIuY29tL3RrMTIwNDA0XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAn4K+nJyxcclxuICAgICcyJzogJ+CvqCcsXHJcbiAgICAnMyc6ICfgr6knLFxyXG4gICAgJzQnOiAn4K+qJyxcclxuICAgICc1JzogJ+CvqycsXHJcbiAgICAnNic6ICfgr6wnLFxyXG4gICAgJzcnOiAn4K+tJyxcclxuICAgICc4JzogJ+CvricsXHJcbiAgICAnOSc6ICfgr68nLFxyXG4gICAgJzAnOiAn4K+mJ1xyXG59O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgJ+Cvpyc6ICcxJyxcclxuICAgICfgr6gnOiAnMicsXHJcbiAgICAn4K+pJzogJzMnLFxyXG4gICAgJ+Cvqic6ICc0JyxcclxuICAgICfgr6snOiAnNScsXHJcbiAgICAn4K+sJzogJzYnLFxyXG4gICAgJ+CvrSc6ICc3JyxcclxuICAgICfgr64nOiAnOCcsXHJcbiAgICAn4K+vJzogJzknLFxyXG4gICAgJ+Cvpic6ICcwJ1xyXG59O1xyXG5cclxudmFyIHRhID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGEnLCB7XHJcbiAgICBtb250aHMgOiAn4K6c4K6p4K614K6w4K6/X+CuquCuv+CuquCvjeCusOCuteCusOCuv1/grq7grr7grrDgr43grprgr41f4K6P4K6q4K+N4K6w4K6y4K+NX+CuruCvh1/grpzgr4Lgrqngr41f4K6c4K+C4K6y4K+IX+CuhuCuleCuuOCvjeCun+CvjV/grprgr4bgrqrgr43grp/gr4bgrq7gr43grqrgrrDgr41f4K6F4K6V4K+N4K6f4K+H4K6+4K6q4K6w4K+NX+CuqOCuteCuruCvjeCuquCusOCvjV/grp/grr/grprgrq7gr43grqrgrrDgr40nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfgrpzgrqngrrXgrrDgrr9f4K6q4K6/4K6q4K+N4K6w4K614K6w4K6/X+CuruCuvuCusOCvjeCumuCvjV/gro/grqrgr43grrDgrrLgr41f4K6u4K+HX+CunOCvguCuqeCvjV/grpzgr4LgrrLgr4hf4K6G4K6V4K644K+N4K6f4K+NX+CumuCvhuCuquCvjeCun+CvhuCuruCvjeCuquCusOCvjV/groXgrpXgr43grp/gr4fgrr7grqrgrrDgr41f4K6o4K614K6u4K+N4K6q4K6w4K+NX+Cun+Cuv+CumuCuruCvjeCuquCusOCvjScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ+CunuCuvuCur+Cuv+CuseCvjeCuseCvgeCuleCvjeCuleCuv+CutOCuruCviF/grqTgrr/grpngr43grpXgrp/gr43grpXgrr/grrTgrq7gr4hf4K6a4K+G4K614K+N4K614K6+4K6v4K+N4K6V4K6/4K604K6u4K+IX+CuquCvgeCupOCuqeCvjeCuleCuv+CutOCuruCviF/grrXgrr/grq/grr7grrTgrpXgr43grpXgrr/grrTgrq7gr4hf4K614K+G4K6z4K+N4K6z4K6/4K6V4K+N4K6V4K6/4K604K6u4K+IX+CumuCuqeCuv+CuleCvjeCuleCuv+CutOCuruCviCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4K6e4K6+4K6v4K6/4K6x4K+BX+CupOCuv+CumeCvjeCuleCus+CvjV/grprgr4bgrrXgr43grrXgrr7grq/gr41f4K6q4K+B4K6k4K6p4K+NX+CuteCuv+Cur+CuvuCutOCuqeCvjV/grrXgr4bgrrPgr43grrPgrr9f4K6a4K6p4K6/Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn4K6e4K6+X+CupOCuv1/grprgr4Zf4K6q4K+BX+CuteCuv1/grrXgr4Zf4K6aJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4K6H4K6p4K+N4K6x4K+BXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4K6o4K6+4K6z4K+IXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+CuqOCvh+CuseCvjeCuseCvgV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgrpXgrp/grqjgr43grqQg4K614K6+4K6w4K6u4K+NXSBkZGRkLCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIOCuh+CusuCvjScsXHJcbiAgICAgICAgcGFzdCA6ICclcyDgrq7gr4Hgrqngr40nLFxyXG4gICAgICAgIHMgOiAn4K6S4K6w4K+BIOCumuCuv+CusiDgrrXgrr/grqjgrr7grp/grr/grpXgrrPgr40nLFxyXG4gICAgICAgIG0gOiAn4K6S4K6w4K+BIOCuqOCuv+CuruCuv+Cun+CuruCvjScsXHJcbiAgICAgICAgbW0gOiAnJWQg4K6o4K6/4K6u4K6/4K6f4K6Z4K+N4K6V4K6z4K+NJyxcclxuICAgICAgICBoIDogJ+CukuCusOCvgSDgrq7grqPgrr8g4K6o4K+H4K6w4K6u4K+NJyxcclxuICAgICAgICBoaCA6ICclZCDgrq7grqPgrr8g4K6o4K+H4K6w4K6u4K+NJyxcclxuICAgICAgICBkIDogJ+CukuCusOCvgSDgrqjgrr7grrPgr40nLFxyXG4gICAgICAgIGRkIDogJyVkIOCuqOCuvuCun+CvjeCuleCus+CvjScsXHJcbiAgICAgICAgTSA6ICfgrpLgrrDgr4Eg4K6u4K6+4K6k4K6u4K+NJyxcclxuICAgICAgICBNTSA6ICclZCDgrq7grr7grqTgrpngr43grpXgrrPgr40nLFxyXG4gICAgICAgIHkgOiAn4K6S4K6w4K+BIOCuteCusOCvgeCun+CuruCvjScsXHJcbiAgICAgICAgeXkgOiAnJWQg4K6G4K6j4K+N4K6f4K+B4K6V4K6z4K+NJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfeCuteCupOCvgS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAn4K614K6k4K+BJztcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Cvp+CvqOCvqeCvquCvq+CvrOCvreCvruCvr+Cvpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gcmVmZXIgaHR0cDovL3RhLndpa2lwZWRpYS5vcmcvcy8xZXIxXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4K6v4K6+4K6u4K6u4K+NfOCuteCviOCuleCuseCviHzgrpXgrr7grrLgr4h84K6o4K6j4K+N4K6q4K6V4K6y4K+NfOCujuCuseCvjeCuquCuvuCun+CvgXzgrq7grr7grrLgr4gvLFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnIOCur+CuvuCuruCuruCvjSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgNikge1xyXG4gICAgICAgICAgICByZXR1cm4gJyDgrrXgr4jgrpXgrrHgr4gnOyAgLy8g4K614K+I4K6V4K6x4K+IXHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcg4K6V4K6+4K6y4K+IJzsgLy8g4K6V4K6+4K6y4K+IXHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcg4K6o4K6j4K+N4K6q4K6V4K6y4K+NJzsgLy8g4K6o4K6j4K+N4K6q4K6V4K6y4K+NXHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcg4K6O4K6x4K+N4K6q4K6+4K6f4K+BJzsgLy8g4K6O4K6x4K+N4K6q4K6+4K6f4K+BXHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcg4K6u4K6+4K6y4K+IJzsgLy8g4K6u4K6+4K6y4K+IXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcg4K6v4K6+4K6u4K6u4K+NJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgrq/grr7grq7grq7gr40nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgMiA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CuteCviOCuleCuseCviCcgfHwgbWVyaWRpZW0gPT09ICfgrpXgrr7grrLgr4gnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgrqjgrqPgr43grqrgrpXgrrLgr40nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdGE7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVGVsdWd1IFt0ZV1cclxuLy8hIGF1dGhvciA6IEtyaXNobmEgQ2hhaXRhbnlhIFRob3RhIDogaHR0cHM6Ly9naXRodWIuY29tL2tjdGhvdGFcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0ZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RlJywge1xyXG4gICAgbW9udGhzIDogJ+CwnOCwqOCwteCwsOCwv1/gsKvgsL/gsKzgsY3gsLDgsLXgsLDgsL9f4LCu4LC+4LCw4LGN4LCa4LC/X+Cwj+CwquCxjeCwsOCwv+CwsuCxjV/gsK7gsYdf4LCc4LGC4LCo4LGNX+CwnOCxguCwsuCxhuCxll/gsIbgsJfgsLjgsY3gsJ/gsYFf4LC44LGG4LCq4LGN4LCf4LGG4LCC4LCs4LCw4LGNX+CwheCwleCxjeCwn+Cxi+CwrOCwsOCxjV/gsKjgsLXgsILgsKzgsLDgsY1f4LCh4LC/4LC44LGG4LCC4LCs4LCw4LGNJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4LCc4LCoLl/gsKvgsL/gsKzgsY3gsLAuX+CwruCwvuCwsOCxjeCwmuCwv1/gsI/gsKrgsY3gsLDgsL8uX+CwruCxh1/gsJzgsYLgsKjgsY1f4LCc4LGC4LCy4LGG4LGWX+CwhuCwly5f4LC44LGG4LCq4LGNLl/gsIXgsJXgsY3gsJ/gsYsuX+CwqOCwtS5f4LCh4LC/4LC44LGGLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAn4LCG4LCm4LC/4LC14LC+4LCw4LCCX+CwuOCxi+CwruCwteCwvuCwsOCwgl/gsK7gsILgsJfgsLPgsLXgsL7gsLDgsIJf4LCs4LGB4LCn4LC14LC+4LCw4LCCX+Cwl+CxgeCwsOCxgeCwteCwvuCwsOCwgl/gsLbgsYHgsJXgsY3gsLDgsLXgsL7gsLDgsIJf4LC24LCo4LC/4LC14LC+4LCw4LCCJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgsIbgsKbgsL9f4LC44LGL4LCuX+CwruCwguCwl+Cws1/gsKzgsYHgsKdf4LCX4LGB4LCw4LGBX+CwtuCxgeCwleCxjeCwsF/gsLbgsKjgsL8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgsIZf4LC44LGLX+CwruCwgl/gsKzgsYFf4LCX4LGBX+CwtuCxgV/gsLYnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdBIGg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4LCo4LGH4LCh4LGBXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4LCw4LGH4LCq4LGBXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+CwqOCwv+CwqOCxjeCwqF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgsJfgsKRdIGRkZGQsIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg4LCy4LGLJyxcclxuICAgICAgICBwYXN0IDogJyVzIOCwleCxjeCwsOCwv+CwpOCwgicsXHJcbiAgICAgICAgcyA6ICfgsJXgsYrgsKjgsY3gsKjgsL8g4LCV4LGN4LC34LCj4LC+4LCy4LGBJyxcclxuICAgICAgICBtIDogJ+CwkuCwlSDgsKjgsL/gsK7gsL/gsLfgsIInLFxyXG4gICAgICAgIG1tIDogJyVkIOCwqOCwv+CwruCwv+Cwt+CwvuCwsuCxgScsXHJcbiAgICAgICAgaCA6ICfgsJLgsJUg4LCX4LCC4LCfJyxcclxuICAgICAgICBoaCA6ICclZCDgsJfgsILgsJ/gsLLgsYEnLFxyXG4gICAgICAgIGQgOiAn4LCS4LCVIOCwsOCxi+CwnOCxgScsXHJcbiAgICAgICAgZGQgOiAnJWQg4LCw4LGL4LCc4LGB4LCy4LGBJyxcclxuICAgICAgICBNIDogJ+CwkuCwlSDgsKjgsYbgsLInLFxyXG4gICAgICAgIE1NIDogJyVkIOCwqOCxhuCwsuCwsuCxgScsXHJcbiAgICAgICAgeSA6ICfgsJLgsJUg4LC44LCC4LC14LCk4LGN4LC44LCw4LCCJyxcclxuICAgICAgICB5eSA6ICclZCDgsLjgsILgsLXgsKTgsY3gsLjgsLDgsL7gsLLgsYEnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfeCwtS8sXHJcbiAgICBvcmRpbmFsIDogJyVk4LC1JyxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gsLDgsL7gsKTgsY3gsLDgsL984LCJ4LCm4LCv4LCCfOCwruCwp+CxjeCwr+CwvuCwueCxjeCwqOCwgnzgsLjgsL7gsK/gsILgsKTgsY3gsLDgsIIvLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgsLDgsL7gsKTgsY3gsLDgsL8nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CwieCwpuCwr+CwgicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CwruCwp+CxjeCwr+CwvuCwueCxjeCwqOCwgicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgsLjgsL7gsK/gsILgsKTgsY3gsLDgsIInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CwsOCwvuCwpOCxjeCwsOCwvyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgsIngsKbgsK/gsIInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LCu4LCn4LGN4LCv4LC+4LC54LGN4LCo4LCCJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CwuOCwvuCwr+CwguCwpOCxjeCwsOCwgic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgsLDgsL7gsKTgsY3gsLDgsL8nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdGU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVGV0dW4gRGlsaSAoRWFzdCBUaW1vcikgW3RldF1cclxuLy8hIGF1dGhvciA6IEpvc2h1YSBCcm9va3MgOiBodHRwczovL2dpdGh1Yi5jb20vam9zaGJyb29rc1xyXG4vLyEgYXV0aG9yIDogT25vcmlvIERlIEouIEFmb25zbyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJvYm9cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0ZXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0ZXQnLCB7XHJcbiAgICBtb250aHMgOiAnSmFuZWlydV9GZXZlcmVpcnVfTWFyc3VfQWJyaWxfTWFpdV9KdW5pdV9KdWxpdV9BdWd1c3R1X1NldGVtYnJ1X091dHVicnVfTm92ZW1icnVfRGV6ZW1icnUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmV2X01hcl9BYnJfTWFpX0p1bl9KdWxfQXVnX1NldF9PdXRfTm92X0Rleicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ0RvbWluZ3VfU2VndW5kYV9UZXJzYV9LdWFydGFfS2ludGFfU2V4dGFfU2FiYWR1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdEb21fU2VnX1RlcnNfS3VhX0tpbnRfU2V4dF9TYWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdEb19TZWdfVGVfS3VfS2lfU2V4X1NhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbT2hpbiBpaGFdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW0FiYW4gaWhhXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtpaGFdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW0hvcmlzZWlrIGloYV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbc2VtYW5hIGtvdHVrXSBbaWhhXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnaWhhICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGxpdWJhJyxcclxuICAgICAgICBzIDogJ21pbnV0dSBiYWx1bicsXHJcbiAgICAgICAgbSA6ICdtaW51dHUgaWRhJyxcclxuICAgICAgICBtbSA6ICdtaW51dHVzICVkJyxcclxuICAgICAgICBoIDogJ2hvcmFzIGlkYScsXHJcbiAgICAgICAgaGggOiAnaG9yYXMgJWQnLFxyXG4gICAgICAgIGQgOiAnbG9yb24gaWRhJyxcclxuICAgICAgICBkZCA6ICdsb3JvbiAlZCcsXHJcbiAgICAgICAgTSA6ICdmdWxhbiBpZGEnLFxyXG4gICAgICAgIE1NIDogJ2Z1bGFuICVkJyxcclxuICAgICAgICB5IDogJ3RpbmFuIGlkYScsXHJcbiAgICAgICAgeXkgOiAndGluYW4gJWQnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0fG5kfHJkfHRoKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XHJcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcclxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdGV0O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGV0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVGhhaSBbdGhdXHJcbi8vISBhdXRob3IgOiBLcmlkc2FkYSBUaGFuYWJ1bHBvbmcgOiBodHRwczovL2dpdGh1Yi5jb20vc2lyblxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHRoID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGgnLCB7XHJcbiAgICBtb250aHMgOiAn4Lih4LiB4Lij4Liy4LiE4LihX+C4geC4uOC4oeC4oOC4suC4nuC4seC4meC4mOC5jF/guKHguLXguJnguLLguITguKFf4LmA4Lih4Lip4Liy4Lii4LiZX+C4nuC4pOC4qeC4oOC4suC4hOC4oV/guKHguLTguJbguLjguJnguLLguKLguJlf4LiB4Lij4LiB4LiO4Liy4LiE4LihX+C4quC4tOC4h+C4q+C4suC4hOC4oV/guIHguLHguJnguKLguLLguKLguJlf4LiV4Li44Lil4Liy4LiE4LihX+C4nuC4pOC4qOC4iOC4tOC4geC4suC4ouC4mV/guJjguLHguJnguKfguLLguITguKEnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfguKEu4LiELl/guIEu4LieLl/guKHguLUu4LiELl/guYDguKEu4LiiLl/guJ4u4LiELl/guKHguLQu4LiiLl/guIEu4LiELl/guKou4LiELl/guIEu4LiiLl/guJUu4LiELl/guJ4u4LiiLl/guJgu4LiELicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICfguK3guLLguJfguLTguJXguKLguYxf4LiI4Lix4LiZ4LiX4Lij4LmMX+C4reC4seC4h+C4hOC4suC4o1/guJ7guLjguJhf4Lie4Lik4Lir4Lix4Liq4Lia4LiU4Li1X+C4qOC4uOC4geC4o+C5jF/guYDguKrguLLguKPguYwnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+C4reC4suC4l+C4tOC4leC4ouC5jF/guIjguLHguJnguJfguKPguYxf4Lit4Lix4LiH4LiE4Liy4LijX+C4nuC4uOC4mF/guJ7guKTguKvguLHguKpf4Lio4Li44LiB4Lij4LmMX+C5gOC4quC4suC4o+C5jCcuc3BsaXQoJ18nKSwgLy8geWVzLCB0aHJlZSBjaGFyYWN0ZXJzIGRpZmZlcmVuY2VcclxuICAgIHdlZWtkYXlzTWluIDogJ+C4reC4si5f4LiILl/guK0uX+C4ni5f4Lie4LikLl/guKguX+C4qi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSDguYDguKfguKXguLIgSDptbScsXHJcbiAgICAgICAgTExMTCA6ICfguKfguLHguJlkZGRk4LiX4Li14LmIIEQgTU1NTSBZWVlZIOC5gOC4p+C4peC4siBIOm1tJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/guIHguYjguK3guJnguYDguJfguLXguYjguKLguId84Lir4Lil4Lix4LiH4LmA4LiX4Li14LmI4Lii4LiHLyxcclxuICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gJ+C4q+C4peC4seC4h+C5gOC4l+C4teC5iOC4ouC4hyc7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C4geC5iOC4reC4meC5gOC4l+C4teC5iOC4ouC4hyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfguKvguKXguLHguIfguYDguJfguLXguYjguKLguIcnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vguKfguLHguJnguJnguLXguYkg4LmA4Lin4Lil4LiyXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4Lie4Lij4Li44LmI4LiH4LiZ4Li14LmJIOC5gOC4p+C4peC4sl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGRb4Lir4LiZ4LmJ4LiyIOC5gOC4p+C4peC4sl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+C5gOC4oeC4t+C5iOC4reC4p+C4suC4meC4meC4teC5iSDguYDguKfguKXguLJdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4Lin4Lix4LiZXWRkZGRb4LiX4Li14LmI4LmB4Lil4LmJ4LinIOC5gOC4p+C4peC4sl0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfguK3guLXguIEgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXPguJfguLXguYjguYHguKXguYnguKcnLFxyXG4gICAgICAgIHMgOiAn4LmE4Lih4LmI4LiB4Li14LmI4Lin4Li04LiZ4Liy4LiX4Li1JyxcclxuICAgICAgICBtIDogJzEg4LiZ4Liy4LiX4Li1JyxcclxuICAgICAgICBtbSA6ICclZCDguJnguLLguJfguLUnLFxyXG4gICAgICAgIGggOiAnMSDguIrguLHguYjguKfguYLguKHguIcnLFxyXG4gICAgICAgIGhoIDogJyVkIOC4iuC4seC5iOC4p+C5guC4oeC4hycsXHJcbiAgICAgICAgZCA6ICcxIOC4p+C4seC4mScsXHJcbiAgICAgICAgZGQgOiAnJWQg4Lin4Lix4LiZJyxcclxuICAgICAgICBNIDogJzEg4LmA4LiU4Li34Lit4LiZJyxcclxuICAgICAgICBNTSA6ICclZCDguYDguJTguLfguK3guJknLFxyXG4gICAgICAgIHkgOiAnMSDguJvguLUnLFxyXG4gICAgICAgIHl5IDogJyVkIOC4m+C4tSdcclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdGg7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVGFnYWxvZyAoUGhpbGlwcGluZXMpIFt0bC1waF1cclxuLy8hIGF1dGhvciA6IERhbiBIYWdtYW4gOiBodHRwczovL2dpdGh1Yi5jb20vaGFnbWFuZGFuXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdGxQaCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RsLXBoJywge1xyXG4gICAgbW9udGhzIDogJ0VuZXJvX1BlYnJlcm9fTWFyc29fQWJyaWxfTWF5b19IdW55b19IdWx5b19BZ29zdG9fU2V0eWVtYnJlX09rdHVicmVfTm9ieWVtYnJlX0Rpc3llbWJyZScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0VuZV9QZWJfTWFyX0Ficl9NYXlfSHVuX0h1bF9BZ29fU2V0X09rdF9Ob2JfRGlzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnTGluZ2dvX0x1bmVzX01hcnRlc19NaXllcmt1bGVzX0h1d2ViZXNfQml5ZXJuZXNfU2FiYWRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdMaW5fTHVuX01hcl9NaXlfSHV3X0JpeV9TYWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdMaV9MdV9NYV9NaV9IdV9CaV9TYWInLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ01NL0QvWVlZWScsXHJcbiAgICAgICAgTEwgOiAnTU1NTSBELCBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnTU1NTSBELCBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gREQsIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ0xUIFtuZ2F5b25nIGFyYXddJyxcclxuICAgICAgICBuZXh0RGF5OiAnW0J1a2FzIG5nXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdMVCBbc2Egc3VzdW5vZCBuYV0gZGRkZCcsXHJcbiAgICAgICAgbGFzdERheTogJ0xUIFtrYWhhcG9uXScsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdMVCBbbm9vbmcgbmFrYXJhYW5nXSBkZGRkJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdzYSBsb29iIG5nICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGFuZyBuYWthbGlwYXMnLFxyXG4gICAgICAgIHMgOiAnaWxhbmcgc2VndW5kbycsXHJcbiAgICAgICAgbSA6ICdpc2FuZyBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0bycsXHJcbiAgICAgICAgaCA6ICdpc2FuZyBvcmFzJyxcclxuICAgICAgICBoaCA6ICclZCBvcmFzJyxcclxuICAgICAgICBkIDogJ2lzYW5nIGFyYXcnLFxyXG4gICAgICAgIGRkIDogJyVkIGFyYXcnLFxyXG4gICAgICAgIE0gOiAnaXNhbmcgYnV3YW4nLFxyXG4gICAgICAgIE1NIDogJyVkIGJ1d2FuJyxcclxuICAgICAgICB5IDogJ2lzYW5nIHRhb24nLFxyXG4gICAgICAgIHl5IDogJyVkIHRhb24nXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdGxQaDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGwtcGguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGwtcGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBLbGluZ29uIFt0bGhdXHJcbi8vISBhdXRob3IgOiBEb21pbmlrYSBLcnVrIDogaHR0cHM6Ly9naXRodWIuY29tL2FtYXJhbnRocm9zZVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG51bWJlcnNOb3VucyA9ICdwYWdoX3dh4oCZX2NoYeKAmV93ZWpfbG9TX3ZhZ2hfamF2X1NvY2hfY2hvcmdoX0h1dCcuc3BsaXQoJ18nKTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZUZ1dHVyZShvdXRwdXQpIHtcclxuICAgIHZhciB0aW1lID0gb3V0cHV0O1xyXG4gICAgdGltZSA9IChvdXRwdXQuaW5kZXhPZignamFqJykgIT09IC0xKSA/XHJcbiAgICB0aW1lLnNsaWNlKDAsIC0zKSArICdsZVMnIDpcclxuICAgIChvdXRwdXQuaW5kZXhPZignamFyJykgIT09IC0xKSA/XHJcbiAgICB0aW1lLnNsaWNlKDAsIC0zKSArICd3YVEnIDpcclxuICAgIChvdXRwdXQuaW5kZXhPZignRElTJykgIT09IC0xKSA/XHJcbiAgICB0aW1lLnNsaWNlKDAsIC0zKSArICduZW0nIDpcclxuICAgIHRpbWUgKyAnIHBJcSc7XHJcbiAgICByZXR1cm4gdGltZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNsYXRlUGFzdChvdXRwdXQpIHtcclxuICAgIHZhciB0aW1lID0gb3V0cHV0O1xyXG4gICAgdGltZSA9IChvdXRwdXQuaW5kZXhPZignamFqJykgIT09IC0xKSA/XHJcbiAgICB0aW1lLnNsaWNlKDAsIC0zKSArICdIdeKAmScgOlxyXG4gICAgKG91dHB1dC5pbmRleE9mKCdqYXInKSAhPT0gLTEpID9cclxuICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ3dlbicgOlxyXG4gICAgKG91dHB1dC5pbmRleE9mKCdESVMnKSAhPT0gLTEpID9cclxuICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ2JlbicgOlxyXG4gICAgdGltZSArICcgcmV0JztcclxuICAgIHJldHVybiB0aW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgbnVtYmVyTm91biA9IG51bWJlckFzTm91bihudW1iZXIpO1xyXG4gICAgc3dpdGNoIChzdHJpbmcpIHtcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJOb3VuICsgJyB0dXAnO1xyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIHJlcCc7XHJcbiAgICAgICAgY2FzZSAnZGQnOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTm91biArICcgamFqJztcclxuICAgICAgICBjYXNlICdNTSc6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJOb3VuICsgJyBqYXInO1xyXG4gICAgICAgIGNhc2UgJ3l5JzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIERJUyc7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51bWJlckFzTm91bihudW1iZXIpIHtcclxuICAgIHZhciBodW5kcmVkID0gTWF0aC5mbG9vcigobnVtYmVyICUgMTAwMCkgLyAxMDApLFxyXG4gICAgdGVuID0gTWF0aC5mbG9vcigobnVtYmVyICUgMTAwKSAvIDEwKSxcclxuICAgIG9uZSA9IG51bWJlciAlIDEwLFxyXG4gICAgd29yZCA9ICcnO1xyXG4gICAgaWYgKGh1bmRyZWQgPiAwKSB7XHJcbiAgICAgICAgd29yZCArPSBudW1iZXJzTm91bnNbaHVuZHJlZF0gKyAndmF0bGgnO1xyXG4gICAgfVxyXG4gICAgaWYgKHRlbiA+IDApIHtcclxuICAgICAgICB3b3JkICs9ICgod29yZCAhPT0gJycpID8gJyAnIDogJycpICsgbnVtYmVyc05vdW5zW3Rlbl0gKyAnbWFIJztcclxuICAgIH1cclxuICAgIGlmIChvbmUgPiAwKSB7XHJcbiAgICAgICAgd29yZCArPSAoKHdvcmQgIT09ICcnKSA/ICcgJyA6ICcnKSArIG51bWJlcnNOb3Vuc1tvbmVdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICh3b3JkID09PSAnJykgPyAncGFnaCcgOiB3b3JkO1xyXG59XHJcblxyXG52YXIgdGxoID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGxoJywge1xyXG4gICAgbW9udGhzIDogJ3RlcmHigJkgamFyIHdh4oCZX3RlcmHigJkgamFyIGNoYeKAmV90ZXJh4oCZIGphciB3ZWpfdGVyYeKAmSBqYXIgbG9TX3RlcmHigJkgamFyIHZhZ2hfdGVyYeKAmSBqYXIgamF2X3RlcmHigJkgamFyIFNvY2hfdGVyYeKAmSBqYXIgY2hvcmdoX3RlcmHigJkgamFyIEh1dF90ZXJh4oCZIGphciB3YeKAmW1hSF90ZXJh4oCZIGphciB3YeKAmW1hSCB3YeKAmV90ZXJh4oCZIGphciB3YeKAmW1hSCBjaGHigJknLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYXIgd2HigJlfamFyIGNoYeKAmV9qYXIgd2VqX2phciBsb1NfamFyIHZhZ2hfamFyIGphdl9qYXIgU29jaF9qYXIgY2hvcmdoX2phciBIdXRfamFyIHdh4oCZbWFIX2phciB3YeKAmW1hSCB3YeKAmV9qYXIgd2HigJltYUggY2hh4oCZJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdsb2ptSXRqYWpfRGFTamFqX3Bvdmphal9naEl0bGhqYWpfbG9naGphal9idXFqYWpfZ2hJbmphaicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbG9qbUl0amFqX0RhU2phal9wb3ZqYWpfZ2hJdGxoamFqX2xvZ2hqYWpfYnVxamFqX2doSW5qYWonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdsb2ptSXRqYWpfRGFTamFqX3Bvdmphal9naEl0bGhqYWpfbG9naGphal9idXFqYWpfZ2hJbmphaicuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0RhSGphal0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbd2HigJlsZVNdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ0xMTCcsXHJcbiAgICAgICAgbGFzdERheTogJ1t3YeKAmUh14oCZXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdMTEwnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogdHJhbnNsYXRlRnV0dXJlLFxyXG4gICAgICAgIHBhc3QgOiB0cmFuc2xhdGVQYXN0LFxyXG4gICAgICAgIHMgOiAncHVTIGx1cCcsXHJcbiAgICAgICAgbSA6ICd3YeKAmSB0dXAnLFxyXG4gICAgICAgIG1tIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGggOiAnd2HigJkgcmVwJyxcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogJ3dh4oCZIGphaicsXHJcbiAgICAgICAgZGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSA6ICd3YeKAmSBqYXInLFxyXG4gICAgICAgIE1NIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgOiAnd2HigJkgRElTJyxcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdGxoO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bGguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGxoLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVHVya2lzaCBbdHJdXHJcbi8vISBhdXRob3JzIDogRXJoYW4gR3VuZG9nYW4gOiBodHRwczovL2dpdGh1Yi5jb20vZXJoYW5ndW5kb2dhbixcclxuLy8hICAgICAgICAgICBCdXJhayBZacSfaXQgS2F5YTogaHR0cHM6Ly9naXRodWIuY29tL0JZS1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN1ZmZpeGVzID0ge1xyXG4gICAgMTogJ1xcJ2luY2knLFxyXG4gICAgNTogJ1xcJ2luY2knLFxyXG4gICAgODogJ1xcJ2luY2knLFxyXG4gICAgNzA6ICdcXCdpbmNpJyxcclxuICAgIDgwOiAnXFwnaW5jaScsXHJcbiAgICAyOiAnXFwnbmNpJyxcclxuICAgIDc6ICdcXCduY2knLFxyXG4gICAgMjA6ICdcXCduY2knLFxyXG4gICAgNTA6ICdcXCduY2knLFxyXG4gICAgMzogJ1xcJ8O8bmPDvCcsXHJcbiAgICA0OiAnXFwnw7xuY8O8JyxcclxuICAgIDEwMDogJ1xcJ8O8bmPDvCcsXHJcbiAgICA2OiAnXFwnbmPEsScsXHJcbiAgICA5OiAnXFwndW5jdScsXHJcbiAgICAxMDogJ1xcJ3VuY3UnLFxyXG4gICAgMzA6ICdcXCd1bmN1JyxcclxuICAgIDYwOiAnXFwnxLFuY8SxJyxcclxuICAgIDkwOiAnXFwnxLFuY8SxJ1xyXG59O1xyXG5cclxudmFyIHRyID0gbW9tZW50LmRlZmluZUxvY2FsZSgndHInLCB7XHJcbiAgICBtb250aHMgOiAnT2Nha1/FnnViYXRfTWFydF9OaXNhbl9NYXnEsXNfSGF6aXJhbl9UZW1tdXpfQcSfdXN0b3NfRXlsw7xsX0VraW1fS2FzxLFtX0FyYWzEsWsnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdPY2FfxZ51Yl9NYXJfTmlzX01heV9IYXpfVGVtX0HEn3VfRXlsX0VraV9LYXNfQXJhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnUGF6YXJfUGF6YXJ0ZXNpX1NhbMSxX8OHYXLFn2FtYmFfUGVyxZ9lbWJlX0N1bWFfQ3VtYXJ0ZXNpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdQYXpfUHRzX1NhbF/Dh2FyX1Blcl9DdW1fQ3RzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnUHpfUHRfU2Ffw4dhX1BlX0N1X0N0Jy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW2J1Z8O8biBzYWF0XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbeWFyxLFuIHNhYXRdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdbZ2VsZWNla10gZGRkZCBbc2FhdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW2TDvG5dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbZ2XDp2VuXSBkZGRkIFtzYWF0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIHNvbnJhJyxcclxuICAgICAgICBwYXN0IDogJyVzIMO2bmNlJyxcclxuICAgICAgICBzIDogJ2Jpcmthw6cgc2FuaXllJyxcclxuICAgICAgICBtIDogJ2JpciBkYWtpa2EnLFxyXG4gICAgICAgIG1tIDogJyVkIGRha2lrYScsXHJcbiAgICAgICAgaCA6ICdiaXIgc2FhdCcsXHJcbiAgICAgICAgaGggOiAnJWQgc2FhdCcsXHJcbiAgICAgICAgZCA6ICdiaXIgZ8O8bicsXHJcbiAgICAgICAgZGQgOiAnJWQgZ8O8bicsXHJcbiAgICAgICAgTSA6ICdiaXIgYXknLFxyXG4gICAgICAgIE1NIDogJyVkIGF5JyxcclxuICAgICAgICB5IDogJ2JpciB5xLFsJyxcclxuICAgICAgICB5eSA6ICclZCB5xLFsJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfScoaW5jaXxuY2l8w7xuY8O8fG5jxLF8dW5jdXzEsW5jxLEpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKG51bWJlciA9PT0gMCkgeyAgLy8gc3BlY2lhbCBjYXNlIGZvciB6ZXJvXHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnXFwnxLFuY8SxJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgYiA9IG51bWJlciAlIDEwMCAtIGEsXHJcbiAgICAgICAgICAgIGMgPSBudW1iZXIgPj0gMTAwID8gMTAwIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgKHN1ZmZpeGVzW2FdIHx8IHN1ZmZpeGVzW2JdIHx8IHN1ZmZpeGVzW2NdKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdHI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVGFsb3NzYW4gW3R6bF1cclxuLy8hIGF1dGhvciA6IFJvYmluIHZhbiBkZXIgVmxpZXQgOiBodHRwczovL2dpdGh1Yi5jb20vcm9iaW4wdmFuMGRlcjB2XHJcbi8vISBhdXRob3IgOiBJdXN0w6wgQ2FudW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbi8vIEFmdGVyIHRoZSB5ZWFyIHRoZXJlIHNob3VsZCBiZSBhIHNsYXNoIGFuZCB0aGUgYW1vdW50IG9mIHllYXJzIHNpbmNlIERlY2VtYmVyIDI2LCAxOTc5IGluIFJvbWFuIG51bWVyYWxzLlxyXG4vLyBUaGlzIGlzIGN1cnJlbnRseSB0b28gZGlmZmljdWx0IChtYXliZSBldmVuIGltcG9zc2libGUpIHRvIGFkZC5cclxudmFyIHR6bCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3R6bCcsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJfRmV2cmFnbGhfTWFyw6dfQXZyw691X01haV9Hw7xuX0p1bGlhX0d1c2NodF9TZXRlbXZhcl9MaXN0b3DDpHRzX05vZW12YXJfWmVjZW12YXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmV2X01hcl9BdnJfTWFpX0fDvG5fSnVsX0d1c19TZXRfTGlzX05vZV9aZWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdTw7psYWRpX0zDum5lw6dpX01haXR6aV9Nw6FyY3VyaV9YaMO6YWRpX1Zpw6luZXLDp2lfU8OhdHVyaScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU8O6bF9Mw7puX01haV9Nw6FyX1how7pfVmnDqV9Tw6F0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU8O6X0zDul9NYV9Nw6FfWGhfVmlfU8OhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEgubW0nLFxyXG4gICAgICAgIExUUyA6ICdISC5tbS5zcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFtkYWxsYXNdIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFtkYWxsYXNdIFlZWVkgSEgubW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgW2xpXSBELiBNTU1NIFtkYWxsYXNdIFlZWVkgSEgubW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL2RcXCdvfGRcXCdhL2ksXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICdkXFwnbycgPT09IGlucHV0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdkXFwnbycgOiAnRFxcJ08nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2RcXCdhJyA6ICdEXFwnQSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW294aGkgw6BdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tkZW3DoCDDoF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW8OgXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbaWVpcmkgw6BdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbc8O8ciBlbF0gZGRkZCBbbGFzdGV1IMOgXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ29zcHJlaSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdqYSVzJyxcclxuICAgICAgICBzIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGRkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdzJzogWyd2aWVuc2FzIHNlY3VuZHMnLCAnXFwnaWVuc2FzIHNlY3VuZHMnXSxcclxuICAgICAgICAnbSc6IFsnXFwnbiBtw611dCcsICdcXCdpZW5zIG3DrXV0J10sXHJcbiAgICAgICAgJ21tJzogW251bWJlciArICcgbcOtdXRzJywgJycgKyBudW1iZXIgKyAnIG3DrXV0cyddLFxyXG4gICAgICAgICdoJzogWydcXCduIMO+b3JhJywgJ1xcJ2llbnNhIMO+b3JhJ10sXHJcbiAgICAgICAgJ2hoJzogW251bWJlciArICcgw75vcmFzJywgJycgKyBudW1iZXIgKyAnIMO+b3JhcyddLFxyXG4gICAgICAgICdkJzogWydcXCduIHppdWEnLCAnXFwnaWVuc2Egeml1YSddLFxyXG4gICAgICAgICdkZCc6IFtudW1iZXIgKyAnIHppdWFzJywgJycgKyBudW1iZXIgKyAnIHppdWFzJ10sXHJcbiAgICAgICAgJ00nOiBbJ1xcJ24gbWVzJywgJ1xcJ2llbnMgbWVzJ10sXHJcbiAgICAgICAgJ01NJzogW251bWJlciArICcgbWVzZW4nLCAnJyArIG51bWJlciArICcgbWVzZW4nXSxcclxuICAgICAgICAneSc6IFsnXFwnbiBhcicsICdcXCdpZW5zIGFyJ10sXHJcbiAgICAgICAgJ3l5JzogW251bWJlciArICcgYXJzJywgJycgKyBudW1iZXIgKyAnIGFycyddXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGlzRnV0dXJlID8gZm9ybWF0W2tleV1bMF0gOiAod2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV0pO1xyXG59XHJcblxyXG5yZXR1cm4gdHpsO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHpsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ2VudHJhbCBBdGxhcyBUYW1hemlnaHQgTGF0aW4gW3R6bS1sYXRuXVxyXG4vLyEgYXV0aG9yIDogQWJkZWwgU2FpZCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hYmRlbHNhaWRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0em1MYXRuID0gbW9tZW50LmRlZmluZUxvY2FsZSgndHptLWxhdG4nLCB7XHJcbiAgICBtb250aHMgOiAnaW5uYXlyX2Jyy6RheXLLpF9tYXLLpHPLpF9pYnJpcl9tYXl5d195d255d195d2x5d3pfyaN3xaF0X8Whd3RhbmJpcl9rdMukd2Jyy6Rfbnd3YW5iaXJfZHdqbmJpcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2lubmF5cl9icsukYXlyy6RfbWFyy6Rzy6RfaWJyaXJfbWF5eXdfeXdueXdfeXdseXd6X8mjd8WhdF/FoXd0YW5iaXJfa3TLpHdicsukX253d2FuYmlyX2R3am5iaXInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdhc2FtYXNfYXluYXNfYXNpbmFzX2FrcmFzX2Frd2FzX2FzaW13YXNfYXNp4biNeWFzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdhc2FtYXNfYXluYXNfYXNpbmFzX2FrcmFzX2Frd2FzX2FzaW13YXNfYXNp4biNeWFzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnYXNhbWFzX2F5bmFzX2FzaW5hc19ha3Jhc19ha3dhc19hc2ltd2FzX2FzaeG4jXlhcycuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbYXNka2ggZ10gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbYXNrYSBnXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtnXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1thc3NhbnQgZ10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbZ10gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhZGtoIHMgeWFuICVzJyxcclxuICAgICAgICBwYXN0IDogJ3lhbiAlcycsXHJcbiAgICAgICAgcyA6ICdpbWlrJyxcclxuICAgICAgICBtIDogJ21pbnXhuI0nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnXhuI0nLFxyXG4gICAgICAgIGggOiAnc2HJm2EnLFxyXG4gICAgICAgIGhoIDogJyVkIHRhc3NhyZtpbicsXHJcbiAgICAgICAgZCA6ICdhc3MnLFxyXG4gICAgICAgIGRkIDogJyVkIG9zc2FuJyxcclxuICAgICAgICBNIDogJ2F5b3dyJyxcclxuICAgICAgICBNTSA6ICclZCBpeXlpcm4nLFxyXG4gICAgICAgIHkgOiAnYXNnYXMnLFxyXG4gICAgICAgIHl5IDogJyVkIGlzZ2FzbidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdHptTGF0bjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLWxhdG4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLWxhdG4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBDZW50cmFsIEF0bGFzIFRhbWF6aWdodCBbdHptXVxyXG4vLyEgYXV0aG9yIDogQWJkZWwgU2FpZCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hYmRlbHNhaWRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0em0gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0em0nLCB7XHJcbiAgICBtb250aHMgOiAn4rWJ4rWP4rWP4rSw4rWi4rWUX+K0seK1leK0sOK1ouK1lV/itY7itLDitZXitZpf4rWJ4rSx4rWU4rWJ4rWUX+K1juK0sOK1ouK1ouK1k1/itaLitZPitY/itaLitZNf4rWi4rWT4rWN4rWi4rWT4rWjX+K1luK1k+K1m+K1nF/itZvitZPitZzitLDitY/itLHitYnitZRf4rS94rWf4rWT4rSx4rWVX+K1j+K1k+K1oeK0sOK1j+K0seK1ieK1lF/itLfitZPitYritY/itLHitYnitZQnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfitYnitY/itY/itLDitaLitZRf4rSx4rWV4rSw4rWi4rWVX+K1juK0sOK1leK1ml/itYnitLHitZTitYnitZRf4rWO4rSw4rWi4rWi4rWTX+K1ouK1k+K1j+K1ouK1k1/itaLitZPitY3itaLitZPitaNf4rWW4rWT4rWb4rWcX+K1m+K1k+K1nOK0sOK1j+K0seK1ieK1lF/itL3itZ/itZPitLHitZVf4rWP4rWT4rWh4rSw4rWP4rSx4rWJ4rWUX+K0t+K1k+K1iuK1j+K0seK1ieK1lCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ+K0sOK1meK0sOK1juK0sOK1mV/itLDitaLitY/itLDitZlf4rSw4rWZ4rWJ4rWP4rSw4rWZX+K0sOK0veK1lOK0sOK1mV/itLDitL3itaHitLDitZlf4rSw4rWZ4rWJ4rWO4rWh4rSw4rWZX+K0sOK1meK1ieK0ueK1ouK0sOK1mScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4rSw4rWZ4rSw4rWO4rSw4rWZX+K0sOK1ouK1j+K0sOK1mV/itLDitZnitYnitY/itLDitZlf4rSw4rS94rWU4rSw4rWZX+K0sOK0veK1oeK0sOK1mV/itLDitZnitYnitY7itaHitLDitZlf4rSw4rWZ4rWJ4rS54rWi4rSw4rWZJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn4rSw4rWZ4rSw4rWO4rSw4rWZX+K0sOK1ouK1j+K0sOK1mV/itLDitZnitYnitY/itLDitZlf4rSw4rS94rWU4rSw4rWZX+K0sOK0veK1oeK0sOK1mV/itLDitZnitYnitY7itaHitLDitZlf4rSw4rWZ4rWJ4rS54rWi4rSw4rWZJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUzogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW+K0sOK1meK0t+K1hSDitLRdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW+K0sOK1meK0veK0sCDitLRdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW+K0tF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb4rSw4rWa4rSw4rWP4rWcIOK0tF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb4rS0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn4rS34rSw4rS34rWFIOK1mSDitaLitLDitY8gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAn4rWi4rSw4rWPICVzJyxcclxuICAgICAgICBzIDogJ+K1ieK1juK1ieK0vScsXHJcbiAgICAgICAgbSA6ICfitY7itYnitY/itZPitLonLFxyXG4gICAgICAgIG1tIDogJyVkIOK1juK1ieK1j+K1k+K0uicsXHJcbiAgICAgICAgaCA6ICfitZnitLDitYTitLAnLFxyXG4gICAgICAgIGhoIDogJyVkIOK1nOK0sOK1meK1meK0sOK1hOK1ieK1jycsXHJcbiAgICAgICAgZCA6ICfitLDitZnitZknLFxyXG4gICAgICAgIGRkIDogJyVkIG/itZnitZnitLDitY8nLFxyXG4gICAgICAgIE0gOiAn4rSw4rWib+K1k+K1lCcsXHJcbiAgICAgICAgTU0gOiAnJWQg4rWJ4rWi4rWi4rWJ4rWU4rWPJyxcclxuICAgICAgICB5IDogJ+K0sOK1meK0s+K0sOK1mScsXHJcbiAgICAgICAgeXkgOiAnJWQg4rWJ4rWZ4rSz4rSw4rWZ4rWPJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0em07XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBVa3JhaW5pYW4gW3VrXVxyXG4vLyEgYXV0aG9yIDogemVtbGFuaW4gOiBodHRwczovL2dpdGh1Yi5jb20vemVtbGFuaW5cclxuLy8hIEF1dGhvciA6IE1lbmVsaW9uIEVsZW5zw7psZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9PaXJlXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBwbHVyYWwod29yZCwgbnVtKSB7XHJcbiAgICB2YXIgZm9ybXMgPSB3b3JkLnNwbGl0KCdfJyk7XHJcbiAgICByZXR1cm4gbnVtICUgMTAgPT09IDEgJiYgbnVtICUgMTAwICE9PSAxMSA/IGZvcm1zWzBdIDogKG51bSAlIDEwID49IDIgJiYgbnVtICUgMTAgPD0gNCAmJiAobnVtICUgMTAwIDwgMTAgfHwgbnVtICUgMTAwID49IDIwKSA/IGZvcm1zWzFdIDogZm9ybXNbMl0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ21tJzogd2l0aG91dFN1ZmZpeCA/ICfRhdCy0LjQu9C40L3QsF/RhdCy0LjQu9C40L3QuF/RhdCy0LjQu9C40L0nIDogJ9GF0LLQuNC70LjQvdGDX9GF0LLQuNC70LjQvdC4X9GF0LLQuNC70LjQvScsXHJcbiAgICAgICAgJ2hoJzogd2l0aG91dFN1ZmZpeCA/ICfQs9C+0LTQuNC90LBf0LPQvtC00LjQvdC4X9Cz0L7QtNC40L0nIDogJ9Cz0L7QtNC40L3Rg1/Qs9C+0LTQuNC90Lhf0LPQvtC00LjQvScsXHJcbiAgICAgICAgJ2RkJzogJ9C00LXQvdGMX9C00L3Rll/QtNC90ZbQsicsXHJcbiAgICAgICAgJ01NJzogJ9C80ZbRgdGP0YbRjF/QvNGW0YHRj9GG0ZZf0LzRltGB0Y/RhtGW0LInLFxyXG4gICAgICAgICd5eSc6ICfRgNGW0Lpf0YDQvtC60Lhf0YDQvtC60ZbQsidcclxuICAgIH07XHJcbiAgICBpZiAoa2V5ID09PSAnbScpIHtcclxuICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICfRhdCy0LjQu9C40L3QsCcgOiAn0YXQstC40LvQuNC90YMnO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnaCcpIHtcclxuICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICfQs9C+0LTQuNC90LAnIDogJ9Cz0L7QtNC40L3Rgyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJyAnICsgcGx1cmFsKGZvcm1hdFtrZXldLCArbnVtYmVyKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3ZWVrZGF5c0Nhc2VSZXBsYWNlKG0sIGZvcm1hdCkge1xyXG4gICAgdmFyIHdlZWtkYXlzID0ge1xyXG4gICAgICAgICdub21pbmF0aXZlJzogJ9C90LXQtNGW0LvRj1/Qv9C+0L3QtdC00ZbQu9C+0Lpf0LLRltCy0YLQvtGA0L7Qul/RgdC10YDQtdC00LBf0YfQtdGC0LLQtdGAX9C/4oCZ0Y/RgtC90LjRhtGPX9GB0YPQsdC+0YLQsCcuc3BsaXQoJ18nKSxcclxuICAgICAgICAnYWNjdXNhdGl2ZSc6ICfQvdC10LTRltC70Y5f0L/QvtC90LXQtNGW0LvQvtC6X9Cy0ZbQstGC0L7RgNC+0Lpf0YHQtdGA0LXQtNGDX9GH0LXRgtCy0LXRgF/Qv+KAmdGP0YLQvdC40YbRjl/RgdGD0LHQvtGC0YMnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgJ2dlbml0aXZlJzogJ9C90LXQtNGW0LvRll/Qv9C+0L3QtdC00ZbQu9C60LBf0LLRltCy0YLQvtGA0LrQsF/RgdC10YDQtdC00Lhf0YfQtdGC0LLQtdGA0LPQsF/Qv+KAmdGP0YLQvdC40YbRll/RgdGD0LHQvtGC0LgnLnNwbGl0KCdfJylcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCFtKSB7XHJcbiAgICAgICAgcmV0dXJuIHdlZWtkYXlzWydub21pbmF0aXZlJ107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5vdW5DYXNlID0gKC8oXFxbW9CS0LLQo9GDXVxcXSkgP2RkZGQvKS50ZXN0KGZvcm1hdCkgP1xyXG4gICAgICAgICdhY2N1c2F0aXZlJyA6XHJcbiAgICAgICAgKCgvXFxbPyg/OtC80LjQvdGD0LvQvtGXfNC90LDRgdGC0YPQv9C90L7Rlyk/ID9cXF0gP2RkZGQvKS50ZXN0KGZvcm1hdCkgP1xyXG4gICAgICAgICAgICAnZ2VuaXRpdmUnIDpcclxuICAgICAgICAgICAgJ25vbWluYXRpdmUnKTtcclxuICAgIHJldHVybiB3ZWVrZGF5c1tub3VuQ2FzZV1bbS5kYXkoKV07XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc0hvdXJzRnVuY3Rpb24oc3RyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBzdHIgKyAn0L4nICsgKHRoaXMuaG91cnMoKSA9PT0gMTEgPyAn0LEnIDogJycpICsgJ10gTFQnO1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIHVrID0gbW9tZW50LmRlZmluZUxvY2FsZSgndWsnLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgJ2Zvcm1hdCc6ICfRgdGW0YfQvdGPX9C70Y7RgtC+0LPQvl/QsdC10YDQtdC30L3Rj1/QutCy0ZbRgtC90Y9f0YLRgNCw0LLQvdGPX9GH0LXRgNCy0L3Rj1/Qu9C40L/QvdGPX9GB0LXRgNC/0L3Rj1/QstC10YDQtdGB0L3Rj1/QttC+0LLRgtC90Y9f0LvQuNGB0YLQvtC/0LDQtNCwX9Cz0YDRg9C00L3Rjycuc3BsaXQoJ18nKSxcclxuICAgICAgICAnc3RhbmRhbG9uZSc6ICfRgdGW0YfQtdC90Yxf0LvRjtGC0LjQuV/QsdC10YDQtdC30LXQvdGMX9C60LLRltGC0LXQvdGMX9GC0YDQsNCy0LXQvdGMX9GH0LXRgNCy0LXQvdGMX9C70LjQv9C10L3RjF/RgdC10YDQv9C10L3RjF/QstC10YDQtdGB0LXQvdGMX9C20L7QstGC0LXQvdGMX9C70LjRgdGC0L7Qv9Cw0LRf0LPRgNGD0LTQtdC90YwnLnNwbGl0KCdfJylcclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6ICfRgdGW0Ydf0LvRjtGCX9Cx0LXRgF/QutCy0ZbRgl/RgtGA0LDQsl/Rh9C10YDQsl/Qu9C40L9f0YHQtdGA0L9f0LLQtdGAX9C20L7QstGCX9C70LjRgdGCX9Cz0YDRg9C0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiB3ZWVrZGF5c0Nhc2VSZXBsYWNlLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn0L3QtF/Qv9C9X9Cy0YJf0YHRgF/Rh9GCX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVkg0YAuJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkg0YAuLCBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSDRgC4sIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6IHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0KHRjNC+0LPQvtC00L3RliAnKSxcclxuICAgICAgICBuZXh0RGF5OiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9CX0LDQstGC0YDQsCAnKSxcclxuICAgICAgICBsYXN0RGF5OiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9CS0YfQvtGA0LAgJyksXHJcbiAgICAgICAgbmV4dFdlZWs6IHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0KNdIGRkZGQgWycpLFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9Cc0LjQvdGD0LvQvtGXXSBkZGRkIFsnKS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzSG91cnNGdW5jdGlvbignW9Cc0LjQvdGD0LvQvtCz0L5dIGRkZGQgWycpLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9C30LAgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg0YLQvtC80YMnLFxyXG4gICAgICAgIHMgOiAn0LTQtdC60ZbQu9GM0LrQsCDRgdC10LrRg9C90LQnLFxyXG4gICAgICAgIG0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBoIDogJ9Cz0L7QtNC40L3RgycsXHJcbiAgICAgICAgaGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGQgOiAn0LTQtdC90YwnLFxyXG4gICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBNIDogJ9C80ZbRgdGP0YbRjCcsXHJcbiAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIHkgOiAn0YDRltC6JyxcclxuICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcclxuICAgIH0sXHJcbiAgICAvLyBNLiBFLjogdGhvc2UgdHdvIGFyZSB2aXJ0dWFsbHkgdW51c2VkIGJ1dCBhIHVzZXIgbWlnaHQgd2FudCB0byBpbXBsZW1lbnQgdGhlbSBmb3IgaGlzL2hlciB3ZWJzaXRlIGZvciBzb21lIHJlYXNvblxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9C90L7Rh9GWfNGA0LDQvdC60YN80LTQvdGPfNCy0LXRh9C+0YDQsC8sXHJcbiAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL14o0LTQvdGPfNCy0LXRh9C+0YDQsCkkLy50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQvdC+0YfRlic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfRgNCw0L3QutGDJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9C00L3Rjyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQstC10YfQvtGA0LAnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNC5fNCz0L4pLyxcclxuICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LknO1xyXG4gICAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdCz0L4nO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHVrO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ay5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ay5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFVyZHUgW3VyXVxyXG4vLyEgYXV0aG9yIDogU2F3b29kIEFsYW0gOiBodHRwczovL2dpdGh1Yi5jb20vaWJuZXNheWVlZFxyXG4vLyEgYXV0aG9yIDogWmFjayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9aYWNrVmlzaW9uXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzID0gW1xyXG4gICAgJ9is2YbZiNix24wnLFxyXG4gICAgJ9mB2LHZiNix24wnLFxyXG4gICAgJ9mF2KfYsdqGJyxcclxuICAgICfYp9m+2LHbjNmEJyxcclxuICAgICfZhdim24wnLFxyXG4gICAgJ9is2YjZhicsXHJcbiAgICAn2KzZiNmE2KfYptuMJyxcclxuICAgICfYp9qv2LPYqicsXHJcbiAgICAn2LPYqtmF2KjYsScsXHJcbiAgICAn2Kfaqdiq2YjYqNixJyxcclxuICAgICfZhtmI2YXYqNixJyxcclxuICAgICfYr9iz2YXYqNixJ1xyXG5dO1xyXG52YXIgZGF5cyA9IFtcclxuICAgICfYp9iq2YjYp9ixJyxcclxuICAgICfZvtuM2LEnLFxyXG4gICAgJ9mF2Ybar9mEJyxcclxuICAgICfYqNiv2r4nLFxyXG4gICAgJ9is2YXYudix2KfYqicsXHJcbiAgICAn2KzZhdi524EnLFxyXG4gICAgJ9uB2YHYqtuBJ1xyXG5dO1xyXG5cclxudmFyIHVyID0gbW9tZW50LmRlZmluZUxvY2FsZSgndXInLCB7XHJcbiAgICBtb250aHMgOiBtb250aHMsXHJcbiAgICBtb250aHNTaG9ydCA6IG1vbnRocyxcclxuICAgIHdlZWtkYXlzIDogZGF5cyxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiBkYXlzLFxyXG4gICAgd2Vla2RheXNNaW4gOiBkYXlzLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGTYjCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv2LXYqNitfNi02KfZhS8sXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICfYtNin2YUnID09PSBpbnB1dDtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2LXYqNitJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICfYtNin2YUnO1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW9ii2Kwg2KjZiNmC2KpdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vaqdmEINio2YjZgtiqXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb2KjZiNmC2KpdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1var9iw2LTYqtuBINix2YjYsiDYqNmI2YLYql0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1var9iw2LTYqtuBXSBkZGRkIFvYqNmI2YLYql0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDYqNi52K8nLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg2YLYqNmEJyxcclxuICAgICAgICBzIDogJ9qG2YbYryDYs9uM2qnZhtqIJyxcclxuICAgICAgICBtIDogJ9in24zaqSDZhdmG2bknLFxyXG4gICAgICAgIG1tIDogJyVkINmF2YbZuScsXHJcbiAgICAgICAgaCA6ICfYp9uM2qkg2q/avtmG2bnbgScsXHJcbiAgICAgICAgaGggOiAnJWQg2q/avtmG2bnbkicsXHJcbiAgICAgICAgZCA6ICfYp9uM2qkg2K/ZhicsXHJcbiAgICAgICAgZGQgOiAnJWQg2K/ZhicsXHJcbiAgICAgICAgTSA6ICfYp9uM2qkg2YXYp9uBJyxcclxuICAgICAgICBNTSA6ICclZCDZhdin24EnLFxyXG4gICAgICAgIHkgOiAn2KfbjNqpINiz2KfZhCcsXHJcbiAgICAgICAgeXkgOiAnJWQg2LPYp9mEJ1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC/YjC9nLCAnLCcpO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLywvZywgJ9iMJyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHVyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFV6YmVrIExhdGluIFt1ei1sYXRuXVxyXG4vLyEgYXV0aG9yIDogUmFzdWxiZWsgTWlyemF5ZXYgOiBnaXRodWIuY29tL1Jhc3VsYmVlZWtcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB1ekxhdG4gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd1ei1sYXRuJywge1xyXG4gICAgbW9udGhzIDogJ1lhbnZhcl9GZXZyYWxfTWFydF9BcHJlbF9NYXlfSXl1bl9JeXVsX0F2Z3VzdF9TZW50YWJyX09rdGFicl9Ob3lhYnJfRGVrYWJyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnWWFuX0Zldl9NYXJfQXByX01heV9JeXVuX0l5dWxfQXZnX1Nlbl9Pa3RfTm95X0Rlaycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1lha3NoYW5iYV9EdXNoYW5iYV9TZXNoYW5iYV9DaG9yc2hhbmJhX1BheXNoYW5iYV9KdW1hX1NoYW5iYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnWWFrX0R1c2hfU2VzaF9DaG9yX1BheV9KdW1fU2hhbicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1lhX0R1X1NlX0Nob19QYV9KdV9TaGEnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnRCBNTU1NIFlZWVksIGRkZGQgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbQnVndW4gc29hdF0gTFQgW2RhXScsXHJcbiAgICAgICAgbmV4dERheSA6ICdbRXJ0YWdhXSBMVCBbZGFdJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtrdW5pIHNvYXRdIExUIFtkYV0nLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0tlY2hhIHNvYXRdIExUIFtkYV0nLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tPXFwndGdhbl0gZGRkZCBba3VuaSBzb2F0XSBMVCBbZGFdJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnWWFxaW4gJXMgaWNoaWRhJyxcclxuICAgICAgICBwYXN0IDogJ0JpciBuZWNoYSAlcyBvbGRpbicsXHJcbiAgICAgICAgcyA6ICdzb25peWEnLFxyXG4gICAgICAgIG0gOiAnYmlyIGRhcWlxYScsXHJcbiAgICAgICAgbW0gOiAnJWQgZGFxaXFhJyxcclxuICAgICAgICBoIDogJ2JpciBzb2F0JyxcclxuICAgICAgICBoaCA6ICclZCBzb2F0JyxcclxuICAgICAgICBkIDogJ2JpciBrdW4nLFxyXG4gICAgICAgIGRkIDogJyVkIGt1bicsXHJcbiAgICAgICAgTSA6ICdiaXIgb3knLFxyXG4gICAgICAgIE1NIDogJyVkIG95JyxcclxuICAgICAgICB5IDogJ2JpciB5aWwnLFxyXG4gICAgICAgIHl5IDogJyVkIHlpbCdcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdXpMYXRuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei1sYXRuLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LWxhdG4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBVemJlayBbdXpdXHJcbi8vISBhdXRob3IgOiBTYXJkb3IgTXVtaW5vdiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tdW1pbm9mZlxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHV6ID0gbW9tZW50LmRlZmluZUxvY2FsZSgndXonLCB7XHJcbiAgICBtb250aHMgOiAn0Y/QvdCy0LDRgF/RhNC10LLRgNCw0Ltf0LzQsNGA0YJf0LDQv9GA0LXQu1/QvNCw0Llf0LjRjtC9X9C40Y7Qu1/QsNCy0LPRg9GB0YJf0YHQtdC90YLRj9Cx0YBf0L7QutGC0Y/QsdGAX9C90L7Rj9Cx0YBf0LTQtdC60LDQsdGAJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn0Y/QvdCyX9GE0LXQsl/QvNCw0YBf0LDQv9GAX9C80LDQuV/QuNGO0L1f0LjRjtC7X9Cw0LLQs1/RgdC10L1f0L7QutGCX9C90L7Rj1/QtNC10LonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfQr9C60YjQsNC90LHQsF/QlNGD0YjQsNC90LHQsF/QodC10YjQsNC90LHQsF/Qp9C+0YDRiNCw0L3QsdCwX9Cf0LDQudGI0LDQvdCx0LBf0JbRg9C80LBf0KjQsNC90LHQsCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn0K/QutGIX9CU0YPRiF/QodC10Yhf0KfQvtGAX9Cf0LDQuV/QltGD0Lxf0KjQsNC9Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn0K/Qul/QlNGDX9Ch0LVf0KfQvl/Qn9CwX9CW0YNf0KjQsCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdEIE1NTU0gWVlZWSwgZGRkZCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vQkdGD0LPRg9C9INGB0L7QsNGCXSBMVCBb0LTQsF0nLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9Ct0YDRgtCw0LPQsF0gTFQgW9C00LBdJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvQutGD0L3QuCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vQmtC10YfQsCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb0KPRgtCz0LDQvV0gZGRkZCBb0LrRg9C90Lgg0YHQvtCw0YJdIExUIFvQtNCwXScsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9Cv0LrQuNC9ICVzINC40YfQuNC00LAnLFxyXG4gICAgICAgIHBhc3QgOiAn0JHQuNGAINC90LXRh9CwICVzINC+0LvQtNC40L0nLFxyXG4gICAgICAgIHMgOiAn0YTRg9GA0YHQsNGCJyxcclxuICAgICAgICBtIDogJ9Cx0LjRgCDQtNCw0LrQuNC60LAnLFxyXG4gICAgICAgIG1tIDogJyVkINC00LDQutC40LrQsCcsXHJcbiAgICAgICAgaCA6ICfQsdC40YAg0YHQvtCw0YInLFxyXG4gICAgICAgIGhoIDogJyVkINGB0L7QsNGCJyxcclxuICAgICAgICBkIDogJ9Cx0LjRgCDQutGD0L0nLFxyXG4gICAgICAgIGRkIDogJyVkINC60YPQvScsXHJcbiAgICAgICAgTSA6ICfQsdC40YAg0L7QuScsXHJcbiAgICAgICAgTU0gOiAnJWQg0L7QuScsXHJcbiAgICAgICAgeSA6ICfQsdC40YAg0LnQuNC7JyxcclxuICAgICAgICB5eSA6ICclZCDQudC40LsnXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHV6O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFZpZXRuYW1lc2UgW3ZpXVxyXG4vLyEgYXV0aG9yIDogQmFuZyBOZ3V5ZW4gOiBodHRwczovL2dpdGh1Yi5jb20vYmFuZ25rXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdmkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd2aScsIHtcclxuICAgIG1vbnRocyA6ICd0aMOhbmcgMV90aMOhbmcgMl90aMOhbmcgM190aMOhbmcgNF90aMOhbmcgNV90aMOhbmcgNl90aMOhbmcgN190aMOhbmcgOF90aMOhbmcgOV90aMOhbmcgMTBfdGjDoW5nIDExX3Row6FuZyAxMicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ1RoMDFfVGgwMl9UaDAzX1RoMDRfVGgwNV9UaDA2X1RoMDdfVGgwOF9UaDA5X1RoMTBfVGgxMV9UaDEyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdjaOG7pyBuaOG6rXRfdGjhu6kgaGFpX3Ro4bupIGJhX3Ro4bupIHTGsF90aOG7qSBuxINtX3Ro4bupIHPDoXVfdGjhu6kgYuG6o3knLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0NOX1QyX1QzX1Q0X1Q1X1Q2X1Q3Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnQ05fVDJfVDNfVDRfVDVfVDZfVDcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL3NhfGNoL2ksXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIC9eY2gkL2kudGVzdChpbnB1dCk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdzYScgOiAnU0EnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2NoJyA6ICdDSCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFtuxINtXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFtuxINtXSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBbbsSDbV0gWVlZWSBISDptbScsXHJcbiAgICAgICAgbCA6ICdERC9NL1lZWVknLFxyXG4gICAgICAgIGxsIDogJ0QgTU1NIFlZWVknLFxyXG4gICAgICAgIGxsbCA6ICdEIE1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBsbGxsIDogJ2RkZCwgRCBNTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0jDtG0gbmF5IGzDumNdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW05nw6B5IG1haSBsw7pjXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt0deG6p24gdOG7m2kgbMO6Y10gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbSMO0bSBxdWEgbMO6Y10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnZGRkZCBbdHXhuqduIHLhu5NpIGzDumNdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyB04bubaScsXHJcbiAgICAgICAgcGFzdCA6ICclcyB0csaw4bubYycsXHJcbiAgICAgICAgcyA6ICd2w6BpIGdpw6J5JyxcclxuICAgICAgICBtIDogJ23hu5l0IHBow7p0JyxcclxuICAgICAgICBtbSA6ICclZCBwaMO6dCcsXHJcbiAgICAgICAgaCA6ICdt4buZdCBnaeG7nScsXHJcbiAgICAgICAgaGggOiAnJWQgZ2nhu50nLFxyXG4gICAgICAgIGQgOiAnbeG7mXQgbmfDoHknLFxyXG4gICAgICAgIGRkIDogJyVkIG5nw6B5JyxcclxuICAgICAgICBNIDogJ23hu5l0IHRow6FuZycsXHJcbiAgICAgICAgTU0gOiAnJWQgdGjDoW5nJyxcclxuICAgICAgICB5IDogJ23hu5l0IG7Eg20nLFxyXG4gICAgICAgIHl5IDogJyVkIG7Eg20nXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdmk7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3ZpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3ZpLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUHNldWRvIFt4LXBzZXVkb11cclxuLy8hIGF1dGhvciA6IEFuZHJldyBIb29kIDogaHR0cHM6Ly9naXRodWIuY29tL2FuZHJld2hvb2QxMjVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB4UHNldWRvID0gbW9tZW50LmRlZmluZUxvY2FsZSgneC1wc2V1ZG8nLCB7XHJcbiAgICBtb250aHMgOiAnSn7DocOxw7rDoX5yw71fRn7DqWJyw7p+w6Fyw71ffk3DoXJjfmhfw4FwfnLDrWxffk3DocO9X35Kw7rDscOpfl9Kw7psfsO9X8OBw7p+Z8O6c3R+X1PDqXB+dMOpbWJ+w6lyX8OTfmN0w7NifsOpcl/DkX7Ds3bDqW1+YsOpcl9+RMOpY8Opfm1iw6lyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSn7DocOxX35Gw6liX35Nw6FyX37DgXByX35Nw6HDvV9+SsO6w7FffkrDumxffsOBw7pnX35Tw6lwX37Dk2N0X37DkcOzdl9+RMOpYycuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnU37DusOxZMOhfsO9X03Ds37DsWTDocO9fl9Uw7rDqX5zZMOhw71+X1fDqWR+w7HDqXNkfsOhw71fVH5ow7pyc35kw6HDvV9+RnLDrWR+w6HDvV9TfsOhdMO6cn5kw6HDvScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU37DusOxX35Nw7PDsV9+VMO6w6lfflfDqWRfflRow7pffkZyw61fflPDoXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTfsO6X03Ds35fVMO6X35Xw6lfVH5oX0Zyfl9Tw6EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tUfsOzZMOhfsO9IMOhdF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1R+w7Ntw7N+cnLDs353IMOhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW8OhdF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW8OdfsOpc3R+w6lyZMOhfsO9IMOhdF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMfsOhc3RdIGRkZGQgW8OhdF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfDrX7DsSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDDoX5nw7MnLFxyXG4gICAgICAgIHMgOiAnw6EgfmbDqXcgfnPDqWPDs37DsWRzJyxcclxuICAgICAgICBtIDogJ8OhIH5tw63DsX7DunTDqScsXHJcbiAgICAgICAgbW0gOiAnJWQgbX7DrcOxw7p+dMOpcycsXHJcbiAgICAgICAgaCA6ICfDoX7DsSBow7N+w7pyJyxcclxuICAgICAgICBoaCA6ICclZCBofsOzw7pycycsXHJcbiAgICAgICAgZCA6ICfDoSB+ZMOhw70nLFxyXG4gICAgICAgIGRkIDogJyVkIGR+w6HDvXMnLFxyXG4gICAgICAgIE0gOiAnw6Egfm3Ds8OxfnRoJyxcclxuICAgICAgICBNTSA6ICclZCBtfsOzw7F0fmhzJyxcclxuICAgICAgICB5IDogJ8OhIH7DvcOpw6FyJyxcclxuICAgICAgICB5eSA6ICclZCDDvX7DqcOhcnMnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XHJcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcclxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4geFBzZXVkbztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveC1wc2V1ZG8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveC1wc2V1ZG8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBZb3J1YmEgTmlnZXJpYSBbeW9dXHJcbi8vISBhdXRob3IgOiBBdG9sYWdiZSBBYmlzb3llIDogaHR0cHM6Ly9naXRodWIuY29tL2FuZGVsYS1iYXRvbGFnYmVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB5byA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3lvJywge1xyXG4gICAgbW9udGhzIDogJ1PhurnMgXLhurnMgV9FzIByZcyAbGXMgF/hurhy4bq5zIBuYcyAX0nMgGdiZcyBX0XMgGJpYmlfT8yAa3XMgGR1X0Fn4bq5bW9fT8yAZ3XMgW5fT3dld2Vf4buMzIB3YcyAcmHMgF9CZcyBbHXMgV/hu4zMgHDhurnMgMyAJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnU+G6ucyBcl9FzIBybF/hurhybl9JzIBnYl9FzIBiaV9PzIBrdcyAX0Fn4bq5X0/MgGd1zIFfT3dlX+G7jMyAd2HMgF9CZcyBbF/hu4zMgHDhurnMgMyAJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnQcyAacyAa3XMgV9BamXMgV9JzIBz4bq5zIFndW5f4buMauG7jcyBcnXMgV/hu4xq4buNzIFi4buNX+G6uHRpzIBfQcyAYmHMgW3hurnMgXRhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdBzIBpzIBrX0FqZcyBX0nMgHPhurnMgV/hu4xqcl/hu4xqYl/hurh0acyAX0HMgGJhzIEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdBzIBpzIBfQWpfScyAc1/hu4xyX+G7jGJf4bq4dF9BzIBiJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnaDptbSBBJyxcclxuICAgICAgICBMVFMgOiAnaDptbTpzcyBBJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgaDptbSBBJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIGg6bW0gQSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tPzIBuacyAIG5pXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4buMzIBsYSBuaV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW+G7jHPhurnMgCB0b8yBblxcJ2Lhu41dIFtuaV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0HMgG5hIG5pXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBb4buMc+G6ucyAIHRvzIFs4buNzIFdIFtuaV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICduacyBICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGvhu41qYcyBJyxcclxuICAgICAgICBzIDogJ2nMgHPhurlqdcyBIGFheWHMgSBkaWUnLFxyXG4gICAgICAgIG0gOiAnacyAc+G6uWp1zIEga2FuJyxcclxuICAgICAgICBtbSA6ICdpzIBz4bq5anXMgSAlZCcsXHJcbiAgICAgICAgaCA6ICd3YcyBa2F0aSBrYW4nLFxyXG4gICAgICAgIGhoIDogJ3dhzIFrYXRpICVkJyxcclxuICAgICAgICBkIDogJ+G7jWrhu43MgSBrYW4nLFxyXG4gICAgICAgIGRkIDogJ+G7jWrhu43MgSAlZCcsXHJcbiAgICAgICAgTSA6ICdvc3XMgCBrYW4nLFxyXG4gICAgICAgIE1NIDogJ29zdcyAICVkJyxcclxuICAgICAgICB5IDogJ+G7jWR1zIFuIGthbicsXHJcbiAgICAgICAgeXkgOiAn4buNZHXMgW4gJWQnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC/hu41q4buNzIFcXHNcXGR7MSwyfS8sXHJcbiAgICBvcmRpbmFsIDogJ+G7jWrhu43MgSAlZCcsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB5bztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveW8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveW8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBDaGluZXNlIChDaGluYSkgW3poLWNuXVxyXG4vLyEgYXV0aG9yIDogc3V1cGljIDogaHR0cHM6Ly9naXRodWIuY29tL3N1dXBpY1xyXG4vLyEgYXV0aG9yIDogWmVubyBaZW5nIDogaHR0cHM6Ly9naXRodWIuY29tL3plbm96ZW5nXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgemhDbiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3poLWNuJywge1xyXG4gICAgbW9udGhzIDogJ+S4gOaciF/kuozmnIhf5LiJ5pyIX+Wbm+aciF/kupTmnIhf5YWt5pyIX+S4g+aciF/lhavmnIhf5Lmd5pyIX+WNgeaciF/ljYHkuIDmnIhf5Y2B5LqM5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+WRqOaXpV/lkajkuIBf5ZGo5LqMX+WRqOS4iV/lkajlm5tf5ZGo5LqUX+WRqOWFrScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+aXpV/kuIBf5LqMX+S4iV/lm5tf5LqUX+WFrScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIExMIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBMTEwgOiAnWVlZWeW5tE1NTUTml6VBaOeCuW1t5YiGJyxcclxuICAgICAgICBMTExMIDogJ1lZWVnlubRNTU1E5pelZGRkZEFo54K5bW3liIYnLFxyXG4gICAgICAgIGwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIGxsIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBsbGwgOiAnWVlZWeW5tE1NTUTml6UgSEg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnWVlZWeW5tE1NTUTml6VkZGRkIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/lh4zmmah85pep5LiKfOS4iuWNiHzkuK3ljYh85LiL5Y2IfOaZmuS4ii8sXHJcbiAgICBtZXJpZGllbUhvdXI6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn5YeM5pmoJyB8fCBtZXJpZGllbSA9PT0gJ+aXqeS4iicgfHxcclxuICAgICAgICAgICAgICAgIG1lcmlkaWVtID09PSAn5LiK5Y2IJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAn5Lit5Y2IJ1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIHZhciBobSA9IGhvdXIgKiAxMDAgKyBtaW51dGU7XHJcbiAgICAgICAgaWYgKGhtIDwgNjAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5YeM5pmoJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgOTAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5pep5LiKJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTEzMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+S4iuWNiCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDEyMzApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfkuK3ljYgnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxODAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5LiL5Y2IJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+aZmuS4iic7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+S7iuWkqV1MVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb5piO5aSpXUxUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdb5LiLXWRkZGRMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb5pio5aSpXUxUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb5LiKXWRkZGRMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0o5pelfOaciHzlkagpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aXpSc7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfmnIgnO1xyXG4gICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgY2FzZSAnVyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+WRqCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVz5YaFJyxcclxuICAgICAgICBwYXN0IDogJyVz5YmNJyxcclxuICAgICAgICBzIDogJ+WHoOenkicsXHJcbiAgICAgICAgbSA6ICcxIOWIhumSnycsXHJcbiAgICAgICAgbW0gOiAnJWQg5YiG6ZKfJyxcclxuICAgICAgICBoIDogJzEg5bCP5pe2JyxcclxuICAgICAgICBoaCA6ICclZCDlsI/ml7YnLFxyXG4gICAgICAgIGQgOiAnMSDlpKknLFxyXG4gICAgICAgIGRkIDogJyVkIOWkqScsXHJcbiAgICAgICAgTSA6ICcxIOS4quaciCcsXHJcbiAgICAgICAgTU0gOiAnJWQg5Liq5pyIJyxcclxuICAgICAgICB5IDogJzEg5bm0JyxcclxuICAgICAgICB5eSA6ICclZCDlubQnXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICAvLyBHQi9UIDc0MDgtMTk5NOOAiuaVsOaNruWFg+WSjOS6pOaNouagvOW8j8K35L+h5oGv5Lqk5o2iwrfml6XmnJ/lkozml7bpl7TooajnpLrms5XjgIvkuI5JU08gODYwMToxOTg4562J5pWIXHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB6aENuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1jbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1jbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IENoaW5lc2UgKEhvbmcgS29uZykgW3poLWhrXVxyXG4vLyEgYXV0aG9yIDogQmVuIDogaHR0cHM6Ly9naXRodWIuY29tL2Jlbi1saW5cclxuLy8hIGF1dGhvciA6IENocmlzIExhbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9oZWhhY2hyaXNcclxuLy8hIGF1dGhvciA6IEtvbnN0YW50aW4gOiBodHRwczovL2dpdGh1Yi5jb20vc2tmZFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHpoSGsgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd6aC1oaycsIHtcclxuICAgIG1vbnRocyA6ICfkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn5pif5pyf5pelX+aYn+acn+S4gF/mmJ/mnJ/kuoxf5pif5pyf5LiJX+aYn+acn+Wbm1/mmJ/mnJ/kupRf5pif5pyf5YWtJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfpgLHml6Vf6YCx5LiAX+mAseS6jF/pgLHkuIlf6YCx5ZubX+mAseS6lF/pgLHlha0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfml6Vf5LiAX+S6jF/kuIlf5ZubX+S6lF/lha0nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBMTCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgTExMIDogJ1lZWVnlubRNTU1E5pelIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ1lZWVnlubRNTU1E5pelZGRkZCBISDptbScsXHJcbiAgICAgICAgbCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgbGwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZ5bm0TU1NROaXpSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TU1NROaXpWRkZGQgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+WHjOaZqHzml6nkuIp85LiK5Y2IfOS4reWNiHzkuIvljYh85pma5LiKLyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn5YeM5pmoJyB8fCBtZXJpZGllbSA9PT0gJ+aXqeS4iicgfHwgbWVyaWRpZW0gPT09ICfkuIrljYgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfkuK3ljYgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgdmFyIGhtID0gaG91ciAqIDEwMCArIG1pbnV0ZTtcclxuICAgICAgICBpZiAoaG0gPCA2MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICflh4zmmagnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCA5MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMTMwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5LiK5Y2IJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+S4reWNiCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDE4MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5pma5LiKJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb5LuK5aSpXUxUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vmmI7lpKldTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vkuItdZGRkZExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vmmKjlpKldTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vkuIpdZGRkZExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjml6V85pyIfOmAsSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnIDpcclxuICAgICAgICAgICAgY2FzZSAnRCcgOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnIDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pelJztcclxuICAgICAgICAgICAgY2FzZSAnTScgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfmnIgnO1xyXG4gICAgICAgICAgICBjYXNlICd3JyA6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnIDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn6YCxJztcclxuICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVz5YWnJyxcclxuICAgICAgICBwYXN0IDogJyVz5YmNJyxcclxuICAgICAgICBzIDogJ+W5vuenkicsXHJcbiAgICAgICAgbSA6ICcxIOWIhumQmCcsXHJcbiAgICAgICAgbW0gOiAnJWQg5YiG6ZCYJyxcclxuICAgICAgICBoIDogJzEg5bCP5pmCJyxcclxuICAgICAgICBoaCA6ICclZCDlsI/mmYInLFxyXG4gICAgICAgIGQgOiAnMSDlpKknLFxyXG4gICAgICAgIGRkIDogJyVkIOWkqScsXHJcbiAgICAgICAgTSA6ICcxIOWAi+aciCcsXHJcbiAgICAgICAgTU0gOiAnJWQg5YCL5pyIJyxcclxuICAgICAgICB5IDogJzEg5bm0JyxcclxuICAgICAgICB5eSA6ICclZCDlubQnXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHpoSGs7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWhrLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWhrLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ2hpbmVzZSAoVGFpd2FuKSBbemgtdHddXHJcbi8vISBhdXRob3IgOiBCZW4gOiBodHRwczovL2dpdGh1Yi5jb20vYmVuLWxpblxyXG4vLyEgYXV0aG9yIDogQ2hyaXMgTGFtIDogaHR0cHM6Ly9naXRodWIuY29tL2hlaGFjaHJpc1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHpoVHcgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd6aC10dycsIHtcclxuICAgIG1vbnRocyA6ICfkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn5pif5pyf5pelX+aYn+acn+S4gF/mmJ/mnJ/kuoxf5pif5pyf5LiJX+aYn+acn+Wbm1/mmJ/mnJ/kupRf5pif5pyf5YWtJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfpgLHml6Vf6YCx5LiAX+mAseS6jF/pgLHkuIlf6YCx5ZubX+mAseS6lF/pgLHlha0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfml6Vf5LiAX+S6jF/kuIlf5ZubX+S6lF/lha0nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBMTCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgTExMIDogJ1lZWVnlubRNTU1E5pelIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ1lZWVnlubRNTU1E5pelZGRkZCBISDptbScsXHJcbiAgICAgICAgbCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgbGwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZ5bm0TU1NROaXpSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TU1NROaXpWRkZGQgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+WHjOaZqHzml6nkuIp85LiK5Y2IfOS4reWNiHzkuIvljYh85pma5LiKLyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn5YeM5pmoJyB8fCBtZXJpZGllbSA9PT0gJ+aXqeS4iicgfHwgbWVyaWRpZW0gPT09ICfkuIrljYgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfkuK3ljYgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn5LiL5Y2IJyB8fCBtZXJpZGllbSA9PT0gJ+aZmuS4iicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgdmFyIGhtID0gaG91ciAqIDEwMCArIG1pbnV0ZTtcclxuICAgICAgICBpZiAoaG0gPCA2MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICflh4zmmagnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCA5MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMTMwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5LiK5Y2IJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+S4reWNiCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDE4MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5pma5LiKJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb5LuK5aSpXUxUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vmmI7lpKldTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vkuItdZGRkZExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vmmKjlpKldTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vkuIpdZGRkZExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjml6V85pyIfOmAsSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnIDpcclxuICAgICAgICAgICAgY2FzZSAnRCcgOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnIDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pelJztcclxuICAgICAgICAgICAgY2FzZSAnTScgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfmnIgnO1xyXG4gICAgICAgICAgICBjYXNlICd3JyA6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnIDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn6YCxJztcclxuICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVz5YWnJyxcclxuICAgICAgICBwYXN0IDogJyVz5YmNJyxcclxuICAgICAgICBzIDogJ+W5vuenkicsXHJcbiAgICAgICAgbSA6ICcxIOWIhumQmCcsXHJcbiAgICAgICAgbW0gOiAnJWQg5YiG6ZCYJyxcclxuICAgICAgICBoIDogJzEg5bCP5pmCJyxcclxuICAgICAgICBoaCA6ICclZCDlsI/mmYInLFxyXG4gICAgICAgIGQgOiAnMSDlpKknLFxyXG4gICAgICAgIGRkIDogJyVkIOWkqScsXHJcbiAgICAgICAgTSA6ICcxIOWAi+aciCcsXHJcbiAgICAgICAgTU0gOiAnJWQg5YCL5pyIJyxcclxuICAgICAgICB5IDogJzEg5bm0JyxcclxuICAgICAgICB5eSA6ICclZCDlubQnXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHpoVHc7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLXR3LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLXR3LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qc1xyXG4vLyEgdmVyc2lvbiA6IDIuMTkuMlxyXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xyXG4vLyEgbGljZW5zZSA6IE1JVFxyXG4vLyEgbW9tZW50anMuY29tXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcclxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XHJcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXHJcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGhvb2tDYWxsYmFjaztcclxuXHJcbmZ1bmN0aW9uIGhvb2tzICgpIHtcclxuICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxufVxyXG5cclxuLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcclxuLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXHJcbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcclxuICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xyXG4gICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXHJcbiAgICAvLyBpbnB1dCAhPSBudWxsXHJcbiAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcclxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xyXG4gICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgaztcclxuICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcclxuICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XHJcbiAgICB2YXIgcmVzID0gW10sIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XHJcbiAgICBmb3IgKHZhciBpIGluIGIpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xyXG4gICAgICAgICAgICBhW2ldID0gYltpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcclxuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XHJcbiAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XHJcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxyXG4gICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxyXG4gICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxyXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXHJcbiAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcclxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcclxuICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcclxuICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcclxuICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxyXG4gICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xyXG4gICAgaWYgKG0uX3BmID09IG51bGwpIHtcclxuICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtLl9wZjtcclxufVxyXG5cclxudmFyIHNvbWU7XHJcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xyXG4gICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xyXG59IGVsc2Uge1xyXG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcclxuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcclxuICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWQobSkge1xyXG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcclxuICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxyXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcclxuICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXHJcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcclxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXHJcbiAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcclxuICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxyXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxyXG4gICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXHJcbiAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XHJcblxyXG4gICAgICAgIGlmIChtLl9zdHJpY3QpIHtcclxuICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcclxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcclxuICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcclxuICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XHJcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XHJcbiAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xyXG4gICAgaWYgKGZsYWdzICE9IG51bGwpIHtcclxuICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbTtcclxufVxyXG5cclxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxyXG4vLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxyXG52YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcclxuXHJcbmZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcclxuICAgIHZhciBpLCBwcm9wLCB2YWw7XHJcblxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XHJcbiAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcclxuICAgICAgICB0by5faSA9IGZyb20uX2k7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XHJcbiAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xyXG4gICAgICAgIHRvLl9sID0gZnJvbS5fbDtcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xyXG4gICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcclxuICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcclxuICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xyXG4gICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xyXG4gICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xyXG4gICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xyXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0bztcclxufVxyXG5cclxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHJcbi8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XHJcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcclxuICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcclxuICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xyXG4gICAgfVxyXG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxyXG4gICAgLy8gb2JqZWN0cy5cclxuICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcclxuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcclxuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XHJcbiAgICBpZiAobnVtYmVyIDwgMCkge1xyXG4gICAgICAgIC8vIC0wIC0+IDBcclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xyXG4gICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcclxuICAgICAgICB2YWx1ZSA9IDA7XHJcblxyXG4gICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcclxuICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xyXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xyXG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxyXG4gICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXHJcbiAgICAgICAgZGlmZnMgPSAwLFxyXG4gICAgICAgIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxyXG4gICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XHJcbiAgICAgICAgICAgIGRpZmZzKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcclxufVxyXG5cclxuZnVuY3Rpb24gd2Fybihtc2cpIHtcclxuICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXHJcbiAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xyXG4gICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIHZhciBhcmc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmcgPSAnJztcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcclxuICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSwgZm4pO1xyXG59XHJcblxyXG52YXIgZGVwcmVjYXRpb25zID0ge307XHJcblxyXG5mdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XHJcbiAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcclxuICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcclxuICAgIH1cclxuICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XHJcbiAgICAgICAgd2Fybihtc2cpO1xyXG4gICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xyXG5ob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xyXG5cclxuZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0IChjb25maWcpIHtcclxuICAgIHZhciBwcm9wLCBpO1xyXG4gICAgZm9yIChpIGluIGNvbmZpZykge1xyXG4gICAgICAgIHByb3AgPSBjb25maWdbaV07XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcclxuICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xyXG4gICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXHJcbiAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxyXG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxyXG4gICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxyXG4gICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXHJcbiAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xyXG4gICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcclxuICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxyXG4gICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXHJcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcclxuICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcclxuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBrZXlzO1xyXG5cclxuaWYgKE9iamVjdC5rZXlzKSB7XHJcbiAgICBrZXlzID0gT2JqZWN0LmtleXM7XHJcbn0gZWxzZSB7XHJcbiAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBpLCByZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59XHJcblxyXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xyXG4gICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXHJcbiAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxyXG4gICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcclxuICAgIHNhbWVFbHNlIDogJ0wnXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xyXG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xyXG59XHJcblxyXG52YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xyXG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxyXG4gICAgTFQgICA6ICdoOm1tIEEnLFxyXG4gICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcclxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcclxuICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXHJcbiAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXHJcbn07XHJcblxyXG5mdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XHJcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcclxuICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcclxuXHJcbiAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XHJcblxyXG5mdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XHJcbnZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XHJcblxyXG5mdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcclxuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcclxufVxyXG5cclxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XHJcbiAgICBmdXR1cmUgOiAnaW4gJXMnLFxyXG4gICAgcGFzdCAgIDogJyVzIGFnbycsXHJcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcclxuICAgIHNzIDogJyVkIHNlY29uZHMnLFxyXG4gICAgbSAgOiAnYSBtaW51dGUnLFxyXG4gICAgbW0gOiAnJWQgbWludXRlcycsXHJcbiAgICBoICA6ICdhbiBob3VyJyxcclxuICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgIGQgIDogJ2EgZGF5JyxcclxuICAgIGRkIDogJyVkIGRheXMnLFxyXG4gICAgTSAgOiAnYSBtb250aCcsXHJcbiAgICBNTSA6ICclZCBtb250aHMnLFxyXG4gICAgeSAgOiAnYSB5ZWFyJyxcclxuICAgIHl5IDogJyVkIHllYXJzJ1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcclxuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcclxuICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XHJcbiAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxyXG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcclxuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcclxufVxyXG5cclxudmFyIGFsaWFzZXMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XHJcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcclxuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcclxuICAgICAgICBub3JtYWxpemVkUHJvcCxcclxuICAgICAgICBwcm9wO1xyXG5cclxuICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xyXG59XHJcblxyXG52YXIgcHJpb3JpdGllcyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XHJcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcclxuICAgIHZhciB1bml0cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xyXG4gICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XHJcbiAgICB9XHJcbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdW5pdHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcclxuICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXHJcbiAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxyXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcclxuICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcclxuICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcclxufVxyXG5cclxudmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xyXG5cclxudmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XHJcblxyXG52YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XHJcblxyXG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcclxuXHJcbi8vIHRva2VuOiAgICAnTSdcclxuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxyXG4vLyBvcmRpbmFsOiAgJ01vJ1xyXG4vLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cclxuZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xyXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcclxuICAgIH1cclxuICAgIGlmIChwYWRkZWQpIHtcclxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChvcmRpbmFsKSB7XHJcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcclxuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XHJcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcclxuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcclxuZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xyXG4gICAgaWYgKCFtLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcclxuICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcclxuICAgIHZhciBpID0gNTtcclxuXHJcbiAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcclxuICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcclxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcclxuICAgICAgICBpIC09IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxufVxyXG5cclxudmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcclxudmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxyXG52YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XHJcbnZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XHJcbnZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcclxudmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxyXG52YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxyXG52YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcclxudmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxyXG52YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxyXG52YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XHJcblxyXG52YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXHJcbnZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcclxuXHJcbnZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXHJcbnZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXHJcblxyXG52YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xyXG5cclxuLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXHJcbi8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcclxudmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xyXG5cclxuXHJcbnZhciByZWdleGVzID0ge307XHJcblxyXG5mdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XHJcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcclxuICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcclxuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xyXG59XHJcblxyXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XHJcbmZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcclxuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcclxuICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XHJcbiAgICB9KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcclxuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG59XHJcblxyXG52YXIgdG9rZW5zID0ge307XHJcblxyXG5mdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcclxuICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XHJcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRva2VuID0gW3Rva2VuXTtcclxuICAgIH1cclxuICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcclxuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XHJcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XHJcbiAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xyXG4gICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XHJcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XHJcbiAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIFlFQVIgPSAwO1xyXG52YXIgTU9OVEggPSAxO1xyXG52YXIgREFURSA9IDI7XHJcbnZhciBIT1VSID0gMztcclxudmFyIE1JTlVURSA9IDQ7XHJcbnZhciBTRUNPTkQgPSA1O1xyXG52YXIgTUlMTElTRUNPTkQgPSA2O1xyXG52YXIgV0VFSyA9IDc7XHJcbnZhciBXRUVLREFZID0gODtcclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcclxuICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xyXG5cclxuLy8gUFJJT1JJVElFU1xyXG5cclxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xyXG5hZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XHJcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuXHJcbmFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XHJcbmFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xyXG59KTtcclxuXHJcbi8vIEhFTFBFUlNcclxuXHJcbmZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xyXG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xyXG4gICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xyXG59XHJcblxyXG4vLyBIT09LU1xyXG5cclxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XHJcbn07XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XHJcblxyXG5mdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcclxuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcclxuICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cclxuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcclxuICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XHJcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcclxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xyXG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gbW9kKG4sIHgpIHtcclxuICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcclxufVxyXG5cclxudmFyIGluZGV4T2Y7XHJcblxyXG5pZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcclxuICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcclxufSBlbHNlIHtcclxuICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIC8vIEkga25vd1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xyXG4gICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcclxuICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XHJcbiAgICByZXR1cm4gbW9kTW9udGggPT09IDEgPyAoaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpIDogKDMxIC0gbW9kTW9udGggJSA3ICUgMik7XHJcbn1cclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XHJcbn0pO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XHJcblxyXG4vLyBQUklPUklUWVxyXG5cclxuYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcclxufSk7XHJcbmFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XHJcbn0pO1xyXG5cclxuYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcclxufSk7XHJcblxyXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xyXG4gICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XHJcbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cclxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XHJcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIExPQ0FMRVNcclxuXHJcbnZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xyXG52YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xyXG5mdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xyXG4gICAgaWYgKCFtKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcclxuICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcclxufVxyXG5cclxudmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcclxuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xyXG4gICAgaWYgKCFtKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnQgOlxyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XHJcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xyXG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcclxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xyXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0cmljdCkge1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcclxuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xyXG5cclxuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXHJcbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXHJcbiAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcclxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XHJcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcclxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxuZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcclxuICAgIHZhciBkYXlPZk1vbnRoO1xyXG5cclxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIC8vIE5vIG9wXHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcclxuICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XHJcbiAgICByZXR1cm4gbW9tO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xyXG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xyXG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XHJcbmZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XHJcbmZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xyXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcclxuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XHJcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXHJcbiAgICAgICAgaSwgbW9tO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcclxuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xyXG4gICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XHJcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XHJcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcclxuICAgIH1cclxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcclxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cclxuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcclxuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xyXG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xyXG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XHJcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcclxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcclxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xyXG5cclxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxyXG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcclxuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcclxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XHJcblxyXG4gICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxyXG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcclxuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGU7XHJcbn1cclxuXHJcbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXHJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xyXG4gICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxyXG4gICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXHJcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxyXG4gICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcclxuXHJcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcclxufVxyXG5cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcclxuZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XHJcbiAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXHJcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXHJcbiAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcclxuICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XHJcblxyXG4gICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XHJcbiAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xyXG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XHJcbiAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcclxuICAgICAgICByZXNZZWFyID0geWVhciArIDE7XHJcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzWWVhciA9IHllYXI7XHJcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeWVhcjogcmVzWWVhcixcclxuICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XHJcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXHJcbiAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcclxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xyXG5cclxuICAgIGlmICh3ZWVrIDwgMSkge1xyXG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcclxuICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcclxuICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xyXG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xyXG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XHJcbiAgICAgICAgcmVzV2VlayA9IHdlZWs7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3ZWVrOiByZXNXZWVrLFxyXG4gICAgICAgIHllYXI6IHJlc1llYXJcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XHJcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXHJcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcclxuICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcclxuYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xyXG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xyXG5cclxuLy8gUFJJT1JJVElFU1xyXG5cclxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XHJcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuXHJcbmFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xyXG59KTtcclxuXHJcbi8vIEhFTFBFUlNcclxuXHJcbi8vIExPQ0FMRVNcclxuXHJcbmZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xyXG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcclxuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG59O1xyXG5cclxuZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XHJcbn1cclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XHJcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XHJcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XHJcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcclxuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcclxufVxyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcclxuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xyXG5hZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xyXG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XHJcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcclxuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xyXG59KTtcclxuYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xyXG59KTtcclxuYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XHJcbn0pO1xyXG5cclxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcclxuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxyXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xyXG4gICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xyXG59KTtcclxuXHJcbi8vIEhFTFBFUlNcclxuXHJcbmZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xyXG59XHJcblxyXG4vLyBMT0NBTEVTXHJcblxyXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xyXG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XHJcbiAgICBpZiAoIW0pIHtcclxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWydzdGFuZGFsb25lJ107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XHJcbiAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xyXG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XHJcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XHJcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XHJcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcclxuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xyXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xyXG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XHJcblxyXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxyXG5cclxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XHJcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xyXG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxyXG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgfVxyXG4gICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XHJcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZGF5O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgfVxyXG4gICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcclxuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XHJcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxyXG4gICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxyXG5cclxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XHJcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xyXG5mdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XHJcbmZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XHJcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxyXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XHJcbiAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XHJcbiAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xyXG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcclxuICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcclxuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XHJcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xyXG4gICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcclxuICAgIH1cclxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxyXG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxyXG4gICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcclxuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xyXG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcclxuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcclxuICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xyXG5cclxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxuICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5mdW5jdGlvbiBoRm9ybWF0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBrRm9ybWF0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcclxufVxyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XHJcbmFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcclxuYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXHJcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcclxuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcclxuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxubWVyaWRpZW0oJ2EnLCB0cnVlKTtcclxubWVyaWRpZW0oJ0EnLCBmYWxzZSk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcclxufVxyXG5cclxuYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcclxuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcclxuYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcclxuYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcclxuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xyXG5cclxuYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XHJcbmFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcclxuICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XHJcbiAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XHJcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xyXG4gICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xyXG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XHJcbiAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcclxuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xyXG59KTtcclxuYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcclxuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xyXG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XHJcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XHJcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XHJcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcclxuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xyXG59KTtcclxuXHJcbi8vIExPQ0FMRVNcclxuXHJcbmZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XHJcbiAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXHJcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cclxuICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcclxuZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICBpZiAoaG91cnMgPiAxMSkge1xyXG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG4vLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcclxuLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxyXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcclxuLy8gdGhpcyBydWxlLlxyXG52YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XHJcblxyXG4vLyBtb250aHNcclxuLy8gd2Vla1xyXG4vLyB3ZWVrZGF5c1xyXG4vLyBtZXJpZGllbVxyXG52YXIgYmFzZUNvbmZpZyA9IHtcclxuICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXHJcbiAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxyXG4gICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcclxuICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXHJcbiAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXHJcblxyXG4gICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcclxuXHJcbiAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcclxuXHJcbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxyXG4gICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcclxuICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxyXG5cclxuICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXHJcbn07XHJcblxyXG4vLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXHJcbnZhciBsb2NhbGVzID0ge307XHJcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xyXG52YXIgZ2xvYmFsTG9jYWxlO1xyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xyXG4gICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xyXG59XHJcblxyXG4vLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcclxuLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcclxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxyXG5mdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcclxuICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xyXG4gICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xyXG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XHJcbiAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xyXG4gICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcclxuICAgICAgICB3aGlsZSAoaiA+IDApIHtcclxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xyXG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcclxuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGotLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xyXG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XHJcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxyXG4gICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcclxuICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xyXG4gICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xyXG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xyXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XHJcbn1cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxyXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxyXG4vLyBsb2NhbGUga2V5LlxyXG5mdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XHJcbiAgICB2YXIgZGF0YTtcclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xyXG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xyXG4gICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xyXG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcclxuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcclxuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcclxuXHJcbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcclxuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXHJcbiAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXHJcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xyXG4gICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XHJcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XHJcbiAgICAgICAgLy8gTUVSR0VcclxuICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xyXG4gICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcclxuICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XHJcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcclxuXHJcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXHJcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xyXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcclxuZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcclxuICAgIHZhciBsb2NhbGU7XHJcblxyXG4gICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xyXG4gICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xyXG4gICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XHJcbiAgICAgICAgaWYgKGxvY2FsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkgPSBba2V5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xyXG4gICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcclxuICAgIHZhciBvdmVyZmxvdztcclxuICAgIHZhciBhID0gbS5fYTtcclxuXHJcbiAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XHJcbiAgICAgICAgb3ZlcmZsb3cgPVxyXG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XHJcbiAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxyXG4gICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxyXG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxyXG4gICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxyXG4gICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XHJcbiAgICAgICAgICAgIC0xO1xyXG5cclxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xyXG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG07XHJcbn1cclxuXHJcbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cclxuZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xyXG4gICAgaWYgKGEgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG4gICAgaWYgKGIgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XHJcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxyXG4gICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xyXG4gICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XHJcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xyXG59XHJcblxyXG4vLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cclxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcclxuLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXHJcbi8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxyXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xyXG4gICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5fZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcclxuXHJcbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXHJcbiAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xyXG4gICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xyXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcclxuICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcclxuICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xyXG4gICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxyXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxyXG4gICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcclxuICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXHJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcclxuICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcclxuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxyXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXHJcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxyXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XHJcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcclxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XHJcbiAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcclxuICAgIC8vIHdpdGggcGFyc2Vab25lLlxyXG4gICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcclxuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcuX25leHREYXkpIHtcclxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcclxuICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gY29uZmlnLl9kLmdldERheSgpKSB7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xyXG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xyXG5cclxuICAgIHcgPSBjb25maWcuX3c7XHJcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XHJcbiAgICAgICAgZG93ID0gMTtcclxuICAgICAgICBkb3kgPSA0O1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cclxuICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXHJcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcclxuICAgICAgICAvLyBjcmVhdGUgbm93KS5cclxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcclxuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcclxuICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcclxuICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcclxuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcclxuICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XHJcblxyXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XHJcblxyXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xyXG5cclxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cclxuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xyXG5cclxuICAgICAgICBpZiAody5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXHJcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XHJcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xyXG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXHJcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XHJcbiAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcclxuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcclxuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XHJcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcclxuICAgIH1cclxufVxyXG5cclxuLy8gaXNvIDg2MDEgcmVnZXhcclxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXHJcbnZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xyXG52YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XHJcblxyXG52YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcclxuXHJcbnZhciBpc29EYXRlcyA9IFtcclxuICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxyXG4gICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXHJcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcclxuICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcclxuICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxyXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXHJcbiAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcclxuICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXHJcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXHJcbiAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxyXG4gICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcclxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxyXG5dO1xyXG5cclxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xyXG52YXIgaXNvVGltZXMgPSBbXHJcbiAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXHJcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxyXG4gICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxyXG4gICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXHJcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcclxuICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcclxuICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxyXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxyXG4gICAgWydISCcsIC9cXGRcXGQvXVxyXG5dO1xyXG5cclxudmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XHJcblxyXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxyXG5mdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xyXG4gICAgdmFyIGksIGwsXHJcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxyXG4gICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXHJcbiAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcclxuXHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0Y2hbNF0pIHtcclxuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcclxuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XHJcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xyXG52YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XHJcblxyXG5mdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gW1xyXG4gICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxyXG4gICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcclxuICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcclxuICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXHJcbiAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcclxuICAgIF07XHJcblxyXG4gICAgaWYgKHNlY29uZFN0cikge1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XHJcbiAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcclxuICAgIGlmICh5ZWFyIDw9IDQ5KSB7XHJcbiAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xyXG4gICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xyXG4gICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcclxuICAgIH1cclxuICAgIHJldHVybiB5ZWFyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XHJcbiAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxyXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS50cmltKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XHJcbiAgICBpZiAod2Vla2RheVN0cikge1xyXG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cclxuICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcclxuICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xyXG4gICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxudmFyIG9ic09mZnNldHMgPSB7XHJcbiAgICBVVDogMCxcclxuICAgIEdNVDogMCxcclxuICAgIEVEVDogLTQgKiA2MCxcclxuICAgIEVTVDogLTUgKiA2MCxcclxuICAgIENEVDogLTUgKiA2MCxcclxuICAgIENTVDogLTYgKiA2MCxcclxuICAgIE1EVDogLTYgKiA2MCxcclxuICAgIE1TVDogLTcgKiA2MCxcclxuICAgIFBEVDogLTcgKiA2MCxcclxuICAgIFBTVDogLTggKiA2MFxyXG59O1xyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xyXG4gICAgaWYgKG9ic09mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XHJcbiAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XHJcbiAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xyXG4gICAgICAgIHZhciBtID0gaG0gJSAxMDAsIGggPSAoaG0gLSBtKSAvIDEwMDtcclxuICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxyXG5mdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcclxuICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XHJcbiAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xyXG4gICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcclxuXHJcbiAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xyXG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XHJcblxyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcclxuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcclxuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcclxuXHJcbiAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xyXG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcclxuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xyXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcclxufVxyXG5cclxuaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXHJcbiAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xyXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXHJcbiAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXHJcbiAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXHJcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcclxuICAgIH1cclxuKTtcclxuXHJcbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcclxuaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXHJcbmhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XHJcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xyXG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcclxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcclxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbmZpZy5fYSA9IFtdO1xyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xyXG5cclxuICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXHJcbiAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXHJcbiAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXHJcbiAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcclxuICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcclxuXHJcbiAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXHJcbiAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xyXG4gICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xyXG4gICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xyXG4gICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxyXG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XHJcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XHJcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcclxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXHJcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xyXG4gICAgLy8gaGFuZGxlIG1lcmlkaWVtXHJcbiAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XHJcblxyXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XHJcbiAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcclxuICAgIHZhciBpc1BtO1xyXG5cclxuICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xyXG4gICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgfVxyXG4gICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcclxuICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEZhbGxiYWNrXHJcbiAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcclxuICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgaG91ciArPSAxMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaG91cjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXHJcbiAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcclxuICAgIHZhciB0ZW1wQ29uZmlnLFxyXG4gICAgICAgIGJlc3RNb21lbnQsXHJcblxyXG4gICAgICAgIHNjb3JlVG9CZWF0LFxyXG4gICAgICAgIGksXHJcbiAgICAgICAgY3VycmVudFNjb3JlO1xyXG5cclxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XHJcbiAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XHJcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcclxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XHJcblxyXG4gICAgICAgIC8vb3IgdG9rZW5zXHJcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XHJcblxyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcclxuXHJcbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcclxuICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XHJcbiAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZy5fZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XHJcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xyXG4gICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcclxuICAgIGlmIChyZXMuX25leHREYXkpIHtcclxuICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcclxuICAgICAgICByZXMuYWRkKDEsICdkJyk7XHJcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xyXG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxyXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcclxuXHJcbiAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xyXG5cclxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcclxuICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XHJcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XHJcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xyXG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcclxuICAgIH0gIGVsc2Uge1xyXG4gICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XHJcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xyXG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xyXG4gICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcclxuICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xyXG4gICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcclxuICAgIHZhciBjID0ge307XHJcblxyXG4gICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xyXG4gICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcclxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcclxuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcclxuICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XHJcbiAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xyXG4gICAgYy5fbCA9IGxvY2FsZTtcclxuICAgIGMuX2kgPSBpbnB1dDtcclxuICAgIGMuX2YgPSBmb3JtYXQ7XHJcbiAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XHJcblxyXG4gICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcclxufVxyXG5cclxudmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcclxuICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXHJcbiAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG52YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxyXG4gICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbi8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXHJcbi8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cclxuLy9cclxuLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxyXG4vLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxyXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcclxuICAgIHZhciByZXMsIGk7XHJcbiAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xyXG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xyXG4gICAgfVxyXG4gICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xyXG4gICAgfVxyXG4gICAgcmVzID0gbW9tZW50c1swXTtcclxuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cclxuZnVuY3Rpb24gbWluICgpIHtcclxuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1heCAoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XHJcbn1cclxuXHJcbnZhciBub3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcclxufTtcclxuXHJcbnZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xyXG5cclxuZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBtKSB7XHJcbiAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xyXG4gICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xyXG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcclxuICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXHJcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxyXG4gICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxyXG4gICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcclxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxyXG4gICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcclxuICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxyXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXHJcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XHJcblxyXG4gICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xyXG5cclxuICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXHJcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcclxuICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxyXG4gICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcclxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcclxuICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxyXG4gICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxyXG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcclxuICAgICAgICB3ZWVrcyAqIDc7XHJcbiAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xyXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcclxuICAgIC8vIGl0IHNlcGFyYXRlbHkuXHJcbiAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcclxuICAgICAgICBxdWFydGVycyAqIDMgK1xyXG4gICAgICAgIHllYXJzICogMTI7XHJcblxyXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xyXG5cclxuICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xyXG5cclxuICAgIHRoaXMuX2J1YmJsZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcclxuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcclxufVxyXG5cclxuZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xyXG4gICAgaWYgKG51bWJlciA8IDApIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcclxuICAgIH1cclxufVxyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XHJcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xyXG4gICAgICAgIHZhciBzaWduID0gJysnO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XHJcbiAgICAgICAgICAgIHNpZ24gPSAnLSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XHJcbiAgICB9KTtcclxufVxyXG5cclxub2Zmc2V0KCdaJywgJzonKTtcclxub2Zmc2V0KCdaWicsICcnKTtcclxuXHJcbi8vIFBBUlNJTkdcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XHJcbmFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xyXG4gICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcclxufSk7XHJcblxyXG4vLyBIRUxQRVJTXHJcblxyXG4vLyB0aW1lem9uZSBjaHVua2VyXHJcbi8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxyXG4vLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cclxudmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xyXG5cclxuZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcclxuICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XHJcblxyXG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcclxuICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcclxuICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcclxuXHJcbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XHJcbiAgICAgIDAgOlxyXG4gICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xyXG59XHJcblxyXG4vLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxyXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XHJcbiAgICB2YXIgcmVzLCBkaWZmO1xyXG4gICAgaWYgKG1vZGVsLl9pc1VUQykge1xyXG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XHJcbiAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcclxuICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXHJcbiAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xyXG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcclxuICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcclxuICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcclxufVxyXG5cclxuLy8gSE9PS1NcclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cclxuLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXHJcbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxuLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XHJcbi8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XHJcbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcclxuLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxyXG4vL1xyXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcclxuLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XHJcbi8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cclxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXHJcbi8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXHJcbmZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXHJcbiAgICAgICAgbG9jYWxBZGp1c3Q7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcclxuICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XHJcbiAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XHJcbiAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xyXG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgaWYgKHRoaXMuX2lzVVRDKSB7XHJcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XHJcbiAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XHJcbiAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XHJcbiAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xyXG5cclxuICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcclxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXHJcbiAgICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xyXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYyA9IHt9O1xyXG5cclxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XHJcbiAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcclxuXHJcbiAgICBpZiAoYy5fYSkge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XHJcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcclxuICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMb2NhbCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNVdGMgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XHJcbn1cclxuXHJcbi8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxyXG52YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcclxuXHJcbi8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXHJcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcclxuLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxyXG52YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcclxuICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxyXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXHJcbiAgICAgICAgbWF0Y2ggPSBudWxsLFxyXG4gICAgICAgIHNpZ24sXHJcbiAgICAgICAgcmV0LFxyXG4gICAgICAgIGRpZmZSZXM7XHJcblxyXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSB7XHJcbiAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcclxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcclxuICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XHJcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcclxuICAgICAgICBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgeSAgOiAwLFxyXG4gICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXHJcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcclxuICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxyXG4gICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXHJcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xyXG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xyXG4gICAgICAgIGR1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxyXG4gICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxyXG4gICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxyXG4gICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxyXG4gICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxyXG4gICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxyXG4gICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcclxuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XHJcblxyXG4gICAgICAgIGR1cmF0aW9uID0ge307XHJcbiAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcclxuICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcclxuXHJcbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xyXG4gICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG5jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcclxuY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcclxuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXHJcbiAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cclxuICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cclxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xyXG4gICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxyXG4gICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XHJcbiAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcclxuXHJcbiAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXHJcbiAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xyXG4gICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xyXG4gICAgICAgIC0tcmVzLm1vbnRocztcclxuICAgIH1cclxuXHJcbiAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XHJcbiAgICB2YXIgcmVzO1xyXG4gICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xyXG4gICAgfVxyXG5cclxuICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcclxuICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xyXG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcclxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcclxuZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XHJcbiAgICAgICAgdmFyIGR1ciwgdG1wO1xyXG4gICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxyXG4gICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XHJcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcclxuICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcclxuICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcclxuICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XHJcbiAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcclxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxyXG4gICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXHJcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XHJcblxyXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgLy8gTm8gb3BcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xyXG5cclxuICAgIGlmIChtb250aHMpIHtcclxuICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRheXMpIHtcclxuICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XHJcbiAgICB9XHJcbiAgICBpZiAobWlsbGlzZWNvbmRzKSB7XHJcbiAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcclxuICAgIH1cclxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcclxuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcclxudmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xyXG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcclxuICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcclxuICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XHJcbiAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcclxuICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxyXG4gICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XHJcbiAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcclxuICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXHJcbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cclxuICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXHJcbiAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXHJcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xyXG5cclxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjbG9uZSAoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XHJcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xyXG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcclxuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XHJcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xyXG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcclxuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XHJcbiAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XHJcbiAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxyXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcclxuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXHJcbiAgICAgICAgaW5wdXRNcztcclxuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XHJcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcclxuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcclxuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcclxuICAgIHZhciB0aGF0LFxyXG4gICAgICAgIHpvbmVEZWx0YSxcclxuICAgICAgICBkZWx0YSwgb3V0cHV0O1xyXG5cclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xyXG5cclxuICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XHJcblxyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcblxyXG4gICAgc3dpdGNoICh1bml0cykge1xyXG4gICAgICAgIGNhc2UgJ3llYXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcclxuICAgICAgICBjYXNlICdzZWNvbmQnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzOyBicmVhazsgLy8gMTAwMFxyXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcclxuICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxyXG4gICAgICAgIGNhc2UgJ2RheSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcclxuICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XHJcbiAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcclxuICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXHJcbiAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXHJcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcclxuICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXHJcbiAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xyXG5cclxuICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xyXG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xyXG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXHJcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcclxuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxyXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXHJcbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcclxufVxyXG5cclxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XHJcbmhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XHJcblxyXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XHJcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XHJcbiAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cclxuICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cclxuICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxyXG4gKlxyXG4gKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xyXG4gKi9cclxuZnVuY3Rpb24gaW5zcGVjdCAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcclxuICAgIH1cclxuICAgIHZhciBmdW5jID0gJ21vbWVudCc7XHJcbiAgICB2YXIgem9uZSA9ICcnO1xyXG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xyXG4gICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xyXG4gICAgICAgIHpvbmUgPSAnWic7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcclxuICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcclxuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xyXG4gICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XHJcbiAgICBpZiAoIWlucHV0U3RyaW5nKSB7XHJcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcclxuICAgIH1cclxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xyXG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXHJcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XHJcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xyXG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXHJcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XHJcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XHJcbn1cclxuXHJcbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcclxuLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXHJcbmZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XHJcbiAgICB2YXIgbmV3TG9jYWxlRGF0YTtcclxuXHJcbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XHJcbiAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5cclxudmFyIGxhbmcgPSBkZXByZWNhdGUoXHJcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxyXG4gICAgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXHJcbiAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXHJcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XHJcbiAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdxdWFydGVyJzpcclxuICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcclxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxyXG4gICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgY2FzZSAnZGF0ZSc6XHJcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdob3VyJzpcclxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xyXG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgY2FzZSAnbWludXRlJzpcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xyXG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcclxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXHJcbiAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xyXG4gICAgICAgIHRoaXMud2Vla2RheSgwKTtcclxuICAgIH1cclxuICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XHJcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcclxuICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XHJcbiAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICdkYXRlJyBpcyBhbiBhbGlhcyBmb3IgJ2RheScsIHNvIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIHN1Y2guXHJcbiAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xyXG4gICAgICAgIHVuaXRzID0gJ2RheSc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsdWVPZiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdW5peCAoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0RhdGUgKCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9BcnJheSAoKSB7XHJcbiAgICB2YXIgbSA9IHRoaXM7XHJcbiAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9PYmplY3QgKCkge1xyXG4gICAgdmFyIG0gPSB0aGlzO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB5ZWFyczogbS55ZWFyKCksXHJcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXHJcbiAgICAgICAgZGF0ZTogbS5kYXRlKCksXHJcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcclxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcclxuICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcclxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XHJcbiAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXHJcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xyXG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XHJcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xyXG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbnB1dDogdGhpcy5faSxcclxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXHJcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXHJcbiAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxyXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcclxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcclxufVxyXG5cclxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcclxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcclxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcclxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcclxuYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuXHJcbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcclxuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xyXG5cclxuXHJcbi8vIFBBUlNJTkdcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcclxuYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xyXG5hZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xyXG5hZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xyXG5cclxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XHJcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XHJcbn0pO1xyXG5cclxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xyXG59KTtcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcclxuICAgICAgICAgICAgaW5wdXQsXHJcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxyXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcclxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxyXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcclxuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXHJcbiAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XHJcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XHJcbiAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcclxuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcclxuICAgIHZhciB3ZWVrc1RhcmdldDtcclxuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcclxuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xyXG4gICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcclxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcclxuXHJcbiAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcclxuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcclxuICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcclxuXHJcbi8vIFBSSU9SSVRZXHJcblxyXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcclxuXHJcbi8vIFBBUlNJTkdcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xyXG5hZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcclxufSk7XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG5mdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XHJcblxyXG4vLyBQUklPUk9JVFlcclxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5hZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAgICByZXR1cm4gaXNTdHJpY3QgP1xyXG4gICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XHJcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XHJcbn0pO1xyXG5cclxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XHJcbmFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xyXG4gICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XHJcbn0pO1xyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxudmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XHJcblxyXG4vLyBQUklPUklUWVxyXG5hZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XHJcbmFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xyXG5hZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcclxufSk7XHJcblxyXG4vLyBIRUxQRVJTXHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG5mdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XHJcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xyXG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuXHJcbmFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbnZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcclxuXHJcbi8vIFBSSU9SSVRZXHJcblxyXG5hZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcclxuXHJcbi8vIFBBUlNJTkdcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbmFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG52YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xyXG59KTtcclxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xyXG59KTtcclxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XHJcbn0pO1xyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xyXG59KTtcclxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xyXG59KTtcclxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XHJcbn0pO1xyXG5cclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcclxuXHJcbi8vIFBSSU9SSVRZXHJcblxyXG5hZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcclxuYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcclxuXHJcbnZhciB0b2tlbjtcclxuZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xyXG4gICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xyXG59XHJcblxyXG5mb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XHJcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcclxufVxyXG4vLyBNT01FTlRTXHJcblxyXG52YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcclxuYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG5mdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XHJcbn1cclxuXHJcbnZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XHJcblxyXG5wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcclxucHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xyXG5wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xyXG5wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XHJcbnByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XHJcbnByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xyXG5wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XHJcbnByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcclxucHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcclxucHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcclxucHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XHJcbnByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xyXG5wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XHJcbnByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XHJcbnByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xyXG5wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcclxucHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xyXG5wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xyXG5wcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcclxucHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xyXG5wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcclxucHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xyXG5wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcclxucHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XHJcbnByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xyXG5wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcclxucHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xyXG5wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xyXG5wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XHJcbnByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XHJcbnByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xyXG5wcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xyXG5wcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XHJcbnByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xyXG5wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xyXG5wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XHJcbnByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcclxucHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XHJcblxyXG4vLyBZZWFyXHJcbnByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xyXG5wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcclxuXHJcbi8vIFdlZWsgWWVhclxyXG5wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xyXG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xyXG5cclxuLy8gUXVhcnRlclxyXG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xyXG5cclxuLy8gTW9udGhcclxucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcclxucHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcclxuXHJcbi8vIFdlZWtcclxucHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xyXG5wcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XHJcbnByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XHJcbnByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XHJcblxyXG4vLyBEYXlcclxucHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XHJcbnByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xyXG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xyXG5wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xyXG5wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xyXG5cclxuLy8gSG91clxyXG5wcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xyXG5cclxuLy8gTWludXRlXHJcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XHJcblxyXG4vLyBTZWNvbmRcclxucHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcclxuXHJcbi8vIE1pbGxpc2Vjb25kXHJcbnByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XHJcblxyXG4vLyBPZmZzZXRcclxucHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XHJcbnByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XHJcbnByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcclxucHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcclxucHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcclxucHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcclxucHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xyXG5wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xyXG5wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xyXG5wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xyXG5cclxuLy8gVGltZXpvbmVcclxucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcclxucHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcclxuXHJcbi8vIERlcHJlY2F0aW9uc1xyXG5wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XHJcbnByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xyXG5wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcclxucHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xyXG5wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJblpvbmUgKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nO1xyXG59XHJcblxyXG52YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XHJcblxyXG5wcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xyXG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xyXG5wcm90byQxLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xyXG5wcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XHJcbnByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xyXG5wcm90byQxLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcclxucHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XHJcbnByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcclxucHJvdG8kMS5zZXQgICAgICAgICAgICAgPSBzZXQ7XHJcblxyXG4vLyBNb250aFxyXG5wcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcclxucHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcclxucHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcclxucHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xyXG5wcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcclxuXHJcbi8vIFdlZWtcclxucHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcclxucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xyXG5wcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XHJcblxyXG4vLyBEYXkgb2YgV2Vla1xyXG5wcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xyXG5wcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xyXG5wcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XHJcbnByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcclxuXHJcbnByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xyXG5wcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xyXG5wcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcclxuXHJcbi8vIEhvdXJzXHJcbnByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XHJcbnByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcclxuXHJcbmZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XHJcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XHJcbiAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xyXG4gICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcclxuICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XHJcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcclxuXHJcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuLy8gKClcclxuLy8gKDUpXHJcbi8vIChmbXQsIDUpXHJcbi8vIChmbXQpXHJcbi8vICh0cnVlKVxyXG4vLyAodHJ1ZSwgNSlcclxuLy8gKHRydWUsIGZtdCwgNSlcclxuLy8gKHRydWUsIGZtdClcclxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xyXG4gICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xyXG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcclxuICAgICAgICBpbmRleCA9IGZvcm1hdDtcclxuICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXHJcbiAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcclxuXHJcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3V0ID0gW107XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcclxuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcclxuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcclxuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcclxuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XHJcbn1cclxuXHJcbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcclxuaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xyXG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XHJcblxyXG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xyXG5cclxuZnVuY3Rpb24gYWJzICgpIHtcclxuICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XHJcblxyXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xyXG4gICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcclxuICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcclxuXHJcbiAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcclxuICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcclxuICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcclxuICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XHJcbiAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcclxuICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xyXG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcclxuXHJcbiAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XHJcbiAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xyXG4gICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xyXG5cclxuICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XHJcbn1cclxuXHJcbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcclxuZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcclxufVxyXG5cclxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcclxuZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XHJcbiAgICBpZiAobnVtYmVyIDwgMCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYnViYmxlICgpIHtcclxuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XHJcbiAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcclxuICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XHJcbiAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcclxuICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xyXG5cclxuICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcclxuICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxyXG4gICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcclxuICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XHJcbiAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xyXG4gICAgICAgIGRheXMgPSAwO1xyXG4gICAgICAgIG1vbnRocyA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxyXG4gICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxyXG4gICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xyXG5cclxuICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XHJcbiAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcclxuXHJcbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XHJcbiAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcclxuXHJcbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XHJcbiAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XHJcblxyXG4gICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcclxuXHJcbiAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXHJcbiAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XHJcbiAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XHJcbiAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XHJcblxyXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxyXG4gICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XHJcbiAgICBtb250aHMgJT0gMTI7XHJcblxyXG4gICAgZGF0YS5kYXlzICAgPSBkYXlzO1xyXG4gICAgZGF0YS5tb250aHMgPSBtb250aHM7XHJcbiAgICBkYXRhLnllYXJzICA9IHllYXJzO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcclxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcclxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxyXG4gICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xyXG4gICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXHJcbiAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcclxufVxyXG5cclxuZnVuY3Rpb24gYXMgKHVuaXRzKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIHZhciBkYXlzO1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XHJcblxyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcblxyXG4gICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcclxuICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcclxuICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XHJcbiAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcclxuICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xyXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcclxuICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcclxuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXHJcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xyXG5mdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXHJcbiAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcclxuICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcclxuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XHJcbiAgICApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcclxudmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XHJcbnZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xyXG52YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcclxudmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XHJcbnZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xyXG52YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcclxudmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XHJcblxyXG5mdW5jdGlvbiBjbG9uZSQxICgpIHtcclxuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xyXG52YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xyXG52YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xyXG52YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcclxudmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcclxudmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xyXG52YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcclxuXHJcbmZ1bmN0aW9uIHdlZWtzICgpIHtcclxuICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xyXG59XHJcblxyXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xyXG52YXIgdGhyZXNob2xkcyA9IHtcclxuICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcclxuICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxyXG4gICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxyXG4gICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxyXG4gICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcclxuICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxyXG59O1xyXG5cclxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcclxuZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xyXG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xyXG4gICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XHJcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcclxuICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xyXG4gICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XHJcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcclxuICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xyXG5cclxuICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxyXG4gICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxyXG4gICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcclxuICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxyXG4gICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XHJcbiAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxyXG4gICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XHJcblxyXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XHJcbiAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcclxuICAgIGFbNF0gPSBsb2NhbGU7XHJcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XHJcbn1cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcclxuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcclxuICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gcm91bmQ7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcclxuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XHJcbiAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XHJcbiAgICB9XHJcbiAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcclxuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xyXG4gICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XHJcbiAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XHJcblxyXG4gICAgaWYgKHdpdGhTdWZmaXgpIHtcclxuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcclxufVxyXG5cclxudmFyIGFicyQxID0gTWF0aC5hYnM7XHJcblxyXG5mdW5jdGlvbiBzaWduKHgpIHtcclxuICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xyXG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcclxuICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcclxuICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcclxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcclxuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXHJcbiAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcclxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcclxuICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcclxuICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xyXG4gICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcclxuXHJcbiAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcclxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcclxuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcclxuICAgIHNlY29uZHMgJT0gNjA7XHJcbiAgICBtaW51dGVzICU9IDYwO1xyXG5cclxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcclxuICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcclxuICAgIG1vbnRocyAlPSAxMjtcclxuXHJcblxyXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcclxuICAgIHZhciBZID0geWVhcnM7XHJcbiAgICB2YXIgTSA9IG1vbnRocztcclxuICAgIHZhciBEID0gZGF5cztcclxuICAgIHZhciBoID0gaG91cnM7XHJcbiAgICB2YXIgbSA9IG1pbnV0ZXM7XHJcbiAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xyXG4gICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcclxuXHJcbiAgICBpZiAoIXRvdGFsKSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxyXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcclxuICAgICAgICByZXR1cm4gJ1AwRCc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xyXG4gICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcclxuICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XHJcbiAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcclxuXHJcbiAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcclxuICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xyXG4gICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXHJcbiAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xyXG4gICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcclxuICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcclxuICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcclxuICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xyXG59XHJcblxyXG52YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcclxuXHJcbnByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XHJcbnByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XHJcbnByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcclxucHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XHJcbnByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcclxucHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xyXG5wcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xyXG5wcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xyXG5wcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcclxucHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcclxucHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XHJcbnByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcclxucHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XHJcbnByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XHJcbnByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XHJcbnByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xyXG5wcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XHJcbnByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XHJcbnByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xyXG5wcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcclxucHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xyXG5wcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcclxucHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xyXG5wcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xyXG5wcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XHJcbnByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcclxucHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XHJcbnByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xyXG5wcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcclxucHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcclxucHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XHJcblxyXG4vLyBEZXByZWNhdGlvbnNcclxucHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcclxucHJvdG8kMi5sYW5nID0gbGFuZztcclxuXHJcbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcclxuYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcclxuYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcclxuYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xyXG59KTtcclxuXHJcbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcclxuXHJcblxyXG5ob29rcy52ZXJzaW9uID0gJzIuMTkuMic7XHJcblxyXG5zZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xyXG5cclxuaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XHJcbmhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcclxuaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xyXG5ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XHJcbmhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcclxuaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcclxuaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcclxuaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xyXG5ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XHJcbmhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XHJcbmhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xyXG5ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcclxuaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xyXG5ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XHJcbmhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcclxuaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcclxuaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xyXG5ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XHJcbmhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcclxuaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xyXG5ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcclxuaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XHJcbmhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xyXG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcclxuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xyXG5ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcclxuaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XHJcblxyXG5yZXR1cm4gaG9va3M7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==
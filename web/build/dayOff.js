webpackJsonp([0],{

/***/ "./app/Resources/assets/js/pages/dayOff.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__("./node_modules/jquery/dist/jquery.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_bootstrap_sass__ = __webpack_require__("./node_modules/bootstrap-sass/assets/javascripts/bootstrap.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_bootstrap_sass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_bootstrap_sass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_bootstrap_datepicker__ = __webpack_require__("./node_modules/bootstrap-datepicker/dist/js/bootstrap-datepicker.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_bootstrap_datepicker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_bootstrap_datepicker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_daterangepicker__ = __webpack_require__("./node_modules/daterangepicker/daterangepicker.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_daterangepicker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_daterangepicker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_fullcalendar__ = __webpack_require__("./node_modules/fullcalendar/dist/fullcalendar.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_fullcalendar___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_fullcalendar__);






//delete console log at the end
console.log(array);
console.log(freeDays);
console.log(daysOff);
var event = [];

__WEBPACK_IMPORTED_MODULE_0_jquery___default()(function () {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('input[name="daterange"]').daterangepicker({
        datesDisabled: JSON.parse(array),
        locale: {
            format: 'MM/DD/YYYY',
            daysOfWeekDisabled: '06',
            todayHighlight: true,
            defaultDate: new Date()
        },
        isInvalidDate: function isInvalidDate(date) {
            if (date.day() === 0 || date.day() === 6 || __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.inArray(date.format('MM/DD/YYYY'), JSON.parse(array)) !== -1) {
                return true;
            }
        }

    });
});
__WEBPACK_IMPORTED_MODULE_0_jquery___default()(function () {
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#calendar').fullCalendar({

        eventSources: [{
            events: JSON.parse(freeDays),
            color: '#a94442', // an option!
            textColor: 'white' // an option!

        }],

        eventClick: function eventClick(event, jsEvent, view) {
            var id = event.id;
            if (id === undefined) {
                return false;
            } else {
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#addModal').modal();
                __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#modalSaveBtn').attr('onclick', 'javascript:moveFreeDay(' + id + ')');
            }
        },
        weekends: false
    });

    __WEBPACK_IMPORTED_MODULE_0_jquery___default.a.each(JSON.parse(daysOff), function (key, value) {
        var event1 = {
            events: value['daysOff'],
            allDay: true,
            nextDayThreshold: "00:00:00",
            color: value['color'], // an option!
            textColor: 'white' // an option!

        };

        __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#calendar').fullCalendar('addEventSource', event1);
    });
});

__WEBPACK_IMPORTED_MODULE_0_jquery___default()(function () {
    console.log(array);
    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('#datetime').datepicker({
        autoclose: true, // It is false, by default
        format: 'mm/dd/yyyy',
        datesDisabled: JSON.parse(array),
        daysOfWeekDisabled: '06',
        todayHighlight: true,
        minDate: 0

    }).on('changeDate', function (e) {});
});

/***/ }),

/***/ "./node_modules/bootstrap-datepicker/dist/js/bootstrap-datepicker.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Datepicker for Bootstrap v1.7.1 (https://github.com/uxsolutions/bootstrap-datepicker)
 *
 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */

(function(factory){
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object') {
        factory(require('jquery'));
    } else {
        factory(jQuery);
    }
}(function($, undefined){
	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function isUTCEquals(date1, date2) {
		return (
			date1.getUTCFullYear() === date2.getUTCFullYear() &&
			date1.getUTCMonth() === date2.getUTCMonth() &&
			date1.getUTCDate() === date2.getUTCDate()
		);
	}
	function alias(method, deprecationMsg){
		return function(){
			if (deprecationMsg !== undefined) {
				$.fn.datepicker.deprecated(deprecationMsg);
			}

			return this[method].apply(this, arguments);
		};
	}
	function isValidDate(d) {
		return d && !isNaN(d.getTime());
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i < l; i++)
          // Use date arithmetic to allow dates with different times to match
          if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 1000*60*60*24)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.length = 0;
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		};
	})();


	// Picker object

	var Datepicker = function(element, options){
		$.data(element, 'datepicker', this);
		this._process_options(options);

		this.dates = new DateArray();
		this.viewDate = this.o.defaultViewDate;
		this.focusDate = null;

		this.element = $(element);
		this.isInput = this.element.is('input');
		this.inputField = this.isInput ? this.element : this.element.find('input');
		this.component = this.element.hasClass('date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
		if (this.component && this.component.length === 0)
			this.component = false;
		this.isInline = !this.component && this.element.is('div');

		this.picker = $(DPGlobal.template);

		// Checking templates and inserting
		if (this._check_template(this.o.templates.leftArrow)) {
			this.picker.find('.prev').html(this.o.templates.leftArrow);
		}

		if (this._check_template(this.o.templates.rightArrow)) {
			this.picker.find('.next').html(this.o.templates.rightArrow);
		}

		this._buildEvents();
		this._attachEvents();

		if (this.isInline){
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		}
		else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
		}

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		if (this.o.calendarWeeks) {
			this.picker.find('.datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear')
				.attr('colspan', function(i, val){
					return Number(val) + 1;
				});
		}

		this._process_options({
			startDate: this._o.startDate,
			endDate: this._o.endDate,
			daysOfWeekDisabled: this.o.daysOfWeekDisabled,
			daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
			datesDisabled: this.o.datesDisabled
		});

		this._allow_update = false;
		this.setViewMode(this.o.startView);
		this._allow_update = true;

		this.fillDow();
		this.fillMonths();

		this.update();

		if (this.isInline){
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_resolveViewName: function(view){
			$.each(DPGlobal.viewModes, function(i, viewMode){
				if (view === i || $.inArray(view, viewMode.names) !== -1){
					view = i;
					return false;
				}
			});

			return view;
		},

		_resolveDaysOfWeek: function(daysOfWeek){
			if (!$.isArray(daysOfWeek))
				daysOfWeek = daysOfWeek.split(/[,\s]*/);
			return $.map(daysOfWeek, Number);
		},

		_check_template: function(tmp){
			try {
				// If empty
				if (tmp === undefined || tmp === "") {
					return false;
				}
				// If no html, everything ok
				if ((tmp.match(/[<>]/g) || []).length <= 0) {
					return true;
				}
				// Checking if html is fine
				var jDom = $(tmp);
				return jDom.length > 0;
			}
			catch (ex) {
				return false;
			}
		},

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			// Retrieve view index from any aliases
			o.startView = this._resolveViewName(o.startView);
			o.minViewMode = this._resolveViewName(o.minViewMode);
			o.maxViewMode = this._resolveViewName(o.maxViewMode);

			// Check view is between min and max
			o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView));

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = (o.weekStart + 6) % 7;

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity){
				if (!!o.startDate){
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity){
				if (!!o.endDate){
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear);
				}
				else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled||[]);
			o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted||[]);

			o.datesDisabled = o.datesDisabled||[];
			if (!$.isArray(o.datesDisabled)) {
				o.datesDisabled = o.datesDisabled.split(',');
			}
			o.datesDisabled = $.map(o.datesDisabled, function(d){
				return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return /^auto|left|right|top|bottom$/.test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch (plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return /^left|right$/.test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return /^top|bottom$/.test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
			if (o.defaultViewDate instanceof Date || typeof o.defaultViewDate === 'string') {
				o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
			} else if (o.defaultViewDate) {
				var year = o.defaultViewDate.year || new Date().getFullYear();
				var month = o.defaultViewDate.month || 0;
				var day = o.defaultViewDate.day || 1;
				o.defaultViewDate = UTCDate(year, month, day);
			} else {
				o.defaultViewDate = UTCToday();
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev, ch; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				} else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
            var events = {
                keyup: $.proxy(function(e){
                    if ($.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) === -1)
                        this.update();
                }, this),
                keydown: $.proxy(this.keydown, this),
                paste: $.proxy(this.paste, this)
            };

            if (this.o.showOnFocus === true) {
                events.focus = $.proxy(this.show, this);
            }

            if (this.isInput) { // single input
                this._events = [
                    [this.element, events]
                ];
            }
            // component: input + button
            else if (this.component && this.inputField.length) {
                this._events = [
                    // For components that are not readonly, allow keyboard nav
                    [this.inputField, events],
                    [this.component, {
                        click: $.proxy(this.show, this)
                    }]
                ];
            }
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			if (this.o.immediateUpdates) {
				// Trigger input updates immediately on changed year/month
				this._events.push([this.element, {
					'changeYear changeMonth': $.proxy(function(e){
						this.update(e.date);
					}, this)
				}]);
			}

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[this.picker, '.prev, .next', {
					click: $.proxy(this.navArrowsClick, this)
				}],
				[this.picker, '.day:not(.disabled)', {
					click: $.proxy(this.dayCellClick, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function(e){
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length ||
							this.isInline
						)){
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				viewMode: this.viewMode,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					} else if (typeof ix === 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(){
			if (this.inputField.prop('disabled') || (this.inputField.prop('readonly') && this.o.enableOnReadonly === false))
				return;
			if (!this.isInline)
				this.picker.appendTo(this.o.container);
			this.place();
			this.picker.show();
			this._attachSecondaryEvents();
			this._trigger('show');
			if ((window.navigator.msMaxTouchPoints || 'ontouchstart' in document) && this.o.disableTouchKeyboard) {
				$(this.element).blur();
			}
			return this;
		},

		hide: function(){
			if (this.isInline || !this.picker.is(':visible'))
				return this;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.setViewMode(this.o.startView);

			if (this.o.forceParse && this.inputField.val())
				this.setValue();
			this._trigger('hide');
			return this;
		},

		destroy: function(){
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput){
				delete this.element.data().date;
			}
			return this;
		},

		paste: function(e){
			var dateString;
			if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types
				&& $.inArray('text/plain', e.originalEvent.clipboardData.types) !== -1) {
				dateString = e.originalEvent.clipboardData.getData('text/plain');
			} else if (window.clipboardData) {
				dateString = window.clipboardData.getData('Text');
			} else {
				return;
			}
			this.setDate(dateString);
			this.update();
			e.preventDefault();
		},

		_utc_to_local: function(utc){
			if (!utc) {
				return utc;
			}

			var local = new Date(utc.getTime() + (utc.getTimezoneOffset() * 60000));

			if (local.getTimezoneOffset() !== utc.getTimezoneOffset()) {
				local = new Date(utc.getTime() + (local.getTimezoneOffset() * 60000));
			}

			return local;
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){
				return new Date(d);
			});
		},

		getDate: function(){
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function(){
			var selected_date = this.dates.get(-1);
			if (selected_date !== undefined) {
				return new Date(selected_date);
			} else {
				return null;
			}
		},

		clearDates: function(){
			this.inputField.val('');
			this.update();
			this._trigger('changeDate');

			if (this.o.autoclose) {
				this.hide();
			}
		},

		setDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, args);
			this._trigger('changeDate');
			this.setValue();
			return this;
		},

		setUTCDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.setDates.apply(this, $.map(args, this._utc_to_local));
			return this;
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead'),

		setValue: function(){
			var formatted = this.getFormattedDate();
			this.inputField.val(formatted);
			return this;
		},

		getFormattedDate: function(format){
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		getStartDate: function(){
			return this.o.startDate;
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		getEndDate: function(){
			return this.o.endDate;
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
			return this;
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			return this;
		},

		setDaysOfWeekHighlighted: function(daysOfWeekHighlighted){
			this._process_options({daysOfWeekHighlighted: daysOfWeekHighlighted});
			this.update();
			return this;
		},

		setDatesDisabled: function(datesDisabled){
			this._process_options({datesDisabled: datesDisabled});
			this.update();
			return this;
		},

		place: function(){
			if (this.isInline)
				return this;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				container = $(this.o.container),
				windowWidth = container.width(),
				scrollTop = this.o.container === 'body' ? $(document).scrollTop() : container.scrollTop(),
				appendOffset = container.offset();

			var parentsZindex = [0];
			this.element.parents().each(function(){
				var itemZIndex = $(this).css('z-index');
				if (itemZIndex !== 'auto' && Number(itemZIndex) !== 0) parentsZindex.push(Number(itemZIndex));
			});
			var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left - appendOffset.left;
			var top = offset.top - appendOffset.top;

			if (this.o.container !== 'body') {
				top += scrollTop;
			}

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto'){
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				if (offset.left < 0) {
					// component is outside the window on the left side. Move it into visible range
					this.picker.addClass('datepicker-orient-left');
					left -= offset.left - visualPadding;
				} else if (left + calendarWidth > windowWidth) {
					// the calendar passes the widow right edge. Align it to component right side
					this.picker.addClass('datepicker-orient-right');
					left += width - calendarWidth;
				} else {
					if (this.o.rtl) {
						// Default to right
						this.picker.addClass('datepicker-orient-right');
					} else {
						// Default to left
						this.picker.addClass('datepicker-orient-left');
					}
				}
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow;
			if (yorient === 'auto'){
				top_overflow = -scrollTop + top - calendarHeight;
				yorient = top_overflow < 0 ? 'bottom' : 'top';
			}

			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));
			else
				top += height;

			if (this.o.rtl) {
				var right = windowWidth - (left + width);
				this.picker.css({
					top: top,
					right: right,
					zIndex: zIndex
				});
			} else {
				this.picker.css({
					top: top,
					left: left,
					zIndex: zIndex
				});
			}
			return this;
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update)
				return this;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if (arguments.length){
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			} else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.inputField.val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					!this.dateWithinRange(date) ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.o.updateViewDate) {
				if (this.dates.length)
					this.viewDate = new Date(this.dates.get(-1));
				else if (this.viewDate < this.o.startDate)
					this.viewDate = new Date(this.o.startDate);
				else if (this.viewDate > this.o.endDate)
					this.viewDate = new Date(this.o.endDate);
				else
					this.viewDate = this.o.defaultViewDate;
			}

			if (fromArgs){
				// setting date by clicking
				this.setValue();
				this.element.change();
			}
			else if (this.dates.length){
				// setting date by typing
				if (String(oldDates) !== String(this.dates) && fromArgs) {
					this._trigger('changeDate');
					this.element.change();
				}
			}
			if (!this.dates.length && oldDates.length) {
				this._trigger('clearDate');
				this.element.change();
			}

			this.fill();
			return this;
		},

		fillDow: function(){
      if (this.o.showWeekDays) {
			var dowCnt = this.o.weekStart,
				html = '<tr>';
			if (this.o.calendarWeeks){
				html += '<th class="cw">&#160;</th>';
			}
			while (dowCnt < this.o.weekStart + 7){
				html += '<th class="dow';
        if ($.inArray(dowCnt, this.o.daysOfWeekDisabled) !== -1)
          html += ' disabled';
        html += '">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
      }
		},

		fillMonths: function(){
      var localDate = this._utc_to_local(this.viewDate);
			var html = '';
			var focused;
			for (var i = 0; i < 12; i++){
				focused = localDate && localDate.getMonth() === i ? ' focused' : '';
				html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i] + '</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){
					return d.valueOf();
				});
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = UTCToday();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
				cls.push('old');
			} else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with UTC today, not local today
			if (this.o.todayHighlight && isUTCEquals(date, today)) {
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (!this.dateWithinRange(date)){
				cls.push('disabled');
			}
			if (this.dateIsDisabled(date)){
				cls.push('disabled', 'disabled-date');
			}
			if ($.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1){
				cls.push('highlighted');
			}

			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) !== -1){
					cls.push('selected');
				}
				if (date.valueOf() === this.range[0]){
          cls.push('range-start');
        }
        if (date.valueOf() === this.range[this.range.length-1]){
          cls.push('range-end');
        }
			}
			return cls;
		},

		_fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn){
			var html = '';
			var step = factor / 10;
			var view = this.picker.find(selector);
			var startVal = Math.floor(year / factor) * factor;
			var endVal = startVal + step * 9;
			var focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step;
			var selected = $.map(this.dates, function(d){
				return Math.floor(d.getUTCFullYear() / step) * step;
			});

			var classes, tooltip, before;
			for (var currVal = startVal - step; currVal <= endVal + step; currVal += step) {
				classes = [cssClass];
				tooltip = null;

				if (currVal === startVal - step) {
					classes.push('old');
				} else if (currVal === endVal + step) {
					classes.push('new');
				}
				if ($.inArray(currVal, selected) !== -1) {
					classes.push('active');
				}
				if (currVal < startYear || currVal > endYear) {
					classes.push('disabled');
				}
				if (currVal === focusedVal) {
				  classes.push('focused');
        }

				if (beforeFn !== $.noop) {
					before = beforeFn(new Date(currVal, 0, 1));
					if (before === undefined) {
						before = {};
					} else if (typeof before === 'boolean') {
						before = {enabled: before};
					} else if (typeof before === 'string') {
						before = {classes: before};
					}
					if (before.enabled === false) {
						classes.push('disabled');
					}
					if (before.classes) {
						classes = classes.concat(before.classes.split(/\s+/));
					}
					if (before.tooltip) {
						tooltip = before.tooltip;
					}
				}

				html += '<span class="' + classes.join(' ') + '"' + (tooltip ? ' title="' + tooltip + '"' : '') + '>' + currVal + '</span>';
			}

			view.find('.datepicker-switch').text(startVal + '-' + endVal);
			view.find('td').html(html);
		},

		fill: function(){
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				todaytxt = dates[this.o.language].today || dates['en'].today || '',
				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
				titleFormat = dates[this.o.language].titleFormat || dates['en'].titleFormat,
				tooltip,
				before;
			if (isNaN(year) || isNaN(month))
				return;
			this.picker.find('.datepicker-days .datepicker-switch')
						.text(DPGlobal.formatDate(d, titleFormat, this.o.language));
			this.picker.find('tfoot .today')
						.text(todaytxt)
						.css('display', this.o.todayBtn === true || this.o.todayBtn === 'linked' ? 'table-cell' : 'none');
			this.picker.find('tfoot .clear')
						.text(cleartxt)
						.css('display', this.o.clearBtn === true ? 'table-cell' : 'none');
			this.picker.find('thead .datepicker-title')
						.text(this.o.title)
						.css('display', typeof this.o.title === 'string' && this.o.title !== '' ? 'table-cell' : 'none');
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month, 0),
				day = prevMonth.getUTCDate();
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			if (prevMonth.getUTCFullYear() < 100){
        nextMonth.setUTCFullYear(prevMonth.getUTCFullYear());
      }
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var weekDay, clsName;
			while (prevMonth.valueOf() < nextMonth){
				weekDay = prevMonth.getUTCDay();
				if (weekDay === this.o.weekStart){
					html.push('<tr>');
					if (this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek = (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');
					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				var content = prevMonth.getUTCDate();

				if (this.o.beforeShowDay !== $.noop){
					before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
					if (before.content)
						content = before.content;
				}

				//Check if uniqueSort exists (supported by jquery >=1.12 and >=2.2)
				//Fallback to unique function for older jquery versions
				if ($.isFunction($.uniqueSort)) {
					clsName = $.uniqueSort(clsName);
				} else {
					clsName = $.unique(clsName);
				}

				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + ' data-date="' + prevMonth.getTime().toString() + '">' + content + '</td>');
				tooltip = null;
				if (weekDay === this.o.weekEnd){
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
			}
			this.picker.find('.datepicker-days tbody').html(html.join(''));

			var monthsTitle = dates[this.o.language].monthsTitle || dates['en'].monthsTitle || 'Months';
			var months = this.picker.find('.datepicker-months')
						.find('.datepicker-switch')
							.text(this.o.maxViewMode < 2 ? monthsTitle : year)
							.end()
						.find('tbody span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() === year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear){
				months.addClass('disabled');
			}
			if (year === startYear){
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year === endYear){
				months.slice(endMonth+1).addClass('disabled');
			}

			if (this.o.beforeShowMonth !== $.noop){
				var that = this;
				$.each(months, function(i, month){
          var moDate = new Date(year, i, 1);
          var before = that.o.beforeShowMonth(moDate);
					if (before === undefined)
						before = {};
					else if (typeof before === 'boolean')
						before = {enabled: before};
					else if (typeof before === 'string')
						before = {classes: before};
					if (before.enabled === false && !$(month).hasClass('disabled'))
					    $(month).addClass('disabled');
					if (before.classes)
					    $(month).addClass(before.classes);
					if (before.tooltip)
					    $(month).prop('title', before.tooltip);
				});
			}

			// Generating decade/years picker
			this._fill_yearsView(
				'.datepicker-years',
				'year',
				10,
				year,
				startYear,
				endYear,
				this.o.beforeShowYear
			);

			// Generating century/decades picker
			this._fill_yearsView(
				'.datepicker-decades',
				'decade',
				100,
				year,
				startYear,
				endYear,
				this.o.beforeShowDecade
			);

			// Generating millennium/centuries picker
			this._fill_yearsView(
				'.datepicker-centuries',
				'century',
				1000,
				year,
				startYear,
				endYear,
				this.o.beforeShowCentury
			);
		},

		updateNavArrows: function(){
			if (!this._allow_update)
				return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				prevIsDisabled,
				nextIsDisabled,
				factor = 1;
			switch (this.viewMode){
				case 0:
					prevIsDisabled = year <= startYear && month <= startMonth;
					nextIsDisabled = year >= endYear && month >= endMonth;
					break;
				case 4:
					factor *= 10;
					/* falls through */
				case 3:
					factor *= 10;
					/* falls through */
				case 2:
					factor *= 10;
					/* falls through */
				case 1:
					prevIsDisabled = Math.floor(year / factor) * factor <= startYear;
					nextIsDisabled = Math.floor(year / factor) * factor + factor >= endYear;
					break;
			}

			this.picker.find('.prev').toggleClass('disabled', prevIsDisabled);
			this.picker.find('.next').toggleClass('disabled', nextIsDisabled);
		},

		click: function(e){
			e.preventDefault();
			e.stopPropagation();

			var target, dir, day, year, month;
			target = $(e.target);

			// Clicked on the switch
			if (target.hasClass('datepicker-switch') && this.viewMode !== this.o.maxViewMode){
				this.setViewMode(this.viewMode + 1);
			}

			// Clicked on today button
			if (target.hasClass('today') && !target.hasClass('day')){
				this.setViewMode(0);
				this._setDate(UTCToday(), this.o.todayBtn === 'linked' ? null : 'view');
			}

			// Clicked on clear button
			if (target.hasClass('clear')){
				this.clearDates();
			}

			if (!target.hasClass('disabled')){
				// Clicked on a month, year, decade, century
				if (target.hasClass('month')
						|| target.hasClass('year')
						|| target.hasClass('decade')
						|| target.hasClass('century')) {
					this.viewDate.setUTCDate(1);

					day = 1;
					if (this.viewMode === 1){
						month = target.parent().find('span').index(target);
						year = this.viewDate.getUTCFullYear();
						this.viewDate.setUTCMonth(month);
					} else {
						month = 0;
						year = Number(target.text());
						this.viewDate.setUTCFullYear(year);
					}

					this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate);

					if (this.viewMode === this.o.minViewMode){
						this._setDate(UTCDate(year, month, day));
					} else {
						this.setViewMode(this.viewMode - 1);
						this.fill();
					}
				}
			}

			if (this.picker.is(':visible') && this._focused_from){
				this._focused_from.focus();
			}
			delete this._focused_from;
		},

		dayCellClick: function(e){
			var $target = $(e.currentTarget);
			var timestamp = $target.data('date');
			var date = new Date(timestamp);

			if (this.o.updateViewDate) {
				if (date.getUTCFullYear() !== this.viewDate.getUTCFullYear()) {
					this._trigger('changeYear', this.viewDate);
				}

				if (date.getUTCMonth() !== this.viewDate.getUTCMonth()) {
					this._trigger('changeMonth', this.viewDate);
				}
			}
			this._setDate(date);
		},

		// Clicked on prev or next
		navArrowsClick: function(e){
			var $target = $(e.currentTarget);
			var dir = $target.hasClass('prev') ? -1 : 1;
			if (this.viewMode !== 0){
				dir *= DPGlobal.viewModes[this.viewMode].navStep * 12;
			}
			this.viewDate = this.moveMonth(this.viewDate, dir);
			this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate);
			this.fill();
		},

		_toggle_multidate: function(date){
			var ix = this.dates.contains(date);
			if (!date){
				this.dates.clear();
			}

			if (ix !== -1){
				if (this.o.multidate === true || this.o.multidate > 1 || this.o.toggleActive){
					this.dates.remove(ix);
				}
			} else if (this.o.multidate === false) {
				this.dates.clear();
				this.dates.push(date);
			}
			else {
				this.dates.push(date);
			}

			if (typeof this.o.multidate === 'number')
				while (this.dates.length > this.o.multidate)
					this.dates.remove(0);
		},

		_setDate: function(date, which){
			if (!which || which === 'date')
				this._toggle_multidate(date && new Date(date));
			if ((!which && this.o.updateViewDate) || which === 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			if (!which || which !== 'view') {
				this._trigger('changeDate');
			}
			this.inputField.trigger('change');
			if (this.o.autoclose && (!which || which === 'date')){
				this.hide();
			}
		},

		moveDay: function(date, dir){
			var newDate = new Date(date);
			newDate.setUTCDate(date.getUTCDate() + dir);

			return newDate;
		},

		moveWeek: function(date, dir){
			return this.moveDay(date, dir * 7);
		},

		moveMonth: function(date, dir){
			if (!isValidDate(date))
				return this.o.defaultViewDate;
			if (!dir)
				return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag === 1){
				test = dir === -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){
						return new_date.getUTCMonth() === month;
					}
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){
						return new_date.getUTCMonth() !== new_month;
					};
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				new_month = (new_month + 12) % 12;
			}
			else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){
					return new_month !== new_date.getUTCMonth();
				};
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		moveAvailableDate: function(date, dir, fn){
			do {
				date = this[fn](date, dir);

				if (!this.dateWithinRange(date))
					return false;

				fn = 'moveDay';
			}
			while (this.dateIsDisabled(date));

			return date;
		},

		weekOfDateIsDisabled: function(date){
			return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
		},

		dateIsDisabled: function(date){
			return (
				this.weekOfDateIsDisabled(date) ||
				$.grep(this.o.datesDisabled, function(d){
					return isUTCEquals(date, d);
				}).length > 0
			);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (!this.picker.is(':visible')){
				if (e.keyCode === 40 || e.keyCode === 27) { // allow down to re-show picker
					this.show();
					e.stopPropagation();
        }
				return;
			}
			var dateChanged = false,
				dir, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch (e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					e.stopPropagation();
					break;
				case 37: // left
				case 38: // up
				case 39: // right
				case 40: // down
					if (!this.o.keyboardNavigation || this.o.daysOfWeekDisabled.length === 7)
						break;
					dir = e.keyCode === 37 || e.keyCode === 38 ? -1 : 1;
          if (this.viewMode === 0) {
  					if (e.ctrlKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');

  						if (newViewDate)
  							this._trigger('changeYear', this.viewDate);
  					} else if (e.shiftKey){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');

  						if (newViewDate)
  							this._trigger('changeMonth', this.viewDate);
  					} else if (e.keyCode === 37 || e.keyCode === 39){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveDay');
  					} else if (!this.weekOfDateIsDisabled(focusDate)){
  						newViewDate = this.moveAvailableDate(focusDate, dir, 'moveWeek');
  					}
          } else if (this.viewMode === 1) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveMonth');
          } else if (this.viewMode === 2) {
            if (e.keyCode === 38 || e.keyCode === 40) {
              dir = dir * 4;
            }
            newViewDate = this.moveAvailableDate(focusDate, dir, 'moveYear');
          }
					if (newViewDate){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 13: // enter
					if (!this.o.forceParse)
						break;
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					if (this.o.keyboardNavigation) {
						this._toggle_multidate(focusDate);
						dateChanged = true;
					}
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					if (this.picker.is(':visible')){
						e.preventDefault();
						e.stopPropagation();
						if (this.o.autoclose)
							this.hide();
					}
					break;
				case 9: // tab
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				this.inputField.trigger('change');
			}
		},

		setViewMode: function(viewMode){
			this.viewMode = viewMode;
			this.picker
				.children('div')
				.hide()
				.filter('.datepicker-' + DPGlobal.viewModes[this.viewMode].clsName)
					.show();
			this.updateNavArrows();
      this._trigger('changeViewMode', new Date(this.viewDate));
		}
	};

	var DateRangePicker = function(element, options){
		$.data(element, 'datepicker', this);
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){
			return i.jquery ? i[0] : i;
		});
		delete options.inputs;

		this.keepEmptyValues = options.keepEmptyValues;
		delete options.keepEmptyValues;

		datepickerPlugin.call($(this.inputs), options)
			.on('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){
			return $.data(i, 'datepicker');
		});
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){
				return i.getUTCDate();
			});
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){
				return d.valueOf();
			});
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $.data(e.target, 'datepicker');

			if (dp === undefined) {
				return;
			}

			var new_date = dp.getUTCDate(),
				keep_empty_values = this.keepEmptyValues,
				i = $.inArray(e.target, this.inputs),
				j = i - 1,
				k = i + 1,
				l = this.inputs.length;
			if (i === -1)
				return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate() && (p === dp || !keep_empty_values))
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[j]){
				// Date being moved earlier/left
				while (j >= 0 && new_date < this.dates[j]){
					this.pickers[j--].setUTCDate(new_date);
				}
			} else if (new_date > this.dates[k]){
				// Date being moved later/right
				while (k < l && new_date > this.dates[k]){
					this.pickers[k++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		destroy: function(){
			$.map(this.pickers, function(p){ p.destroy(); });
			$(this.inputs).off('changeDate', this.dateUpdated);
			delete this.element.data().datepicker;
		},
		remove: alias('destroy', 'Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead')
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
		prefix = new RegExp('^' + prefix.toLowerCase());
		function re_lower(_,a){
			return a.toLowerCase();
		}
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, re_lower);
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]){
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	var datepickerPlugin = function(option){
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function(){
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data){
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.hasClass('input-daterange') || opts.inputs){
					$.extend(opts, {
						inputs: opts.inputs || $this.find('input').toArray()
					});
					data = new DateRangePicker(this, opts);
				}
				else {
					data = new Datepicker(this, opts);
				}
				$this.data('datepicker', data);
			}
			if (typeof option === 'string' && typeof data[option] === 'function'){
				internal_return = data[option].apply(data, args);
			}
		});

		if (
			internal_return === undefined ||
			internal_return instanceof Datepicker ||
			internal_return instanceof DateRangePicker
		)
			return this;

		if (this.length > 1)
			throw new Error('Using only allowed for the collection of a single element (' + option + ' function)');
		else
			return internal_return;
	};
	$.fn.datepicker = datepickerPlugin;

	var defaults = $.fn.datepicker.defaults = {
		assumeNearbyYear: false,
		autoclose: false,
		beforeShowDay: $.noop,
		beforeShowMonth: $.noop,
		beforeShowYear: $.noop,
		beforeShowDecade: $.noop,
		beforeShowCentury: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		toggleActive: false,
		daysOfWeekDisabled: [],
		daysOfWeekHighlighted: [],
		datesDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keepEmptyValues: false,
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		maxViewMode: 4,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		updateViewDate: true,
		weekStart: 0,
		disableTouchKeyboard: false,
		enableOnReadonly: true,
		showOnFocus: true,
		zIndexOffset: 10,
		container: 'body',
		immediateUpdates: false,
		title: '',
		templates: {
			leftArrow: '&#x00AB;',
			rightArrow: '&#x00BB;'
		},
    showWeekDays: true
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear",
			titleFormat: "MM yyyy"
		}
	};

	var DPGlobal = {
		viewModes: [
			{
				names: ['days', 'month'],
				clsName: 'days',
				e: 'changeMonth'
			},
			{
				names: ['months', 'year'],
				clsName: 'months',
				e: 'changeYear',
				navStep: 1
			},
			{
				names: ['years', 'decade'],
				clsName: 'years',
				e: 'changeDecade',
				navStep: 10
			},
			{
				names: ['decades', 'century'],
				clsName: 'decades',
				e: 'changeCentury',
				navStep: 100
			},
			{
				names: ['centuries', 'millennium'],
				clsName: 'centuries',
				e: 'changeMillennium',
				navStep: 1000
			}
		],
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			if (typeof format.toValue === 'function' && typeof format.toDisplay === 'function')
                return format;
            // IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language, assumeNearby){
			if (!date)
				return undefined;
			if (date instanceof Date)
				return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toValue)
				return format.toValue(date, format, language);
			var fn_map = {
					d: 'moveDay',
					m: 'moveMonth',
					w: 'moveWeek',
					y: 'moveYear'
				},
				dateAliases = {
					yesterday: '-1d',
					today: '+0d',
					tomorrow: '+1d'
				},
				parts, part, dir, i, fn;
			if (date in dateAliases){
				date = dateAliases[date];
			}
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)){
				parts = date.match(/([\-+]\d+)([dmwy])/gi);
				date = new Date();
				for (i=0; i < parts.length; i++){
					part = parts[i].match(/([\-+]\d+)([dmwy])/i);
					dir = Number(part[1]);
					fn = fn_map[part[2].toLowerCase()];
					date = Datepicker.prototype[fn](date, dir);
				}
				return Datepicker.prototype._zero_utc_time(date);
			}

			parts = date && date.match(this.nonpunctuation) || [];

			function applyNearbyYear(year, threshold){
				if (threshold === true)
					threshold = 10;

				// if year is 2 digits or less, than the user most likely is trying to get a recent century
				if (year < 100){
					year += 2000;
					// if the new year is more than threshold years in advance, use last century
					if (year > ((new Date()).getFullYear()+threshold)){
						year -= 100;
					}
				}

				return year;
			}

			var parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){
						return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
					},
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() !== v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){
						return d.setUTCDate(v);
					}
				},
				val, filtered;
			setters_map['yy'] = setters_map['yyyy'];
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCToday();
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length !== fparts.length){
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			function match_part(){
				var m = this.slice(0, parts[i].length),
					p = parts[i].slice(0, m.length);
				return m.toLowerCase() === p.toLowerCase();
			}
			if (parts.length === fparts.length){
				var cnt;
				for (i=0, cnt = fparts.length; i < cnt; i++){
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)){
						switch (part){
							case 'MM':
								filtered = $(dates[language].months).filter(match_part);
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(match_part);
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				var _date, s;
				for (i=0; i < setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			if (format.toDisplay)
                return format.toDisplay(date, format, language);
            var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			date = [];
			var seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
			              '<tr>'+
			                '<th colspan="7" class="datepicker-title"></th>'+
			              '</tr>'+
							'<tr>'+
								'<th class="prev">'+defaults.templates.leftArrow+'</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">'+defaults.templates.rightArrow+'</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot>'+
							'<tr>'+
								'<th colspan="7" class="today"></th>'+
							'</tr>'+
							'<tr>'+
								'<th colspan="7" class="clear"></th>'+
							'</tr>'+
						'</tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-decades">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-centuries">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};

	/* DATEPICKER VERSION
	 * =================== */
	$.fn.datepicker.version = '1.7.1';

	$.fn.datepicker.deprecated = function(msg){
		var console = window.console;
		if (console && console.warn) {
			console.warn('DEPRECATED: ' + msg);
		}
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker'))
				return;
			e.preventDefault();
			// component click requires us to explicitly show it
			datepickerPlugin.call($this, 'show');
		}
	);
	$(function(){
		datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
	});

}));


/***/ }),

/***/ "./node_modules/daterangepicker/daterangepicker.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
* @version: 2.1.25
* @author: Dan Grossman http://www.dangrossman.info/
* @copyright: Copyright (c) 2012-2017 Dan Grossman. All rights reserved.
* @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
* @website: http://www.daterangepicker.com/
*/
// Follow the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
(function (root, factory) {
    if (true) {
        // AMD. Make globaly available as well
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/moment/moment.js"), __webpack_require__("./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (moment, jquery) {
            return (root.daterangepicker = factory(moment, jquery));
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        // Node / Browserify
        //isomorphic issue
        var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
        if (!jQuery) {
            jQuery = require('jquery');
            if (!jQuery.fn) jQuery.fn = {};
        }
        var moment = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : require('moment');
        module.exports = factory(moment, jQuery);
    } else {
        // Browser globals
        root.daterangepicker = factory(root.moment, root.jQuery);
    }
}(this, function(moment, $) {
    var DateRangePicker = function(element, options, cb) {

        //default settings for options
        this.parentEl = 'body';
        this.element = $(element);
        this.startDate = moment().startOf('day');
        this.endDate = moment().endOf('day');
        this.minDate = false;
        this.maxDate = false;
        this.dateLimit = false;
        this.autoApply = false;
        this.singleDatePicker = false;
        this.showDropdowns = false;
        this.showWeekNumbers = false;
        this.showISOWeekNumbers = false;
        this.showCustomRangeLabel = true;
        this.timePicker = false;
        this.timePicker24Hour = false;
        this.timePickerIncrement = 1;
        this.timePickerSeconds = false;
        this.linkedCalendars = true;
        this.autoUpdateInput = true;
        this.alwaysShowCalendars = false;
        this.ranges = {};

        this.opens = 'right';
        if (this.element.hasClass('pull-right'))
            this.opens = 'left';

        this.drops = 'down';
        if (this.element.hasClass('dropup'))
            this.drops = 'up';

        this.buttonClasses = 'btn btn-sm';
        this.applyClass = 'btn-success';
        this.cancelClass = 'btn-default';

        this.locale = {
            direction: 'ltr',
            format: moment.localeData().longDateFormat('L'),
            separator: ' - ',
            applyLabel: 'Apply',
            cancelLabel: 'Cancel',
            weekLabel: 'W',
            customRangeLabel: 'Custom Range',
            daysOfWeek: moment.weekdaysMin(),
            monthNames: moment.monthsShort(),
            firstDay: moment.localeData().firstDayOfWeek()
        };

        this.callback = function() { };

        //some state information
        this.isShowing = false;
        this.leftCalendar = {};
        this.rightCalendar = {};

        //custom options from user
        if (typeof options !== 'object' || options === null)
            options = {};

        //allow setting options with data attributes
        //data-api options will be overwritten with custom javascript options
        options = $.extend(this.element.data(), options);

        //html template for the picker UI
        if (typeof options.template !== 'string' && !(options.template instanceof $))
            options.template = '<div class="daterangepicker dropdown-menu">' +
                '<div class="calendar left">' +
                    '<div class="daterangepicker_input">' +
                      '<input class="input-mini form-control" type="text" name="daterangepicker_start" value="" />' +
                      '<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
                      '<div class="calendar-time">' +
                        '<div></div>' +
                        '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                      '</div>' +
                    '</div>' +
                    '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="calendar right">' +
                    '<div class="daterangepicker_input">' +
                      '<input class="input-mini form-control" type="text" name="daterangepicker_end" value="" />' +
                      '<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
                      '<div class="calendar-time">' +
                        '<div></div>' +
                        '<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
                      '</div>' +
                    '</div>' +
                    '<div class="calendar-table"></div>' +
                '</div>' +
                '<div class="ranges">' +
                    '<div class="range_inputs">' +
                        '<button class="applyBtn" disabled="disabled" type="button"></button> ' +
                        '<button class="cancelBtn" type="button"></button>' +
                    '</div>' +
                '</div>' +
            '</div>';

        this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
        this.container = $(options.template).appendTo(this.parentEl);

        //
        // handle all the possible options overriding defaults
        //

        if (typeof options.locale === 'object') {

            if (typeof options.locale.direction === 'string')
                this.locale.direction = options.locale.direction;

            if (typeof options.locale.format === 'string')
                this.locale.format = options.locale.format;

            if (typeof options.locale.separator === 'string')
                this.locale.separator = options.locale.separator;

            if (typeof options.locale.daysOfWeek === 'object')
                this.locale.daysOfWeek = options.locale.daysOfWeek.slice();

            if (typeof options.locale.monthNames === 'object')
              this.locale.monthNames = options.locale.monthNames.slice();

            if (typeof options.locale.firstDay === 'number')
              this.locale.firstDay = options.locale.firstDay;

            if (typeof options.locale.applyLabel === 'string')
              this.locale.applyLabel = options.locale.applyLabel;

            if (typeof options.locale.cancelLabel === 'string')
              this.locale.cancelLabel = options.locale.cancelLabel;

            if (typeof options.locale.weekLabel === 'string')
              this.locale.weekLabel = options.locale.weekLabel;

            if (typeof options.locale.customRangeLabel === 'string'){
                //Support unicode chars in the custom range name.
                var elem = document.createElement('textarea');
                elem.innerHTML = options.locale.customRangeLabel;
                var rangeHtml = elem.value;
                this.locale.customRangeLabel = rangeHtml;
            }
        }
        this.container.addClass(this.locale.direction);

        if (typeof options.startDate === 'string')
            this.startDate = moment(options.startDate, this.locale.format);

        if (typeof options.endDate === 'string')
            this.endDate = moment(options.endDate, this.locale.format);

        if (typeof options.minDate === 'string')
            this.minDate = moment(options.minDate, this.locale.format);

        if (typeof options.maxDate === 'string')
            this.maxDate = moment(options.maxDate, this.locale.format);

        if (typeof options.startDate === 'object')
            this.startDate = moment(options.startDate);

        if (typeof options.endDate === 'object')
            this.endDate = moment(options.endDate);

        if (typeof options.minDate === 'object')
            this.minDate = moment(options.minDate);

        if (typeof options.maxDate === 'object')
            this.maxDate = moment(options.maxDate);

        // sanity check for bad options
        if (this.minDate && this.startDate.isBefore(this.minDate))
            this.startDate = this.minDate.clone();

        // sanity check for bad options
        if (this.maxDate && this.endDate.isAfter(this.maxDate))
            this.endDate = this.maxDate.clone();

        if (typeof options.applyClass === 'string')
            this.applyClass = options.applyClass;

        if (typeof options.cancelClass === 'string')
            this.cancelClass = options.cancelClass;

        if (typeof options.dateLimit === 'object')
            this.dateLimit = options.dateLimit;

        if (typeof options.opens === 'string')
            this.opens = options.opens;

        if (typeof options.drops === 'string')
            this.drops = options.drops;

        if (typeof options.showWeekNumbers === 'boolean')
            this.showWeekNumbers = options.showWeekNumbers;

        if (typeof options.showISOWeekNumbers === 'boolean')
            this.showISOWeekNumbers = options.showISOWeekNumbers;

        if (typeof options.buttonClasses === 'string')
            this.buttonClasses = options.buttonClasses;

        if (typeof options.buttonClasses === 'object')
            this.buttonClasses = options.buttonClasses.join(' ');

        if (typeof options.showDropdowns === 'boolean')
            this.showDropdowns = options.showDropdowns;

        if (typeof options.showCustomRangeLabel === 'boolean')
            this.showCustomRangeLabel = options.showCustomRangeLabel;

        if (typeof options.singleDatePicker === 'boolean') {
            this.singleDatePicker = options.singleDatePicker;
            if (this.singleDatePicker)
                this.endDate = this.startDate.clone();
        }

        if (typeof options.timePicker === 'boolean')
            this.timePicker = options.timePicker;

        if (typeof options.timePickerSeconds === 'boolean')
            this.timePickerSeconds = options.timePickerSeconds;

        if (typeof options.timePickerIncrement === 'number')
            this.timePickerIncrement = options.timePickerIncrement;

        if (typeof options.timePicker24Hour === 'boolean')
            this.timePicker24Hour = options.timePicker24Hour;

        if (typeof options.autoApply === 'boolean')
            this.autoApply = options.autoApply;

        if (typeof options.autoUpdateInput === 'boolean')
            this.autoUpdateInput = options.autoUpdateInput;

        if (typeof options.linkedCalendars === 'boolean')
            this.linkedCalendars = options.linkedCalendars;

        if (typeof options.isInvalidDate === 'function')
            this.isInvalidDate = options.isInvalidDate;

        if (typeof options.isCustomDate === 'function')
            this.isCustomDate = options.isCustomDate;

        if (typeof options.alwaysShowCalendars === 'boolean')
            this.alwaysShowCalendars = options.alwaysShowCalendars;

        // update day names order to firstDay
        if (this.locale.firstDay != 0) {
            var iterator = this.locale.firstDay;
            while (iterator > 0) {
                this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
                iterator--;
            }
        }

        var start, end, range;

        //if no start/end dates set, check if an input element contains initial values
        if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
            if ($(this.element).is('input[type=text]')) {
                var val = $(this.element).val(),
                    split = val.split(this.locale.separator);

                start = end = null;

                if (split.length == 2) {
                    start = moment(split[0], this.locale.format);
                    end = moment(split[1], this.locale.format);
                } else if (this.singleDatePicker && val !== "") {
                    start = moment(val, this.locale.format);
                    end = moment(val, this.locale.format);
                }
                if (start !== null && end !== null) {
                    this.setStartDate(start);
                    this.setEndDate(end);
                }
            }
        }

        if (typeof options.ranges === 'object') {
            for (range in options.ranges) {

                if (typeof options.ranges[range][0] === 'string')
                    start = moment(options.ranges[range][0], this.locale.format);
                else
                    start = moment(options.ranges[range][0]);

                if (typeof options.ranges[range][1] === 'string')
                    end = moment(options.ranges[range][1], this.locale.format);
                else
                    end = moment(options.ranges[range][1]);

                // If the start or end date exceed those allowed by the minDate or dateLimit
                // options, shorten the range to the allowable period.
                if (this.minDate && start.isBefore(this.minDate))
                    start = this.minDate.clone();

                var maxDate = this.maxDate;
                if (this.dateLimit && maxDate && start.clone().add(this.dateLimit).isAfter(maxDate))
                    maxDate = start.clone().add(this.dateLimit);
                if (maxDate && end.isAfter(maxDate))
                    end = maxDate.clone();

                // If the end of the range is before the minimum or the start of the range is
                // after the maximum, don't display this range option at all.
                if ((this.minDate && end.isBefore(this.minDate, this.timepicker ? 'minute' : 'day')) 
                  || (maxDate && start.isAfter(maxDate, this.timepicker ? 'minute' : 'day')))
                    continue;

                //Support unicode chars in the range names.
                var elem = document.createElement('textarea');
                elem.innerHTML = range;
                var rangeHtml = elem.value;

                this.ranges[rangeHtml] = [start, end];
            }

            var list = '<ul>';
            for (range in this.ranges) {
                list += '<li data-range-key="' + range + '">' + range + '</li>';
            }
            if (this.showCustomRangeLabel) {
                list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
            }
            list += '</ul>';
            this.container.find('.ranges').prepend(list);
        }

        if (typeof cb === 'function') {
            this.callback = cb;
        }

        if (!this.timePicker) {
            this.startDate = this.startDate.startOf('day');
            this.endDate = this.endDate.endOf('day');
            this.container.find('.calendar-time').hide();
        }

        //can't be used together for now
        if (this.timePicker && this.autoApply)
            this.autoApply = false;

        if (this.autoApply && typeof options.ranges !== 'object') {
            this.container.find('.ranges').hide();
        } else if (this.autoApply) {
            this.container.find('.applyBtn, .cancelBtn').addClass('hide');
        }

        if (this.singleDatePicker) {
            this.container.addClass('single');
            this.container.find('.calendar.left').addClass('single');
            this.container.find('.calendar.left').show();
            this.container.find('.calendar.right').hide();
            this.container.find('.daterangepicker_input input, .daterangepicker_input > i').hide();
            if (this.timePicker) {
                this.container.find('.ranges ul').hide();
            } else {
                this.container.find('.ranges').hide();
            }
        }

        if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
            this.container.addClass('show-calendar');
        }

        this.container.addClass('opens' + this.opens);

        //swap the position of the predefined ranges if opens right
        if (typeof options.ranges !== 'undefined' && this.opens == 'right') {
            this.container.find('.ranges').prependTo( this.container.find('.calendar.left').parent() );
        }

        //apply CSS classes and labels to buttons
        this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
        if (this.applyClass.length)
            this.container.find('.applyBtn').addClass(this.applyClass);
        if (this.cancelClass.length)
            this.container.find('.cancelBtn').addClass(this.cancelClass);
        this.container.find('.applyBtn').html(this.locale.applyLabel);
        this.container.find('.cancelBtn').html(this.locale.cancelLabel);

        //
        // event listeners
        //

        this.container.find('.calendar')
            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
            .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
            .on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
            .on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs, this))
            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))
            .on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this))
            .on('click.daterangepicker', '.daterangepicker_input input', $.proxy(this.showCalendars, this))
            .on('focus.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsFocused, this))
            .on('blur.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsBlurred, this))
            .on('change.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this));

        this.container.find('.ranges')
            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this))
            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))
            .on('mouseenter.daterangepicker', 'li', $.proxy(this.hoverRange, this))
            .on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs, this));

        if (this.element.is('input') || this.element.is('button')) {
            this.element.on({
                'click.daterangepicker': $.proxy(this.show, this),
                'focus.daterangepicker': $.proxy(this.show, this),
                'keyup.daterangepicker': $.proxy(this.elementChanged, this),
                'keydown.daterangepicker': $.proxy(this.keydown, this)
            });
        } else {
            this.element.on('click.daterangepicker', $.proxy(this.toggle, this));
        }

        //
        // if attached to a text input, set the initial value
        //

        if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
            this.element.trigger('change');
        } else if (this.element.is('input') && this.autoUpdateInput) {
            this.element.val(this.startDate.format(this.locale.format));
            this.element.trigger('change');
        }

    };

    DateRangePicker.prototype = {

        constructor: DateRangePicker,

        setStartDate: function(startDate) {
            if (typeof startDate === 'string')
                this.startDate = moment(startDate, this.locale.format);

            if (typeof startDate === 'object')
                this.startDate = moment(startDate);

            if (!this.timePicker)
                this.startDate = this.startDate.startOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.minDate && this.startDate.isBefore(this.minDate)) {
                this.startDate = this.minDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
                this.startDate = this.maxDate.clone();
                if (this.timePicker && this.timePickerIncrement)
                    this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
            }

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        setEndDate: function(endDate) {
            if (typeof endDate === 'string')
                this.endDate = moment(endDate, this.locale.format);

            if (typeof endDate === 'object')
                this.endDate = moment(endDate);

            if (!this.timePicker)
                this.endDate = this.endDate.endOf('day');

            if (this.timePicker && this.timePickerIncrement)
                this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

            if (this.endDate.isBefore(this.startDate))
                this.endDate = this.startDate.clone();

            if (this.maxDate && this.endDate.isAfter(this.maxDate))
                this.endDate = this.maxDate.clone();

            if (this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate))
                this.endDate = this.startDate.clone().add(this.dateLimit);

            this.previousRightTime = this.endDate.clone();

            if (!this.isShowing)
                this.updateElement();

            this.updateMonthsInView();
        },

        isInvalidDate: function() {
            return false;
        },

        isCustomDate: function() {
            return false;
        },

        updateView: function() {
            if (this.timePicker) {
                this.renderTimePicker('left');
                this.renderTimePicker('right');
                if (!this.endDate) {
                    this.container.find('.right .calendar-time select').attr('disabled', 'disabled').addClass('disabled');
                } else {
                    this.container.find('.right .calendar-time select').removeAttr('disabled').removeClass('disabled');
                }
            }
            if (this.endDate) {
                this.container.find('input[name="daterangepicker_end"]').removeClass('active');
                this.container.find('input[name="daterangepicker_start"]').addClass('active');
            } else {
                this.container.find('input[name="daterangepicker_end"]').addClass('active');
                this.container.find('input[name="daterangepicker_start"]').removeClass('active');
            }
            this.updateMonthsInView();
            this.updateCalendars();
            this.updateFormInputs();
        },

        updateMonthsInView: function() {
            if (this.endDate) {

                //if both dates are visible already, do nothing
                if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
                    (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                    &&
                    (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
                    ) {
                    return;
                }

                this.leftCalendar.month = this.startDate.clone().date(2);
                if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
                    this.rightCalendar.month = this.endDate.clone().date(2);
                } else {
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }

            } else {
                if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
                    this.leftCalendar.month = this.startDate.clone().date(2);
                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
                }
            }
            if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
              this.rightCalendar.month = this.maxDate.clone().date(2);
              this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
            }
        },

        updateCalendars: function() {

            if (this.timePicker) {
                var hour, minute, second;
                if (this.endDate) {
                    hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                } else {
                    hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                }
                this.leftCalendar.month.hour(hour).minute(minute).second(second);
                this.rightCalendar.month.hour(hour).minute(minute).second(second);
            }

            this.renderCalendar('left');
            this.renderCalendar('right');

            //highlight any predefined range matching the current start and end dates
            this.container.find('.ranges li').removeClass('active');
            if (this.endDate == null) return;

            this.calculateChosenLabel();
        },

        renderCalendar: function(side) {

            //
            // Build the matrix of dates that will populate the calendar
            //

            var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
            var month = calendar.month.month();
            var year = calendar.month.year();
            var hour = calendar.month.hour();
            var minute = calendar.month.minute();
            var second = calendar.month.second();
            var daysInMonth = moment([year, month]).daysInMonth();
            var firstDay = moment([year, month, 1]);
            var lastDay = moment([year, month, daysInMonth]);
            var lastMonth = moment(firstDay).subtract(1, 'month').month();
            var lastYear = moment(firstDay).subtract(1, 'month').year();
            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
            var dayOfWeek = firstDay.day();

            //initialize a 6 rows x 7 columns array for the calendar
            var calendar = [];
            calendar.firstDay = firstDay;
            calendar.lastDay = lastDay;

            for (var i = 0; i < 6; i++) {
                calendar[i] = [];
            }

            //populate the calendar with date objects
            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
            if (startDay > daysInLastMonth)
                startDay -= 7;

            if (dayOfWeek == this.locale.firstDay)
                startDay = daysInLastMonth - 6;

            var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

            var col, row;
            for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {
                if (i > 0 && col % 7 === 0) {
                    col = 0;
                    row++;
                }
                calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
                curDate.hour(12);

                if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
                    calendar[row][col] = this.minDate.clone();
                }

                if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
                    calendar[row][col] = this.maxDate.clone();
                }

            }

            //make the calendar object available to hoverDate/clickDate
            if (side == 'left') {
                this.leftCalendar.calendar = calendar;
            } else {
                this.rightCalendar.calendar = calendar;
            }

            //
            // Display the calendar
            //

            var minDate = side == 'left' ? this.minDate : this.startDate;
            var maxDate = this.maxDate;
            var selected = side == 'left' ? this.startDate : this.endDate;
            var arrow = this.locale.direction == 'ltr' ? {left: 'chevron-left', right: 'chevron-right'} : {left: 'chevron-right', right: 'chevron-left'};

            var html = '<table class="table-condensed">';
            html += '<thead>';
            html += '<tr>';

            // add empty cell for week number
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th></th>';

            if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
                html += '<th class="prev available"><i class="fa fa-' + arrow.left + ' glyphicon glyphicon-' + arrow.left + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(" YYYY");

            if (this.showDropdowns) {
                var currentMonth = calendar[1][1].month();
                var currentYear = calendar[1][1].year();
                var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);
                var minYear = (minDate && minDate.year()) || (currentYear - 50);
                var inMinYear = currentYear == minYear;
                var inMaxYear = currentYear == maxYear;

                var monthHtml = '<select class="monthselect">';
                for (var m = 0; m < 12; m++) {
                    if ((!inMinYear || m >= minDate.month()) && (!inMaxYear || m <= maxDate.month())) {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            ">" + this.locale.monthNames[m] + "</option>";
                    } else {
                        monthHtml += "<option value='" + m + "'" +
                            (m === currentMonth ? " selected='selected'" : "") +
                            " disabled='disabled'>" + this.locale.monthNames[m] + "</option>";
                    }
                }
                monthHtml += "</select>";

                var yearHtml = '<select class="yearselect">';
                for (var y = minYear; y <= maxYear; y++) {
                    yearHtml += '<option value="' + y + '"' +
                        (y === currentYear ? ' selected="selected"' : '') +
                        '>' + y + '</option>';
                }
                yearHtml += '</select>';

                dateHtml = monthHtml + yearHtml;
            }

            html += '<th colspan="5" class="month">' + dateHtml + '</th>';
            if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
                html += '<th class="next available"><i class="fa fa-' + arrow.right + ' glyphicon glyphicon-' + arrow.right + '"></i></th>';
            } else {
                html += '<th></th>';
            }

            html += '</tr>';
            html += '<tr>';

            // add week number label
            if (this.showWeekNumbers || this.showISOWeekNumbers)
                html += '<th class="week">' + this.locale.weekLabel + '</th>';

            $.each(this.locale.daysOfWeek, function(index, dayOfWeek) {
                html += '<th>' + dayOfWeek + '</th>';
            });

            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            //adjust maxDate to reflect the dateLimit setting in order to
            //grey out end dates beyond the dateLimit
            if (this.endDate == null && this.dateLimit) {
                var maxLimit = this.startDate.clone().add(this.dateLimit).endOf('day');
                if (!maxDate || maxLimit.isBefore(maxDate)) {
                    maxDate = maxLimit;
                }
            }

            for (var row = 0; row < 6; row++) {
                html += '<tr>';

                // add week number
                if (this.showWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].week() + '</td>';
                else if (this.showISOWeekNumbers)
                    html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';

                for (var col = 0; col < 7; col++) {

                    var classes = [];

                    //highlight today's date
                    if (calendar[row][col].isSame(new Date(), "day"))
                        classes.push('today');

                    //highlight weekends
                    if (calendar[row][col].isoWeekday() > 5)
                        classes.push('weekend');

                    //grey out the dates in other months displayed at beginning and end of this calendar
                    if (calendar[row][col].month() != calendar[1][1].month())
                        classes.push('off');

                    //don't allow selection of dates before the minimum date
                    if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of dates after the maximum date
                    if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
                        classes.push('off', 'disabled');

                    //don't allow selection of date if a custom function decides it's invalid
                    if (this.isInvalidDate(calendar[row][col]))
                        classes.push('off', 'disabled');

                    //highlight the currently selected start date
                    if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
                        classes.push('active', 'start-date');

                    //highlight the currently selected end date
                    if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
                        classes.push('active', 'end-date');

                    //highlight dates in-between the selected dates
                    if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
                        classes.push('in-range');

                    //apply custom classes for this date
                    var isCustom = this.isCustomDate(calendar[row][col]);
                    if (isCustom !== false) {
                        if (typeof isCustom === 'string')
                            classes.push(isCustom);
                        else
                            Array.prototype.push.apply(classes, isCustom);
                    }

                    var cname = '', disabled = false;
                    for (var i = 0; i < classes.length; i++) {
                        cname += classes[i] + ' ';
                        if (classes[i] == 'disabled')
                            disabled = true;
                    }
                    if (!disabled)
                        cname += 'available';

                    html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';

                }
                html += '</tr>';
            }

            html += '</tbody>';
            html += '</table>';

            this.container.find('.calendar.' + side + ' .calendar-table').html(html);

        },

        renderTimePicker: function(side) {

            // Don't bother updating the time picker if it's currently disabled
            // because an end date hasn't been clicked yet
            if (side == 'right' && !this.endDate) return;

            var html, selected, minDate, maxDate = this.maxDate;

            if (this.dateLimit && (!this.maxDate || this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate)))
                maxDate = this.startDate.clone().add(this.dateLimit);

            if (side == 'left') {
                selected = this.startDate.clone();
                minDate = this.minDate;
            } else if (side == 'right') {
                selected = this.endDate.clone();
                minDate = this.startDate;

                //Preserve the time already selected
                var timeSelector = this.container.find('.calendar.right .calendar-time div');
                if (timeSelector.html() != '') {

                    selected.hour(timeSelector.find('.hourselect option:selected').val() || selected.hour());
                    selected.minute(timeSelector.find('.minuteselect option:selected').val() || selected.minute());
                    selected.second(timeSelector.find('.secondselect option:selected').val() || selected.second());

                    if (!this.timePicker24Hour) {
                        var ampm = timeSelector.find('.ampmselect option:selected').val();
                        if (ampm === 'PM' && selected.hour() < 12)
                            selected.hour(selected.hour() + 12);
                        if (ampm === 'AM' && selected.hour() === 12)
                            selected.hour(0);
                    }

                }

                if (selected.isBefore(this.startDate))
                    selected = this.startDate.clone();

                if (maxDate && selected.isAfter(maxDate))
                    selected = maxDate.clone();

            }

            //
            // hours
            //

            html = '<select class="hourselect">';

            var start = this.timePicker24Hour ? 0 : 1;
            var end = this.timePicker24Hour ? 23 : 12;

            for (var i = start; i <= end; i++) {
                var i_in_24 = i;
                if (!this.timePicker24Hour)
                    i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);

                var time = selected.clone().hour(i_in_24);
                var disabled = false;
                if (minDate && time.minute(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.minute(0).isAfter(maxDate))
                    disabled = true;

                if (i_in_24 == selected.hour() && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + i + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + i + '</option>';
                } else {
                    html += '<option value="' + i + '">' + i + '</option>';
                }
            }

            html += '</select> ';

            //
            // minutes
            //

            html += ': <select class="minuteselect">';

            for (var i = 0; i < 60; i += this.timePickerIncrement) {
                var padded = i < 10 ? '0' + i : i;
                var time = selected.clone().minute(i);

                var disabled = false;
                if (minDate && time.second(59).isBefore(minDate))
                    disabled = true;
                if (maxDate && time.second(0).isAfter(maxDate))
                    disabled = true;

                if (selected.minute() == i && !disabled) {
                    html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                } else if (disabled) {
                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                } else {
                    html += '<option value="' + i + '">' + padded + '</option>';
                }
            }

            html += '</select> ';

            //
            // seconds
            //

            if (this.timePickerSeconds) {
                html += ': <select class="secondselect">';

                for (var i = 0; i < 60; i++) {
                    var padded = i < 10 ? '0' + i : i;
                    var time = selected.clone().second(i);

                    var disabled = false;
                    if (minDate && time.isBefore(minDate))
                        disabled = true;
                    if (maxDate && time.isAfter(maxDate))
                        disabled = true;

                    if (selected.second() == i && !disabled) {
                        html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
                    } else if (disabled) {
                        html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
                    } else {
                        html += '<option value="' + i + '">' + padded + '</option>';
                    }
                }

                html += '</select> ';
            }

            //
            // AM/PM
            //

            if (!this.timePicker24Hour) {
                html += '<select class="ampmselect">';

                var am_html = '';
                var pm_html = '';

                if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))
                    am_html = ' disabled="disabled" class="disabled"';

                if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))
                    pm_html = ' disabled="disabled" class="disabled"';

                if (selected.hour() >= 12) {
                    html += '<option value="AM"' + am_html + '>AM</option><option value="PM" selected="selected"' + pm_html + '>PM</option>';
                } else {
                    html += '<option value="AM" selected="selected"' + am_html + '>AM</option><option value="PM"' + pm_html + '>PM</option>';
                }

                html += '</select>';
            }

            this.container.find('.calendar.' + side + ' .calendar-time div').html(html);

        },

        updateFormInputs: function() {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            this.container.find('input[name=daterangepicker_start]').val(this.startDate.format(this.locale.format));
            if (this.endDate)
                this.container.find('input[name=daterangepicker_end]').val(this.endDate.format(this.locale.format));

            if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
                this.container.find('button.applyBtn').removeAttr('disabled');
            } else {
                this.container.find('button.applyBtn').attr('disabled', 'disabled');
            }

        },

        move: function() {
            var parentOffset = { top: 0, left: 0 },
                containerTop;
            var parentRightEdge = $(window).width();
            if (!this.parentEl.is('body')) {
                parentOffset = {
                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()
                };
                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
            }

            if (this.drops == 'up')
                containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
            else
                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
            this.container[this.drops == 'up' ? 'addClass' : 'removeClass']('dropup');

            if (this.opens == 'left') {
                this.container.css({
                    top: containerTop,
                    right: parentRightEdge - this.element.offset().left - this.element.outerWidth(),
                    left: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else if (this.opens == 'center') {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
                            - this.container.outerWidth() / 2,
                    right: 'auto'
                });
                if (this.container.offset().left < 0) {
                    this.container.css({
                        right: 'auto',
                        left: 9
                    });
                }
            } else {
                this.container.css({
                    top: containerTop,
                    left: this.element.offset().left - parentOffset.left,
                    right: 'auto'
                });
                if (this.container.offset().left + this.container.outerWidth() > $(window).width()) {
                    this.container.css({
                        left: 'auto',
                        right: 0
                    });
                }
            }
        },

        show: function(e) {
            if (this.isShowing) return;

            // Create a click proxy that is private to this instance of datepicker, for unbinding
            this._outsideClickProxy = $.proxy(function(e) { this.outsideClick(e); }, this);

            // Bind global datepicker mousedown for hiding and
            $(document)
              .on('mousedown.daterangepicker', this._outsideClickProxy)
              // also support mobile devices
              .on('touchend.daterangepicker', this._outsideClickProxy)
              // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them
              .on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)
              // and also close when focus changes to outside the picker (eg. tabbing between controls)
              .on('focusin.daterangepicker', this._outsideClickProxy);

            // Reposition the picker if the window is resized while it's open
            $(window).on('resize.daterangepicker', $.proxy(function(e) { this.move(e); }, this));

            this.oldStartDate = this.startDate.clone();
            this.oldEndDate = this.endDate.clone();
            this.previousRightTime = this.endDate.clone();

            this.updateView();
            this.container.show();
            this.move();
            this.element.trigger('show.daterangepicker', this);
            this.isShowing = true;
        },

        hide: function(e) {
            if (!this.isShowing) return;

            //incomplete date selection, revert to last values
            if (!this.endDate) {
                this.startDate = this.oldStartDate.clone();
                this.endDate = this.oldEndDate.clone();
            }

            //if a new date range was selected, invoke the user callback function
            if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
                this.callback(this.startDate, this.endDate, this.chosenLabel);

            //if picker is attached to a text input, update it
            this.updateElement();

            $(document).off('.daterangepicker');
            $(window).off('.daterangepicker');
            this.container.hide();
            this.element.trigger('hide.daterangepicker', this);
            this.isShowing = false;
        },

        toggle: function(e) {
            if (this.isShowing) {
                this.hide();
            } else {
                this.show();
            }
        },

        outsideClick: function(e) {
            var target = $(e.target);
            // if the page is clicked anywhere except within the daterangerpicker/button
            // itself then call this.hide()
            if (
                // ie modal dialog fix
                e.type == "focusin" ||
                target.closest(this.element).length ||
                target.closest(this.container).length ||
                target.closest('.calendar-table').length
                ) return;
            this.hide();
            this.element.trigger('outsideClick.daterangepicker', this);
        },

        showCalendars: function() {
            this.container.addClass('show-calendar');
            this.move();
            this.element.trigger('showCalendar.daterangepicker', this);
        },

        hideCalendars: function() {
            this.container.removeClass('show-calendar');
            this.element.trigger('hideCalendar.daterangepicker', this);
        },

        hoverRange: function(e) {

            //ignore mouse movements while an above-calendar text input has focus
            if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
                return;

            var label = e.target.getAttribute('data-range-key');

            if (label == this.locale.customRangeLabel) {
                this.updateView();
            } else {
                var dates = this.ranges[label];
                this.container.find('input[name=daterangepicker_start]').val(dates[0].format(this.locale.format));
                this.container.find('input[name=daterangepicker_end]').val(dates[1].format(this.locale.format));
            }

        },

        clickRange: function(e) {
            var label = e.target.getAttribute('data-range-key');
            this.chosenLabel = label;
            if (label == this.locale.customRangeLabel) {
                this.showCalendars();
            } else {
                var dates = this.ranges[label];
                this.startDate = dates[0];
                this.endDate = dates[1];

                if (!this.timePicker) {
                    this.startDate.startOf('day');
                    this.endDate.endOf('day');
                }

                if (!this.alwaysShowCalendars)
                    this.hideCalendars();
                this.clickApply();
            }
        },

        clickPrev: function(e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.subtract(1, 'month');
                if (this.linkedCalendars)
                    this.rightCalendar.month.subtract(1, 'month');
            } else {
                this.rightCalendar.month.subtract(1, 'month');
            }
            this.updateCalendars();
        },

        clickNext: function(e) {
            var cal = $(e.target).parents('.calendar');
            if (cal.hasClass('left')) {
                this.leftCalendar.month.add(1, 'month');
            } else {
                this.rightCalendar.month.add(1, 'month');
                if (this.linkedCalendars)
                    this.leftCalendar.month.add(1, 'month');
            }
            this.updateCalendars();
        },

        hoverDate: function(e) {

            //ignore mouse movements while an above-calendar text input has focus
            //if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
            //    return;

            //ignore dates that can't be selected
            if (!$(e.target).hasClass('available')) return;

            //have the text inputs above calendars reflect the date being hovered over
            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            if (this.endDate && !this.container.find('input[name=daterangepicker_start]').is(":focus")) {
                this.container.find('input[name=daterangepicker_start]').val(date.format(this.locale.format));
            } else if (!this.endDate && !this.container.find('input[name=daterangepicker_end]').is(":focus")) {
                this.container.find('input[name=daterangepicker_end]').val(date.format(this.locale.format));
            }

            //highlight the dates between the start date and the date being hovered as a potential end date
            var leftCalendar = this.leftCalendar;
            var rightCalendar = this.rightCalendar;
            var startDate = this.startDate;
            if (!this.endDate) {
                this.container.find('.calendar tbody td').each(function(index, el) {

                    //skip week numbers, only look at dates
                    if ($(el).hasClass('week')) return;

                    var title = $(el).attr('data-title');
                    var row = title.substr(1, 1);
                    var col = title.substr(3, 1);
                    var cal = $(el).parents('.calendar');
                    var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

                    if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
                        $(el).addClass('in-range');
                    } else {
                        $(el).removeClass('in-range');
                    }

                });
            }

        },

        clickDate: function(e) {

            if (!$(e.target).hasClass('available')) return;

            var title = $(e.target).attr('data-title');
            var row = title.substr(1, 1);
            var col = title.substr(3, 1);
            var cal = $(e.target).parents('.calendar');
            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

            //
            // this function needs to do a few things:
            // * alternate between selecting a start and end date for the range,
            // * if the time picker is enabled, apply the hour/minute/second from the select boxes to the clicked date
            // * if autoapply is enabled, and an end date was chosen, apply the selection
            // * if single date picker mode, and time picker isn't enabled, apply the selection immediately
            // * if one of the inputs above the calendars was focused, cancel that manual input
            //

            if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.left .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.left .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.endDate = null;
                this.setStartDate(date.clone());
            } else if (!this.endDate && date.isBefore(this.startDate)) {
                //special case: clicking the same date for start/end,
                //but the time of the end date is before the start date
                this.setEndDate(this.startDate.clone());
            } else { // picking end
                if (this.timePicker) {
                    var hour = parseInt(this.container.find('.right .hourselect').val(), 10);
                    if (!this.timePicker24Hour) {
                        var ampm = this.container.find('.right .ampmselect').val();
                        if (ampm === 'PM' && hour < 12)
                            hour += 12;
                        if (ampm === 'AM' && hour === 12)
                            hour = 0;
                    }
                    var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
                    var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
                    date = date.clone().hour(hour).minute(minute).second(second);
                }
                this.setEndDate(date.clone());
                if (this.autoApply) {
                  this.calculateChosenLabel();
                  this.clickApply();
                }
            }

            if (this.singleDatePicker) {
                this.setEndDate(this.startDate);
                if (!this.timePicker)
                    this.clickApply();
            }

            this.updateView();

            //This is to cancel the blur event handler if the mouse was in one of the inputs
            e.stopPropagation();

        },

        calculateChosenLabel: function () {
            var customRange = true;
            var i = 0;
            for (var range in this.ranges) {
                if (this.timePicker) {
                    if (this.startDate.isSame(this.ranges[range][0]) && this.endDate.isSame(this.ranges[range][1])) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                } else {
                    //ignore times when comparing dates if time picker is not enabled
                    if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
                        customRange = false;
                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
                        break;
                    }
                }
                i++;
            }
            if (customRange) {
                if (this.showCustomRangeLabel) {
                    this.chosenLabel = this.container.find('.ranges li:last').addClass('active').html();
                } else {
                    this.chosenLabel = null;
                }
                this.showCalendars();
            }
        },

        clickApply: function(e) {
            this.hide();
            this.element.trigger('apply.daterangepicker', this);
        },

        clickCancel: function(e) {
            this.startDate = this.oldStartDate;
            this.endDate = this.oldEndDate;
            this.hide();
            this.element.trigger('cancel.daterangepicker', this);
        },

        monthOrYearChanged: function(e) {
            var isLeft = $(e.target).closest('.calendar').hasClass('left'),
                leftOrRight = isLeft ? 'left' : 'right',
                cal = this.container.find('.calendar.'+leftOrRight);

            // Month must be Number for new moment versions
            var month = parseInt(cal.find('.monthselect').val(), 10);
            var year = cal.find('.yearselect').val();

            if (!isLeft) {
                if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
                    month = this.startDate.month();
                    year = this.startDate.year();
                }
            }

            if (this.minDate) {
                if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
                    month = this.minDate.month();
                    year = this.minDate.year();
                }
            }

            if (this.maxDate) {
                if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
                    month = this.maxDate.month();
                    year = this.maxDate.year();
                }
            }

            if (isLeft) {
                this.leftCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
            } else {
                this.rightCalendar.month.month(month).year(year);
                if (this.linkedCalendars)
                    this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
            }
            this.updateCalendars();
        },

        timeChanged: function(e) {

            var cal = $(e.target).closest('.calendar'),
                isLeft = cal.hasClass('left');

            var hour = parseInt(cal.find('.hourselect').val(), 10);
            var minute = parseInt(cal.find('.minuteselect').val(), 10);
            var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;

            if (!this.timePicker24Hour) {
                var ampm = cal.find('.ampmselect').val();
                if (ampm === 'PM' && hour < 12)
                    hour += 12;
                if (ampm === 'AM' && hour === 12)
                    hour = 0;
            }

            if (isLeft) {
                var start = this.startDate.clone();
                start.hour(hour);
                start.minute(minute);
                start.second(second);
                this.setStartDate(start);
                if (this.singleDatePicker) {
                    this.endDate = this.startDate.clone();
                } else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
                    this.setEndDate(start.clone());
                }
            } else if (this.endDate) {
                var end = this.endDate.clone();
                end.hour(hour);
                end.minute(minute);
                end.second(second);
                this.setEndDate(end);
            }

            //update the calendars so all clickable dates reflect the new time component
            this.updateCalendars();

            //update the form inputs above the calendars with the new time
            this.updateFormInputs();

            //re-render the time pickers because changing one selection can affect what's enabled in another
            this.renderTimePicker('left');
            this.renderTimePicker('right');

        },

        formInputsChanged: function(e) {
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            var start = moment(this.container.find('input[name="daterangepicker_start"]').val(), this.locale.format);
            var end = moment(this.container.find('input[name="daterangepicker_end"]').val(), this.locale.format);

            if (start.isValid() && end.isValid()) {

                if (isRight && end.isBefore(start))
                    start = end.clone();

                this.setStartDate(start);
                this.setEndDate(end);

                if (isRight) {
                    this.container.find('input[name="daterangepicker_start"]').val(this.startDate.format(this.locale.format));
                } else {
                    this.container.find('input[name="daterangepicker_end"]').val(this.endDate.format(this.locale.format));
                }

            }

            this.updateView();
        },

        formInputsFocused: function(e) {

            // Highlight the focused input
            this.container.find('input[name="daterangepicker_start"], input[name="daterangepicker_end"]').removeClass('active');
            $(e.target).addClass('active');

            // Set the state such that if the user goes back to using a mouse, 
            // the calendars are aware we're selecting the end of the range, not
            // the start. This allows someone to edit the end of a date range without
            // re-selecting the beginning, by clicking on the end date input then
            // using the calendar.
            var isRight = $(e.target).closest('.calendar').hasClass('right');
            if (isRight) {
                this.endDate = null;
                this.setStartDate(this.startDate.clone());
                this.updateView();
            }

        },

        formInputsBlurred: function(e) {

            // this function has one purpose right now: if you tab from the first
            // text input to the second in the UI, the endDate is nulled so that
            // you can click another, but if you tab out without clicking anything
            // or changing the input value, the old endDate should be retained

            if (!this.endDate) {
                var val = this.container.find('input[name="daterangepicker_end"]').val();
                var end = moment(val, this.locale.format);
                if (end.isValid()) {
                    this.setEndDate(end);
                    this.updateView();
                }
            }

        },

        elementChanged: function() {
            if (!this.element.is('input')) return;
            if (!this.element.val().length) return;
            if (this.element.val().length < this.locale.format.length) return;

            var dateString = this.element.val().split(this.locale.separator),
                start = null,
                end = null;

            if (dateString.length === 2) {
                start = moment(dateString[0], this.locale.format);
                end = moment(dateString[1], this.locale.format);
            }

            if (this.singleDatePicker || start === null || end === null) {
                start = moment(this.element.val(), this.locale.format);
                end = start;
            }

            if (!start.isValid() || !end.isValid()) return;

            this.setStartDate(start);
            this.setEndDate(end);
            this.updateView();
        },

        keydown: function(e) {
            //hide on tab or enter
            if ((e.keyCode === 9) || (e.keyCode === 13)) {
                this.hide();
            }
        },

        updateElement: function() {
            if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
                this.element.trigger('change');
            } else if (this.element.is('input') && this.autoUpdateInput) {
                this.element.val(this.startDate.format(this.locale.format));
                this.element.trigger('change');
            }
        },

        remove: function() {
            this.container.remove();
            this.element.off('.daterangepicker');
            this.element.removeData();
        }

    };

    $.fn.daterangepicker = function(options, callback) {
        this.each(function() {
            var el = $(this);
            if (el.data('daterangepicker'))
                el.data('daterangepicker').remove();
            el.data('daterangepicker', new DateRangePicker(el, options, callback));
        });
        return this;
    };

    return DateRangePicker;

}));


/***/ }),

/***/ "./node_modules/fullcalendar/dist/fullcalendar.js":
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__("./node_modules/jquery/dist/jquery.js"), __webpack_require__("./node_modules/moment/moment.js"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery", "moment"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jquery"), require("moment")) : factory(root["jQuery"], root["moment"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 72);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {


/*
derived from:
https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js

only include the helpers we need, to keep down filesize
*/

var extendStatics =
	/* NOTE: tslib's as-is method is not compatible with how CoffeeScript does subclasses.
	 * When CoffeeScript is stripped out, can revert.
	 *
	 * Object.setPrototypeOf ||
	 * ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	 */
	function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

exports.__extends = function (d, b) {
	extendStatics(d, b);
	function __() { this.constructor = d; }
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
    if (scrollbarWidths.left) {
        rowEls.css({
            'border-left-width': 1,
            'margin-left': scrollbarWidths.left - 1
        });
    }
    if (scrollbarWidths.right) {
        rowEls.css({
            'border-right-width': 1,
            'margin-right': scrollbarWidths.right - 1
        });
    }
}
exports.compensateScroll = compensateScroll;
// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
    rowEls.css({
        'margin-left': '',
        'margin-right': '',
        'border-left-width': '',
        'border-right-width': ''
    });
}
exports.uncompensateScroll = uncompensateScroll;
// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
    $('body').addClass('fc-not-allowed');
}
exports.disableCursor = disableCursor;
// Returns the mouse cursor to its original look
function enableCursor() {
    $('body').removeClass('fc-not-allowed');
}
exports.enableCursor = enableCursor;
// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {
    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
    var flexEls = []; // elements that are allowed to expand. array of DOM nodes
    var flexOffsets = []; // amount of vertical space it takes up
    var flexHeights = []; // actual css height
    var usedHeight = 0;
    undistributeHeight(els); // give all elements their natural height
    // find elements that are below the recommended height (expandable).
    // important to query for heights in a single first pass (to avoid reflow oscillation).
    els.each(function (i, el) {
        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = $(el).outerHeight(true);
        if (naturalOffset < minOffset) {
            flexEls.push(el);
            flexOffsets.push(naturalOffset);
            flexHeights.push($(el).height());
        }
        else {
            // this element stretches past recommended height (non-expandable). mark the space as occupied.
            usedHeight += naturalOffset;
        }
    });
    // readjust the recommended height to only consider the height available to non-maxed-out rows.
    if (shouldRedistribute) {
        availableHeight -= usedHeight;
        minOffset1 = Math.floor(availableHeight / flexEls.length);
        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
    }
    // assign heights to all expandable elements
    $(flexEls).each(function (i, el) {
        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = flexOffsets[i];
        var naturalHeight = flexHeights[i];
        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
        if (naturalOffset < minOffset) {
            $(el).height(newHeight);
        }
    });
}
exports.distributeHeight = distributeHeight;
// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
    els.height('');
}
exports.undistributeHeight = undistributeHeight;
// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
    var maxInnerWidth = 0;
    els.find('> *').each(function (i, innerEl) {
        var innerWidth = $(innerEl).outerWidth();
        if (innerWidth > maxInnerWidth) {
            maxInnerWidth = innerWidth;
        }
    });
    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
    els.width(maxInnerWidth);
    return maxInnerWidth;
}
exports.matchCellWidths = matchCellWidths;
// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
    var both = outerEl.add(innerEl);
    var diff;
    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
    both.css({
        position: 'relative',
        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
    });
    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
    both.css({ position: '', left: '' }); // undo hack
    return diff;
}
exports.subtractInnerElHeight = subtractInnerElHeight;
/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/
// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
    var position = el.css('position'), scrollParent = el.parents().filter(function () {
        var parent = $(this);
        return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
    }).eq(0);
    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}
exports.getScrollParent = getScrollParent;
// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
    var offset = el.offset();
    var left = offset.left - (origin ? origin.left : 0);
    var top = offset.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.outerWidth(),
        top: top,
        bottom: top + el.outerHeight()
    };
}
exports.getOuterRect = getOuterRect;
// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
    var offset = el.offset();
    var scrollbarWidths = getScrollbarWidths(el);
    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el[0].clientWidth,
        top: top,
        bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
    };
}
exports.getClientRect = getClientRect;
// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
    var offset = el.offset(); // just outside of border, margin not included
    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
        (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
        (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.width(),
        top: top,
        bottom: top + el.height()
    };
}
exports.getContentRect = getContentRect;
// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
    var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
    var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
    var widths;
    leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
    bottomWidth = sanitizeScrollbarWidth(bottomWidth);
    widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };
    if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') {
        widths.left = leftRightWidth;
    }
    else {
        widths.right = leftRightWidth;
    }
    return widths;
}
exports.getScrollbarWidths = getScrollbarWidths;
// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
    width = Math.max(0, width); // no negatives
    width = Math.round(width);
    return width;
}
// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
var _isLeftRtlScrollbars = null;
function getIsLeftRtlScrollbars() {
    if (_isLeftRtlScrollbars === null) {
        _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
    }
    return _isLeftRtlScrollbars;
}
function computeIsLeftRtlScrollbars() {
    var el = $('<div><div/></div>')
        .css({
        position: 'absolute',
        top: -1000,
        left: 0,
        border: 0,
        padding: 0,
        overflow: 'scroll',
        direction: 'rtl'
    })
        .appendTo('body');
    var innerEl = el.children();
    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
    el.remove();
    return res;
}
// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
    return parseFloat(el.css(prop)) || 0;
}
/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
    return ev.which == 1 && !ev.ctrlKey;
}
exports.isPrimaryMouseButton = isPrimaryMouseButton;
function getEvX(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageX;
    }
    return ev.pageX;
}
exports.getEvX = getEvX;
function getEvY(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageY;
    }
    return ev.pageY;
}
exports.getEvY = getEvY;
function getEvIsTouch(ev) {
    return /^touch/.test(ev.type);
}
exports.getEvIsTouch = getEvIsTouch;
function preventSelection(el) {
    el.addClass('fc-unselectable')
        .on('selectstart', preventDefault);
}
exports.preventSelection = preventSelection;
function allowSelection(el) {
    el.removeClass('fc-unselectable')
        .off('selectstart', preventDefault);
}
exports.allowSelection = allowSelection;
// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
    ev.preventDefault();
}
exports.preventDefault = preventDefault;
/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/
// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
    var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
    };
    if (res.left < res.right && res.top < res.bottom) {
        return res;
    }
    return false;
}
exports.intersectRects = intersectRects;
// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
    return {
        left: Math.min(Math.max(point.left, rect.left), rect.right),
        top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
}
exports.constrainPoint = constrainPoint;
// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
    return {
        left: (rect.left + rect.right) / 2,
        top: (rect.top + rect.bottom) / 2
    };
}
exports.getRectCenter = getRectCenter;
// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
    return {
        left: point1.left - point2.left,
        top: point1.top - point2.top
    };
}
exports.diffPoints = diffPoints;
/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/
function parseFieldSpecs(input) {
    var specs = [];
    var tokens = [];
    var i, token;
    if (typeof input === 'string') {
        tokens = input.split(/\s*,\s*/);
    }
    else if (typeof input === 'function') {
        tokens = [input];
    }
    else if ($.isArray(input)) {
        tokens = input;
    }
    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (typeof token === 'string') {
            specs.push(token.charAt(0) == '-' ?
                { field: token.substring(1), order: -1 } :
                { field: token, order: 1 });
        }
        else if (typeof token === 'function') {
            specs.push({ func: token });
        }
    }
    return specs;
}
exports.parseFieldSpecs = parseFieldSpecs;
function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
    var i;
    var cmp;
    for (i = 0; i < fieldSpecs.length; i++) {
        cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
        if (cmp) {
            return cmp;
        }
    }
    return 0;
}
exports.compareByFieldSpecs = compareByFieldSpecs;
function compareByFieldSpec(obj1, obj2, fieldSpec) {
    if (fieldSpec.func) {
        return fieldSpec.func(obj1, obj2);
    }
    return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
        (fieldSpec.order || 1);
}
exports.compareByFieldSpec = compareByFieldSpec;
function flexibleCompare(a, b) {
    if (!a && !b) {
        return 0;
    }
    if (b == null) {
        return -1;
    }
    if (a == null) {
        return 1;
    }
    if ($.type(a) === 'string' || $.type(b) === 'string') {
        return String(a).localeCompare(String(b));
    }
    return a - b;
}
exports.flexibleCompare = flexibleCompare;
/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/
exports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
exports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending
// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
        ms: a.time() - b.time() // time-of-day from day start. disregards timezone
    });
}
exports.diffDayTime = diffDayTime;
// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
    });
}
exports.diffDay = diffDay;
// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true
    unit);
}
exports.diffByUnit = diffByUnit;
// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
    var i, unit;
    var val;
    for (i = 0; i < exports.unitsDesc.length; i++) {
        unit = exports.unitsDesc[i];
        val = computeRangeAs(unit, start, end);
        if (val >= 1 && isInt(val)) {
            break;
        }
    }
    return unit; // will be "milliseconds" if nothing else matches
}
exports.computeGreatestUnit = computeGreatestUnit;
// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
    var unit = computeGreatestUnit(duration);
    // prevent days:7 from being interpreted as a week
    if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
        unit = 'day';
    }
    return unit;
}
exports.computeDurationGreatestUnit = computeDurationGreatestUnit;
// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {
    if (end != null) {
        return end.diff(start, unit, true);
    }
    else if (moment.isDuration(start)) {
        return start.as(unit);
    }
    else {
        return start.end.diff(start.start, unit, true);
    }
}
// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
    var months;
    if (durationHasTime(dur)) {
        return (end - start) / dur;
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return end.diff(start, 'months', true) / months;
    }
    return end.diff(start, 'days', true) / dur.asDays();
}
exports.divideRangeByDuration = divideRangeByDuration;
// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
    var months1, months2;
    if (durationHasTime(dur1) || durationHasTime(dur2)) {
        return dur1 / dur2;
    }
    months1 = dur1.asMonths();
    months2 = dur2.asMonths();
    if (Math.abs(months1) >= 1 && isInt(months1) &&
        Math.abs(months2) >= 1 && isInt(months2)) {
        return months1 / months2;
    }
    return dur1.asDays() / dur2.asDays();
}
exports.divideDurationByDuration = divideDurationByDuration;
// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
    var months;
    if (durationHasTime(dur)) {
        return moment.duration(dur * n);
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return moment.duration({ months: months * n });
    }
    return moment.duration({ days: dur.asDays() * n });
}
exports.multiplyDuration = multiplyDuration;
// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}
exports.durationHasTime = durationHasTime;
function isNativeDate(input) {
    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}
exports.isNativeDate = isNativeDate;
// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
    return typeof str === 'string' &&
        /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}
exports.isTimeString = isTimeString;
/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.log) {
        return console.log.apply(console, args);
    }
}
exports.log = log;
function warn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.warn) {
        return console.warn.apply(console, args);
    }
    else {
        return log.apply(null, args);
    }
}
exports.warn = warn;
/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/
var hasOwnPropMethod = {}.hasOwnProperty;
// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
    var dest = {};
    var i, name;
    var complexObjs;
    var j, val;
    var props;
    if (complexProps) {
        for (i = 0; i < complexProps.length; i++) {
            name = complexProps[i];
            complexObjs = [];
            // collect the trailing object values, stopping when a non-object is discovered
            for (j = propObjs.length - 1; j >= 0; j--) {
                val = propObjs[j][name];
                if (typeof val === 'object') {
                    complexObjs.unshift(val);
                }
                else if (val !== undefined) {
                    dest[name] = val; // if there were no objects, this value will be used
                    break;
                }
            }
            // if the trailing values were objects, use the merged value
            if (complexObjs.length) {
                dest[name] = mergeProps(complexObjs);
            }
        }
    }
    // copy values into the destination, going from last to first
    for (i = propObjs.length - 1; i >= 0; i--) {
        props = propObjs[i];
        for (name in props) {
            if (!(name in dest)) {
                dest[name] = props[name];
            }
        }
    }
    return dest;
}
exports.mergeProps = mergeProps;
function copyOwnProps(src, dest) {
    for (var name in src) {
        if (hasOwnProp(src, name)) {
            dest[name] = src[name];
        }
    }
}
exports.copyOwnProps = copyOwnProps;
function hasOwnProp(obj, name) {
    return hasOwnPropMethod.call(obj, name);
}
exports.hasOwnProp = hasOwnProp;
function applyAll(functions, thisObj, args) {
    if ($.isFunction(functions)) {
        functions = [functions];
    }
    if (functions) {
        var i;
        var ret;
        for (i = 0; i < functions.length; i++) {
            ret = functions[i].apply(thisObj, args) || ret;
        }
        return ret;
    }
}
exports.applyAll = applyAll;
function removeMatching(array, testFunc) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (testFunc(array[i])) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeMatching = removeMatching;
function removeExact(array, exactVal) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (array[i] === exactVal) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeExact = removeExact;
function isArraysEqual(a0, a1) {
    var len = a0.length;
    var i;
    if (len == null || len !== a1.length) {
        return false;
    }
    for (i = 0; i < len; i++) {
        if (a0[i] !== a1[i]) {
            return false;
        }
    }
    return true;
}
exports.isArraysEqual = isArraysEqual;
function firstDefined() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        if (args[i] !== undefined) {
            return args[i];
        }
    }
}
exports.firstDefined = firstDefined;
function htmlEscape(s) {
    return (s + '').replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/'/g, '&#039;')
        .replace(/"/g, '&quot;')
        .replace(/\n/g, '<br />');
}
exports.htmlEscape = htmlEscape;
function stripHtmlEntities(text) {
    return text.replace(/&.*?;/g, '');
}
exports.stripHtmlEntities = stripHtmlEntities;
// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
    var statements = [];
    $.each(cssProps, function (name, val) {
        if (val != null) {
            statements.push(name + ':' + val);
        }
    });
    return statements.join(';');
}
exports.cssToStr = cssToStr;
// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
    var parts = [];
    $.each(attrs, function (name, val) {
        if (val != null) {
            parts.push(name + '="' + htmlEscape(val) + '"');
        }
    });
    return parts.join(' ');
}
exports.attrsToStr = attrsToStr;
function capitaliseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.capitaliseFirstLetter = capitaliseFirstLetter;
function compareNumbers(a, b) {
    return a - b;
}
exports.compareNumbers = compareNumbers;
function isInt(n) {
    return n % 1 === 0;
}
exports.isInt = isInt;
// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
    var method = obj[methodName];
    return function () {
        return method.apply(obj, arguments);
    };
}
exports.proxy = proxy;
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
    if (immediate === void 0) { immediate = false; }
    var timeout, args, context, timestamp, result;
    var later = function () {
        var last = +new Date() - timestamp;
        if (last < wait) {
            timeout = setTimeout(later, wait - last);
        }
        else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    };
    return function () {
        context = this;
        args = arguments;
        timestamp = +new Date();
        var callNow = immediate && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
}
exports.debounce = debounce;


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var moment_ext_1 = __webpack_require__(9);
var UnzonedRange = /** @class */ (function () {
    function UnzonedRange(startInput, endInput) {
        // TODO: move these into footprint.
        // Especially, doesn't make sense for null startMs/endMs.
        this.isStart = true;
        this.isEnd = true;
        if (moment.isMoment(startInput)) {
            startInput = startInput.clone().stripZone();
        }
        if (moment.isMoment(endInput)) {
            endInput = endInput.clone().stripZone();
        }
        if (startInput) {
            this.startMs = startInput.valueOf();
        }
        if (endInput) {
            this.endMs = endInput.valueOf();
        }
    }
    UnzonedRange.prototype.intersect = function (otherRange) {
        var startMs = this.startMs;
        var endMs = this.endMs;
        var newRange = null;
        if (otherRange.startMs != null) {
            if (startMs == null) {
                startMs = otherRange.startMs;
            }
            else {
                startMs = Math.max(startMs, otherRange.startMs);
            }
        }
        if (otherRange.endMs != null) {
            if (endMs == null) {
                endMs = otherRange.endMs;
            }
            else {
                endMs = Math.min(endMs, otherRange.endMs);
            }
        }
        if (startMs == null || endMs == null || startMs < endMs) {
            newRange = new UnzonedRange(startMs, endMs);
            newRange.isStart = this.isStart && startMs === this.startMs;
            newRange.isEnd = this.isEnd && endMs === this.endMs;
        }
        return newRange;
    };
    UnzonedRange.prototype.intersectsWith = function (otherRange) {
        return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&
            (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);
    };
    UnzonedRange.prototype.containsRange = function (innerRange) {
        return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&
            (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));
    };
    // `date` can be a moment, a Date, or a millisecond time.
    UnzonedRange.prototype.containsDate = function (date) {
        var ms = date.valueOf();
        return (this.startMs == null || ms >= this.startMs) &&
            (this.endMs == null || ms < this.endMs);
    };
    // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).
    // `date` can be a moment, a Date, or a millisecond time.
    // Returns a MS-time.
    UnzonedRange.prototype.constrainDate = function (date) {
        var ms = date.valueOf();
        if (this.startMs != null && ms < this.startMs) {
            ms = this.startMs;
        }
        if (this.endMs != null && ms >= this.endMs) {
            ms = this.endMs - 1;
        }
        return ms;
    };
    UnzonedRange.prototype.equals = function (otherRange) {
        return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;
    };
    UnzonedRange.prototype.clone = function () {
        var range = new UnzonedRange(this.startMs, this.endMs);
        range.isStart = this.isStart;
        range.isEnd = this.isEnd;
        return range;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getStart = function () {
        if (this.startMs != null) {
            return moment_ext_1.default.utc(this.startMs).stripZone();
        }
        return null;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getEnd = function () {
        if (this.endMs != null) {
            return moment_ext_1.default.utc(this.endMs).stripZone();
        }
        return null;
    };
    UnzonedRange.prototype.as = function (unit) {
        return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);
    };
    /*
    SIDEEFFECT: will mutate eventRanges.
    Will return a new array result.
    Only works for non-open-ended ranges.
    */
    UnzonedRange.invertRanges = function (ranges, constraintRange) {
        var invertedRanges = [];
        var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range
        var i;
        var dateRange;
        // ranges need to be in order. required for our date-walking algorithm
        ranges.sort(compareUnzonedRanges);
        for (i = 0; i < ranges.length; i++) {
            dateRange = ranges[i];
            // add the span of time before the event (if there is any)
            if (dateRange.startMs > startMs) {
                invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));
            }
            if (dateRange.endMs > startMs) {
                startMs = dateRange.endMs;
            }
        }
        // add the span of time after the last event (if there is any)
        if (startMs < constraintRange.endMs) {
            invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));
        }
        return invertedRanges;
    };
    return UnzonedRange;
}());
exports.default = UnzonedRange;
/*
Only works for non-open-ended ranges.
*/
function compareUnzonedRanges(range1, range2) {
    return range1.startMs - range2.startMs; // earlier ranges go first
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var ParsableModelMixin_1 = __webpack_require__(50);
var Class_1 = __webpack_require__(21);
var EventDefParser_1 = __webpack_require__(33);
var EventSource = /** @class */ (function (_super) {
    tslib_1.__extends(EventSource, _super);
    // can we do away with calendar? at least for the abstract?
    // useful for buildEventDef
    function EventSource(calendar) {
        var _this = _super.call(this) || this;
        _this.calendar = calendar;
        _this.className = [];
        _this.uid = String(EventSource.uuid++);
        return _this;
    }
    EventSource.prototype.fetch = function (start, end, timezone) {
        // subclasses must implement. must return a promise.
    };
    EventSource.prototype.removeEventDefsById = function (eventDefId) {
        // optional for subclasses to implement
    };
    EventSource.prototype.removeAllEventDefs = function () {
        // optional for subclasses to implement
    };
    /*
    For compairing/matching
    */
    EventSource.prototype.getPrimitive = function (otherSource) {
        // subclasses must implement
    };
    EventSource.prototype.parseEventDefs = function (rawEventDefs) {
        var i;
        var eventDef;
        var eventDefs = [];
        for (i = 0; i < rawEventDefs.length; i++) {
            eventDef = this.parseEventDef(rawEventDefs[i]);
            if (eventDef) {
                eventDefs.push(eventDef);
            }
        }
        return eventDefs;
    };
    EventSource.prototype.parseEventDef = function (rawInput) {
        var calendarTransform = this.calendar.opt('eventDataTransform');
        var sourceTransform = this.eventDataTransform;
        if (calendarTransform) {
            rawInput = calendarTransform(rawInput);
        }
        if (sourceTransform) {
            rawInput = sourceTransform(rawInput);
        }
        return EventDefParser_1.default.parse(rawInput, this);
    };
    EventSource.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventSource.normalizeId(rawProps.id);
        }
        // TODO: converge with EventDef
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        else if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    /*
    rawInput can be any data type!
    */
    EventSource.parse = function (rawInput, calendar) {
        var source = new this(calendar);
        if (typeof rawInput === 'object') {
            if (source.applyProps(rawInput)) {
                return source;
            }
        }
        return false;
    };
    EventSource.normalizeId = function (id) {
        if (id) {
            return String(id);
        }
        return null;
    };
    EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    // IDs
    // -----------------------------------------------------------------------------------------------------------------
    // TODO: converge with EventDef
    EventSource.uuid = 0;
    return EventSource;
}(Class_1.default));
exports.default = EventSource;
ParsableModelMixin_1.default.mixInto(EventSource);
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
EventSource.defineStandardProps({
    // manually process...
    id: false,
    className: false,
    // automatically transfer...
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    rendering: true,
    overlap: true,
    constraint: true,
    allDayDefault: true,
    eventDataTransform: true
});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.

USAGE:
    import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'
in class:
    listenTo: ListenerInterface['listenTo']
    stopListeningTo: ListenerInterface['stopListeningTo']
after class:
    ListenerMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var Mixin_1 = __webpack_require__(12);
var guid = 0;
var ListenerMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ListenerMixin, _super);
    function ListenerMixin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listenerId = null;
        return _this;
    }
    /*
    Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
    The `callback` will be called with the `this` context of the object that .listenTo is being called on.
    Can be called:
        .listenTo(other, eventName, callback)
    OR
        .listenTo(other, {
            eventName1: callback1,
            eventName2: callback2
        })
    */
    ListenerMixin.prototype.listenTo = function (other, arg, callback) {
        if (typeof arg === 'object') {
            for (var eventName in arg) {
                if (arg.hasOwnProperty(eventName)) {
                    this.listenTo(other, eventName, arg[eventName]);
                }
            }
        }
        else if (typeof arg === 'string') {
            other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
            $.proxy(callback, this) // always use `this` context
            // the usually-undesired jQuery guid behavior doesn't matter,
            // because we always unbind via namespace
            );
        }
    };
    /*
    Causes the current object to stop listening to events on the `other` object.
    `eventName` is optional. If omitted, will stop listening to ALL events on `other`.
    */
    ListenerMixin.prototype.stopListeningTo = function (other, eventName) {
        other.off((eventName || '') + '.' + this.getListenerNamespace());
    };
    /*
    Returns a string, unique to this object, to be used for event namespacing
    */
    ListenerMixin.prototype.getListenerNamespace = function () {
        if (this.listenerId == null) {
            this.listenerId = guid++;
        }
        return '_listener' + this.listenerId;
    };
    return ListenerMixin;
}(Mixin_1.default));
exports.default = ListenerMixin;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    version: "<%= version %>",
    // When introducing internal API incompatibilities (where fullcalendar plugins would break),
    // the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
    // and the below integer should be incremented.
    internalApiVersion: 12,
    // for GlobalEmitter
    touchMouseIgnoreWait: 500,
    // for ExternalDropping
    // Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
    // A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
    dataAttrPrefix: '',
    views: {},
    locales: {}
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
    import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
in class:
    on: EmitterInterface['on']
    one: EmitterInterface['one']
    off: EmitterInterface['off']
    trigger: EmitterInterface['trigger']
    triggerWith: EmitterInterface['triggerWith']
    hasHandlers: EmitterInterface['hasHandlers']
after class:
    EmitterMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var Mixin_1 = __webpack_require__(12);
var EmitterMixin = /** @class */ (function (_super) {
    tslib_1.__extends(EmitterMixin, _super);
    function EmitterMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // jQuery-ification via $(this) allows a non-DOM object to have
    // the same event handling capabilities (including namespaces).
    EmitterMixin.prototype.on = function (types, handler) {
        $(this).on(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype.one = function (types, handler) {
        $(this).one(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype._prepareIntercept = function (handler) {
        // handlers are always called with an "event" object as their first param.
        // sneak the `this` context and arguments into the extra parameter object
        // and forward them on to the original handler.
        var intercept = function (ev, extra) {
            return handler.apply(extra.context || this, extra.args || []);
        };
        // mimick jQuery's internal "proxy" system (risky, I know)
        // causing all functions with the same .guid to appear to be the same.
        // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
        // this is needed for calling .off with the original non-intercept handler.
        if (!handler.guid) {
            handler.guid = $.guid++;
        }
        intercept.guid = handler.guid;
        return intercept;
    };
    EmitterMixin.prototype.off = function (types, handler) {
        $(this).off(types, handler);
        return this; // for chaining
    };
    EmitterMixin.prototype.trigger = function (types) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // pass in "extra" info to the intercept
        $(this).triggerHandler(types, { args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.triggerWith = function (types, context, args) {
        // `triggerHandler` is less reliant on the DOM compared to `trigger`.
        // pass in "extra" info to the intercept.
        $(this).triggerHandler(types, { context: context, args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.hasHandlers = function (type) {
        var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/
        return hash && hash[type] && hash[type].length > 0;
    };
    return EmitterMixin;
}(Mixin_1.default));
exports.default = EmitterMixin;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
/*
GENERAL NOTE on moments throughout the *entire rest* of the codebase:
All moments are assumed to be ambiguously-zoned unless otherwise noted,
with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
*/
var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
exports.newMomentProto = newMomentProto;
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
exports.oldMomentProto = oldMomentProto;
// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');
/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}
exports.oldMomentFormat = oldMomentFormat;
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
var momentExt = function () {
    return makeMoment(arguments);
};
exports.default = momentExt;
// Sames as momentExt, but forces the resulting moment to be in the UTC timezone.
momentExt.utc = function () {
    var mom = makeMoment(arguments, true);
    // Force it into UTC because makeMoment doesn't guarantee it
    // (if given a pre-existing moment for example)
    if (mom.hasTime()) {
        mom.utc();
    }
    return mom;
};
// Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
momentExt.parseZone = function () {
    return makeMoment(arguments, true, true);
};
// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
    if (parseAsUTC === void 0) { parseAsUTC = false; }
    if (parseZone === void 0) { parseZone = false; }
    var input = args[0];
    var isSingleString = args.length == 1 && typeof input === 'string';
    var isAmbigTime;
    var isAmbigZone;
    var ambigMatch;
    var mom;
    if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {
        mom = moment.apply(null, args);
    }
    else {
        isAmbigTime = false;
        isAmbigZone = false;
        if (isSingleString) {
            if (ambigDateOfMonthRegex.test(input)) {
                // accept strings like '2014-05', but convert to the first of the month
                input += '-01';
                args = [input]; // for when we pass it on to moment's constructor
                isAmbigTime = true;
                isAmbigZone = true;
            }
            else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
                isAmbigTime = !ambigMatch[5]; // no time part?
                isAmbigZone = true;
            }
        }
        else if ($.isArray(input)) {
            // arrays have no timezone information, so assume ambiguous zone
            isAmbigZone = true;
        }
        // otherwise, probably a string with a format
        if (parseAsUTC || isAmbigTime) {
            mom = moment.utc.apply(moment, args);
        }
        else {
            mom = moment.apply(null, args);
        }
        if (isAmbigTime) {
            mom._ambigTime = true;
            mom._ambigZone = true; // ambiguous time always means ambiguous zone
        }
        else if (parseZone) {
            if (isAmbigZone) {
                mom._ambigZone = true;
            }
            else if (isSingleString) {
                mom.utcOffset(input); // if not a valid zone, will assign UTC
            }
        }
    }
    mom._fullCalendar = true; // flag for extended functionality
    return mom;
}
// Week Number
// -------------------------------------------------------------------------------------------------
// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function (input) {
    var weekCalc = this._locale._fullCalendar_weekCalc;
    if (input == null && typeof weekCalc === 'function') {
        return weekCalc(this);
    }
    else if (weekCalc === 'ISO') {
        return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
    }
    return oldMomentProto.week.apply(this, arguments); // local getter/setter
};
// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function (time) {
    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
    if (!this._fullCalendar) {
        return oldMomentProto.time.apply(this, arguments);
    }
    if (time == null) {
        return moment.duration({
            hours: this.hours(),
            minutes: this.minutes(),
            seconds: this.seconds(),
            milliseconds: this.milliseconds()
        });
    }
    else {
        this._ambigTime = false; // mark that the moment now has a time
        if (!moment.isDuration(time) && !moment.isMoment(time)) {
            time = moment.duration(time);
        }
        // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
        // Only for Duration times, not Moment times.
        var dayHours = 0;
        if (moment.isDuration(time)) {
            dayHours = Math.floor(time.asDays()) * 24;
        }
        // We need to set the individual fields.
        // Can't use startOf('day') then add duration. In case of DST at start of day.
        return this.hours(dayHours + time.hours())
            .minutes(time.minutes())
            .seconds(time.seconds())
            .milliseconds(time.milliseconds());
    }
};
// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function () {
    if (!this._ambigTime) {
        this.utc(true); // keepLocalTime=true (for keeping *date* value)
        // set time to zero
        this.set({
            hours: 0,
            minutes: 0,
            seconds: 0,
            ms: 0
        });
        // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears all ambig flags.
        this._ambigTime = true;
        this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
    }
    return this; // for chaining
};
// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function () {
    return !this._ambigTime;
};
// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function () {
    var wasAmbigTime;
    if (!this._ambigZone) {
        wasAmbigTime = this._ambigTime;
        this.utc(true); // keepLocalTime=true (for keeping date and time values)
        // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
        this._ambigTime = wasAmbigTime || false;
        // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears the ambig flags.
        this._ambigZone = true;
    }
    return this; // for chaining
};
// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function () {
    return !this._ambigZone;
};
// implicitly marks a zone
newMomentProto.local = function (keepLocalTime) {
    // for when converting from ambiguously-zoned to local,
    // keep the time values when converting from UTC -> local
    oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this; // for chaining
};
// implicitly marks a zone
newMomentProto.utc = function (keepLocalTime) {
    oldMomentProto.utc.call(this, keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this;
};
// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function (tzo) {
    if (tzo != null) {
        // these assignments needs to happen before the original zone method is called.
        // I forget why, something to do with a browser crash.
        this._ambigTime = false;
        this._ambigZone = false;
    }
    return oldMomentProto.utcOffset.apply(this, arguments);
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
/*
Meant to be immutable
*/
var ComponentFootprint = /** @class */ (function () {
    function ComponentFootprint(unzonedRange, isAllDay) {
        this.isAllDay = false; // component can choose to ignore this
        this.unzonedRange = unzonedRange;
        this.isAllDay = isAllDay;
    }
    /*
    Only works for non-open-ended ranges.
    */
    ComponentFootprint.prototype.toLegacy = function (calendar) {
        return {
            start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),
            end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)
        };
    };
    return ComponentFootprint;
}());
exports.default = ComponentFootprint;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var EventDef_1 = __webpack_require__(22);
var EventInstance_1 = __webpack_require__(51);
var EventDateProfile_1 = __webpack_require__(15);
var SingleEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(SingleEventDef, _super);
    function SingleEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Will receive start/end params, but will be ignored.
    */
    SingleEventDef.prototype.buildInstances = function () {
        return [this.buildInstance()];
    };
    SingleEventDef.prototype.buildInstance = function () {
        return new EventInstance_1.default(this, // definition
        this.dateProfile);
    };
    SingleEventDef.prototype.isAllDay = function () {
        return this.dateProfile.isAllDay();
    };
    SingleEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        def.dateProfile = this.dateProfile;
        return def;
    };
    SingleEventDef.prototype.rezone = function () {
        var calendar = this.source.calendar;
        var dateProfile = this.dateProfile;
        this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);
    };
    /*
    NOTE: if super-method fails, should still attempt to apply
    */
    SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure
        if (dateProfile) {
            this.dateProfile = dateProfile;
            // make sure `date` shows up in the legacy event objects as-is
            if (rawProps.date != null) {
                this.miscProps.date = rawProps.date;
            }
            return superSuccess;
        }
        else {
            return false;
        }
    };
    return SingleEventDef;
}(EventDef_1.default));
exports.default = SingleEventDef;
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
SingleEventDef.defineStandardProps({
    start: false,
    date: false,
    end: false,
    allDay: false
});


/***/ }),
/* 12 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Mixin = /** @class */ (function () {
    function Mixin() {
    }
    Mixin.mixInto = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            if (!destClass.prototype[name]) {
                destClass.prototype[name] = _this.prototype[name];
            }
        });
    };
    /*
    will override existing methods
    */
    Mixin.mixOver = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            destClass.prototype[name] = _this.prototype[name];
        });
    };
    return Mixin;
}());
exports.default = Mixin;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Interaction = /** @class */ (function () {
    function Interaction(component) {
        this.view = component._getView();
        this.component = component;
    }
    Interaction.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    Interaction.prototype.end = function () {
        // subclasses can implement
    };
    return Interaction;
}());
exports.default = Interaction;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var namespace_hooks_1 = __webpack_require__(7);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var globalEmitter = null;
var neededCount = 0;
/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/
var GlobalEmitter = /** @class */ (function () {
    function GlobalEmitter() {
        this.isTouching = false;
        this.mouseIgnoreDepth = 0;
    }
    GlobalEmitter.prototype.bind = function () {
        var _this = this;
        this.listenTo($(document), {
            touchstart: this.handleTouchStart,
            touchcancel: this.handleTouchCancel,
            touchend: this.handleTouchEnd,
            mousedown: this.handleMouseDown,
            mousemove: this.handleMouseMove,
            mouseup: this.handleMouseUp,
            click: this.handleClick,
            selectstart: this.handleSelectStart,
            contextmenu: this.handleContextMenu
        });
        // because we need to call preventDefault
        // because https://www.chromestatus.com/features/5093566007214080
        // TODO: investigate performance because this is a global handler
        window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {
            _this.handleTouchMove($.Event(ev));
        }, { passive: false } // allows preventDefault()
        );
        // attach a handler to get called when ANY scroll action happens on the page.
        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
        // http://stackoverflow.com/a/32954565/96342
        window.addEventListener('scroll', this.handleScrollProxy = function (ev) {
            _this.handleScroll($.Event(ev));
        }, true // useCapture
        );
    };
    GlobalEmitter.prototype.unbind = function () {
        this.stopListeningTo($(document));
        window.removeEventListener('touchmove', this.handleTouchMoveProxy);
        window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture
        );
    };
    // Touch Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleTouchStart = function (ev) {
        // if a previous touch interaction never ended with a touchend, then implicitly end it,
        // but since a new touch interaction is about to begin, don't start the mouse ignore period.
        this.stopTouch(ev, true); // skipMouseIgnore=true
        this.isTouching = true;
        this.trigger('touchstart', ev);
    };
    GlobalEmitter.prototype.handleTouchMove = function (ev) {
        if (this.isTouching) {
            this.trigger('touchmove', ev);
        }
    };
    GlobalEmitter.prototype.handleTouchCancel = function (ev) {
        if (this.isTouching) {
            this.trigger('touchcancel', ev);
            // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
            // If touchend fires later, it won't have any effect b/c isTouching will be false.
            this.stopTouch(ev);
        }
    };
    GlobalEmitter.prototype.handleTouchEnd = function (ev) {
        this.stopTouch(ev);
    };
    // Mouse Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleMouseDown = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousedown', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseMove = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousemove', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseUp = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mouseup', ev);
        }
    };
    GlobalEmitter.prototype.handleClick = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('click', ev);
        }
    };
    // Misc Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleSelectStart = function (ev) {
        this.trigger('selectstart', ev);
    };
    GlobalEmitter.prototype.handleContextMenu = function (ev) {
        this.trigger('contextmenu', ev);
    };
    GlobalEmitter.prototype.handleScroll = function (ev) {
        this.trigger('scroll', ev);
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {
        if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }
        if (this.isTouching) {
            this.isTouching = false;
            this.trigger('touchend', ev);
            if (!skipMouseIgnore) {
                this.startTouchMouseIgnore();
            }
        }
    };
    GlobalEmitter.prototype.startTouchMouseIgnore = function () {
        var _this = this;
        var wait = namespace_hooks_1.default.touchMouseIgnoreWait;
        if (wait) {
            this.mouseIgnoreDepth++;
            setTimeout(function () {
                _this.mouseIgnoreDepth--;
            }, wait);
        }
    };
    GlobalEmitter.prototype.shouldIgnoreMouse = function () {
        return this.isTouching || Boolean(this.mouseIgnoreDepth);
    };
    // Singleton
    // -----------------------------------------------------------------------------------------------------------------
    // gets the singleton
    GlobalEmitter.get = function () {
        if (!globalEmitter) {
            globalEmitter = new GlobalEmitter();
            globalEmitter.bind();
        }
        return globalEmitter;
    };
    // called when an object knows it will need a GlobalEmitter in the near future.
    GlobalEmitter.needed = function () {
        GlobalEmitter.get(); // ensures globalEmitter
        neededCount++;
    };
    // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
    GlobalEmitter.unneeded = function () {
        neededCount--;
        if (!neededCount) {
            globalEmitter.unbind();
            globalEmitter = null;
        }
    };
    return GlobalEmitter;
}());
exports.default = GlobalEmitter;
ListenerMixin_1.default.mixInto(GlobalEmitter);
EmitterMixin_1.default.mixInto(GlobalEmitter);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(4);
/*
Meant to be immutable
*/
var EventDateProfile = /** @class */ (function () {
    function EventDateProfile(start, end, calendar) {
        this.start = start;
        this.end = end || null;
        this.unzonedRange = this.buildUnzonedRange(calendar);
    }
    EventDateProfile.prototype.isAllDay = function () {
        return !(this.start.hasTime() || (this.end && this.end.hasTime()));
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.buildUnzonedRange = function (calendar) {
        var startMs = this.start.clone().stripZone().valueOf();
        var endMs = this.getEnd(calendar).stripZone().valueOf();
        return new UnzonedRange_1.default(startMs, endMs);
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.getEnd = function (calendar) {
        return this.end ?
            this.end.clone() :
            // derive the end from the start and allDay. compute allDay if necessary
            calendar.getDefaultEventEnd(this.isAllDay(), this.start);
    };
    EventDateProfile.isStandardProp = function (propName) {
        return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';
    };
    /*
    Needs an EventSource object
    */
    EventDateProfile.parse = function (rawProps, source) {
        var startInput = rawProps.start || rawProps.date;
        var endInput = rawProps.end;
        if (!startInput) {
            return false;
        }
        var calendar = source.calendar;
        var start = calendar.moment(startInput);
        var end = endInput ? calendar.moment(endInput) : null;
        var forcedAllDay = rawProps.allDay;
        var forceEventDuration = calendar.opt('forceEventDuration');
        if (!start.isValid()) {
            return false;
        }
        if (end && (!end.isValid() || !end.isAfter(start))) {
            end = null;
        }
        if (forcedAllDay == null) {
            forcedAllDay = source.allDayDefault;
            if (forcedAllDay == null) {
                forcedAllDay = calendar.opt('allDayDefault');
            }
        }
        if (forcedAllDay === true) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else if (forcedAllDay === false) {
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        if (!end && forceEventDuration) {
            end = calendar.getDefaultEventEnd(!start.hasTime(), start);
        }
        return new EventDateProfile(start, end, calendar);
    };
    return EventDateProfile;
}());
exports.default = EventDateProfile;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var PromiseStub = {
    construct: function (executor) {
        var deferred = $.Deferred();
        var promise = deferred.promise();
        if (typeof executor === 'function') {
            executor(function (val) {
                deferred.resolve(val);
                attachImmediatelyResolvingThen(promise, val);
            }, function () {
                deferred.reject();
                attachImmediatelyRejectingThen(promise);
            });
        }
        return promise;
    },
    resolve: function (val) {
        var deferred = $.Deferred().resolve(val);
        var promise = deferred.promise();
        attachImmediatelyResolvingThen(promise, val);
        return promise;
    },
    reject: function () {
        var deferred = $.Deferred().reject();
        var promise = deferred.promise();
        attachImmediatelyRejectingThen(promise);
        return promise;
    }
};
exports.default = PromiseStub;
function attachImmediatelyResolvingThen(promise, val) {
    promise.then = function (onResolve) {
        if (typeof onResolve === 'function') {
            return PromiseStub.resolve(onResolve(val));
        }
        return promise;
    };
}
function attachImmediatelyRejectingThen(promise) {
    promise.then = function (onResolve, onReject) {
        if (typeof onReject === 'function') {
            onReject();
        }
        return promise;
    };
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(4);
var util_1 = __webpack_require__(23);
var EventRange_1 = __webpack_require__(53);
/*
It's expected that there will be at least one EventInstance,
OR that an explicitEventDef is assigned.
*/
var EventInstanceGroup = /** @class */ (function () {
    function EventInstanceGroup(eventInstances) {
        this.eventInstances = eventInstances || [];
    }
    EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {
        if (constraintRange) {
            return this.sliceNormalRenderRanges(constraintRange);
        }
        else {
            return this.eventInstances.map(util_1.eventInstanceToEventRange);
        }
    };
    EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {
        if (this.isInverse()) {
            return this.sliceInverseRenderRanges(constraintRange);
        }
        else {
            return this.sliceNormalRenderRanges(constraintRange);
        }
    };
    EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {
        var eventInstances = this.eventInstances;
        var i, eventInstance;
        var slicedRange;
        var slicedEventRanges = [];
        for (i = 0; i < eventInstances.length; i++) {
            eventInstance = eventInstances[i];
            slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);
            if (slicedRange) {
                slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));
            }
        }
        return slicedEventRanges;
    };
    EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {
        var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);
        var ownerDef = this.getEventDef();
        unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);
        return unzonedRanges.map(function (unzonedRange) {
            return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance
        });
    };
    EventInstanceGroup.prototype.isInverse = function () {
        return this.getEventDef().hasInverseRendering();
    };
    EventInstanceGroup.prototype.getEventDef = function () {
        return this.explicitEventDef || this.eventInstances[0].def;
    };
    return EventInstanceGroup;
}());
exports.default = EventInstanceGroup;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var DragListener_1 = __webpack_require__(39);
/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/
var HitDragListener = /** @class */ (function (_super) {
    tslib_1.__extends(HitDragListener, _super);
    function HitDragListener(component, options) {
        var _this = _super.call(this, options) || this;
        _this.component = component;
        return _this;
    }
    // Called when drag listening starts (but a real drag has not necessarily began).
    // ev might be undefined if dragging was started manually.
    HitDragListener.prototype.handleInteractionStart = function (ev) {
        var subjectEl = this.subjectEl;
        var subjectRect;
        var origPoint;
        var point;
        this.component.hitsNeeded();
        this.computeScrollBounds(); // for autoscroll
        if (ev) {
            origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };
            point = origPoint;
            // constrain the point to bounds of the element being dragged
            if (subjectEl) {
                subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well
                point = util_1.constrainPoint(point, subjectRect);
            }
            this.origHit = this.queryHit(point.left, point.top);
            // treat the center of the subject as the collision point?
            if (subjectEl && this.options.subjectCenter) {
                // only consider the area the subject overlaps the hit. best for large subjects.
                // TODO: skip this if hit didn't supply left/right/top/bottom
                if (this.origHit) {
                    subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||
                        subjectRect; // in case there is no intersection
                }
                point = util_1.getRectCenter(subjectRect);
            }
            this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint
        }
        else {
            this.origHit = null;
            this.coordAdjust = null;
        }
        // call the super-method. do it after origHit has been computed
        _super.prototype.handleInteractionStart.call(this, ev);
    };
    // Called when the actual drag has started
    HitDragListener.prototype.handleDragStart = function (ev) {
        var hit;
        _super.prototype.handleDragStart.call(this, ev);
        // might be different from this.origHit if the min-distance is large
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        // report the initial hit the mouse is over
        // especially important if no min-distance and drag starts immediately
        if (hit) {
            this.handleHitOver(hit);
        }
    };
    // Called when the drag moves
    HitDragListener.prototype.handleDrag = function (dx, dy, ev) {
        var hit;
        _super.prototype.handleDrag.call(this, dx, dy, ev);
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        if (!isHitsEqual(hit, this.hit)) {
            if (this.hit) {
                this.handleHitOut();
            }
            if (hit) {
                this.handleHitOver(hit);
            }
        }
    };
    // Called when dragging has been stopped
    HitDragListener.prototype.handleDragEnd = function (ev) {
        this.handleHitDone();
        _super.prototype.handleDragEnd.call(this, ev);
    };
    // Called when a the mouse has just moved over a new hit
    HitDragListener.prototype.handleHitOver = function (hit) {
        var isOrig = isHitsEqual(hit, this.origHit);
        this.hit = hit;
        this.trigger('hitOver', this.hit, isOrig, this.origHit);
    };
    // Called when the mouse has just moved out of a hit
    HitDragListener.prototype.handleHitOut = function () {
        if (this.hit) {
            this.trigger('hitOut', this.hit);
            this.handleHitDone();
            this.hit = null;
        }
    };
    // Called after a hitOut. Also called before a dragStop
    HitDragListener.prototype.handleHitDone = function () {
        if (this.hit) {
            this.trigger('hitDone', this.hit);
        }
    };
    // Called when the interaction ends, whether there was a real drag or not
    HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);
        this.origHit = null;
        this.hit = null;
        this.component.hitsNotNeeded();
    };
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    HitDragListener.prototype.handleScrollEnd = function () {
        _super.prototype.handleScrollEnd.call(this);
        // hits' absolute positions will be in new places after a user's scroll.
        // HACK for recomputing.
        if (this.isDragging) {
            this.component.releaseHits();
            this.component.prepareHits();
        }
    };
    // Gets the hit underneath the coordinates for the given mouse event
    HitDragListener.prototype.queryHit = function (left, top) {
        if (this.coordAdjust) {
            left += this.coordAdjust.left;
            top += this.coordAdjust.top;
        }
        return this.component.queryHit(left, top);
    };
    return HitDragListener;
}(DragListener_1.default));
exports.default = HitDragListener;
// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) {
        return true;
    }
    if (hit0 && hit1) {
        return hit0.component === hit1.component &&
            isHitPropsWithin(hit0, hit1) &&
            isHitPropsWithin(hit1, hit0); // ensures all props are identical
    }
    return false;
}
// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
    for (var propName in subHit) {
        if (!/^(component|left|right|top|bottom)$/.test(propName)) {
            if (subHit[propName] !== superHit[propName]) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(2);
exports.globalDefaults = {
    titleRangeSeparator: ' \u2013 ',
    monthYearFormat: 'MMMM YYYY',
    defaultTimedEventDuration: '02:00:00',
    defaultAllDayEventDuration: { days: 1 },
    forceEventDuration: false,
    nextDayThreshold: '09:00:00',
    // display
    columnHeader: true,
    defaultView: 'month',
    aspectRatio: 1.35,
    header: {
        left: 'title',
        center: '',
        right: 'today prev,next'
    },
    weekends: true,
    weekNumbers: false,
    weekNumberTitle: 'W',
    weekNumberCalculation: 'local',
    //editable: false,
    //nowIndicator: false,
    scrollTime: '06:00:00',
    minTime: '00:00:00',
    maxTime: '24:00:00',
    showNonCurrentDates: true,
    // event ajax
    lazyFetching: true,
    startParam: 'start',
    endParam: 'end',
    timezoneParam: 'timezone',
    timezone: false,
    //allDayDefault: undefined,
    // locale
    locale: null,
    isRTL: false,
    buttonText: {
        prev: "prev",
        next: "next",
        prevYear: "prev year",
        nextYear: "next year",
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day'
    },
    //buttonIcons: null,
    allDayText: 'all-day',
    // allows setting a min-height to the event segment to prevent short events overlapping each other
    agendaEventMinHeight: 0,
    // jquery-ui theming
    theme: false,
    //themeButtonIcons: null,
    //eventResizableFromStart: false,
    dragOpacity: .75,
    dragRevertDuration: 500,
    dragScroll: true,
    //selectable: false,
    unselectAuto: true,
    //selectMinDistance: 0,
    dropAccept: '*',
    eventOrder: 'title',
    //eventRenderWait: null,
    eventLimit: false,
    eventLimitText: 'more',
    eventLimitClick: 'popover',
    dayPopoverFormat: 'LL',
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1000
};
exports.englishDefaults = {
    dayPopoverFormat: 'dddd, MMMM D'
};
exports.rtlDefaults = {
    header: {
        left: 'next,prev today',
        center: '',
        right: 'title'
    },
    buttonIcons: {
        prev: 'right-single-arrow',
        next: 'left-single-arrow',
        prevYear: 'right-double-arrow',
        nextYear: 'left-double-arrow'
    },
    themeButtonIcons: {
        prev: 'circle-triangle-e',
        next: 'circle-triangle-w',
        nextYear: 'seek-prev',
        prevYear: 'seek-next'
    }
};
var complexOptions = [
    'header',
    'footer',
    'buttonText',
    'buttonIcons',
    'themeButtonIcons'
];
// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
    return util_1.mergeProps(optionObjs, complexOptions);
}
exports.mergeOptions = mergeOptions;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var namespace_hooks_1 = __webpack_require__(7);
var options_1 = __webpack_require__(19);
var util_1 = __webpack_require__(2);
var localeOptionHash = namespace_hooks_1.default.locales;
exports.localeOptionHash = localeOptionHash;
// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
function datepickerLocale(localeCode, dpLocaleCode, dpOptions) {
    // get the FullCalendar internal option hash for this locale. create if necessary
    var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});
    // transfer some simple options from datepicker to fc
    fcOptions.isRTL = dpOptions.isRTL;
    fcOptions.weekNumberTitle = dpOptions.weekHeader;
    // compute some more complex options from datepicker
    $.each(dpComputableOptions, function (name, func) {
        fcOptions[name] = func(dpOptions);
    });
    var jqDatePicker = $.datepicker;
    // is jQuery UI Datepicker is on the page?
    if (jqDatePicker) {
        // Register the locale data.
        // FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
        // does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
        // Make an alias so the locale can be referenced either way.
        jqDatePicker.regional[dpLocaleCode] =
            jqDatePicker.regional[localeCode] = // alias
                dpOptions;
        // Alias 'en' to the default locale data. Do this every time.
        jqDatePicker.regional.en = jqDatePicker.regional[''];
        // Set as Datepicker's global defaults.
        jqDatePicker.setDefaults(dpOptions);
    }
}
exports.datepickerLocale = datepickerLocale;
// Sets FullCalendar-specific translations. Will set the locales as the global default.
function locale(localeCode, newFcOptions) {
    var fcOptions;
    var momOptions;
    // get the FullCalendar internal option hash for this locale. create if necessary
    fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});
    // provided new options for this locales? merge them in
    if (newFcOptions) {
        fcOptions = localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);
    }
    // compute locale options that weren't defined.
    // always do this. newFcOptions can be undefined when initializing from i18n file,
    // so no way to tell if this is an initialization or a default-setting.
    momOptions = getMomentLocaleData(localeCode); // will fall back to en
    $.each(momComputableOptions, function (name, func) {
        if (fcOptions[name] == null) {
            fcOptions[name] = func(momOptions, fcOptions);
        }
    });
    // set it as the default locale for FullCalendar
    options_1.globalDefaults.locale = localeCode;
}
exports.locale = locale;
;
// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {
    buttonText: function (dpOptions) {
        return {
            // the translations sometimes wrongly contain HTML entities
            prev: util_1.stripHtmlEntities(dpOptions.prevText),
            next: util_1.stripHtmlEntities(dpOptions.nextText),
            today: util_1.stripHtmlEntities(dpOptions.currentText)
        };
    },
    // Produces format strings like "MMMM YYYY" -> "September 2014"
    monthYearFormat: function (dpOptions) {
        return dpOptions.showMonthAfterYear ?
            'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
            'MMMM YYYY[' + dpOptions.yearSuffix + ']';
    }
};
var momComputableOptions = {
    // Produces format strings like "ddd M/D" -> "Fri 9/15"
    dayOfMonthFormat: function (momOptions, fcOptions) {
        var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"
        // strip the year off the edge, as well as other misc non-whitespace chars
        format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');
        if (fcOptions.isRTL) {
            format += ' ddd'; // for RTL, add day-of-week to end
        }
        else {
            format = 'ddd ' + format; // for LTR, add day-of-week to beginning
        }
        return format;
    },
    // Produces format strings like "h:mma" -> "6:00pm"
    mediumTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
    smallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
    extraSmallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
    },
    // Produces format strings like "ha" / "H" -> "6pm" / "18"
    hourFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '')
            .replace(/(\Wmm)$/, '') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
    noMeridiemTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, ''); // remove trailing AM/PM
    }
};
// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {
    // Produces format strings for results like "Mo 16"
    smallDayDateFormat: function (options) {
        return options.isRTL ?
            'D dd' :
            'dd D';
    },
    // Produces format strings for results like "Wk 5"
    weekFormat: function (options) {
        return options.isRTL ?
            'w[ ' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ' ]w';
    },
    // Produces format strings for results like "Wk5"
    smallWeekFormat: function (options) {
        return options.isRTL ?
            'w[' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ']w';
    }
};
// TODO: make these computable properties in optionsManager
function populateInstanceComputableOptions(options) {
    $.each(instanceComputableOptions, function (name, func) {
        if (options[name] == null) {
            options[name] = func(options);
        }
    });
}
exports.populateInstanceComputableOptions = populateInstanceComputableOptions;
// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
    return moment.localeData(localeCode) || moment.localeData('en');
}
exports.getMomentLocaleData = getMomentLocaleData;
// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
locale('en', options_1.englishDefaults);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
// Class that all other classes will inherit from
var Class = /** @class */ (function () {
    function Class() {
    }
    // Called on a class to create a subclass.
    // LIMITATION: cannot provide a constructor!
    Class.extend = function (members) {
        var SubClass = /** @class */ (function (_super) {
            tslib_1.__extends(SubClass, _super);
            function SubClass() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return SubClass;
        }(this));
        ;
        util_1.copyOwnProps(members, SubClass.prototype);
        return SubClass;
    };
    // Adds new member variables/methods to the class's prototype.
    // Can be called with another class, or a plain object hash containing new members.
    Class.mixin = function (members) {
        util_1.copyOwnProps(members, this.prototype);
    };
    return Class;
}());
exports.default = Class;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var ParsableModelMixin_1 = __webpack_require__(50);
var EventDef = /** @class */ (function () {
    function EventDef(source) {
        this.source = source;
        this.className = [];
        this.miscProps = {};
    }
    EventDef.prototype.clone = function () {
        var copy = new this.constructor(this.source);
        copy.id = this.id;
        copy.rawId = this.rawId;
        copy.uid = this.uid; // not really unique anymore :(
        EventDef.copyVerbatimStandardProps(this, copy);
        copy.className = this.className.slice(); // copy
        copy.miscProps = $.extend({}, this.miscProps);
        return copy;
    };
    EventDef.prototype.hasInverseRendering = function () {
        return this.getRendering() === 'inverse-background';
    };
    EventDef.prototype.hasBgRendering = function () {
        var rendering = this.getRendering();
        return rendering === 'inverse-background' || rendering === 'background';
    };
    EventDef.prototype.getRendering = function () {
        if (this.rendering != null) {
            return this.rendering;
        }
        return this.source.rendering;
    };
    EventDef.prototype.getConstraint = function () {
        if (this.constraint != null) {
            return this.constraint;
        }
        if (this.source.constraint != null) {
            return this.source.constraint;
        }
        return this.source.calendar.opt('eventConstraint'); // what about View option?
    };
    EventDef.prototype.getOverlap = function () {
        if (this.overlap != null) {
            return this.overlap;
        }
        if (this.source.overlap != null) {
            return this.source.overlap;
        }
        return this.source.calendar.opt('eventOverlap'); // what about View option?
    };
    EventDef.prototype.isStartExplicitlyEditable = function () {
        if (this.startEditable != null) {
            return this.startEditable;
        }
        return this.source.startEditable;
    };
    EventDef.prototype.isDurationExplicitlyEditable = function () {
        if (this.durationEditable != null) {
            return this.durationEditable;
        }
        return this.source.durationEditable;
    };
    EventDef.prototype.isExplicitlyEditable = function () {
        if (this.editable != null) {
            return this.editable;
        }
        return this.source.editable;
    };
    EventDef.prototype.toLegacy = function () {
        var obj = $.extend({}, this.miscProps);
        obj._id = this.uid;
        obj.source = this.source;
        obj.className = this.className.slice(); // copy
        obj.allDay = this.isAllDay();
        if (this.rawId != null) {
            obj.id = this.rawId;
        }
        EventDef.copyVerbatimStandardProps(this, obj);
        return obj;
    };
    EventDef.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventDef.normalizeId((this.rawId = rawProps.id));
        }
        else {
            this.id = EventDef.generateId();
        }
        if (rawProps._id != null) {
            this.uid = String(rawProps._id);
        }
        else {
            this.uid = EventDef.generateId();
        }
        // TODO: converge with EventSource
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    EventDef.prototype.applyMiscProps = function (rawProps) {
        $.extend(this.miscProps, rawProps);
    };
    EventDef.parse = function (rawInput, source) {
        var def = new this(source);
        if (def.applyProps(rawInput)) {
            return def;
        }
        return false;
    };
    EventDef.normalizeId = function (id) {
        return String(id);
    };
    EventDef.generateId = function () {
        return '_fc' + (EventDef.uuid++);
    };
    EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    // IDs
    // ---------------------------------------------------------------------------------------------------------------------
    // TODO: converge with EventSource
    EventDef.uuid = 0;
    return EventDef;
}());
exports.default = EventDef;
ParsableModelMixin_1.default.mixInto(EventDef);
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
EventDef.defineStandardProps({
    // not automatically assigned (`false`)
    _id: false,
    id: false,
    className: false,
    source: false,
    // automatically assigned (`true`)
    title: true,
    url: true,
    rendering: true,
    constraint: true,
    overlap: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true
});


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange_1 = __webpack_require__(53);
var EventFootprint_1 = __webpack_require__(24);
var ComponentFootprint_1 = __webpack_require__(10);
function eventDefsToEventInstances(eventDefs, unzonedRange) {
    var eventInstances = [];
    var i;
    for (i = 0; i < eventDefs.length; i++) {
        eventInstances.push.apply(eventInstances, // append
        eventDefs[i].buildInstances(unzonedRange));
    }
    return eventInstances;
}
exports.eventDefsToEventInstances = eventDefsToEventInstances;
function eventInstanceToEventRange(eventInstance) {
    return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);
}
exports.eventInstanceToEventRange = eventInstanceToEventRange;
function eventRangeToEventFootprint(eventRange) {
    return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist
    );
}
exports.eventRangeToEventFootprint = eventRangeToEventFootprint;
function eventInstanceToUnzonedRange(eventInstance) {
    return eventInstance.dateProfile.unzonedRange;
}
exports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;
function eventFootprintToComponentFootprint(eventFootprint) {
    return eventFootprint.componentFootprint;
}
exports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventFootprint = /** @class */ (function () {
    function EventFootprint(componentFootprint, eventDef, eventInstance) {
        this.componentFootprint = componentFootprint;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    EventFootprint.prototype.getEventLegacy = function () {
        return (this.eventInstance || this.eventDef).toLegacy();
    };
    return EventFootprint;
}());
exports.default = EventFootprint;


/***/ }),
/* 25 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    sourceClasses: [],
    registerClass: function (EventSourceClass) {
        this.sourceClasses.unshift(EventSourceClass); // give highest priority
    },
    parse: function (rawInput, calendar) {
        var sourceClasses = this.sourceClasses;
        var i;
        var eventSource;
        for (i = 0; i < sourceClasses.length; i++) {
            eventSource = sourceClasses[i].parse(rawInput, calendar);
            if (eventSource) {
                return eventSource;
            }
        }
    }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(2);
var EventDateProfile_1 = __webpack_require__(15);
var EventDef_1 = __webpack_require__(22);
var EventDefDateMutation_1 = __webpack_require__(35);
var SingleEventDef_1 = __webpack_require__(11);
var EventDefMutation = /** @class */ (function () {
    function EventDefMutation() {
    }
    /*
    eventDef assumed to be a SingleEventDef.
    returns an undo function.
    */
    EventDefMutation.prototype.mutateSingle = function (eventDef) {
        var origDateProfile;
        if (this.dateMutation) {
            origDateProfile = eventDef.dateProfile;
            eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.eventDefId != null) {
            eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.className) {
            eventDef.className = this.className;
        }
        // can't undo
        if (this.verbatimStandardProps) {
            SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src
            eventDef // dest
            );
        }
        // can't undo
        if (this.miscProps) {
            eventDef.applyMiscProps(this.miscProps);
        }
        if (origDateProfile) {
            return function () {
                eventDef.dateProfile = origDateProfile;
            };
        }
        else {
            return function () { };
        }
    };
    EventDefMutation.prototype.setDateMutation = function (dateMutation) {
        if (dateMutation && !dateMutation.isEmpty()) {
            this.dateMutation = dateMutation;
        }
        else {
            this.dateMutation = null;
        }
    };
    EventDefMutation.prototype.isEmpty = function () {
        return !this.dateMutation;
    };
    EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {
        var eventDef = eventInstance.def;
        var dateProps = {};
        var standardProps = {};
        var miscProps = {};
        var verbatimStandardProps = {};
        var eventDefId = null;
        var className = null;
        var propName;
        var dateProfile;
        var dateMutation;
        var defMutation;
        for (propName in rawProps) {
            if (EventDateProfile_1.default.isStandardProp(propName)) {
                dateProps[propName] = rawProps[propName];
            }
            else if (eventDef.isStandardProp(propName)) {
                standardProps[propName] = rawProps[propName];
            }
            else if (eventDef.miscProps[propName] !== rawProps[propName]) {
                miscProps[propName] = rawProps[propName];
            }
        }
        dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);
        if (dateProfile) {
            dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);
        }
        if (standardProps.id !== eventDef.id) {
            eventDefId = standardProps.id; // only apply if there's a change
        }
        if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {
            className = standardProps.className; // only apply if there's a change
        }
        EventDef_1.default.copyVerbatimStandardProps(standardProps, // src
        verbatimStandardProps // dest
        );
        defMutation = new EventDefMutation();
        defMutation.eventDefId = eventDefId;
        defMutation.className = className;
        defMutation.verbatimStandardProps = verbatimStandardProps;
        defMutation.miscProps = miscProps;
        if (dateMutation) {
            defMutation.dateMutation = dateMutation;
        }
        return defMutation;
    };
    return EventDefMutation;
}());
exports.default = EventDefMutation;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var Theme = /** @class */ (function () {
    function Theme(optionsManager) {
        this.optionsManager = optionsManager;
        this.processIconOverride();
    }
    Theme.prototype.processIconOverride = function () {
        if (this.iconOverrideOption) {
            this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));
        }
    };
    Theme.prototype.setIconOverride = function (iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;
        if ($.isPlainObject(iconOverrideHash)) {
            iconClassesCopy = $.extend({}, this.iconClasses);
            for (buttonName in iconOverrideHash) {
                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
            }
            this.iconClasses = iconClassesCopy;
        }
        else if (iconOverrideHash === false) {
            this.iconClasses = {};
        }
    };
    Theme.prototype.applyIconOverridePrefix = function (className) {
        var prefix = this.iconOverridePrefix;
        if (prefix && className.indexOf(prefix) !== 0) {
            className = prefix + className;
        }
        return className;
    };
    Theme.prototype.getClass = function (key) {
        return this.classes[key] || '';
    };
    Theme.prototype.getIconClass = function (buttonName) {
        var className = this.iconClasses[buttonName];
        if (className) {
            return this.baseIconClass + ' ' + className;
        }
        return '';
    };
    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
        var className;
        if (this.iconOverrideCustomButtonOption) {
            className = customButtonProps[this.iconOverrideCustomButtonOption];
            if (className) {
                return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
            }
        }
        return '';
    };
    return Theme;
}());
exports.default = Theme;
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = '';
Theme.prototype.iconOverridePrefix = '';


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Class_1 = __webpack_require__(21);
/*
Embodies a div that has potential scrollbars
*/
var Scroller = /** @class */ (function (_super) {
    tslib_1.__extends(Scroller, _super);
    function Scroller(options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.overflowX = options.overflowX || options.overflow || 'auto';
        _this.overflowY = options.overflowY || options.overflow || 'auto';
        return _this;
    }
    Scroller.prototype.render = function () {
        this.el = this.renderEl();
        this.applyOverflow();
    };
    Scroller.prototype.renderEl = function () {
        return (this.scrollEl = $('<div class="fc-scroller"></div>'));
    };
    // sets to natural height, unlocks overflow
    Scroller.prototype.clear = function () {
        this.setHeight('auto');
        this.applyOverflow();
    };
    Scroller.prototype.destroy = function () {
        this.el.remove();
    };
    // Overflow
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.applyOverflow = function () {
        this.scrollEl.css({
            'overflow-x': this.overflowX,
            'overflow-y': this.overflowY
        });
    };
    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
    // Useful for preserving scrollbar widths regardless of future resizes.
    // Can pass in scrollbarWidths for optimization.
    Scroller.prototype.lockOverflow = function (scrollbarWidths) {
        var overflowX = this.overflowX;
        var overflowY = this.overflowY;
        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
        if (overflowX === 'auto') {
            overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth) ? 'scroll' : 'hidden';
        }
        if (overflowY === 'auto') {
            overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight) ? 'scroll' : 'hidden';
        }
        this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
    };
    // Getters / Setters
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.setHeight = function (height) {
        this.scrollEl.height(height);
    };
    Scroller.prototype.getScrollTop = function () {
        return this.scrollEl.scrollTop();
    };
    Scroller.prototype.setScrollTop = function (top) {
        this.scrollEl.scrollTop(top);
    };
    Scroller.prototype.getClientWidth = function () {
        return this.scrollEl[0].clientWidth;
    };
    Scroller.prototype.getClientHeight = function () {
        return this.scrollEl[0].clientHeight;
    };
    Scroller.prototype.getScrollbarWidths = function () {
        return util_1.getScrollbarWidths(this.scrollEl);
    };
    return Scroller;
}(Class_1.default));
exports.default = Scroller;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var DateComponent_1 = __webpack_require__(61);
var GlobalEmitter_1 = __webpack_require__(14);
var InteractiveDateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InteractiveDateComponent, _super);
    function InteractiveDateComponent(_view, _options) {
        var _this = _super.call(this, _view, _options) || this;
        // self-config, overridable by subclasses
        _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?
        if (_this.dateSelectingClass) {
            _this.dateClicking = new _this.dateClickingClass(_this);
        }
        if (_this.dateSelectingClass) {
            _this.dateSelecting = new _this.dateSelectingClass(_this);
        }
        if (_this.eventPointingClass) {
            _this.eventPointing = new _this.eventPointingClass(_this);
        }
        if (_this.eventDraggingClass && _this.eventPointing) {
            _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);
        }
        if (_this.eventResizingClass && _this.eventPointing) {
            _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);
        }
        if (_this.externalDroppingClass) {
            _this.externalDropping = new _this.externalDroppingClass(_this);
        }
        return _this;
    }
    // Sets the container element that the view should render inside of, does global DOM-related initializations,
    // and renders all the non-date-related content inside.
    InteractiveDateComponent.prototype.setElement = function (el) {
        _super.prototype.setElement.call(this, el);
        if (this.dateClicking) {
            this.dateClicking.bindToEl(el);
        }
        if (this.dateSelecting) {
            this.dateSelecting.bindToEl(el);
        }
        this.bindAllSegHandlersToEl(el);
    };
    InteractiveDateComponent.prototype.removeElement = function () {
        this.endInteractions();
        _super.prototype.removeElement.call(this);
    };
    InteractiveDateComponent.prototype.executeEventUnrender = function () {
        this.endInteractions();
        _super.prototype.executeEventUnrender.call(this);
    };
    InteractiveDateComponent.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.bindToDocument();
        }
    };
    InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.unbindFromDocument();
        }
    };
    InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {
        var _this = this;
        // attach a handler to the grid's root element.
        // jQuery will take care of unregistering them when removeElement gets called.
        this.el.on(name, function (ev) {
            if (!$(ev.target).is(_this.segSelector + ',' + // directly on an event element
                _this.segSelector + ' *,' + // within an event element
                '.fc-more,' + // a "more.." link
                'a[data-goto]' // a clickable nav link
            )) {
                return handler.call(_this, ev);
            }
        });
    };
    InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {
        [
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (eventInteraction) {
            if (eventInteraction) {
                eventInteraction.bindToEl(el);
            }
        });
    };
    InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {
        var _this = this;
        el.on(name, this.segSelector, function (ev) {
            var seg = $(ev.currentTarget).data('fc-seg'); // grab segment data. put there by View::renderEventsPayload
            if (seg && !_this.shouldIgnoreEventPointing()) {
                return handler.call(_this, seg, ev); // context will be the Grid
            }
        });
    };
    InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {
        // HACK
        // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.
        return GlobalEmitter_1.default.get().shouldIgnoreMouse();
    };
    InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {
        var view = this._getView();
        // On iOS (and Android?) when a new selection is initiated overtop another selection,
        // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
        // HACK: simply don't allow this to happen.
        // ALSO: prevent selection when an *event* is already raised.
        return view.isSelected || view.selectedEvent;
    };
    InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {
        // only call the handlers if there is not a drag/resize in progress
        return (this.eventDragging && this.eventDragging.isDragging) ||
            (this.eventResizing && this.eventResizing.isResizing);
    };
    InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {
        return util_1.getEvIsTouch(ev) &&
            !this.canStartResize(seg, ev) &&
            (this.isEventDefDraggable(seg.footprint.eventDef) ||
                this.isEventDefResizable(seg.footprint.eventDef));
    };
    InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {
        return !this.canStartResize(seg, ev) &&
            this.isEventDefDraggable(seg.footprint.eventDef);
    };
    InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {
        var view = this._getView();
        var eventDef = seg.footprint.eventDef;
        return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&
            this.isEventDefResizable(eventDef) &&
            $(ev.target).is('.fc-resizer');
    };
    // Kills all in-progress dragging.
    // Useful for when public API methods that result in re-rendering are invoked during a drag.
    // Also useful for when touch devices misbehave and don't fire their touchend.
    InteractiveDateComponent.prototype.endInteractions = function () {
        [
            this.dateClicking,
            this.dateSelecting,
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (interaction) {
            if (interaction) {
                interaction.end();
            }
        });
    };
    // Event Drag-n-Drop
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be dragged by the user
    InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {
        return this.isEventDefStartEditable(eventDef);
    };
    InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {
        var isEditable = eventDef.isStartExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('eventStartEditable');
            if (isEditable == null) {
                isEditable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isEditable;
    };
    InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {
        var isEditable = eventDef.isExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('editable');
        }
        return isEditable;
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be resized from its starting edge
    InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {
        return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized from its ending edge
    InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {
        return this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized by the user at all
    InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {
        var isResizable = eventDef.isDurationExplicitlyEditable();
        if (isResizable == null) {
            isResizable = this.opt('eventDurationEditable');
            if (isResizable == null) {
                isResizable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isResizable;
    };
    // Event Mutation / Constraints
    // ---------------------------------------------------------------------------------------------------------------
    // Diffs the two dates, returning a duration, based on granularity of the grid
    // TODO: port isTimeScale into this system?
    InteractiveDateComponent.prototype.diffDates = function (a, b) {
        if (this.largeUnit) {
            return util_1.diffByUnit(a, b, this.largeUnit);
        }
        else {
            return util_1.diffDayTime(a, b);
        }
    };
    // is it allowed, in relation to the view's validRange?
    // NOTE: very similar to isExternalInstanceGroupAllowed
    InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            // TODO: just use getAllEventRanges directly
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);
    };
    // NOTE: very similar to isEventInstanceGroupAllowed
    // when it's a completely anonymous external drag, no event.
    InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        for (i = 0; i < eventFootprints.length; i++) {
            // treat it as a selection
            // TODO: pass in eventInstanceGroup instead
            //  because we don't want calendar's constraint system to depend on a component's
            //  determination of footprints.
            if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {
                return false;
            }
        }
        return true;
    };
    return InteractiveDateComponent;
}(DateComponent_1.default));
exports.default = InteractiveDateComponent;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var RenderQueue_1 = __webpack_require__(60);
var DateProfileGenerator_1 = __webpack_require__(62);
var InteractiveDateComponent_1 = __webpack_require__(29);
var GlobalEmitter_1 = __webpack_require__(14);
var UnzonedRange_1 = __webpack_require__(4);
/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/
var View = /** @class */ (function (_super) {
    tslib_1.__extends(View, _super);
    function View(calendar, viewSpec) {
        var _this = _super.call(this, null, viewSpec.options) || this;
        _this.batchRenderDepth = 0;
        _this.isSelected = false; // boolean whether a range of time is user-selected or not
        _this.calendar = calendar;
        _this.viewSpec = viewSpec;
        // shortcuts
        _this.type = viewSpec.type;
        // .name is deprecated
        _this.name = _this.type;
        _this.initRenderQueue();
        _this.initHiddenDays();
        _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);
        _this.bindBaseRenderHandlers();
        _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));
        // legacy
        if (_this['initialize']) {
            _this['initialize']();
        }
        return _this;
    }
    View.prototype._getView = function () {
        return this;
    };
    // Retrieves an option with the given name
    View.prototype.opt = function (name) {
        return this.options[name];
    };
    /* Render Queue
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.initRenderQueue = function () {
        this.renderQueue = new RenderQueue_1.default({
            event: this.opt('eventRenderWait')
        });
        this.renderQueue.on('start', this.onRenderQueueStart.bind(this));
        this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));
        this.on('before:change', this.startBatchRender);
        this.on('change', this.stopBatchRender);
    };
    View.prototype.onRenderQueueStart = function () {
        this.calendar.freezeContentHeight();
        this.addScroll(this.queryScroll());
    };
    View.prototype.onRenderQueueStop = function () {
        if (this.calendar.updateViewSize()) {
            this.popScroll();
        }
        this.calendar.thawContentHeight();
    };
    View.prototype.startBatchRender = function () {
        if (!(this.batchRenderDepth++)) {
            this.renderQueue.pause();
        }
    };
    View.prototype.stopBatchRender = function () {
        if (!(--this.batchRenderDepth)) {
            this.renderQueue.resume();
        }
    };
    View.prototype.requestRender = function (func, namespace, actionType) {
        this.renderQueue.queue(func, namespace, actionType);
    };
    // given func will auto-bind to `this`
    View.prototype.whenSizeUpdated = function (func) {
        if (this.renderQueue.isRunning) {
            this.renderQueue.one('stop', func.bind(this));
        }
        else {
            func.call(this);
        }
    };
    /* Title and Date Formatting
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes what the title at the top of the calendar should be for this view
    View.prototype.computeTitle = function (dateProfile) {
        var unzonedRange;
        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
            unzonedRange = dateProfile.currentUnzonedRange;
        }
        else {
            unzonedRange = dateProfile.activeUnzonedRange;
        }
        return this.formatRange({
            start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),
            end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)
        }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));
    };
    // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
    View.prototype.computeTitleFormat = function (dateProfile) {
        var currentRangeUnit = dateProfile.currentRangeUnit;
        if (currentRangeUnit == 'year') {
            return 'YYYY';
        }
        else if (currentRangeUnit == 'month') {
            return this.opt('monthYearFormat'); // like "September 2014"
        }
        else if (dateProfile.currentUnzonedRange.as('days') > 1) {
            return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
        }
        else {
            return 'LL'; // one day. longer, like "September 9 2014"
        }
    };
    // Date Setting/Unsetting
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.setDate = function (date) {
        var currentDateProfile = this.get('dateProfile');
        var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true
        if (!currentDateProfile ||
            !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {
            this.set('dateProfile', newDateProfile);
        }
    };
    View.prototype.unsetDate = function () {
        this.unset('dateProfile');
    };
    // Event Data
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.fetchInitialEvents = function (dateProfile) {
        var calendar = this.calendar;
        var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;
        return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));
    };
    View.prototype.bindEventChanges = function () {
        this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event
    };
    View.prototype.unbindEventChanges = function () {
        this.stopListeningTo(this.calendar, 'eventsReset');
    };
    View.prototype.setEvents = function (eventsPayload) {
        this.set('currentEvents', eventsPayload);
        this.set('hasEvents', true);
    };
    View.prototype.unsetEvents = function () {
        this.unset('currentEvents');
        this.unset('hasEvents');
    };
    View.prototype.resetEvents = function (eventsPayload) {
        this.startBatchRender();
        this.unsetEvents();
        this.setEvents(eventsPayload);
        this.stopBatchRender();
    };
    // Date High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestDateRender = function (dateProfile) {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateRender(dateProfile);
        }, 'date', 'init');
    };
    View.prototype.requestDateUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateUnrender();
        }, 'date', 'destroy');
    };
    // if dateProfile not specified, uses current
    View.prototype.executeDateRender = function (dateProfile) {
        _super.prototype.executeDateRender.call(this, dateProfile);
        if (this['render']) {
            this['render'](); // TODO: deprecate
        }
        this.trigger('datesRendered');
        this.addScroll({ isDateInit: true });
        this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon
    };
    View.prototype.executeDateUnrender = function () {
        this.unselect();
        this.stopNowIndicator();
        this.trigger('before:datesUnrendered');
        if (this['destroy']) {
            this['destroy'](); // TODO: deprecate
        }
        _super.prototype.executeDateUnrender.call(this);
    };
    // "Base" rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.bindBaseRenderHandlers = function () {
        var _this = this;
        this.on('datesRendered', function () {
            _this.whenSizeUpdated(_this.triggerViewRender);
        });
        this.on('before:datesUnrendered', function () {
            _this.triggerViewDestroy();
        });
    };
    View.prototype.triggerViewRender = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerViewDestroy = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Event High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestEventsRender = function (eventsPayload) {
        var _this = this;
        this.requestRender(function () {
            _this.executeEventRender(eventsPayload);
            _this.whenSizeUpdated(_this.triggerAfterEventsRendered);
        }, 'event', 'init');
    };
    View.prototype.requestEventsUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.triggerBeforeEventsDestroyed();
            _this.executeEventUnrender();
        }, 'event', 'destroy');
    };
    // Business Hour High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {
        var _this = this;
        this.requestRender(function () {
            _this.renderBusinessHours(businessHourGenerator);
        }, 'businessHours', 'init');
    };
    View.prototype.requestBusinessHoursUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.unrenderBusinessHours();
        }, 'businessHours', 'destroy');
    };
    // Misc view rendering utils
    // -----------------------------------------------------------------------------------------------------------------
    // Binds DOM handlers to elements that reside outside the view container, such as the document
    View.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        this.listenTo(GlobalEmitter_1.default.get(), {
            touchstart: this.processUnselect,
            mousedown: this.handleDocumentMousedown
        });
    };
    // Unbinds DOM handlers from elements that reside outside the view container
    View.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        this.stopListeningTo(GlobalEmitter_1.default.get());
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    // Immediately render the current time indicator and begins re-rendering it at an interval,
    // which is defined by this.getNowIndicatorUnit().
    // TODO: somehow do this for the current whole day's background too
    View.prototype.startNowIndicator = function () {
        var _this = this;
        var unit;
        var update;
        var delay; // ms wait value
        if (this.opt('nowIndicator')) {
            unit = this.getNowIndicatorUnit();
            if (unit) {
                update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`
                this.initialNowDate = this.calendar.getNow();
                this.initialNowQueriedMs = +new Date();
                // wait until the beginning of the next interval
                delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
                this.nowIndicatorTimeoutID = setTimeout(function () {
                    _this.nowIndicatorTimeoutID = null;
                    update();
                    delay = +moment.duration(1, unit);
                    delay = Math.max(100, delay); // prevent too frequent
                    _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
                }, delay);
            }
            // rendering will be initiated in updateSize
        }
    };
    // rerenders the now indicator, computing the new current time from the amount of time that has passed
    // since the initial getNow call.
    View.prototype.updateNowIndicator = function () {
        if (this.isDatesRendered &&
            this.initialNowDate // activated before?
        ) {
            this.unrenderNowIndicator(); // won't unrender if unnecessary
            this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms
            );
            this.isNowIndicatorRendered = true;
        }
    };
    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
    // Won't cause side effects if indicator isn't rendered.
    View.prototype.stopNowIndicator = function () {
        if (this.isNowIndicatorRendered) {
            if (this.nowIndicatorTimeoutID) {
                clearTimeout(this.nowIndicatorTimeoutID);
                this.nowIndicatorTimeoutID = null;
            }
            if (this.nowIndicatorIntervalID) {
                clearInterval(this.nowIndicatorIntervalID);
                this.nowIndicatorIntervalID = null;
            }
            this.unrenderNowIndicator();
            this.isNowIndicatorRendered = false;
        }
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        if (this['setHeight']) {
            this['setHeight'](totalHeight, isAuto);
        }
        else {
            _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        }
        this.updateNowIndicator();
    };
    /* Scroller
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.addScroll = function (scroll) {
        var queuedScroll = this.queuedScroll || (this.queuedScroll = {});
        $.extend(queuedScroll, scroll);
    };
    View.prototype.popScroll = function () {
        this.applyQueuedScroll();
        this.queuedScroll = null;
    };
    View.prototype.applyQueuedScroll = function () {
        if (this.queuedScroll) {
            this.applyScroll(this.queuedScroll);
        }
    };
    View.prototype.queryScroll = function () {
        var scroll = {};
        if (this.isDatesRendered) {
            $.extend(scroll, this.queryDateScroll());
        }
        return scroll;
    };
    View.prototype.applyScroll = function (scroll) {
        if (scroll.isDateInit && this.isDatesRendered) {
            $.extend(scroll, this.computeInitialDateScroll());
        }
        if (this.isDatesRendered) {
            this.applyDateScroll(scroll);
        }
    };
    View.prototype.computeInitialDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.queryDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.applyDateScroll = function (scroll) {
        ; // subclasses must implement
    };
    /* Event Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation, this.calendar);
        var dateMutation = eventMutation.dateMutation;
        // update the EventInstance, for handlers
        if (dateMutation) {
            eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        }
        this.triggerEventDrop(eventInstance, 
        // a drop doesn't necessarily mean a date mutation (ex: resource change)
        (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);
    };
    // Triggers event-drop handlers that have subscribed via the API
    View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventDrop', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                dateDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* External Element Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
    // `meta` is the parsed data that has been embedded into the dragging event.
    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
    View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {
        if (isEvent) {
            this.calendar.eventManager.addEventDef(singleEventDef, isSticky);
        }
        this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);
    };
    // Triggers external-drop handlers that have subscribed via the API
    View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {
        // trigger 'drop' regardless of whether element represents an event
        this.publiclyTrigger('drop', {
            context: el[0],
            args: [
                singleEventDef.dateProfile.start.clone(),
                ev,
                ui,
                this
            ]
        });
        if (isEvent) {
            // signal an external event landed
            this.publiclyTrigger('eventReceive', {
                context: this,
                args: [
                    singleEventDef.buildInstance().toLegacy(),
                    this
                ]
            });
        }
    };
    /* Event Resizing
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an event in the view has been resized to a new length
    View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation, this.calendar);
        // update the EventInstance, for handlers
        eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        this.triggerEventResize(eventInstance, eventMutation.dateMutation.endDelta, undoFunc, el, ev);
    };
    // Triggers event-resize handlers that have subscribed via the API
    View.prototype.triggerEventResize = function (eventInstance, durationDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventResize', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                durationDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* Selection (time range)
    ------------------------------------------------------------------------------------------------------------------*/
    // Selects a date span on the view. `start` and `end` are both Moments.
    // `ev` is the native mouse event that begin the interaction.
    View.prototype.select = function (footprint, ev) {
        this.unselect(ev);
        this.renderSelectionFootprint(footprint);
        this.reportSelection(footprint, ev);
    };
    View.prototype.renderSelectionFootprint = function (footprint) {
        if (this['renderSelection']) {
            this['renderSelection'](footprint.toLegacy(this.calendar));
        }
        else {
            _super.prototype.renderSelectionFootprint.call(this, footprint);
        }
    };
    // Called when a new selection is made. Updates internal state and triggers handlers.
    View.prototype.reportSelection = function (footprint, ev) {
        this.isSelected = true;
        this.triggerSelect(footprint, ev);
    };
    // Triggers handlers to 'select'
    View.prototype.triggerSelect = function (footprint, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('select', {
            context: this,
            args: [
                dateProfile.start,
                dateProfile.end,
                ev,
                this
            ]
        });
    };
    // Undoes a selection. updates in the internal state and triggers handlers.
    // `ev` is the native mouse event that began the interaction.
    View.prototype.unselect = function (ev) {
        if (ev === void 0) { ev = null; }
        if (this.isSelected) {
            this.isSelected = false;
            if (this['destroySelection']) {
                this['destroySelection'](); // TODO: deprecate
            }
            this.unrenderSelection();
            this.publiclyTrigger('unselect', {
                context: this,
                args: [ev, this]
            });
        }
    };
    /* Event Selection
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.selectEventInstance = function (eventInstance) {
        if (!this.selectedEventInstance ||
            this.selectedEventInstance !== eventInstance) {
            this.unselectEventInstance();
            this.getEventSegs().forEach(function (seg) {
                if (seg.footprint.eventInstance === eventInstance &&
                    seg.el // necessary?
                ) {
                    seg.el.addClass('fc-selected');
                }
            });
            this.selectedEventInstance = eventInstance;
        }
    };
    View.prototype.unselectEventInstance = function () {
        if (this.selectedEventInstance) {
            this.getEventSegs().forEach(function (seg) {
                if (seg.el) {
                    seg.el.removeClass('fc-selected');
                }
            });
            this.selectedEventInstance = null;
        }
    };
    View.prototype.isEventDefSelected = function (eventDef) {
        // event references might change on refetchEvents(), while selectedEventInstance doesn't,
        // so compare IDs
        return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;
    };
    /* Mouse / Touch Unselecting (time range & event unselection)
    ------------------------------------------------------------------------------------------------------------------*/
    // TODO: move consistently to down/start or up/end?
    // TODO: don't kill previous selection if touch scrolling
    View.prototype.handleDocumentMousedown = function (ev) {
        if (util_1.isPrimaryMouseButton(ev)) {
            this.processUnselect(ev);
        }
    };
    View.prototype.processUnselect = function (ev) {
        this.processRangeUnselect(ev);
        this.processEventUnselect(ev);
    };
    View.prototype.processRangeUnselect = function (ev) {
        var ignore;
        // is there a time-range selection?
        if (this.isSelected && this.opt('unselectAuto')) {
            // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
            ignore = this.opt('unselectCancel');
            if (!ignore || !$(ev.target).closest(ignore).length) {
                this.unselect(ev);
            }
        }
    };
    View.prototype.processEventUnselect = function (ev) {
        if (this.selectedEventInstance) {
            if (!$(ev.target).closest('.fc-selected').length) {
                this.unselectEventInstance();
            }
        }
    };
    /* Triggers
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.triggerBaseRendered = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerBaseUnrendered = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Triggers handlers to 'dayClick'
    // Span has start/end of the clicked area. Only the start is useful.
    View.prototype.triggerDayClick = function (footprint, dayEl, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('dayClick', {
            context: dayEl,
            args: [dateProfile.start, ev, this]
        });
    };
    /* Date Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // For DateComponent::getDayClasses
    View.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return false;
    };
    // Arguments after name will be forwarded to a hypothetical function value
    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
    // Always clone your objects if you fear mutation.
    View.prototype.getUnzonedRangeOption = function (name) {
        var val = this.opt(name);
        if (typeof val === 'function') {
            val = val.apply(null, Array.prototype.slice.call(arguments, 1));
        }
        if (val) {
            return this.calendar.parseUnzonedRange(val);
        }
    };
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/
    // Initializes internal variables related to calculating hidden days-of-week
    View.prototype.initHiddenDays = function () {
        var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
        var dayCnt = 0;
        var i;
        if (this.opt('weekends') === false) {
            hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        }
        for (i = 0; i < 7; i++) {
            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
                dayCnt++;
            }
        }
        if (!dayCnt) {
            throw 'invalid hiddenDays'; // all days were hidden? bad.
        }
        this.isHiddenDayHash = isHiddenDayHash;
    };
    // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null
    View.prototype.trimHiddenDays = function (inputUnzonedRange) {
        var start = inputUnzonedRange.getStart();
        var end = inputUnzonedRange.getEnd();
        if (start) {
            start = this.skipHiddenDays(start);
        }
        if (end) {
            end = this.skipHiddenDays(end, -1, true);
        }
        if (start === null || end === null || start < end) {
            return new UnzonedRange_1.default(start, end);
        }
        return null;
    };
    // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Moment
    View.prototype.isHiddenDay = function (day) {
        if (moment.isMoment(day)) {
            day = day.day();
        }
        return this.isHiddenDayHash[day];
    };
    // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validUnzonedRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)
    View.prototype.skipHiddenDays = function (date, inc, isExclusive) {
        if (inc === void 0) { inc = 1; }
        if (isExclusive === void 0) { isExclusive = false; }
        var out = date.clone();
        while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
            out.add(inc, 'days');
        }
        return out;
    };
    return View;
}(InteractiveDateComponent_1.default));
exports.default = View;
View.prototype.usesMinMaxTime = false;
View.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;
View.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {
    this.requestDateRender(deps.dateProfile);
}, function () {
    this.requestDateUnrender();
});
View.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {
    this.requestBusinessHoursRender(deps.businessHourGenerator);
}, function () {
    this.requestBusinessHoursUnrender();
});
View.watch('initialEvents', ['dateProfile'], function (deps) {
    return this.fetchInitialEvents(deps.dateProfile);
});
View.watch('bindingEvents', ['initialEvents'], function (deps) {
    this.setEvents(deps.initialEvents);
    this.bindEventChanges();
}, function () {
    this.unbindEventChanges();
    this.unsetEvents();
});
View.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {
    this.requestEventsRender(this.get('currentEvents'));
}, function () {
    this.requestEventsUnrender();
});
View.watch('title', ['dateProfile'], function (deps) {
    return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons
});
View.watch('legacyDateProps', ['dateProfile'], function (deps) {
    var calendar = this.calendar;
    var dateProfile = deps.dateProfile;
    // DEPRECATED, but we need to keep it updated...
    this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);
    this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);
});


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventRenderer = /** @class */ (function () {
    function EventRenderer(component, fillRenderer) {
        this.view = component._getView();
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    EventRenderer.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    // Updates values that rely on options and also relate to range
    EventRenderer.prototype.rangeUpdated = function () {
        var displayEventTime;
        var displayEventEnd;
        this.eventTimeFormat =
            this.opt('eventTimeFormat') ||
                this.opt('timeFormat') || // deprecated
                this.computeEventTimeFormat();
        displayEventTime = this.opt('displayEventTime');
        if (displayEventTime == null) {
            displayEventTime = this.computeDisplayEventTime(); // might be based off of range
        }
        displayEventEnd = this.opt('displayEventEnd');
        if (displayEventEnd == null) {
            displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
        }
        this.displayEventTime = displayEventTime;
        this.displayEventEnd = displayEventEnd;
    };
    EventRenderer.prototype.render = function (eventsPayload) {
        var dateProfile = this.component._getDateProfile();
        var eventDefId;
        var instanceGroup;
        var eventRanges;
        var bgRanges = [];
        var fgRanges = [];
        for (eventDefId in eventsPayload) {
            instanceGroup = eventsPayload[eventDefId];
            eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);
            if (instanceGroup.getEventDef().hasBgRendering()) {
                bgRanges.push.apply(bgRanges, eventRanges);
            }
            else {
                fgRanges.push.apply(fgRanges, eventRanges);
            }
        }
        this.renderBgRanges(bgRanges);
        this.renderFgRanges(fgRanges);
    };
    EventRenderer.prototype.unrender = function () {
        this.unrenderBgRanges();
        this.unrenderFgRanges();
    };
    EventRenderer.prototype.renderFgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        // render an `.el` on each seg
        // returns a subset of the segs. segs that were actually rendered
        segs = this.renderFgSegEls(segs);
        if (this.renderFgSegs(segs) !== false) {
            this.fgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderFgRanges = function () {
        this.unrenderFgSegs(this.fgSegs || []);
        this.fgSegs = null;
    };
    EventRenderer.prototype.renderBgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        if (this.renderBgSegs(segs) !== false) {
            this.bgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderBgRanges = function () {
        this.unrenderBgSegs();
        this.bgSegs = null;
    };
    EventRenderer.prototype.getSegs = function () {
        return (this.bgSegs || []).concat(this.fgSegs || []);
    };
    // Renders foreground event segments onto the grid
    EventRenderer.prototype.renderFgSegs = function (segs) {
        // subclasses must implement
        // segs already has rendered els, and has been filtered.
        return false; // signal failure if not implemented
    };
    // Unrenders all currently rendered foreground segments
    EventRenderer.prototype.unrenderFgSegs = function (segs) {
        // subclasses must implement
    };
    EventRenderer.prototype.renderBgSegs = function (segs) {
        var _this = this;
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('bgEvent', segs, {
                getClasses: function (seg) {
                    return _this.getBgClasses(seg.footprint.eventDef);
                },
                getCss: function (seg) {
                    return {
                        'background-color': _this.getBgColor(seg.footprint.eventDef)
                    };
                },
                filterEl: function (seg, el) {
                    return _this.filterEventRenderEl(seg.footprint, el);
                }
            });
        }
        else {
            return false; // signal failure if no fillRenderer
        }
    };
    EventRenderer.prototype.unrenderBgSegs = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('bgEvent');
        }
    };
    // Renders and assigns an `el` property for each foreground event segment.
    // Only returns segments that successfully rendered.
    EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {
        var _this = this;
        if (disableResizing === void 0) { disableResizing = false; }
        var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of event segment HTML
            for (i = 0; i < segs.length; i++) {
                this.beforeFgSegHtml(segs[i]);
                html += this.fgSegHtml(segs[i], disableResizing);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                if (hasEventRenderHandlers) {
                    el = _this.filterEventRenderEl(seg.footprint, el);
                }
                if (el) {
                    el.data('fc-seg', seg); // used by handlers
                    seg.el = el;
                    renderedSegs.push(seg);
                }
            });
        }
        return renderedSegs;
    };
    EventRenderer.prototype.beforeFgSegHtml = function (seg) {
    };
    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
    EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        // subclasses should implement
    };
    // Generic utility for generating the HTML classNames for an event segment's element
    EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {
        var classes = [
            'fc-event',
            seg.isStart ? 'fc-start' : 'fc-not-start',
            seg.isEnd ? 'fc-end' : 'fc-not-end'
        ].concat(this.getClasses(seg.footprint.eventDef));
        if (isDraggable) {
            classes.push('fc-draggable');
        }
        if (isResizable) {
            classes.push('fc-resizable');
        }
        // event is currently selected? attach a className.
        if (this.view.isEventDefSelected(seg.footprint.eventDef)) {
            classes.push('fc-selected');
        }
        return classes;
    };
    // Given an event and the default element used for rendering, returns the element that should actually be used.
    // Basically runs events and elements through the eventRender hook.
    EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {
        var legacy = eventFootprint.getEventLegacy();
        var custom = this.view.publiclyTrigger('eventRender', {
            context: legacy,
            args: [legacy, el, this.view]
        });
        if (custom === false) {
            el = null;
        }
        else if (custom && custom !== true) {
            el = $(custom);
        }
        return el;
    };
    // Compute the text that should be displayed on an event's element.
    // `range` can be the Event object itself, or something range-like, with at least a `start`.
    // If event times are disabled, or the event has no time, will return a blank string.
    // If not specified, formatStr will default to the eventTimeFormat setting,
    // and displayEnd will default to the displayEventEnd setting.
    EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {
        return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);
    };
    EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {
        if (formatStr == null) {
            formatStr = this.eventTimeFormat;
        }
        if (displayEnd == null) {
            displayEnd = this.displayEventEnd;
        }
        if (this.displayEventTime && !isAllDay) {
            if (displayEnd && end) {
                return this.view.formatRange({ start: start, end: end }, false, // allDay
                formatStr);
            }
            else {
                return start.format(formatStr);
            }
        }
        return '';
    };
    EventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('smallTimeFormat');
    };
    EventRenderer.prototype.computeDisplayEventTime = function () {
        return true;
    };
    EventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    EventRenderer.prototype.getBgClasses = function (eventDef) {
        var classNames = this.getClasses(eventDef);
        classNames.push('fc-bgevent');
        return classNames;
    };
    EventRenderer.prototype.getClasses = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var classNames = [];
        for (i = 0; i < objs.length; i++) {
            classNames.push.apply(// append
            classNames, objs[i].eventClassName || objs[i].className || []);
        }
        return classNames;
    };
    // Utility for generating event skin-related CSS properties
    EventRenderer.prototype.getSkinCss = function (eventDef) {
        return {
            'background-color': this.getBgColor(eventDef),
            'border-color': this.getBorderColor(eventDef),
            color: this.getTextColor(eventDef)
        };
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBgColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBackgroundColor || objs[i].eventColor ||
                objs[i].backgroundColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBackgroundColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBorderColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBorderColor || objs[i].eventColor ||
                objs[i].borderColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBorderColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getTextColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventTextColor ||
                objs[i].textColor;
        }
        if (!val) {
            val = this.opt('eventTextColor');
        }
        return val;
    };
    EventRenderer.prototype.getStylingObjs = function (eventDef) {
        var objs = this.getFallbackStylingObjs(eventDef);
        objs.unshift(eventDef);
        return objs;
    };
    EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {
        return [eventDef.source];
    };
    EventRenderer.prototype.sortEventSegs = function (segs) {
        segs.sort(util_1.proxy(this, 'compareEventSegs'));
    };
    // A cmp function for determining which segments should take visual priority
    EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {
        var f1 = seg1.footprint.componentFootprint;
        var r1 = f1.unzonedRange;
        var f2 = seg2.footprint.componentFootprint;
        var r2 = f2.unzonedRange;
        return r1.startMs - r2.startMs || // earlier events go first
            (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first
            f2.isAllDay - f1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)
            util_1.compareByFieldSpecs(seg1.footprint.eventDef, seg2.footprint.eventDef, this.view.eventOrderSpecs);
    };
    return EventRenderer;
}());
exports.default = EventRenderer;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Class_1 = __webpack_require__(21);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var Model = /** @class */ (function (_super) {
    tslib_1.__extends(Model, _super);
    function Model() {
        var _this = _super.call(this) || this;
        _this._watchers = {};
        _this._props = {};
        _this.applyGlobalWatchers();
        _this.constructed();
        return _this;
    }
    // useful for monkeypatching. TODO: BaseClass?
    Model.prototype.constructed = function () {
    };
    Model.prototype.applyGlobalWatchers = function () {
        var map = this._globalWatchArgs;
        var name;
        for (name in map) {
            this.watch.apply(this, [name].concat(map[name]));
        }
    };
    Model.prototype.has = function (name) {
        return name in this._props;
    };
    Model.prototype.get = function (name) {
        if (name === undefined) {
            return this._props;
        }
        return this._props[name];
    };
    Model.prototype.set = function (name, val) {
        var newProps;
        if (typeof name === 'string') {
            newProps = {};
            newProps[name] = val === undefined ? null : val;
        }
        else {
            newProps = name;
        }
        this.setProps(newProps);
    };
    Model.prototype.reset = function (newProps) {
        var oldProps = this._props;
        var changeset = {}; // will have undefined's to signal unsets
        var name;
        for (name in oldProps) {
            changeset[name] = undefined;
        }
        for (name in newProps) {
            changeset[name] = newProps[name];
        }
        this.setProps(changeset);
    };
    Model.prototype.unset = function (name) {
        var newProps = {};
        var names;
        var i;
        if (typeof name === 'string') {
            names = [name];
        }
        else {
            names = name;
        }
        for (i = 0; i < names.length; i++) {
            newProps[names[i]] = undefined;
        }
        this.setProps(newProps);
    };
    Model.prototype.setProps = function (newProps) {
        var changedProps = {};
        var changedCnt = 0;
        var name, val;
        for (name in newProps) {
            val = newProps[name];
            // a change in value?
            // if an object, don't check equality, because might have been mutated internally.
            // TODO: eventually enforce immutability.
            if (typeof val === 'object' ||
                val !== this._props[name]) {
                changedProps[name] = val;
                changedCnt++;
            }
        }
        if (changedCnt) {
            this.trigger('before:batchChange', changedProps);
            for (name in changedProps) {
                val = changedProps[name];
                this.trigger('before:change', name, val);
                this.trigger('before:change:' + name, val);
            }
            for (name in changedProps) {
                val = changedProps[name];
                if (val === undefined) {
                    delete this._props[name];
                }
                else {
                    this._props[name] = val;
                }
                this.trigger('change:' + name, val);
                this.trigger('change', name, val);
            }
            this.trigger('batchChange', changedProps);
        }
    };
    Model.prototype.watch = function (name, depList, startFunc, stopFunc) {
        var _this = this;
        this.unwatch(name);
        this._watchers[name] = this._watchDeps(depList, function (deps) {
            var res = startFunc.call(_this, deps);
            if (res && res.then) {
                _this.unset(name); // put in an unset state while resolving
                res.then(function (val) {
                    _this.set(name, val);
                });
            }
            else {
                _this.set(name, res);
            }
        }, function (deps) {
            _this.unset(name);
            if (stopFunc) {
                stopFunc.call(_this, deps);
            }
        });
    };
    Model.prototype.unwatch = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            delete this._watchers[name];
            watcher.teardown();
        }
    };
    Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {
        var _this = this;
        var queuedChangeCnt = 0;
        var depCnt = depList.length;
        var satisfyCnt = 0;
        var values = {}; // what's passed as the `deps` arguments
        var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
        var isCallingStop = false;
        var onBeforeDepChange = function (depName, val, isOptional) {
            queuedChangeCnt++;
            if (queuedChangeCnt === 1) {
                if (satisfyCnt === depCnt) {
                    isCallingStop = true;
                    stopFunc(values);
                    isCallingStop = false;
                }
            }
        };
        var onDepChange = function (depName, val, isOptional) {
            if (val === undefined) {
                // required dependency that was previously set?
                if (!isOptional && values[depName] !== undefined) {
                    satisfyCnt--;
                }
                delete values[depName];
            }
            else {
                // required dependency that was previously unset?
                if (!isOptional && values[depName] === undefined) {
                    satisfyCnt++;
                }
                values[depName] = val;
            }
            queuedChangeCnt--;
            if (!queuedChangeCnt) {
                // now finally satisfied or satisfied all along?
                if (satisfyCnt === depCnt) {
                    // if the stopFunc initiated another value change, ignore it.
                    // it will be processed by another change event anyway.
                    if (!isCallingStop) {
                        startFunc(values);
                    }
                }
            }
        };
        // intercept for .on() that remembers handlers
        var bind = function (eventName, handler) {
            _this.on(eventName, handler);
            bindTuples.push([eventName, handler]);
        };
        // listen to dependency changes
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') {
                depName = depName.substring(1);
                isOptional = true;
            }
            bind('before:change:' + depName, function (val) {
                onBeforeDepChange(depName, val, isOptional);
            });
            bind('change:' + depName, function (val) {
                onDepChange(depName, val, isOptional);
            });
        });
        // process current dependency values
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') {
                depName = depName.substring(1);
                isOptional = true;
            }
            if (_this.has(depName)) {
                values[depName] = _this.get(depName);
                satisfyCnt++;
            }
            else if (isOptional) {
                satisfyCnt++;
            }
        });
        // initially satisfied
        if (satisfyCnt === depCnt) {
            startFunc(values);
        }
        return {
            teardown: function () {
                // remove all handlers
                for (var i = 0; i < bindTuples.length; i++) {
                    _this.off(bindTuples[i][0], bindTuples[i][1]);
                }
                bindTuples = null;
                // was satisfied, so call stopFunc
                if (satisfyCnt === depCnt) {
                    stopFunc();
                }
            },
            flash: function () {
                if (satisfyCnt === depCnt) {
                    stopFunc();
                    startFunc(values);
                }
            }
        };
    };
    Model.prototype.flash = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            watcher.flash();
        }
    };
    Model.watch = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // subclasses should make a masked-copy of the superclass's map
        // TODO: write test
        if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {
            this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);
        }
        this.prototype._globalWatchArgs[name] = args;
    };
    return Model;
}(Class_1.default));
exports.default = Model;
Model.prototype._globalWatchArgs = {}; // mutation protection in Model.watch
EmitterMixin_1.default.mixInto(Model);
ListenerMixin_1.default.mixInto(Model);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var SingleEventDef_1 = __webpack_require__(11);
var RecurringEventDef_1 = __webpack_require__(52);
exports.default = {
    parse: function (eventInput, source) {
        if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||
            util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {
            return RecurringEventDef_1.default.parse(eventInput, source);
        }
        else {
            return SingleEventDef_1.default.parse(eventInput, source);
        }
    }
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Promise_1 = __webpack_require__(16);
var EventSource_1 = __webpack_require__(5);
var SingleEventDef_1 = __webpack_require__(11);
var ArrayEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(ArrayEventSource, _super);
    function ArrayEventSource(calendar) {
        var _this = _super.call(this, calendar) || this;
        _this.eventDefs = []; // for if setRawEventDefs is never called
        return _this;
    }
    ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {
        this.rawEventDefs = rawEventDefs;
        this.eventDefs = this.parseEventDefs(rawEventDefs);
    };
    ArrayEventSource.prototype.fetch = function (start, end, timezone) {
        var eventDefs = this.eventDefs;
        var i;
        if (this.currentTimezone != null &&
            this.currentTimezone !== timezone) {
            for (i = 0; i < eventDefs.length; i++) {
                if (eventDefs[i] instanceof SingleEventDef_1.default) {
                    eventDefs[i].rezone();
                }
            }
        }
        this.currentTimezone = timezone;
        return Promise_1.default.resolve(eventDefs);
    };
    ArrayEventSource.prototype.addEventDef = function (eventDef) {
        this.eventDefs.push(eventDef);
    };
    /*
    eventDefId already normalized to a string
    */
    ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {
        return util_1.removeMatching(this.eventDefs, function (eventDef) {
            return eventDef.id === eventDefId;
        });
    };
    ArrayEventSource.prototype.removeAllEventDefs = function () {
        this.eventDefs = [];
    };
    ArrayEventSource.prototype.getPrimitive = function () {
        return this.rawEventDefs;
    };
    ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.setRawEventDefs(rawProps.events);
        return superSuccess;
    };
    ArrayEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isArray(rawInput.events)) {
            rawProps = rawInput;
        }
        else if ($.isArray(rawInput)) {
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    return ArrayEventSource;
}(EventSource_1.default));
exports.default = ArrayEventSource;
ArrayEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(2);
var EventDateProfile_1 = __webpack_require__(15);
var EventDefDateMutation = /** @class */ (function () {
    function EventDefDateMutation() {
        this.clearEnd = false;
        this.forceTimed = false;
        this.forceAllDay = false;
    }
    /*
    returns an undo function.
    */
    EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {
        var start = eventDateProfile.start.clone();
        var end = null;
        var shouldRezone = false;
        if (eventDateProfile.end && !this.clearEnd) {
            end = eventDateProfile.end.clone();
        }
        else if (this.endDelta && !end) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        if (this.forceTimed) {
            shouldRezone = true;
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        else if (this.forceAllDay) {
            if (start.hasTime()) {
                start.stripTime();
            }
            if (end && end.hasTime()) {
                end.stripTime();
            }
        }
        if (this.dateDelta) {
            shouldRezone = true;
            start.add(this.dateDelta);
            if (end) {
                end.add(this.dateDelta);
            }
        }
        // do this before adding startDelta to start, so we can work off of start
        if (this.endDelta) {
            shouldRezone = true;
            end.add(this.endDelta);
        }
        if (this.startDelta) {
            shouldRezone = true;
            start.add(this.startDelta);
        }
        if (shouldRezone) {
            start = calendar.applyTimezone(start);
            if (end) {
                end = calendar.applyTimezone(end);
            }
        }
        // TODO: okay to access calendar option?
        if (!end && calendar.opt('forceEventDuration')) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        return new EventDateProfile_1.default(start, end, calendar);
    };
    EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {
        if (dateDelta && dateDelta.valueOf()) {
            this.dateDelta = dateDelta;
        }
        else {
            this.dateDelta = null;
        }
    };
    EventDefDateMutation.prototype.setStartDelta = function (startDelta) {
        if (startDelta && startDelta.valueOf()) {
            this.startDelta = startDelta;
        }
        else {
            this.startDelta = null;
        }
    };
    EventDefDateMutation.prototype.setEndDelta = function (endDelta) {
        if (endDelta && endDelta.valueOf()) {
            this.endDelta = endDelta;
        }
        else {
            this.endDelta = null;
        }
    };
    EventDefDateMutation.prototype.isEmpty = function () {
        return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&
            !this.dateDelta && !this.startDelta && !this.endDelta;
    };
    EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {
        var clearEnd = dateProfile0.end && !dateProfile1.end;
        var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();
        var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();
        var dateDelta;
        var endDiff;
        var endDelta;
        var mutation;
        // subtracts the dates in the appropriate way, returning a duration
        function subtractDates(date1, date0) {
            if (largeUnit) {
                return util_1.diffByUnit(date1, date0, largeUnit); // poorly named
            }
            else if (dateProfile1.isAllDay()) {
                return util_1.diffDay(date1, date0); // poorly named
            }
            else {
                return util_1.diffDayTime(date1, date0); // poorly named
            }
        }
        dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);
        if (dateProfile1.end) {
            // use unzonedRanges because dateProfile0.end might be null
            endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());
            endDelta = endDiff.subtract(dateDelta);
        }
        mutation = new EventDefDateMutation();
        mutation.clearEnd = clearEnd;
        mutation.forceTimed = forceTimed;
        mutation.forceAllDay = forceAllDay;
        mutation.setDateDelta(dateDelta);
        mutation.setEndDelta(endDelta);
        return mutation;
    };
    return EventDefDateMutation;
}());
exports.default = EventDefDateMutation;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var StandardTheme_1 = __webpack_require__(55);
var JqueryUiTheme_1 = __webpack_require__(56);
exports.default = {
    themeClassHash: {},
    register: function (themeName, themeClass) {
        this.themeClassHash[themeName] = themeClass;
    },
    getThemeClass: function (themeSetting) {
        if (!themeSetting) {
            return StandardTheme_1.default;
        }
        else if (themeSetting === true) {
            return JqueryUiTheme_1.default;
        }
        else {
            return this.themeClassHash[themeSetting];
        }
    }
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment_ext_1 = __webpack_require__(9);
// Plugin
// -------------------------------------------------------------------------------------------------
moment_ext_1.newMomentProto.format = function () {
    if (this._fullCalendar && arguments[0]) {
        return formatDate(this, arguments[0]); // our extended formatting
    }
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) {
        // moment.format() doesn't ensure english, but we want to.
        return moment_ext_1.oldMomentFormat(englishMoment(this));
    }
    return moment_ext_1.oldMomentProto.format.apply(this, arguments);
};
moment_ext_1.newMomentProto.toISOString = function () {
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) {
        // depending on browser, moment might not output english. ensure english.
        // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
        return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);
    }
    return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);
};
function englishMoment(mom) {
    if (mom.locale() !== 'en') {
        return mom.clone().locale('en');
    }
    return mom;
}
// Config
// ---------------------------------------------------------------------------------------------------------------------
/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab
/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1
/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global
/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
    t: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);
    },
    T: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);
    }
};
/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
    Y: { value: 1, unit: 'year' },
    M: { value: 2, unit: 'month' },
    W: { value: 3, unit: 'week' },
    w: { value: 3, unit: 'week' },
    D: { value: 4, unit: 'day' },
    d: { value: 4, unit: 'day' } // day of week
};
// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
    return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);
}
exports.formatDate = formatDate;
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
    var localeData;
    date1 = moment_ext_1.default.parseZone(date1);
    date2 = moment_ext_1.default.parseZone(date2);
    localeData = date1.localeData();
    // Expand localized format strings, like "LL" -> "MMMM D YYYY".
    // BTW, this is not important for `formatDate` because it is impossible to put custom tokens
    // or non-zero areas in Moment's localized format strings.
    formatStr = localeData.longDateFormat(formatStr) || formatStr;
    return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);
}
exports.formatRange = formatRange;
/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
    var sameUnits = parsedFormat.sameUnits;
    var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
    var unzonedDate2 = date2.clone().stripZone(); // "
    var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
    var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);
    var leftI;
    var leftStr = '';
    var rightI;
    var rightStr = '';
    var middleI;
    var middleStr1 = '';
    var middleStr2 = '';
    var middleStr = '';
    // Start at the leftmost side of the formatting string and continue until you hit a token
    // that is not the same between dates.
    for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {
        leftStr += renderedParts1[leftI];
    }
    // Similarly, start at the rightmost side of the formatting string and move left
    for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {
        // If current chunk is on the boundary of unique date-content, and is a special-case
        // date-formatting postfix character, then don't consume it. Consider it unique date-content.
        // TODO: make configurable
        if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
            break;
        }
        rightStr = renderedParts1[rightI] + rightStr;
    }
    // The area in the middle is different for both of the dates.
    // Collect them distinctly so we can jam them together later.
    for (middleI = leftI; middleI <= rightI; middleI++) {
        middleStr1 += renderedParts1[middleI];
        middleStr2 += renderedParts2[middleI];
    }
    if (middleStr1 || middleStr2) {
        if (isRTL) {
            middleStr = middleStr2 + separator + middleStr1;
        }
        else {
            middleStr = middleStr1 + separator + middleStr2;
        }
    }
    return processMaybeMarkers(leftStr + middleStr + rightStr);
}
// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------
var parsedFormatStrCache = {};
/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
    return parsedFormatStrCache[formatStr] ||
        (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}
/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
    var chunks = chunkFormatString(formatStr);
    return {
        fakeFormatString: buildFakeFormatString(chunks),
        sameUnits: buildSameUnits(chunks)
    };
}
/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
    var chunks = [];
    var match;
    // TODO: more descrimination
    // \4 is a backreference to the first character of a multi-character set.
    var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
    while ((match = chunker.exec(formatStr))) {
        if (match[1]) {
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[1]));
        }
        else if (match[2]) {
            chunks.push({ maybe: chunkFormatString(match[2]) });
        }
        else if (match[3]) {
            chunks.push({ token: match[3] });
        }
        else if (match[5]) {
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[5]));
        }
    }
    return chunks;
}
/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
    if (s === '. ') {
        return ['.', ' ']; // for locales with periods bound to the end of each year/month/date
    }
    else {
        return [s];
    }
}
/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
    var parts = [];
    var i, chunk;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (typeof chunk === 'string') {
            parts.push('[' + chunk + ']');
        }
        else if (chunk.token) {
            if (chunk.token in specialTokens) {
                parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing
                    '[' + chunk.token + ']' // preserve as literal text
                );
            }
            else {
                parts.push(chunk.token); // unprotected text implies a format string
            }
        }
        else if (chunk.maybe) {
            parts.push(MAYBE_MARKER + // useful during post-processing
                buildFakeFormatString(chunk.maybe) +
                MAYBE_MARKER);
        }
    }
    return parts.join(PART_SEPARATOR);
}
/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
    var units = [];
    var i, chunk;
    var tokenInfo;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            tokenInfo = largeTokenMap[chunk.token.charAt(0)];
            units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
        }
        else if (chunk.maybe) {
            units.push.apply(units, // append
            buildSameUnits(chunk.maybe));
        }
        else {
            units.push(null);
        }
    }
    return units;
}
// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
    return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));
}
/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
    var parts = [];
    var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);
    var fakeParts = fakeRender.split(PART_SEPARATOR);
    var i, fakePart;
    for (i = 0; i < fakeParts.length; i++) {
        fakePart = fakeParts[i];
        if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
            parts.push(
            // the literal string IS the token's name.
            // call special token's registered function.
            specialTokens[fakePart.substring(1)](date));
        }
        else {
            parts.push(fakePart);
        }
    }
    return parts;
}
/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
    return s.replace(MAYBE_REGEXP, function (m0, m1) {
        if (m1.match(/[1-9]/)) {
            return m1;
        }
        else {
            return '';
        }
    });
}
// Misc Utils
// -------------------------------------------------------------------------------------------------
/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
    var chunks = chunkFormatString(formatStr);
    var i, chunk;
    var candidate;
    var best;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            candidate = largeTokenMap[chunk.token.charAt(0)];
            if (candidate) {
                if (!best || candidate.value > best.value) {
                    best = candidate;
                }
            }
        }
    }
    if (best) {
        return best.unit;
    }
    return null;
}
exports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = /** @class */ (function () {
    function CoordCache(options) {
        this.isHorizontal = false; // whether to query for left/right/width
        this.isVertical = false; // whether to query for top/bottom/height
        this.els = $(options.els);
        this.isHorizontal = options.isHorizontal;
        this.isVertical = options.isVertical;
        this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
    }
    // Queries the els for coordinates and stores them.
    // Call this method before using and of the get* methods below.
    CoordCache.prototype.build = function () {
        var offsetParentEl = this.forcedOffsetParentEl;
        if (!offsetParentEl && this.els.length > 0) {
            offsetParentEl = this.els.eq(0).offsetParent();
        }
        this.origin = offsetParentEl ?
            offsetParentEl.offset() :
            null;
        this.boundingRect = this.queryBoundingRect();
        if (this.isHorizontal) {
            this.buildElHorizontals();
        }
        if (this.isVertical) {
            this.buildElVerticals();
        }
    };
    // Destroys all internal data about coordinates, freeing memory
    CoordCache.prototype.clear = function () {
        this.origin = null;
        this.boundingRect = null;
        this.lefts = null;
        this.rights = null;
        this.tops = null;
        this.bottoms = null;
    };
    // When called, if coord caches aren't built, builds them
    CoordCache.prototype.ensureBuilt = function () {
        if (!this.origin) {
            this.build();
        }
    };
    // Populates the left/right internal coordinate arrays
    CoordCache.prototype.buildElHorizontals = function () {
        var lefts = [];
        var rights = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var left = el.offset().left;
            var width = el.outerWidth();
            lefts.push(left);
            rights.push(left + width);
        });
        this.lefts = lefts;
        this.rights = rights;
    };
    // Populates the top/bottom internal coordinate arrays
    CoordCache.prototype.buildElVerticals = function () {
        var tops = [];
        var bottoms = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var top = el.offset().top;
            var height = el.outerHeight();
            tops.push(top);
            bottoms.push(top + height);
        });
        this.tops = tops;
        this.bottoms = bottoms;
    };
    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getHorizontalIndex = function (leftOffset) {
        this.ensureBuilt();
        var lefts = this.lefts;
        var rights = this.rights;
        var len = lefts.length;
        var i;
        for (i = 0; i < len; i++) {
            if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                return i;
            }
        }
    };
    // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getVerticalIndex = function (topOffset) {
        this.ensureBuilt();
        var tops = this.tops;
        var bottoms = this.bottoms;
        var len = tops.length;
        var i;
        for (i = 0; i < len; i++) {
            if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                return i;
            }
        }
    };
    // Gets the left offset (from document left) of the element at the given index
    CoordCache.prototype.getLeftOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex];
    };
    // Gets the left position (from offsetParent left) of the element at the given index
    CoordCache.prototype.getLeftPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex] - this.origin.left;
    };
    // Gets the right offset (from document left) of the element at the given index.
    // This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex];
    };
    // Gets the right position (from offsetParent left) of the element at the given index.
    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.origin.left;
    };
    // Gets the width of the element at the given index
    CoordCache.prototype.getWidth = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.lefts[leftIndex];
    };
    // Gets the top offset (from document top) of the element at the given index
    CoordCache.prototype.getTopOffset = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex];
    };
    // Gets the top position (from offsetParent top) of the element at the given position
    CoordCache.prototype.getTopPosition = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex] - this.origin.top;
    };
    // Gets the bottom offset (from the document top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomOffset = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex];
    };
    // Gets the bottom position (from the offsetParent top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomPosition = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.origin.top;
    };
    // Gets the height of the element at the given index
    CoordCache.prototype.getHeight = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.tops[topIndex];
    };
    // Bounding Rect
    // TODO: decouple this from CoordCache
    // Compute and return what the elements' bounding rectangle is, from the user's perspective.
    // Right now, only returns a rectangle if constrained by an overflow:scroll element.
    // Returns null if there are no elements
    CoordCache.prototype.queryBoundingRect = function () {
        var scrollParentEl;
        if (this.els.length > 0) {
            scrollParentEl = util_1.getScrollParent(this.els.eq(0));
            if (!scrollParentEl.is(document)) {
                return util_1.getClientRect(scrollParentEl);
            }
        }
        return null;
    };
    CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {
        return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
    };
    CoordCache.prototype.isLeftInBounds = function (leftOffset) {
        return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
    };
    CoordCache.prototype.isTopInBounds = function (topOffset) {
        return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
    };
    return CoordCache;
}());
exports.default = CoordCache;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var ListenerMixin_1 = __webpack_require__(6);
var GlobalEmitter_1 = __webpack_require__(14);
/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter
var DragListener = /** @class */ (function () {
    function DragListener(options) {
        this.isInteracting = false;
        this.isDistanceSurpassed = false;
        this.isDelayEnded = false;
        this.isDragging = false;
        this.isTouch = false;
        this.isGeneric = false; // initiated by 'dragstart' (jqui)
        this.shouldCancelTouchScroll = true;
        this.scrollAlwaysKills = false;
        this.isAutoScroll = false;
        // defaults
        this.scrollSensitivity = 30; // pixels from edge for scrolling to start
        this.scrollSpeed = 200; // pixels per second, at maximum speed
        this.scrollIntervalMs = 50; // millisecond wait between scroll increment
        this.options = options || {};
    }
    // Interaction (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startInteraction = function (ev, extraOptions) {
        if (extraOptions === void 0) { extraOptions = {}; }
        if (ev.type === 'mousedown') {
            if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {
                return;
            }
            else if (!util_1.isPrimaryMouseButton(ev)) {
                return;
            }
            else {
                ev.preventDefault(); // prevents native selection in most browsers
            }
        }
        if (!this.isInteracting) {
            // process options
            this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);
            this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);
            this.subjectEl = this.options.subjectEl;
            util_1.preventSelection($('body'));
            this.isInteracting = true;
            this.isTouch = util_1.getEvIsTouch(ev);
            this.isGeneric = ev.type === 'dragstart';
            this.isDelayEnded = false;
            this.isDistanceSurpassed = false;
            this.originX = util_1.getEvX(ev);
            this.originY = util_1.getEvY(ev);
            this.scrollEl = util_1.getScrollParent($(ev.target));
            this.bindHandlers();
            this.initAutoScroll();
            this.handleInteractionStart(ev);
            this.startDelay(ev);
            if (!this.minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
    };
    DragListener.prototype.handleInteractionStart = function (ev) {
        this.trigger('interactionStart', ev);
    };
    DragListener.prototype.endInteraction = function (ev, isCancelled) {
        if (this.isInteracting) {
            this.endDrag(ev);
            if (this.delayTimeoutId) {
                clearTimeout(this.delayTimeoutId);
                this.delayTimeoutId = null;
            }
            this.destroyAutoScroll();
            this.unbindHandlers();
            this.isInteracting = false;
            this.handleInteractionEnd(ev, isCancelled);
            util_1.allowSelection($('body'));
        }
    };
    DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        this.trigger('interactionEnd', ev, isCancelled || false);
    };
    // Binding To DOM
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.bindHandlers = function () {
        // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
        // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
        var globalEmitter = GlobalEmitter_1.default.get();
        if (this.isGeneric) {
            this.listenTo($(document), {
                drag: this.handleMove,
                dragstop: this.endInteraction
            });
        }
        else if (this.isTouch) {
            this.listenTo(globalEmitter, {
                touchmove: this.handleTouchMove,
                touchend: this.endInteraction,
                scroll: this.handleTouchScroll
            });
        }
        else {
            this.listenTo(globalEmitter, {
                mousemove: this.handleMouseMove,
                mouseup: this.endInteraction
            });
        }
        this.listenTo(globalEmitter, {
            selectstart: util_1.preventDefault,
            contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools
        });
    };
    DragListener.prototype.unbindHandlers = function () {
        this.stopListeningTo(GlobalEmitter_1.default.get());
        this.stopListeningTo($(document)); // for isGeneric
    };
    // Drag (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    // extraOptions ignored if drag already started
    DragListener.prototype.startDrag = function (ev, extraOptions) {
        this.startInteraction(ev, extraOptions); // ensure interaction began
        if (!this.isDragging) {
            this.isDragging = true;
            this.handleDragStart(ev);
        }
    };
    DragListener.prototype.handleDragStart = function (ev) {
        this.trigger('dragStart', ev);
    };
    DragListener.prototype.handleMove = function (ev) {
        var dx = util_1.getEvX(ev) - this.originX;
        var dy = util_1.getEvY(ev) - this.originY;
        var minDistance = this.minDistance;
        var distanceSq; // current distance from the origin, squared
        if (!this.isDistanceSurpassed) {
            distanceSq = dx * dx + dy * dy;
            if (distanceSq >= minDistance * minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
        if (this.isDragging) {
            this.handleDrag(dx, dy, ev);
        }
    };
    // Called while the mouse is being moved and when we know a legitimate drag is taking place
    DragListener.prototype.handleDrag = function (dx, dy, ev) {
        this.trigger('drag', dx, dy, ev);
        this.updateAutoScroll(ev); // will possibly cause scrolling
    };
    DragListener.prototype.endDrag = function (ev) {
        if (this.isDragging) {
            this.isDragging = false;
            this.handleDragEnd(ev);
        }
    };
    DragListener.prototype.handleDragEnd = function (ev) {
        this.trigger('dragEnd', ev);
    };
    // Delay
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startDelay = function (initialEv) {
        var _this = this;
        if (this.delay) {
            this.delayTimeoutId = setTimeout(function () {
                _this.handleDelayEnd(initialEv);
            }, this.delay);
        }
        else {
            this.handleDelayEnd(initialEv);
        }
    };
    DragListener.prototype.handleDelayEnd = function (initialEv) {
        this.isDelayEnded = true;
        if (this.isDistanceSurpassed) {
            this.startDrag(initialEv);
        }
    };
    // Distance
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleDistanceSurpassed = function (ev) {
        this.isDistanceSurpassed = true;
        if (this.isDelayEnded) {
            this.startDrag(ev);
        }
    };
    // Mouse / Touch
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchMove = function (ev) {
        // prevent inertia and touchmove-scrolling while dragging
        if (this.isDragging && this.shouldCancelTouchScroll) {
            ev.preventDefault();
        }
        this.handleMove(ev);
    };
    DragListener.prototype.handleMouseMove = function (ev) {
        this.handleMove(ev);
    };
    // Scrolling (unrelated to auto-scroll)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchScroll = function (ev) {
        // if the drag is being initiated by touch, but a scroll happens before
        // the drag-initiating delay is over, cancel the drag
        if (!this.isDragging || this.scrollAlwaysKills) {
            this.endInteraction(ev, true); // isCancelled=true
        }
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    DragListener.prototype.trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.options[name]) {
            this.options[name].apply(this, args);
        }
        // makes _methods callable by event name. TODO: kill this
        if (this['_' + name]) {
            this['_' + name].apply(this, args);
        }
    };
    // Auto-scroll
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.initAutoScroll = function () {
        var scrollEl = this.scrollEl;
        this.isAutoScroll =
            this.options.scroll &&
                scrollEl &&
                !scrollEl.is(window) &&
                !scrollEl.is(document);
        if (this.isAutoScroll) {
            // debounce makes sure rapid calls don't happen
            this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));
        }
    };
    DragListener.prototype.destroyAutoScroll = function () {
        this.endAutoScroll(); // kill any animation loop
        // remove the scroll handler if there is a scrollEl
        if (this.isAutoScroll) {
            this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
        }
    };
    // Computes and stores the bounding rectangle of scrollEl
    DragListener.prototype.computeScrollBounds = function () {
        if (this.isAutoScroll) {
            this.scrollBounds = util_1.getOuterRect(this.scrollEl);
            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
        }
    };
    // Called when the dragging is in progress and scrolling should be updated
    DragListener.prototype.updateAutoScroll = function (ev) {
        var sensitivity = this.scrollSensitivity;
        var bounds = this.scrollBounds;
        var topCloseness, bottomCloseness;
        var leftCloseness, rightCloseness;
        var topVel = 0;
        var leftVel = 0;
        if (bounds) {
            // compute closeness to edges. valid range is from 0.0 - 1.0
            topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;
            bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;
            leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;
            rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;
            // translate vertical closeness into velocity.
            // mouse must be completely in bounds for velocity to happen.
            if (topCloseness >= 0 && topCloseness <= 1) {
                topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
            }
            else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                topVel = bottomCloseness * this.scrollSpeed;
            }
            // translate horizontal closeness into velocity
            if (leftCloseness >= 0 && leftCloseness <= 1) {
                leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
            }
            else if (rightCloseness >= 0 && rightCloseness <= 1) {
                leftVel = rightCloseness * this.scrollSpeed;
            }
        }
        this.setScrollVel(topVel, leftVel);
    };
    // Sets the speed-of-scrolling for the scrollEl
    DragListener.prototype.setScrollVel = function (topVel, leftVel) {
        this.scrollTopVel = topVel;
        this.scrollLeftVel = leftVel;
        this.constrainScrollVel(); // massages into realistic values
        // if there is non-zero velocity, and an animation loop hasn't already started, then START
        if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
            this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`
            this.scrollIntervalMs);
        }
    };
    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
    DragListener.prototype.constrainScrollVel = function () {
        var el = this.scrollEl;
        if (this.scrollTopVel < 0) {
            if (el.scrollTop() <= 0) {
                this.scrollTopVel = 0;
            }
        }
        else if (this.scrollTopVel > 0) {
            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {
                this.scrollTopVel = 0;
            }
        }
        if (this.scrollLeftVel < 0) {
            if (el.scrollLeft() <= 0) {
                this.scrollLeftVel = 0;
            }
        }
        else if (this.scrollLeftVel > 0) {
            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {
                this.scrollLeftVel = 0;
            }
        }
    };
    // This function gets called during every iteration of the scrolling animation loop
    DragListener.prototype.scrollIntervalFunc = function () {
        var el = this.scrollEl;
        var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by
        // change the value of scrollEl's scroll
        if (this.scrollTopVel) {
            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
        }
        if (this.scrollLeftVel) {
            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
        }
        this.constrainScrollVel(); // since the scroll values changed, recompute the velocities
        // if scrolled all the way, which causes the vels to be zero, stop the animation loop
        if (!this.scrollTopVel && !this.scrollLeftVel) {
            this.endAutoScroll();
        }
    };
    // Kills any existing scrolling animation loop
    DragListener.prototype.endAutoScroll = function () {
        if (this.scrollIntervalId) {
            clearInterval(this.scrollIntervalId);
            this.scrollIntervalId = null;
            this.handleScrollEnd();
        }
    };
    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
    DragListener.prototype.handleDebouncedScroll = function () {
        // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
        if (!this.scrollIntervalId) {
            this.handleScrollEnd();
        }
    };
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    DragListener.prototype.handleScrollEnd = function () {
    };
    return DragListener;
}());
exports.default = DragListener;
ListenerMixin_1.default.mixInto(DragListener);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var Mixin_1 = __webpack_require__(12);
/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = /** @class */ (function (_super) {
    tslib_1.__extends(DayTableMixin, _super);
    function DayTableMixin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.breakOnWeeks = false; // should create a new row for each week?
        return _this;
    }
    // Populates internal variables used for date calculation and rendering
    DayTableMixin.prototype.updateDayTable = function () {
        var t = this;
        var view = t.view;
        var calendar = view.calendar;
        var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);
        var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);
        var dayIndex = -1;
        var dayIndices = [];
        var dayDates = [];
        var daysPerRow;
        var firstDay;
        var rowCnt;
        while (date.isBefore(end)) {
            if (view.isHiddenDay(date)) {
                dayIndices.push(dayIndex + 0.5); // mark that it's between indices
            }
            else {
                dayIndex++;
                dayIndices.push(dayIndex);
                dayDates.push(date.clone());
            }
            date.add(1, 'days');
        }
        if (this.breakOnWeeks) {
            // count columns until the day-of-week repeats
            firstDay = dayDates[0].day();
            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
                if (dayDates[daysPerRow].day() == firstDay) {
                    break;
                }
            }
            rowCnt = Math.ceil(dayDates.length / daysPerRow);
        }
        else {
            rowCnt = 1;
            daysPerRow = dayDates.length;
        }
        this.dayDates = dayDates;
        this.dayIndices = dayIndices;
        this.daysPerRow = daysPerRow;
        this.rowCnt = rowCnt;
        this.updateDayTableCols();
    };
    // Computes and assigned the colCnt property and updates any options that may be computed from it
    DayTableMixin.prototype.updateDayTableCols = function () {
        this.colCnt = this.computeColCnt();
        this.colHeadFormat = this.opt('columnFormat') || this.computeColHeadFormat();
    };
    // Determines how many columns there should be in the table
    DayTableMixin.prototype.computeColCnt = function () {
        return this.daysPerRow;
    };
    // Computes the ambiguously-timed moment for the given cell
    DayTableMixin.prototype.getCellDate = function (row, col) {
        return this.dayDates[this.getCellDayIndex(row, col)].clone();
    };
    // Computes the ambiguously-timed date range for the given cell
    DayTableMixin.prototype.getCellRange = function (row, col) {
        var start = this.getCellDate(row, col);
        var end = start.clone().add(1, 'days');
        return { start: start, end: end };
    };
    // Returns the number of day cells, chronologically, from the first of the grid (0-based)
    DayTableMixin.prototype.getCellDayIndex = function (row, col) {
        return row * this.daysPerRow + this.getColDayIndex(col);
    };
    // Returns the numner of day cells, chronologically, from the first cell in *any given row*
    DayTableMixin.prototype.getColDayIndex = function (col) {
        if (this.isRTL) {
            return this.colCnt - 1 - col;
        }
        else {
            return col;
        }
    };
    // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
    DayTableMixin.prototype.getDateDayIndex = function (date) {
        var dayIndices = this.dayIndices;
        var dayOffset = date.diff(this.dayDates[0], 'days');
        if (dayOffset < 0) {
            return dayIndices[0] - 1;
        }
        else if (dayOffset >= dayIndices.length) {
            return dayIndices[dayIndices.length - 1] + 1;
        }
        else {
            return dayIndices[dayOffset];
        }
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes a default column header formatting string if `colFormat` is not explicitly defined
    DayTableMixin.prototype.computeColHeadFormat = function () {
        // if more than one week row, or if there are a lot of columns with not much space,
        // put just the day numbers will be in each cell
        if (this.rowCnt > 1 || this.colCnt > 10) {
            return 'ddd'; // "Sat"
        }
        else if (this.colCnt > 1) {
            return this.opt('dayOfMonthFormat'); // "Sat 12/10"
        }
        else {
            return 'dddd'; // "Saturday"
        }
    };
    /* Slicing
    ------------------------------------------------------------------------------------------------------------------*/
    // Slices up a date range into a segment for every week-row it intersects with
    DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst, rowLast; // inclusive day-index range for current row
        var segFirst, segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            // intersect segment's offset range with the row's
            segFirst = Math.max(rangeFirst, rowFirst);
            segLast = Math.min(rangeLast, rowLast);
            // deal with in-between indices
            segFirst = Math.ceil(segFirst); // in-between starts round to next cell
            segLast = Math.floor(segLast); // in-between ends round to prev cell
            if (segFirst <= segLast) {
                segs.push({
                    row: row,
                    // normalize to start of row
                    firstRowDayIndex: segFirst - rowFirst,
                    lastRowDayIndex: segLast - rowFirst,
                    // must be matching integers to be the segment's start/end
                    isStart: segFirst === rangeFirst,
                    isEnd: segLast === rangeLast
                });
            }
        }
        return segs;
    };
    // Slices up a date range into a segment for every day-cell it intersects with.
    // TODO: make more DRY with sliceRangeByRow somehow.
    DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst, rowLast; // inclusive day-index range for current row
        var i;
        var segFirst, segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            for (i = rowFirst; i <= rowLast; i++) {
                // intersect segment's offset range with the row's
                segFirst = Math.max(rangeFirst, i);
                segLast = Math.min(rangeLast, i);
                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell
                if (segFirst <= segLast) {
                    segs.push({
                        row: row,
                        // normalize to start of row
                        firstRowDayIndex: segFirst - rowFirst,
                        lastRowDayIndex: segLast - rowFirst,
                        // must be matching integers to be the segment's start/end
                        isStart: segFirst === rangeFirst,
                        isEnd: segLast === rangeLast
                    });
                }
            }
        }
        return segs;
    };
    /* Header Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderHeadHtml = function () {
        var theme = this.view.calendar.theme;
        return '' +
            '<div class="fc-row ' + theme.getClass('headerRow') + '">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            '<thead>' +
            this.renderHeadTrHtml() +
            '</thead>' +
            '</table>' +
            '</div>';
    };
    DayTableMixin.prototype.renderHeadIntroHtml = function () {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderHeadTrHtml = function () {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderHeadIntroHtml()) +
            this.renderHeadDateCellsHtml() +
            (this.isRTL ? this.renderHeadIntroHtml() : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderHeadDateCellsHtml = function () {
        var htmls = [];
        var col, date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(0, col);
            htmls.push(this.renderHeadDateCellHtml(date));
        }
        return htmls.join('');
    };
    // TODO: when internalApiVersion, accept an object for HTML attributes
    // (colspan should be no different)
    DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classNames = [
            'fc-day-header',
            view.calendar.theme.getClass('widgetHeader')
        ];
        var innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));
        // if only one row of days, the classNames on the header can represent the specific days beneath
        if (t.rowCnt === 1) {
            classNames = classNames.concat(
            // includes the day-of-week class
            // noThemeHighlight=true (don't highlight the header)
            t.getDayClasses(date, true));
        }
        else {
            classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class
        }
        return '' +
            '<th class="' + classNames.join(' ') + '"' +
            ((isDateValid && t.rowCnt) === 1 ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' :
                '') +
            (colspan > 1 ?
                ' colspan="' + colspan + '"' :
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '>' +
            (isDateValid ?
                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
                view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :
                // if not valid, display text, but no link
                innerHtml) +
            '</th>';
    };
    /* Background Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderBgTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderBgIntroHtml(row)) +
            this.renderBgCellsHtml(row) +
            (this.isRTL ? this.renderBgIntroHtml(row) : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderBgIntroHtml = function (row) {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderBgCellsHtml = function (row) {
        var htmls = [];
        var col, date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderBgCellHtml(date));
        }
        return htmls.join('');
    };
    DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classes = t.getDayClasses(date);
        classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));
        return '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '></td>';
    };
    /* Generic
    ------------------------------------------------------------------------------------------------------------------*/
    // Generates the default HTML intro for any row. User classes should override
    DayTableMixin.prototype.renderIntroHtml = function () {
    };
    // TODO: a generic method for dealing with <tr>, RTL, intro
    // when increment internalApiVersion
    // wrapTr (scheduler)
    /* Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // Applies the generic "intro" and "outro" HTML to the given cells.
    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
    DayTableMixin.prototype.bookendCells = function (trEl) {
        var introHtml = this.renderIntroHtml();
        if (introHtml) {
            if (this.isRTL) {
                trEl.append(introHtml);
            }
            else {
                trEl.prepend(introHtml);
            }
        }
    };
    return DayTableMixin;
}(Mixin_1.default));
exports.default = DayTableMixin;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var BusinessHourRenderer = /** @class */ (function () {
    /*
    component implements:
        - eventRangesToEventFootprints
        - eventFootprintsToSegs
    */
    function BusinessHourRenderer(component, fillRenderer) {
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    BusinessHourRenderer.prototype.render = function (businessHourGenerator) {
        var component = this.component;
        var unzonedRange = component._getDateProfile().activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);
        var eventFootprints = eventInstanceGroup ?
            component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :
            [];
        this.renderEventFootprints(eventFootprints);
    };
    BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        this.renderSegs(segs);
        this.segs = segs;
    };
    BusinessHourRenderer.prototype.renderSegs = function (segs) {
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('businessHours', segs, {
                getClasses: function (seg) {
                    return ['fc-nonbusiness', 'fc-bgevent'];
                }
            });
        }
    };
    BusinessHourRenderer.prototype.unrender = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('businessHours');
        }
        this.segs = null;
    };
    BusinessHourRenderer.prototype.getSegs = function () {
        return this.segs || [];
    };
    return BusinessHourRenderer;
}());
exports.default = BusinessHourRenderer;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var FillRenderer = /** @class */ (function () {
    function FillRenderer(component) {
        this.fillSegTag = 'div';
        this.component = component;
        this.elsByFill = {};
    }
    FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {
        this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);
    };
    FillRenderer.prototype.renderSegs = function (type, segs, props) {
        var els;
        segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs
        els = this.attachSegEls(type, segs);
        if (els) {
            this.reportEls(type, els);
        }
        return segs;
    };
    // Unrenders a specific type of fill that is currently rendered on the grid
    FillRenderer.prototype.unrender = function (type) {
        var el = this.elsByFill[type];
        if (el) {
            el.remove();
            delete this.elsByFill[type];
        }
    };
    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
    // Only returns segments that successfully rendered.
    FillRenderer.prototype.buildSegEls = function (type, segs, props) {
        var _this = this;
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of segment HTML
            for (i = 0; i < segs.length; i++) {
                html += this.buildSegHtml(type, segs[i], props);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                // allow custom filter methods per-type
                if (props.filterEl) {
                    el = props.filterEl(seg, el);
                }
                if (el) {
                    el = $(el); // allow custom filter to return raw DOM node
                    // correct element type? (would be bad if a non-TD were inserted into a table for example)
                    if (el.is(_this.fillSegTag)) {
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                }
            });
        }
        return renderedSegs;
    };
    // Builds the HTML needed for one fill segment. Generic enough to work with different types.
    FillRenderer.prototype.buildSegHtml = function (type, seg, props) {
        // custom hooks per-type
        var classes = props.getClasses ? props.getClasses(seg) : [];
        var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});
        return '<' + this.fillSegTag +
            (classes.length ? ' class="' + classes.join(' ') + '"' : '') +
            (css ? ' style="' + css + '"' : '') +
            ' />';
    };
    // Should return wrapping DOM structure
    FillRenderer.prototype.attachSegEls = function (type, segs) {
        // subclasses must implement
    };
    FillRenderer.prototype.reportEls = function (type, nodes) {
        if (this.elsByFill[type]) {
            this.elsByFill[type] = this.elsByFill[type].add(nodes);
        }
        else {
            this.elsByFill[type] = $(nodes);
        }
    };
    return FillRenderer;
}());
exports.default = FillRenderer;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventDef_1 = __webpack_require__(11);
var EventFootprint_1 = __webpack_require__(24);
var EventSource_1 = __webpack_require__(5);
var HelperRenderer = /** @class */ (function () {
    function HelperRenderer(component, eventRenderer) {
        this.view = component._getView();
        this.component = component;
        this.eventRenderer = eventRenderer;
    }
    HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {
        this.renderEventFootprints([
            this.fabricateEventFootprint(componentFootprint)
        ]);
    };
    HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));
    };
    HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');
    };
    HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        var classNames = 'fc-helper ' + (extraClassNames || '');
        var i;
        // assigns each seg's el and returns a subset of segs that were rendered
        segs = this.eventRenderer.renderFgSegEls(segs);
        for (i = 0; i < segs.length; i++) {
            segs[i].el.addClass(classNames);
        }
        if (opacity != null) {
            for (i = 0; i < segs.length; i++) {
                segs[i].el.css('opacity', opacity);
            }
        }
        this.helperEls = this.renderSegs(segs, sourceSeg);
    };
    /*
    Must return all mock event elements
    */
    HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        // Subclasses must implement
    };
    HelperRenderer.prototype.unrender = function () {
        if (this.helperEls) {
            this.helperEls.remove();
            this.helperEls = null;
        }
    };
    HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {
        var calendar = this.view.calendar;
        var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);
        var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));
        var dummyInstance;
        dummyEvent.dateProfile = eventDateProfile;
        dummyInstance = dummyEvent.buildInstance();
        return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);
    };
    return HelperRenderer;
}());
exports.default = HelperRenderer;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var GlobalEmitter_1 = __webpack_require__(14);
var Interaction_1 = __webpack_require__(13);
var EventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(EventPointing, _super);
    function EventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    component must implement:
        - publiclyTrigger
    */
    EventPointing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));
        component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));
        component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));
    };
    EventPointing.prototype.handleClick = function (seg, ev) {
        var res = this.component.publiclyTrigger('eventClick', {
            context: seg.el[0],
            args: [seg.footprint.getEventLegacy(), ev, this.view]
        });
        if (res === false) {
            ev.preventDefault();
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused over
    EventPointing.prototype.handleMouseover = function (seg, ev) {
        if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&
            !this.mousedOverSeg) {
            this.mousedOverSeg = seg;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.addClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseover', {
                context: seg.el[0],
                args: [seg.footprint.getEventLegacy(), ev, this.view]
            });
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused out.
    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
    EventPointing.prototype.handleMouseout = function (seg, ev) {
        if (this.mousedOverSeg) {
            this.mousedOverSeg = null;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.removeClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseout', {
                context: seg.el[0],
                args: [
                    seg.footprint.getEventLegacy(),
                    ev || {},
                    this.view
                ]
            });
        }
    };
    EventPointing.prototype.end = function () {
        if (this.mousedOverSeg) {
            this.handleMouseout(this.mousedOverSeg);
        }
    };
    return EventPointing;
}(Interaction_1.default));
exports.default = EventPointing;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Mixin_1 = __webpack_require__(12);
var DateClicking_1 = __webpack_require__(82);
var DateSelecting_1 = __webpack_require__(66);
var EventPointing_1 = __webpack_require__(44);
var EventDragging_1 = __webpack_require__(65);
var EventResizing_1 = __webpack_require__(64);
var ExternalDropping_1 = __webpack_require__(63);
var StandardInteractionsMixin = /** @class */ (function (_super) {
    tslib_1.__extends(StandardInteractionsMixin, _super);
    function StandardInteractionsMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardInteractionsMixin;
}(Mixin_1.default));
exports.default = StandardInteractionsMixin;
StandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;
StandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;
StandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;
StandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;
StandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;
StandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var CoordCache_1 = __webpack_require__(38);
var Popover_1 = __webpack_require__(86);
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var EventFootprint_1 = __webpack_require__(24);
var BusinessHourRenderer_1 = __webpack_require__(41);
var StandardInteractionsMixin_1 = __webpack_require__(45);
var InteractiveDateComponent_1 = __webpack_require__(29);
var DayTableMixin_1 = __webpack_require__(40);
var DayGridEventRenderer_1 = __webpack_require__(87);
var DayGridHelperRenderer_1 = __webpack_require__(88);
var DayGridFillRenderer_1 = __webpack_require__(89);
/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/
var DayGrid = /** @class */ (function (_super) {
    tslib_1.__extends(DayGrid, _super);
    function DayGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.cellWeekNumbersVisible = false; // display week numbers in day cell?
        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid
        // isRigid determines whether the individual rows should ignore the contents and be a constant height.
        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
        _this.isRigid = false;
        _this.hasAllDayBusinessHours = true;
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (this.isRTL) {
                seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
                seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
            }
            else {
                seg.leftCol = seg.firstRowDayIndex;
                seg.rightCol = seg.lastRowDayIndex;
            }
        }
        return segs;
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderGrid();
    };
    DayGrid.prototype.unrenderDates = function () {
        this.removeSegPopover();
    };
    // Renders the rows and columns into the component's `this.el`, which should already be assigned.
    DayGrid.prototype.renderGrid = function () {
        var view = this.view;
        var rowCnt = this.rowCnt;
        var colCnt = this.colCnt;
        var html = '';
        var row;
        var col;
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        for (row = 0; row < rowCnt; row++) {
            html += this.renderDayRowHtml(row, this.isRigid);
        }
        this.el.html(html);
        this.rowEls = this.el.find('.fc-row');
        this.cellEls = this.el.find('.fc-day, .fc-disabled-day');
        this.rowCoordCache = new CoordCache_1.default({
            els: this.rowEls,
            isVertical: true
        });
        this.colCoordCache = new CoordCache_1.default({
            els: this.cellEls.slice(0, this.colCnt),
            isHorizontal: true
        });
        // trigger dayRender with each cell's element
        for (row = 0; row < rowCnt; row++) {
            for (col = 0; col < colCnt; col++) {
                this.publiclyTrigger('dayRender', {
                    context: view,
                    args: [
                        this.getCellDate(row, col),
                        this.getCellEl(row, col),
                        view
                    ]
                });
            }
        }
    };
    // Generates the HTML for a single row, which is a div that wraps a table.
    // `row` is the row number.
    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
        var theme = this.view.calendar.theme;
        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];
        if (isRigid) {
            classes.push('fc-rigid');
        }
        return '' +
            '<div class="' + classes.join(' ') + '">' +
            '<div class="fc-bg">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(row) +
            '</table>' +
            '</div>' +
            '<div class="fc-content-skeleton">' +
            '<table>' +
            (this.getIsNumbersVisible() ?
                '<thead>' +
                    this.renderNumberTrHtml(row) +
                    '</thead>' :
                '') +
            '</table>' +
            '</div>' +
            '</div>';
    };
    DayGrid.prototype.getIsNumbersVisible = function () {
        return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;
    };
    DayGrid.prototype.getIsDayNumbersVisible = function () {
        return this.rowCnt > 1;
    };
    /* Grid Number Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderNumberTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
            this.renderNumberCellsHtml(row) +
            (this.isRTL ? this.renderNumberIntroHtml(row) : '') +
            '</tr>';
    };
    DayGrid.prototype.renderNumberIntroHtml = function (row) {
        return this.renderIntroHtml();
    };
    DayGrid.prototype.renderNumberCellsHtml = function (row) {
        var htmls = [];
        var col, date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderNumberCellHtml(date));
        }
        return htmls.join('');
    };
    // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
    // The number row will only exist if either day numbers or week numbers are turned on.
    DayGrid.prototype.renderNumberCellHtml = function (date) {
        var view = this.view;
        var html = '';
        var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
        var classes;
        var weekCalcFirstDoW;
        if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {
            // no numbers in day cell (week number must be along the side)
            return '<td/>'; //  will create an empty space above events :(
        }
        classes = this.getDayClasses(date);
        classes.unshift('fc-day-top');
        if (this.cellWeekNumbersVisible) {
            // To determine the day of week number change under ISO, we cannot
            // rely on moment.js methods such as firstDayOfWeek() or weekday(),
            // because they rely on the locale's dow (possibly overridden by
            // our firstDay option), which may not be Monday. We cannot change
            // dow, because that would affect the calendar start day as well.
            if (date._locale._fullCalendar_weekCalc === 'ISO') {
                weekCalcFirstDoW = 1; // Monday by ISO 8601 definition
            }
            else {
                weekCalcFirstDoW = date._locale.firstDayOfWeek();
            }
        }
        html += '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format() + '"' :
                '') +
            '>';
        if (this.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
            html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML
            );
        }
        if (isDayNumberVisible) {
            html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.date() // inner HTML
            );
        }
        html += '</td>';
        return html;
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.rowCoordCache.build();
        this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
    };
    DayGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        this.rowCoordCache.clear();
    };
    DayGrid.prototype.queryHit = function (leftOffset, topOffset) {
        if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
            var col = this.colCoordCache.getHorizontalIndex(leftOffset);
            var row = this.rowCoordCache.getVerticalIndex(topOffset);
            if (row != null && col != null) {
                return this.getCellHit(row, col);
            }
        }
    };
    DayGrid.prototype.getHitFootprint = function (hit) {
        var range = this.getCellRange(hit.row, hit.col);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?
        );
    };
    DayGrid.prototype.getHitEl = function (hit) {
        return this.getCellEl(hit.row, hit.col);
    };
    /* Cell System
    ------------------------------------------------------------------------------------------------------------------*/
    // FYI: the first column is the leftmost column, regardless of date
    DayGrid.prototype.getCellHit = function (row, col) {
        return {
            row: row,
            col: col,
            component: this,
            left: this.colCoordCache.getLeftOffset(col),
            right: this.colCoordCache.getRightOffset(col),
            top: this.rowCoordCache.getTopOffset(row),
            bottom: this.rowCoordCache.getBottomOffset(row)
        };
    };
    DayGrid.prototype.getCellEl = function (row, col) {
        return this.cellEls.eq(row * this.colCnt + col);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    // Unrenders all events currently rendered on the grid
    DayGrid.prototype.executeEventUnrender = function () {
        this.removeSegPopover(); // removes the "more.." events popover
        _super.prototype.executeEventUnrender.call(this);
    };
    // Retrieves all rendered segment objects currently rendered on the grid
    DayGrid.prototype.getOwnEventSegs = function () {
        // append the segments from the "more..." popover
        return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event or external element being dragged.
    // `eventLocation` has zoned start and end (optional)
    DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        // render drags from OTHER components as helpers
        if (eventFootprints.length && seg && seg.component !== this) {
            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
            return true; // signal helpers rendered
        }
    };
    // Unrenders any visual indication of a hovering event
    DayGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders a visual indication of an event being resized
    DayGrid.prototype.unrenderEventResize = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* More+ Link Popover
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.removeSegPopover = function () {
        if (this.segPopover) {
            this.segPopover.hide(); // in handler, will call segPopover's removeElement
        }
    };
    // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
    // `levelLimit` can be false (don't limit), a number, or true (should be computed).
    DayGrid.prototype.limitRows = function (levelLimit) {
        var rowStructs = this.eventRenderer.rowStructs || [];
        var row; // row #
        var rowLevelLimit;
        for (row = 0; row < rowStructs.length; row++) {
            this.unlimitRow(row);
            if (!levelLimit) {
                rowLevelLimit = false;
            }
            else if (typeof levelLimit === 'number') {
                rowLevelLimit = levelLimit;
            }
            else {
                rowLevelLimit = this.computeRowLevelLimit(row);
            }
            if (rowLevelLimit !== false) {
                this.limitRow(row, rowLevelLimit);
            }
        }
    };
    // Computes the number of levels a row will accomodate without going outside its bounds.
    // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
    // `row` is the row number.
    DayGrid.prototype.computeRowLevelLimit = function (row) {
        var rowEl = this.rowEls.eq(row); // the containing "fake" row div
        var rowHeight = rowEl.height(); // TODO: cache somehow?
        var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();
        var i, trEl;
        var trHeight;
        function iterInnerHeights(i, childNode) {
            trHeight = Math.max(trHeight, $(childNode).outerHeight());
        }
        // Reveal one level <tr> at a time and stop when we find one out of bounds
        for (i = 0; i < trEls.length; i++) {
            trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)
            // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
            // so instead, find the tallest inner content element.
            trHeight = 0;
            trEl.find('> td > :first-child').each(iterInnerHeights);
            if (trEl.position().top + trHeight > rowHeight) {
                return i;
            }
        }
        return false; // should not limit at all
    };
    // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
    // `row` is the row number.
    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
    DayGrid.prototype.limitRow = function (row, levelLimit) {
        var _this = this;
        var rowStruct = this.eventRenderer.rowStructs[row];
        var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
        var col = 0; // col #, left-to-right (not chronologically)
        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
        var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
        var i, seg;
        var segsBelow; // array of segment objects below `seg` in the current `col`
        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
        var td, rowspan;
        var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
        var j;
        var moreTd, moreWrap, moreLink;
        // Iterates through empty level cells and places "more" links inside if need be
        var emptyCellsUntil = function (endCol) {
            while (col < endCol) {
                segsBelow = _this.getCellSegs(row, col, levelLimit);
                if (segsBelow.length) {
                    td = cellMatrix[levelLimit - 1][col];
                    moreLink = _this.renderMoreLink(row, col, segsBelow);
                    moreWrap = $('<div/>').append(moreLink);
                    td.append(moreWrap);
                    moreNodes.push(moreWrap[0]);
                }
                col++;
            }
        };
        if (levelLimit && levelLimit < rowStruct.segLevels.length) {
            levelSegs = rowStruct.segLevels[levelLimit - 1];
            cellMatrix = rowStruct.cellMatrix;
            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
                .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array
            // iterate though segments in the last allowable level
            for (i = 0; i < levelSegs.length; i++) {
                seg = levelSegs[i];
                emptyCellsUntil(seg.leftCol); // process empty cells before the segment
                // determine *all* segments below `seg` that occupy the same columns
                colSegsBelow = [];
                totalSegsBelow = 0;
                while (col <= seg.rightCol) {
                    segsBelow = this.getCellSegs(row, col, levelLimit);
                    colSegsBelow.push(segsBelow);
                    totalSegsBelow += segsBelow.length;
                    col++;
                }
                if (totalSegsBelow) {
                    td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
                    rowspan = td.attr('rowspan') || 1;
                    segMoreNodes = [];
                    // make a replacement <td> for each column the segment occupies. will be one for each colspan
                    for (j = 0; j < colSegsBelow.length; j++) {
                        moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
                        segsBelow = colSegsBelow[j];
                        moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                        );
                        moreWrap = $('<div/>').append(moreLink);
                        moreTd.append(moreWrap);
                        segMoreNodes.push(moreTd[0]);
                        moreNodes.push(moreTd[0]);
                    }
                    td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
                    limitedNodes.push(td[0]);
                }
            }
            emptyCellsUntil(this.colCnt); // finish off the level
            rowStruct.moreEls = $(moreNodes); // for easy undoing later
            rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
        }
    };
    // Reveals all levels and removes all "more"-related elements for a grid's row.
    // `row` is a row number.
    DayGrid.prototype.unlimitRow = function (row) {
        var rowStruct = this.eventRenderer.rowStructs[row];
        if (rowStruct.moreEls) {
            rowStruct.moreEls.remove();
            rowStruct.moreEls = null;
        }
        if (rowStruct.limitedEls) {
            rowStruct.limitedEls.removeClass('fc-limited');
            rowStruct.limitedEls = null;
        }
    };
    // Renders an <a> element that represents hidden event element for a cell.
    // Responsible for attaching click handler as well.
    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
        var _this = this;
        var view = this.view;
        return $('<a class="fc-more"/>')
            .text(this.getMoreLinkText(hiddenSegs.length))
            .on('click', function (ev) {
            var clickOption = _this.opt('eventLimitClick');
            var date = _this.getCellDate(row, col);
            var moreEl = $(ev.currentTarget);
            var dayEl = _this.getCellEl(row, col);
            var allSegs = _this.getCellSegs(row, col);
            // rescope the segments to be within the cell's date
            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
            if (typeof clickOption === 'function') {
                // the returned value can be an atomic option
                clickOption = _this.publiclyTrigger('eventLimitClick', {
                    context: view,
                    args: [
                        {
                            date: date.clone(),
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs
                        },
                        ev,
                        view
                    ]
                });
            }
            if (clickOption === 'popover') {
                _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
            }
            else if (typeof clickOption === 'string') {
                view.calendar.zoomTo(date, clickOption);
            }
        });
    };
    // Reveals the popover that displays all events within a cell
    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
        var _this = this;
        var view = this.view;
        var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
        var topEl; // the element we want to match the top coordinate of
        var options;
        if (this.rowCnt == 1) {
            topEl = view.el; // will cause the popover to cover any sort of header
        }
        else {
            topEl = this.rowEls.eq(row); // will align with top of row
        }
        options = {
            className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),
            content: this.renderSegPopoverContent(row, col, segs),
            parentEl: view.el,
            top: topEl.offset().top,
            autoHide: true,
            viewportConstrain: this.opt('popoverViewportConstrain'),
            hide: function () {
                // kill everything when the popover is hidden
                // notify events to be removed
                if (_this.popoverSegs) {
                    _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);
                }
                _this.segPopover.removeElement();
                _this.segPopover = null;
                _this.popoverSegs = null;
            }
        };
        // Determine horizontal coordinate.
        // We use the moreWrap instead of the <td> to avoid border confusion.
        if (this.isRTL) {
            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
        }
        else {
            options.left = moreWrap.offset().left - 1; // -1 to be over cell border
        }
        this.segPopover = new Popover_1.default(options);
        this.segPopover.show();
        // the popover doesn't live within the grid's container element, and thus won't get the event
        // delegated-handlers for free. attach event-related handlers to the popover.
        this.bindAllSegHandlersToEl(this.segPopover.el);
        this.triggerAfterEventSegsRendered(segs);
    };
    // Builds the inner DOM contents of the segment popover
    DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {
        var view = this.view;
        var theme = view.calendar.theme;
        var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));
        var content = $('<div class="fc-header ' + theme.getClass('popoverHeader') + '">' +
            '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' +
            '<span class="fc-title">' +
            util_1.htmlEscape(title) +
            '</span>' +
            '<div class="fc-clear"/>' +
            '</div>' +
            '<div class="fc-body ' + theme.getClass('popoverContent') + '">' +
            '<div class="fc-event-container"></div>' +
            '</div>');
        var segContainer = content.find('.fc-event-container');
        var i;
        // render each seg's `el` and only return the visible segs
        segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true
        this.popoverSegs = segs;
        for (i = 0; i < segs.length; i++) {
            // because segments in the popover are not part of a grid coordinate system, provide a hint to any
            // grids that want to do drag-n-drop about which cell it came from
            this.hitsNeeded();
            segs[i].hit = this.getCellHit(row, col);
            this.hitsNotNeeded();
            segContainer.append(segs[i].el);
        }
        return content;
    };
    // Given the events within an array of segment objects, reslice them to be in a single day
    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
        var dayStart = dayDate.clone();
        var dayEnd = dayStart.clone().add(1, 'days');
        var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);
        var newSegs = [];
        var i, seg;
        var slicedRange;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);
            if (slicedRange) {
                newSegs.push($.extend({}, seg, {
                    footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),
                    isStart: seg.isStart && slicedRange.isStart,
                    isEnd: seg.isEnd && slicedRange.isEnd
                }));
            }
        }
        // force an order because eventsToSegs doesn't guarantee one
        // TODO: research if still needed
        this.eventRenderer.sortEventSegs(newSegs);
        return newSegs;
    };
    // Generates the text that should be inside a "more" link, given the number of events it represents
    DayGrid.prototype.getMoreLinkText = function (num) {
        var opt = this.opt('eventLimitText');
        if (typeof opt === 'function') {
            return opt(num);
        }
        else {
            return '+' + num + ' ' + opt;
        }
    };
    // Returns segments within a given cell.
    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
        var level = startLevel || 0;
        var segs = [];
        var seg;
        while (level < segMatrix.length) {
            seg = segMatrix[level][col];
            if (seg) {
                segs.push(seg);
            }
            level++;
        }
        return segs;
    };
    return DayGrid;
}(InteractiveDateComponent_1.default));
exports.default = DayGrid;
DayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;
DayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
DayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;
DayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(DayGrid);
DayTableMixin_1.default.mixInto(DayGrid);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Scroller_1 = __webpack_require__(28);
var View_1 = __webpack_require__(30);
var BasicViewDateProfileGenerator_1 = __webpack_require__(69);
var DayGrid_1 = __webpack_require__(46);
/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
var BasicView = /** @class */ (function (_super) {
    tslib_1.__extends(BasicView, _super);
    function BasicView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.dayGrid = _this.instantiateDayGrid();
        _this.dayGrid.isRigid = _this.hasRigidRows();
        if (_this.opt('weekNumbers')) {
            if (_this.opt('weekNumbersWithinDays')) {
                _this.dayGrid.cellWeekNumbersVisible = true;
                _this.dayGrid.colWeekNumbersVisible = false;
            }
            else {
                _this.dayGrid.cellWeekNumbersVisible = false;
                _this.dayGrid.colWeekNumbersVisible = true;
            }
            ;
        }
        _this.addChild(_this.dayGrid);
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Generates the DayGrid object this view needs. Draws from this.dayGridClass
    BasicView.prototype.instantiateDayGrid = function () {
        // generate a subclass on the fly with BasicView-specific behavior
        // TODO: cache this subclass
        var subclass = makeDayGridSubclass(this.dayGridClass);
        return new subclass(this);
    };
    BasicView.prototype.executeDateRender = function (dateProfile) {
        this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);
        _super.prototype.executeDateRender.call(this, dateProfile);
    };
    BasicView.prototype.renderSkeleton = function () {
        var dayGridContainerEl;
        var dayGridEl;
        this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
        dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
        this.el.find('.fc-body > tr > td').append(dayGridContainerEl);
        this.dayGrid.headContainerEl = this.el.find('.fc-head-container');
        this.dayGrid.setElement(dayGridEl);
    };
    BasicView.prototype.unrenderSkeleton = function () {
        this.dayGrid.removeElement();
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid component will render inside of a container defined by this HTML.
    BasicView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '"></td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the week number column, if it is known
    BasicView.prototype.weekNumberStyleAttr = function () {
        if (this.weekNumberWidth != null) {
            return 'style="width:' + this.weekNumberWidth + 'px"';
        }
        return '';
    };
    // Determines whether each row should have a constant height
    BasicView.prototype.hasRigidRows = function () {
        var eventLimit = this.opt('eventLimit');
        return eventLimit && typeof eventLimit !== 'number';
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Refreshes the horizontal dimensions of the view
    BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit = this.opt('eventLimit');
        var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');
        var scrollerHeight;
        var scrollbarWidths;
        // hack to give the view some height prior to dayGrid's columns being rendered
        // TODO: separate setting height from scroller VS dayGrid.
        if (!this.dayGrid.rowEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        if (this.dayGrid.colWeekNumbersVisible) {
            // Make sure all week number cells running down the side have the same width.
            // Record the width for cells created later.
            this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));
        }
        // reset all heights to be natural
        this.scroller.clear();
        util_1.uncompensateScroll(headRowEl);
        this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
        // is the event limit a constant level number?
        if (eventLimit && typeof eventLimit === 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
        }
        // distribute the height to the rows
        // (totalHeight is a "recommended" value if isAuto)
        scrollerHeight = this.computeScrollerHeight(totalHeight);
        this.setGridHeight(scrollerHeight, isAuto);
        // is the event limit dynamically calculated?
        if (eventLimit && typeof eventLimit !== 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
        }
        if (!isAuto) {
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) {
                util_1.compensateScroll(headRowEl, scrollbarWidths);
                // doing the scrollbar compensation might have created text overflow which created more height. redo
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    BasicView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    // Sets the height of just the DayGrid component in this view
    BasicView.prototype.setGridHeight = function (height, isAuto) {
        if (isAuto) {
            util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
        }
        else {
            util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
        }
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    BasicView.prototype.computeInitialDateScroll = function () {
        return { top: 0 };
    };
    BasicView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    BasicView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    return BasicView;
}(View_1.default));
exports.default = BasicView;
BasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;
BasicView.prototype.dayGridClass = DayGrid_1.default;
// customize the rendering behavior of BasicView's dayGrid
function makeDayGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colWeekNumbersVisible = false; // display week numbers along the side?
            return _this;
        }
        // Generates the HTML that will go before the day-of week header cells
        SubClass.prototype.renderHeadIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<th class="fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '" ' + view.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    util_1.htmlEscape(this.opt('weekNumberTitle')) +
                    '</span>' +
                    '</th>';
            }
            return '';
        };
        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
        SubClass.prototype.renderNumberIntroHtml = function (row) {
            var view = this.view;
            var weekStart = this.getCellDate(row, 0);
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                    { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML
                    ) +
                    '</td>';
            }
            return '';
        };
        // Generates the HTML that goes before the day bg cells for each day-row
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '" ' +
                    view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        // Generates the HTML that goes before every other type of row generated by DayGrid.
        // Affects helper-skeleton and highlight-skeleton rows.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        SubClass.prototype.getIsNumbersVisible = function () {
            return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;
        };
        return SubClass;
    }(SuperClass));
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var Iterator_1 = __webpack_require__(74);
var GlobalEmitter_1 = __webpack_require__(14);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var Toolbar_1 = __webpack_require__(75);
var OptionsManager_1 = __webpack_require__(76);
var ViewSpecManager_1 = __webpack_require__(77);
var Constraints_1 = __webpack_require__(49);
var locale_1 = __webpack_require__(20);
var moment_ext_1 = __webpack_require__(9);
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var EventDateProfile_1 = __webpack_require__(15);
var EventManager_1 = __webpack_require__(78);
var BusinessHourGenerator_1 = __webpack_require__(54);
var EventSourceParser_1 = __webpack_require__(25);
var EventDefParser_1 = __webpack_require__(33);
var SingleEventDef_1 = __webpack_require__(11);
var EventDefMutation_1 = __webpack_require__(26);
var EventSource_1 = __webpack_require__(5);
var ThemeRegistry_1 = __webpack_require__(36);
var Calendar = /** @class */ (function () {
    function Calendar(el, overrides) {
        this.loadingLevel = 0; // number of simultaneous loading tasks
        this.ignoreUpdateViewSize = 0;
        this.freezeContentHeightDepth = 0;
        // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
        // unneeded() is called in destroy.
        GlobalEmitter_1.default.needed();
        this.el = el;
        this.viewsByType = {};
        this.optionsManager = new OptionsManager_1.default(this, overrides);
        this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);
        this.initMomentInternals(); // needs to happen after options hash initialized
        this.initCurrentDate();
        this.initEventManager();
        this.constraints = new Constraints_1.default(this.eventManager, this);
        this.constructed();
    }
    // useful for monkeypatching. used?
    Calendar.prototype.constructed = function () {
    };
    Calendar.prototype.getView = function () {
        return this.view;
    };
    Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {
        var optHandler = this.opt(name);
        var context;
        var args;
        if ($.isPlainObject(triggerInfo)) {
            context = triggerInfo.context;
            args = triggerInfo.args;
        }
        else if ($.isArray(triggerInfo)) {
            args = triggerInfo;
        }
        if (context == null) {
            context = this.el[0]; // fallback context
        }
        if (!args) {
            args = [];
        }
        this.triggerWith(name, context, args); // Emitter's method
        if (optHandler) {
            return optHandler.apply(context, args);
        }
    };
    Calendar.prototype.hasPublicHandlers = function (name) {
        return this.hasHandlers(name) ||
            this.opt(name); // handler specified in options
    };
    // Options Public API
    // -----------------------------------------------------------------------------------------------------------------
    // public getter/setter
    Calendar.prototype.option = function (name, value) {
        var newOptionHash;
        if (typeof name === 'string') {
            if (value === undefined) {
                return this.optionsManager.get(name);
            }
            else {
                newOptionHash = {};
                newOptionHash[name] = value;
                this.optionsManager.add(newOptionHash);
            }
        }
        else if (typeof name === 'object') {
            this.optionsManager.add(name);
        }
    };
    // private getter
    Calendar.prototype.opt = function (name) {
        return this.optionsManager.get(name);
    };
    // View
    // -----------------------------------------------------------------------------------------------------------------
    // Given a view name for a custom view or a standard view, creates a ready-to-go View object
    Calendar.prototype.instantiateView = function (viewType) {
        var spec = this.viewSpecManager.getViewSpec(viewType);
        return new spec['class'](this, spec);
    };
    // Returns a boolean about whether the view is okay to instantiate at some point
    Calendar.prototype.isValidViewType = function (viewType) {
        return Boolean(this.viewSpecManager.getViewSpec(viewType));
    };
    Calendar.prototype.changeView = function (viewName, dateOrRange) {
        if (dateOrRange) {
            if (dateOrRange.start && dateOrRange.end) {
                this.optionsManager.recordOverrides({
                    visibleRange: dateOrRange
                });
            }
            else {
                this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
            }
        }
        this.renderView(viewName);
    };
    // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    Calendar.prototype.zoomTo = function (newDate, viewType) {
        var spec;
        viewType = viewType || 'day'; // day is default zoom
        spec = this.viewSpecManager.getViewSpec(viewType) ||
            this.viewSpecManager.getUnitViewSpec(viewType);
        this.currentDate = newDate.clone();
        this.renderView(spec ? spec.type : null);
    };
    // Current Date
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initCurrentDate = function () {
        var defaultDateInput = this.opt('defaultDate');
        // compute the initial ambig-timezone date
        if (defaultDateInput != null) {
            this.currentDate = this.moment(defaultDateInput).stripZone();
        }
        else {
            this.currentDate = this.getNow(); // getNow already returns unzoned
        }
    };
    Calendar.prototype.prev = function () {
        var view = this.view;
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        if (prevInfo.isValid) {
            this.currentDate = prevInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.next = function () {
        var view = this.view;
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        if (nextInfo.isValid) {
            this.currentDate = nextInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.prevYear = function () {
        this.currentDate.add(-1, 'years');
        this.renderView();
    };
    Calendar.prototype.nextYear = function () {
        this.currentDate.add(1, 'years');
        this.renderView();
    };
    Calendar.prototype.today = function () {
        this.currentDate = this.getNow(); // should deny like prev/next?
        this.renderView();
    };
    Calendar.prototype.gotoDate = function (zonedDateInput) {
        this.currentDate = this.moment(zonedDateInput).stripZone();
        this.renderView();
    };
    Calendar.prototype.incrementDate = function (delta) {
        this.currentDate.add(moment.duration(delta));
        this.renderView();
    };
    // for external API
    Calendar.prototype.getDate = function () {
        return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
    };
    // Loading Triggering
    // -----------------------------------------------------------------------------------------------------------------
    // Should be called when any type of async data fetching begins
    Calendar.prototype.pushLoading = function () {
        if (!(this.loadingLevel++)) {
            this.publiclyTrigger('loading', [true, this.view]);
        }
    };
    // Should be called when any type of async data fetching completes
    Calendar.prototype.popLoading = function () {
        if (!(--this.loadingLevel)) {
            this.publiclyTrigger('loading', [false, this.view]);
        }
    };
    // High-level Rendering
    // -----------------------------------------------------------------------------------
    Calendar.prototype.render = function () {
        if (!this.contentEl) {
            this.initialRender();
        }
        else if (this.elementVisible()) {
            // mainly for the public API
            this.calcSize();
            this.updateViewSize();
        }
    };
    Calendar.prototype.initialRender = function () {
        var _this = this;
        var el = this.el;
        el.addClass('fc');
        // event delegation for nav links
        el.on('click.fc', 'a[data-goto]', function (ev) {
            var anchorEl = $(ev.currentTarget);
            var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
            var date = _this.moment(gotoOptions.date);
            var viewType = gotoOptions.type;
            // property like "navLinkDayClick". might be a string or a function
            var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');
            if (typeof customAction === 'function') {
                customAction(date, ev);
            }
            else {
                if (typeof customAction === 'string') {
                    viewType = customAction;
                }
                _this.zoomTo(date, viewType);
            }
        });
        // called immediately, and upon option change
        this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {
            var themeClass = ThemeRegistry_1.default.getThemeClass(opts.themeSystem || opts.theme);
            var theme = new themeClass(_this.optionsManager);
            var widgetClass = theme.getClass('widget');
            _this.theme = theme;
            if (widgetClass) {
                el.addClass(widgetClass);
            }
        }, function () {
            var widgetClass = _this.theme.getClass('widget');
            _this.theme = null;
            if (widgetClass) {
                el.removeClass(widgetClass);
            }
        });
        this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {
            _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);
            if (_this.view) {
                _this.view.set('businessHourGenerator', _this.businessHourGenerator);
            }
        }, function () {
            _this.businessHourGenerator = null;
        });
        // called immediately, and upon option change.
        // HACK: locale often affects isRTL, so we explicitly listen to that too.
        this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {
            el.toggleClass('fc-ltr', !opts.isRTL);
            el.toggleClass('fc-rtl', opts.isRTL);
        });
        this.contentEl = $("<div class='fc-view-container'/>").prependTo(el);
        this.initToolbars();
        this.renderHeader();
        this.renderFooter();
        this.renderView(this.opt('defaultView'));
        if (this.opt('handleWindowResize')) {
            $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls
            this.windowResize.bind(this), this.opt('windowResizeDelay')));
        }
    };
    Calendar.prototype.destroy = function () {
        if (this.view) {
            this.clearView();
        }
        this.toolbarsManager.proxyCall('removeElement');
        this.contentEl.remove();
        this.el.removeClass('fc fc-ltr fc-rtl');
        // removes theme-related root className
        this.optionsManager.unwatch('settingTheme');
        this.optionsManager.unwatch('settingBusinessHourGenerator');
        this.el.off('.fc'); // unbind nav link handlers
        if (this.windowResizeProxy) {
            $(window).unbind('resize', this.windowResizeProxy);
            this.windowResizeProxy = null;
        }
        GlobalEmitter_1.default.unneeded();
    };
    Calendar.prototype.elementVisible = function () {
        return this.el.is(':visible');
    };
    // Render Queue
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.bindViewHandlers = function (view) {
        var _this = this;
        view.watch('titleForCalendar', ['title'], function (deps) {
            if (view === _this.view) {
                _this.setToolbarsTitle(deps.title);
            }
        });
        view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {
            if (view === _this.view) {
                _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates
                _this.updateToolbarButtons(deps.dateProfile);
            }
        });
    };
    Calendar.prototype.unbindViewHandlers = function (view) {
        view.unwatch('titleForCalendar');
        view.unwatch('dateProfileForCalendar');
    };
    // View Rendering
    // -----------------------------------------------------------------------------------
    // Renders a view because of a date change, view-type change, or for the first time.
    // If not given a viewType, keep the current view but render different dates.
    // Accepts an optional scroll state to restore to.
    Calendar.prototype.renderView = function (viewType) {
        var oldView = this.view;
        var newView;
        this.freezeContentHeight();
        if (oldView && viewType && oldView.type !== viewType) {
            this.clearView();
        }
        // if viewType changed, or the view was never created, create a fresh view
        if (!this.view && viewType) {
            newView = this.view =
                this.viewsByType[viewType] ||
                    (this.viewsByType[viewType] = this.instantiateView(viewType));
            this.bindViewHandlers(newView);
            newView.startBatchRender(); // so that setElement+setDate rendering are joined
            newView.setElement($("<div class='fc-view fc-" + viewType + "-view' />").appendTo(this.contentEl));
            this.toolbarsManager.proxyCall('activateButton', viewType);
        }
        if (this.view) {
            // prevent unnecessary change firing
            if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {
                this.view.set('businessHourGenerator', this.businessHourGenerator);
            }
            this.view.setDate(this.currentDate);
            if (newView) {
                newView.stopBatchRender();
            }
        }
        this.thawContentHeight();
    };
    // Unrenders the current view and reflects this change in the Header.
    // Unregsiters the `view`, but does not remove from viewByType hash.
    Calendar.prototype.clearView = function () {
        var currentView = this.view;
        this.toolbarsManager.proxyCall('deactivateButton', currentView.type);
        this.unbindViewHandlers(currentView);
        currentView.removeElement();
        currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time
        this.view = null;
    };
    // Destroys the view, including the view object. Then, re-instantiates it and renders it.
    // Maintains the same scroll state.
    // TODO: maintain any other user-manipulated state.
    Calendar.prototype.reinitView = function () {
        var oldView = this.view;
        var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll
        this.freezeContentHeight();
        this.clearView();
        this.calcSize();
        this.renderView(oldView.type); // needs the type to freshly render
        this.view.applyScroll(scroll);
        this.thawContentHeight();
    };
    // Resizing
    // -----------------------------------------------------------------------------------
    Calendar.prototype.getSuggestedViewHeight = function () {
        if (this.suggestedViewHeight == null) {
            this.calcSize();
        }
        return this.suggestedViewHeight;
    };
    Calendar.prototype.isHeightAuto = function () {
        return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
    };
    Calendar.prototype.updateViewSize = function (isResize) {
        if (isResize === void 0) { isResize = false; }
        var view = this.view;
        var scroll;
        if (!this.ignoreUpdateViewSize && view) {
            if (isResize) {
                this.calcSize();
                scroll = view.queryScroll();
            }
            this.ignoreUpdateViewSize++;
            view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);
            this.ignoreUpdateViewSize--;
            if (isResize) {
                view.applyScroll(scroll);
            }
            return true; // signal success
        }
    };
    Calendar.prototype.calcSize = function () {
        if (this.elementVisible()) {
            this._calcSize();
        }
    };
    Calendar.prototype._calcSize = function () {
        var contentHeightInput = this.opt('contentHeight');
        var heightInput = this.opt('height');
        if (typeof contentHeightInput === 'number') {
            this.suggestedViewHeight = contentHeightInput;
        }
        else if (typeof contentHeightInput === 'function') {
            this.suggestedViewHeight = contentHeightInput();
        }
        else if (typeof heightInput === 'number') {
            this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
        }
        else if (typeof heightInput === 'function') {
            this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
        }
        else if (heightInput === 'parent') {
            this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
        }
        else {
            this.suggestedViewHeight = Math.round(this.contentEl.width() /
                Math.max(this.opt('aspectRatio'), .5));
        }
    };
    Calendar.prototype.windowResize = function (ev) {
        if (ev.target === window && // so we don't process jqui "resize" events that have bubbled up
            this.view &&
            this.view.isDatesRendered) {
            if (this.updateViewSize(true)) {
                this.publiclyTrigger('windowResize', [this.view]);
            }
        }
    };
    /* Height "Freezing"
    -----------------------------------------------------------------------------*/
    Calendar.prototype.freezeContentHeight = function () {
        if (!(this.freezeContentHeightDepth++)) {
            this.forceFreezeContentHeight();
        }
    };
    Calendar.prototype.forceFreezeContentHeight = function () {
        this.contentEl.css({
            width: '100%',
            height: this.contentEl.height(),
            overflow: 'hidden'
        });
    };
    Calendar.prototype.thawContentHeight = function () {
        this.freezeContentHeightDepth--;
        // always bring back to natural height
        this.contentEl.css({
            width: '',
            height: '',
            overflow: ''
        });
        // but if there are future thaws, re-freeze
        if (this.freezeContentHeightDepth) {
            this.forceFreezeContentHeight();
        }
    };
    // Toolbar
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initToolbars = function () {
        this.header = new Toolbar_1.default(this, this.computeHeaderOptions());
        this.footer = new Toolbar_1.default(this, this.computeFooterOptions());
        this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);
    };
    Calendar.prototype.computeHeaderOptions = function () {
        return {
            extraClasses: 'fc-header-toolbar',
            layout: this.opt('header')
        };
    };
    Calendar.prototype.computeFooterOptions = function () {
        return {
            extraClasses: 'fc-footer-toolbar',
            layout: this.opt('footer')
        };
    };
    // can be called repeatedly and Header will rerender
    Calendar.prototype.renderHeader = function () {
        var header = this.header;
        header.setToolbarOptions(this.computeHeaderOptions());
        header.render();
        if (header.el) {
            this.el.prepend(header.el);
        }
    };
    // can be called repeatedly and Footer will rerender
    Calendar.prototype.renderFooter = function () {
        var footer = this.footer;
        footer.setToolbarOptions(this.computeFooterOptions());
        footer.render();
        if (footer.el) {
            this.el.append(footer.el);
        }
    };
    Calendar.prototype.setToolbarsTitle = function (title) {
        this.toolbarsManager.proxyCall('updateTitle', title);
    };
    Calendar.prototype.updateToolbarButtons = function (dateProfile) {
        var now = this.getNow();
        var view = this.view;
        var todayInfo = view.dateProfileGenerator.build(now);
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?
            'enableButton' :
            'disableButton', 'today');
        this.toolbarsManager.proxyCall(prevInfo.isValid ?
            'enableButton' :
            'disableButton', 'prev');
        this.toolbarsManager.proxyCall(nextInfo.isValid ?
            'enableButton' :
            'disableButton', 'next');
    };
    Calendar.prototype.queryToolbarsHeight = function () {
        return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {
            var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
            return accumulator + toolbarHeight;
        }, 0);
    };
    // Selection
    // -----------------------------------------------------------------------------------------------------------------
    // this public method receives start/end dates in any format, with any timezone
    Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {
        this.view.select(this.buildSelectFootprint.apply(this, arguments));
    };
    Calendar.prototype.unselect = function () {
        if (this.view) {
            this.view.unselect();
        }
    };
    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
    Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {
        var start = this.moment(zonedStartInput).stripZone();
        var end;
        if (zonedEndInput) {
            end = this.moment(zonedEndInput).stripZone();
        }
        else if (start.hasTime()) {
            end = start.clone().add(this.defaultTimedEventDuration);
        }
        else {
            end = start.clone().add(this.defaultAllDayEventDuration);
        }
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());
    };
    // Date Utils
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initMomentInternals = function () {
        var _this = this;
        this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
        this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));
        // Called immediately, and when any of the options change.
        // Happens before any internal objects rebuild or rerender, because this is very core.
        this.optionsManager.watch('buildingMomentLocale', [
            '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
            '?firstDay', '?weekNumberCalculation'
        ], function (opts) {
            var weekNumberCalculation = opts.weekNumberCalculation;
            var firstDay = opts.firstDay;
            var _week;
            // normalize
            if (weekNumberCalculation === 'iso') {
                weekNumberCalculation = 'ISO'; // normalize
            }
            var localeData = Object.create(// make a cheap copy
            locale_1.getMomentLocaleData(opts.locale) // will fall back to en
            );
            if (opts.monthNames) {
                localeData._months = opts.monthNames;
            }
            if (opts.monthNamesShort) {
                localeData._monthsShort = opts.monthNamesShort;
            }
            if (opts.dayNames) {
                localeData._weekdays = opts.dayNames;
            }
            if (opts.dayNamesShort) {
                localeData._weekdaysShort = opts.dayNamesShort;
            }
            if (firstDay == null && weekNumberCalculation === 'ISO') {
                firstDay = 1;
            }
            if (firstDay != null) {
                _week = Object.create(localeData._week); // _week: { dow: # }
                _week.dow = firstDay;
                localeData._week = _week;
            }
            if (weekNumberCalculation === 'ISO' ||
                weekNumberCalculation === 'local' ||
                typeof weekNumberCalculation === 'function') {
                localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
            }
            _this.localeData = localeData;
            // If the internal current date object already exists, move to new locale.
            // We do NOT need to do this technique for event dates, because this happens when converting to "segments".
            if (_this.currentDate) {
                _this.localizeMoment(_this.currentDate); // sets to localeData
            }
        });
    };
    // Builds a moment using the settings of the current calendar: timezone and locale.
    // Accepts anything the vanilla moment() constructor accepts.
    Calendar.prototype.moment = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var mom;
        if (this.opt('timezone') === 'local') {
            mom = moment_ext_1.default.apply(null, args);
            // Force the moment to be local, because momentExt doesn't guarantee it.
            if (mom.hasTime()) {
                mom.local();
            }
        }
        else if (this.opt('timezone') === 'UTC') {
            mom = moment_ext_1.default.utc.apply(null, args); // process as UTC
        }
        else {
            mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone
        }
        this.localizeMoment(mom); // TODO
        return mom;
    };
    Calendar.prototype.msToMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        else {
            mom = this.applyTimezone(mom); // may or may not apply locale
        }
        this.localizeMoment(mom);
        return mom;
    };
    Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        this.localizeMoment(mom);
        return mom;
    };
    // Updates the given moment's locale settings to the current calendar locale settings.
    Calendar.prototype.localizeMoment = function (mom) {
        mom._locale = this.localeData;
    };
    // Returns a boolean about whether or not the calendar knows how to calculate
    // the timezone offset of arbitrary dates in the current timezone.
    Calendar.prototype.getIsAmbigTimezone = function () {
        return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
    };
    // Returns a copy of the given date in the current timezone. Has no effect on dates without times.
    Calendar.prototype.applyTimezone = function (date) {
        if (!date.hasTime()) {
            return date.clone();
        }
        var zonedDate = this.moment(date.toArray());
        var timeAdjust = date.time() - zonedDate.time();
        var adjustedZonedDate;
        // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
        if (timeAdjust) {
            adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
            if (date.time() - adjustedZonedDate.time() === 0) {
                zonedDate = adjustedZonedDate;
            }
        }
        return zonedDate;
    };
    /*
    Assumes the footprint is non-open-ended.
    */
    Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);
        var end;
        if (!ignoreEnd) {
            end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);
        }
        if (componentFootprint.isAllDay) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else {
            start = this.applyTimezone(start);
            if (end) {
                end = this.applyTimezone(end);
            }
        }
        return new EventDateProfile_1.default(start, end, this);
    };
    // Returns a moment for the current date, as defined by the client's computer or from the `now` option.
    // Will return an moment with an ambiguous timezone.
    Calendar.prototype.getNow = function () {
        var now = this.opt('now');
        if (typeof now === 'function') {
            now = now();
        }
        return this.moment(now).stripZone();
    };
    // Produces a human-readable string for the given duration.
    // Side-effect: changes the locale of the given duration.
    Calendar.prototype.humanizeDuration = function (duration) {
        return duration.locale(this.opt('locale')).humanize();
    };
    // will return `null` if invalid range
    Calendar.prototype.parseUnzonedRange = function (rangeInput) {
        var start = null;
        var end = null;
        if (rangeInput.start) {
            start = this.moment(rangeInput.start).stripZone();
        }
        if (rangeInput.end) {
            end = this.moment(rangeInput.end).stripZone();
        }
        if (!start && !end) {
            return null;
        }
        if (start && end && end.isBefore(start)) {
            return null;
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Event-Date Utilities
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initEventManager = function () {
        var _this = this;
        var eventManager = new EventManager_1.default(this);
        var rawSources = this.opt('eventSources') || [];
        var singleRawSource = this.opt('events');
        this.eventManager = eventManager;
        if (singleRawSource) {
            rawSources.unshift(singleRawSource);
        }
        eventManager.on('release', function (eventsPayload) {
            _this.trigger('eventsReset', eventsPayload);
        });
        eventManager.freeze();
        rawSources.forEach(function (rawSource) {
            var source = EventSourceParser_1.default.parse(rawSource, _this);
            if (source) {
                eventManager.addSource(source);
            }
        });
        eventManager.thaw();
    };
    Calendar.prototype.requestEvents = function (start, end) {
        return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));
    };
    // Get an event's normalized end date. If not present, calculate it from the defaults.
    Calendar.prototype.getEventEnd = function (event) {
        if (event.end) {
            return event.end.clone();
        }
        else {
            return this.getDefaultEventEnd(event.allDay, event.start);
        }
    };
    // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd
    Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {
        var end = zonedStart.clone();
        if (allDay) {
            end.stripTime().add(this.defaultAllDayEventDuration);
        }
        else {
            end.add(this.defaultTimedEventDuration);
        }
        if (this.getIsAmbigTimezone()) {
            end.stripZone(); // we don't know what the tzo should be
        }
        return end;
    };
    // Public Events API
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.rerenderEvents = function () {
        this.view.flash('displayingEvents');
    };
    Calendar.prototype.refetchEvents = function () {
        this.eventManager.refetchAllSources();
    };
    Calendar.prototype.renderEvents = function (eventInputs, isSticky) {
        this.eventManager.freeze();
        for (var i = 0; i < eventInputs.length; i++) {
            this.renderEvent(eventInputs[i], isSticky);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.renderEvent = function (eventInput, isSticky) {
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);
        if (eventDef) {
            eventManager.addEventDef(eventDef, isSticky);
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.removeEvents = function (legacyQuery) {
        var eventManager = this.eventManager;
        var legacyInstances = [];
        var idMap = {};
        var eventDef;
        var i;
        if (legacyQuery == null) {
            eventManager.removeAllEventDefs(true); // persist=true
        }
        else {
            eventManager.getEventInstances().forEach(function (eventInstance) {
                legacyInstances.push(eventInstance.toLegacy());
            });
            legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);
            // compute unique IDs
            for (i = 0; i < legacyInstances.length; i++) {
                eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);
                idMap[eventDef.id] = true;
            }
            eventManager.freeze();
            for (i in idMap) {
                eventManager.removeEventDefsById(i, true); // persist=true
            }
            eventManager.thaw();
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.clientEvents = function (legacyQuery) {
        var legacyEventInstances = [];
        this.eventManager.getEventInstances().forEach(function (eventInstance) {
            legacyEventInstances.push(eventInstance.toLegacy());
        });
        return filterLegacyEventInstances(legacyEventInstances, legacyQuery);
    };
    Calendar.prototype.updateEvents = function (eventPropsArray) {
        this.eventManager.freeze();
        for (var i = 0; i < eventPropsArray.length; i++) {
            this.updateEvent(eventPropsArray[i]);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.updateEvent = function (eventProps) {
        var eventDef = this.eventManager.getEventDefByUid(eventProps._id);
        var eventInstance;
        var eventDefMutation;
        if (eventDef instanceof SingleEventDef_1.default) {
            eventInstance = eventDef.buildInstance();
            eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props
            null // largeUnit -- who uses it?
            );
            this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release
        }
    };
    // Public Event Sources API
    // ------------------------------------------------------------------------------------
    Calendar.prototype.getEventSources = function () {
        return this.eventManager.otherSources.slice(); // clone
    };
    Calendar.prototype.getEventSourceById = function (id) {
        return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));
    };
    Calendar.prototype.addEventSource = function (sourceInput) {
        var source = EventSourceParser_1.default.parse(sourceInput, this);
        if (source) {
            this.eventManager.addSource(source);
        }
    };
    Calendar.prototype.removeEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources;
        var i;
        if (sourceMultiQuery == null) {
            this.eventManager.removeAllSources();
        }
        else {
            sources = eventManager.multiQuerySources(sourceMultiQuery);
            eventManager.freeze();
            for (i = 0; i < sources.length; i++) {
                eventManager.removeSource(sources[i]);
            }
            eventManager.thaw();
        }
    };
    Calendar.prototype.removeEventSource = function (sourceQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.querySources(sourceQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.removeSource(sources[i]);
        }
        eventManager.thaw();
    };
    Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.multiQuerySources(sourceMultiQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.refetchSource(sources[i]);
        }
        eventManager.thaw();
    };
    return Calendar;
}());
exports.default = Calendar;
EmitterMixin_1.default.mixInto(Calendar);
ListenerMixin_1.default.mixInto(Calendar);
function filterLegacyEventInstances(legacyEventInstances, legacyQuery) {
    if (legacyQuery == null) {
        return legacyEventInstances;
    }
    else if ($.isFunction(legacyQuery)) {
        return legacyEventInstances.filter(legacyQuery);
    }
    else {
        legacyQuery += ''; // normalize to string
        return legacyEventInstances.filter(function (legacyEventInstance) {
            // soft comparison because id not be normalized to string
            return legacyEventInstance.id == legacyQuery ||
                legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match
        });
    }
}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var EventDefParser_1 = __webpack_require__(33);
var EventSource_1 = __webpack_require__(5);
var util_1 = __webpack_require__(23);
var Constraints = /** @class */ (function () {
    function Constraints(eventManager, _calendar) {
        this.eventManager = eventManager;
        this._calendar = _calendar;
    }
    Constraints.prototype.opt = function (name) {
        return this._calendar.opt(name);
    };
    /*
    determines if eventInstanceGroup is allowed,
    in relation to other EVENTS and business hours.
    */
    Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var eventDef = eventInstanceGroup.getEventDef();
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        var peerEventInstances = this.getPeerEventInstances(eventDef);
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var constraintVal = eventDef.getConstraint();
        var overlapVal = eventDef.getOverlap();
        var eventAllowFunc = this.opt('eventAllow');
        for (i = 0; i < eventFootprints.length; i++) {
            if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {
                return false;
            }
        }
        if (eventAllowFunc) {
            for (i = 0; i < eventFootprints.length; i++) {
                if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {
                    return false;
                }
            }
        }
        return true;
    };
    Constraints.prototype.getPeerEventInstances = function (eventDef) {
        return this.eventManager.getEventInstancesWithoutId(eventDef.id);
    };
    Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        var peerEventInstances = this.eventManager.getEventInstances();
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var selectAllowFunc;
        if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {
            selectAllowFunc = this.opt('selectAllow');
            if (selectAllowFunc) {
                return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional
    ) {
        var constraintFootprints; // ComponentFootprint[]
        var overlapEventFootprints; // EventFootprint[]
        if (constraintVal != null) {
            constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);
            if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {
                return false;
            }
        }
        overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);
        if (overlapVal === false) {
            if (overlapEventFootprints.length) {
                return false;
            }
        }
        else if (typeof overlapVal === 'function') {
            if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {
                return false;
            }
        }
        if (subjectEventInstance) {
            if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {
                return false;
            }
        }
        return true;
    };
    // Constraint
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {
        var i;
        for (i = 0; i < constraintFootprints.length; i++) {
            if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {
        var eventInstances;
        if (constraintVal === 'businessHours') {
            return this.buildCurrentBusinessFootprints(isAllDay);
        }
        else if (typeof constraintVal === 'object') {
            eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events
            if (!eventInstances) {
                return this.parseFootprints(constraintVal);
            }
            else {
                return this.eventInstancesToFootprints(eventInstances);
            }
        }
        else if (constraintVal != null) {
            eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);
            return this.eventInstancesToFootprints(eventInstances);
        }
    };
    // returns ComponentFootprint[]
    // uses current view's range
    Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {
        var view = this._calendar.view;
        var businessHourGenerator = view.get('businessHourGenerator');
        var unzonedRange = view.dateProfile.activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);
        if (eventInstanceGroup) {
            return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);
        }
        else {
            return [];
        }
    };
    // conversion util
    Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {
        var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);
        var eventFootprints = this.eventRangesToEventFootprints(eventRanges);
        return eventFootprints.map(util_1.eventFootprintToComponentFootprint);
    };
    // Overlap
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {
        var overlapEventFootprints = [];
        var i;
        for (i = 0; i < peerEventFootprints.length; i++) {
            if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {
                overlapEventFootprints.push(peerEventFootprints[i]);
            }
        }
        return overlapEventFootprints;
    };
    // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints
    // ------------------------------------------------------------------------------------------------
    // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to
    // constraints whereas the Grid code is related to rendering. Each approach might want to convert
    // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make
    // this more DRY.
    /*
    Returns false on invalid input.
    */
    Constraints.prototype.parseEventDefToInstances = function (eventInput) {
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));
        if (!eventDef) {
            return false;
        }
        return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);
    };
    Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var i;
        var eventFootprints = [];
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// footprints
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_1.eventRangeToEventFootprint(eventRange)];
    };
    /*
    Parses footprints directly.
    Very similar to EventDateProfile::parse :(
    */
    Constraints.prototype.parseFootprints = function (rawInput) {
        var start, end;
        if (rawInput.start) {
            start = this._calendar.moment(rawInput.start);
            if (!start.isValid()) {
                start = null;
            }
        }
        if (rawInput.end) {
            end = this._calendar.moment(rawInput.end);
            if (!end.isValid()) {
                end = null;
            }
        }
        return [
            new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay
            )
        ];
    };
    // Footprint Utils
    // ----------------------------------------------------------------------------------------
    Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {
        return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);
    };
    Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {
        return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);
    };
    return Constraints;
}());
exports.default = Constraints;
// optional subjectEventInstance
function isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {
    var i;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {
            return false;
        }
    }
    return true;
}
function isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {
    var subjectLegacyInstance = subjectEventInstance.toLegacy();
    var i;
    var overlapEventInstance;
    var overlapEventDef;
    var overlapVal;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        overlapEventInstance = overlapEventFootprints[i].eventInstance;
        overlapEventDef = overlapEventInstance.def;
        // don't need to pass in calendar, because don't want to consider global eventOverlap property,
        // because we already considered that earlier in the process.
        overlapVal = overlapEventDef.getOverlap();
        if (overlapVal === false) {
            return false;
        }
        else if (typeof overlapVal === 'function') {
            if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
    import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'
in class:
    applyProps: ParsableModelInterface['applyProps']
    applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']
    applyMiscProps: ParsableModelInterface['applyMiscProps']
    isStandardProp: ParsableModelInterface['isStandardProp']
    static defineStandardProps = ParsableModelMixin.defineStandardProps
    static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps
after class:
    ParsableModelMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var Mixin_1 = __webpack_require__(12);
var ParsableModelMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ParsableModelMixin, _super);
    function ParsableModelMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Returns true/false for success.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyProps = function (rawProps) {
        var standardPropMap = this.standardPropMap;
        var manualProps = {};
        var miscProps = {};
        var propName;
        for (propName in rawProps) {
            if (standardPropMap[propName] === true) {
                this[propName] = rawProps[propName];
            }
            else if (standardPropMap[propName] === false) {
                manualProps[propName] = rawProps[propName];
            }
            else {
                miscProps[propName] = rawProps[propName];
            }
        }
        this.applyMiscProps(miscProps);
        return this.applyManualStandardProps(manualProps);
    };
    /*
    If subclasses override, they must call this supermethod and return the boolean response.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {
        return true;
    };
    /*
    Can be called even after initial object creation.
    */
    ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {
        // subclasses can implement
    };
    /*
    TODO: why is this a method when defineStandardProps is static
    */
    ParsableModelMixin.prototype.isStandardProp = function (propName) {
        return propName in this.standardPropMap;
    };
    ParsableModelMixin.defineStandardProps = function (propDefs) {
        var proto = this.prototype;
        if (!proto.hasOwnProperty('standardPropMap')) {
            proto.standardPropMap = Object.create(proto.standardPropMap);
        }
        util_1.copyOwnProps(propDefs, proto.standardPropMap);
    };
    ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {
        var map = this.prototype.standardPropMap;
        var propName;
        for (propName in map) {
            if (src[propName] != null && // in the src object?
                map[propName] === true // false means "copy verbatim"
            ) {
                dest[propName] = src[propName];
            }
        }
    };
    return ParsableModelMixin;
}(Mixin_1.default));
exports.default = ParsableModelMixin;
ParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps


/***/ }),
/* 51 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventInstance = /** @class */ (function () {
    function EventInstance(def, dateProfile) {
        this.def = def;
        this.dateProfile = dateProfile;
    }
    EventInstance.prototype.toLegacy = function () {
        var dateProfile = this.dateProfile;
        var obj = this.def.toLegacy();
        obj.start = dateProfile.start.clone();
        obj.end = dateProfile.end ? dateProfile.end.clone() : null;
        return obj;
    };
    return EventInstance;
}());
exports.default = EventInstance;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var EventDef_1 = __webpack_require__(22);
var EventInstance_1 = __webpack_require__(51);
var EventDateProfile_1 = __webpack_require__(15);
var RecurringEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(RecurringEventDef, _super);
    function RecurringEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RecurringEventDef.prototype.isAllDay = function () {
        return !this.startTime && !this.endTime;
    };
    RecurringEventDef.prototype.buildInstances = function (unzonedRange) {
        var calendar = this.source.calendar;
        var unzonedDate = unzonedRange.getStart();
        var unzonedEnd = unzonedRange.getEnd();
        var zonedDayStart;
        var instanceStart, instanceEnd;
        var instances = [];
        while (unzonedDate.isBefore(unzonedEnd)) {
            // if everyday, or this particular day-of-week
            if (!this.dowHash || this.dowHash[unzonedDate.day()]) {
                zonedDayStart = calendar.applyTimezone(unzonedDate);
                instanceStart = zonedDayStart.clone();
                instanceEnd = null;
                if (this.startTime) {
                    instanceStart.time(this.startTime);
                }
                else {
                    instanceStart.stripTime();
                }
                if (this.endTime) {
                    instanceEnd = zonedDayStart.clone().time(this.endTime);
                }
                instances.push(new EventInstance_1.default(this, // definition
                new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));
            }
            unzonedDate.add(1, 'days');
        }
        return instances;
    };
    RecurringEventDef.prototype.setDow = function (dowNumbers) {
        if (!this.dowHash) {
            this.dowHash = {};
        }
        for (var i = 0; i < dowNumbers.length; i++) {
            this.dowHash[dowNumbers[i]] = true;
        }
    };
    RecurringEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        if (def.startTime) {
            def.startTime = moment.duration(this.startTime);
        }
        if (def.endTime) {
            def.endTime = moment.duration(this.endTime);
        }
        if (this.dowHash) {
            def.dowHash = $.extend({}, this.dowHash);
        }
        return def;
    };
    return RecurringEventDef;
}(EventDef_1.default));
exports.default = RecurringEventDef;
/*
HACK to work with TypeScript mixins
NOTE: if super-method fails, should still attempt to apply
*/
RecurringEventDef.prototype.applyProps = function (rawProps) {
    var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);
    if (rawProps.start) {
        this.startTime = moment.duration(rawProps.start);
    }
    if (rawProps.end) {
        this.endTime = moment.duration(rawProps.end);
    }
    if (rawProps.dow) {
        this.setDow(rawProps.dow);
    }
    return superSuccess;
};
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
RecurringEventDef.defineStandardProps({
    start: false,
    end: false,
    dow: false
});


/***/ }),
/* 53 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange = /** @class */ (function () {
    function EventRange(unzonedRange, eventDef, eventInstance) {
        this.unzonedRange = unzonedRange;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    return EventRange;
}());
exports.default = EventRange;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(23);
var EventInstanceGroup_1 = __webpack_require__(17);
var RecurringEventDef_1 = __webpack_require__(52);
var EventSource_1 = __webpack_require__(5);
var BUSINESS_HOUR_EVENT_DEFAULTS = {
    start: '09:00',
    end: '17:00',
    dow: [1, 2, 3, 4, 5],
    rendering: 'inverse-background'
    // classNames are defined in businessHoursSegClasses
};
var BusinessHourGenerator = /** @class */ (function () {
    function BusinessHourGenerator(rawComplexDef, calendar) {
        this.rawComplexDef = rawComplexDef;
        this.calendar = calendar;
    }
    BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {
        var eventDefs = this.buildEventDefs(isAllDay);
        var eventInstanceGroup;
        if (eventDefs.length) {
            eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));
            // so that inverse-background rendering can happen even when no eventRanges in view
            eventInstanceGroup.explicitEventDef = eventDefs[0];
            return eventInstanceGroup;
        }
    };
    BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {
        var rawComplexDef = this.rawComplexDef;
        var rawDefs = [];
        var requireDow = false;
        var i;
        var defs = [];
        if (rawComplexDef === true) {
            rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim
        }
        else if ($.isPlainObject(rawComplexDef)) {
            rawDefs = [rawComplexDef];
        }
        else if ($.isArray(rawComplexDef)) {
            rawDefs = rawComplexDef;
            requireDow = true; // every sub-definition NEEDS a day-of-week
        }
        for (i = 0; i < rawDefs.length; i++) {
            if (!requireDow || rawDefs[i].dow) {
                defs.push(this.buildEventDef(isAllDay, rawDefs[i]));
            }
        }
        return defs;
    };
    BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {
        var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);
        if (isAllDay) {
            fullRawDef.start = null;
            fullRawDef.end = null;
        }
        return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source
        );
    };
    return BusinessHourGenerator;
}());
exports.default = BusinessHourGenerator;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Theme_1 = __webpack_require__(27);
var StandardTheme = /** @class */ (function (_super) {
    tslib_1.__extends(StandardTheme, _super);
    function StandardTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardTheme;
}(Theme_1.default));
exports.default = StandardTheme;
StandardTheme.prototype.classes = {
    widget: 'fc-unthemed',
    widgetHeader: 'fc-widget-header',
    widgetContent: 'fc-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'fc-button',
    cornerLeft: 'fc-corner-left',
    cornerRight: 'fc-corner-right',
    stateDefault: 'fc-state-default',
    stateActive: 'fc-state-active',
    stateDisabled: 'fc-state-disabled',
    stateHover: 'fc-state-hover',
    stateDown: 'fc-state-down',
    popoverHeader: 'fc-widget-header',
    popoverContent: 'fc-widget-content',
    // day grid
    headerRow: 'fc-widget-header',
    dayRow: 'fc-widget-content',
    // list view
    listView: 'fc-widget-content'
};
StandardTheme.prototype.baseIconClass = 'fc-icon';
StandardTheme.prototype.iconClasses = {
    close: 'fc-icon-x',
    prev: 'fc-icon-left-single-arrow',
    next: 'fc-icon-right-single-arrow',
    prevYear: 'fc-icon-left-double-arrow',
    nextYear: 'fc-icon-right-double-arrow'
};
StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Theme_1 = __webpack_require__(27);
var JqueryUiTheme = /** @class */ (function (_super) {
    tslib_1.__extends(JqueryUiTheme, _super);
    function JqueryUiTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JqueryUiTheme;
}(Theme_1.default));
exports.default = JqueryUiTheme;
JqueryUiTheme.prototype.classes = {
    widget: 'ui-widget',
    widgetHeader: 'ui-widget-header',
    widgetContent: 'ui-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'ui-button',
    cornerLeft: 'ui-corner-left',
    cornerRight: 'ui-corner-right',
    stateDefault: 'ui-state-default',
    stateActive: 'ui-state-active',
    stateDisabled: 'ui-state-disabled',
    stateHover: 'ui-state-hover',
    stateDown: 'ui-state-down',
    today: 'ui-state-highlight',
    popoverHeader: 'ui-widget-header',
    popoverContent: 'ui-widget-content',
    // day grid
    headerRow: 'ui-widget-header',
    dayRow: 'ui-widget-content',
    // list view
    listView: 'ui-widget-content'
};
JqueryUiTheme.prototype.baseIconClass = 'ui-icon';
JqueryUiTheme.prototype.iconClasses = {
    close: 'ui-icon-closethick',
    prev: 'ui-icon-circle-triangle-w',
    next: 'ui-icon-circle-triangle-e',
    prevYear: 'ui-icon-seek-prev',
    nextYear: 'ui-icon-seek-next'
};
JqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';
JqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';
JqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var Promise_1 = __webpack_require__(16);
var EventSource_1 = __webpack_require__(5);
var FuncEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(FuncEventSource, _super);
    function FuncEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FuncEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve) {
            _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {
                _this.calendar.popLoading();
                onResolve(_this.parseEventDefs(rawEventDefs));
            });
        });
    };
    FuncEventSource.prototype.getPrimitive = function () {
        return this.func;
    };
    FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.func = rawProps.events;
        return superSuccess;
    };
    FuncEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isFunction(rawInput.events)) {
            rawProps = rawInput;
        }
        else if ($.isFunction(rawInput)) {
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    return FuncEventSource;
}(EventSource_1.default));
exports.default = FuncEventSource;
FuncEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Promise_1 = __webpack_require__(16);
var EventSource_1 = __webpack_require__(5);
var JsonFeedEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(JsonFeedEventSource, _super);
    function JsonFeedEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        var ajaxSettings = this.ajaxSettings;
        var onSuccess = ajaxSettings.success;
        var onError = ajaxSettings.error;
        var requestParams = this.buildRequestParams(start, end, timezone);
        // todo: eventually handle the promise's then,
        // don't intercept success/error
        // tho will be a breaking API change
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve, onReject) {
            $.ajax($.extend({}, // destination
            JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {
                url: _this.url,
                data: requestParams,
                success: function (rawEventDefs, status, xhr) {
                    var callbackRes;
                    _this.calendar.popLoading();
                    if (rawEventDefs) {
                        callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`
                        if ($.isArray(callbackRes)) {
                            rawEventDefs = callbackRes;
                        }
                        onResolve(_this.parseEventDefs(rawEventDefs));
                    }
                    else {
                        onReject();
                    }
                },
                error: function (data, status, xhr) {
                    _this.calendar.popLoading();
                    util_1.applyAll(onError, _this, [data, status, xhr]); // redirect `this`
                    onReject();
                }
            }));
        });
    };
    JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {
        var calendar = this.calendar;
        var ajaxSettings = this.ajaxSettings;
        var startParam, endParam, timezoneParam;
        var customRequestParams;
        var params = {};
        startParam = this.startParam;
        if (startParam == null) {
            startParam = calendar.opt('startParam');
        }
        endParam = this.endParam;
        if (endParam == null) {
            endParam = calendar.opt('endParam');
        }
        timezoneParam = this.timezoneParam;
        if (timezoneParam == null) {
            timezoneParam = calendar.opt('timezoneParam');
        }
        // retrieve any outbound GET/POST $.ajax data from the options
        if ($.isFunction(ajaxSettings.data)) {
            // supplied as a function that returns a key/value object
            customRequestParams = ajaxSettings.data();
        }
        else {
            // probably supplied as a straight key/value object
            customRequestParams = ajaxSettings.data || {};
        }
        $.extend(params, customRequestParams);
        params[startParam] = start.format();
        params[endParam] = end.format();
        if (timezone && timezone !== 'local') {
            params[timezoneParam] = timezone;
        }
        return params;
    };
    JsonFeedEventSource.prototype.getPrimitive = function () {
        return this.url;
    };
    JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {
        this.ajaxSettings = rawProps;
    };
    JsonFeedEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if (typeof rawInput.url === 'string') {
            rawProps = rawInput;
        }
        else if (typeof rawInput === 'string') {
            rawProps = { url: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    JsonFeedEventSource.AJAX_DEFAULTS = {
        dataType: 'json',
        cache: false
    };
    return JsonFeedEventSource;
}(EventSource_1.default));
exports.default = JsonFeedEventSource;
JsonFeedEventSource.defineStandardProps({
    // automatically transfer (true)...
    url: true,
    startParam: true,
    endParam: true,
    timezoneParam: true
});


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EmitterMixin_1 = __webpack_require__(8);
var TaskQueue = /** @class */ (function () {
    function TaskQueue() {
        this.q = [];
        this.isPaused = false;
        this.isRunning = false;
    }
    TaskQueue.prototype.queue = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.q.push.apply(this.q, args); // append
        this.tryStart();
    };
    TaskQueue.prototype.pause = function () {
        this.isPaused = true;
    };
    TaskQueue.prototype.resume = function () {
        this.isPaused = false;
        this.tryStart();
    };
    TaskQueue.prototype.getIsIdle = function () {
        return !this.isRunning && !this.isPaused;
    };
    TaskQueue.prototype.tryStart = function () {
        if (!this.isRunning && this.canRunNext()) {
            this.isRunning = true;
            this.trigger('start');
            this.runRemaining();
        }
    };
    TaskQueue.prototype.canRunNext = function () {
        return !this.isPaused && this.q.length;
    };
    TaskQueue.prototype.runRemaining = function () {
        var _this = this;
        var task;
        var res;
        do {
            task = this.q.shift(); // always freshly reference q. might have been reassigned.
            res = this.runTask(task);
            if (res && res.then) {
                res.then(function () {
                    if (_this.canRunNext()) {
                        _this.runRemaining();
                    }
                });
                return; // prevent marking as stopped
            }
        } while (this.canRunNext());
        this.trigger('stop'); // not really a 'stop' ... more of a 'drained'
        this.isRunning = false;
        // if 'stop' handler added more tasks.... TODO: write test for this
        this.tryStart();
    };
    TaskQueue.prototype.runTask = function (task) {
        return task(); // task *is* the function, but subclasses can change the format of a task
    };
    return TaskQueue;
}());
exports.default = TaskQueue;
EmitterMixin_1.default.mixInto(TaskQueue);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var TaskQueue_1 = __webpack_require__(59);
var RenderQueue = /** @class */ (function (_super) {
    tslib_1.__extends(RenderQueue, _super);
    function RenderQueue(waitsByNamespace) {
        var _this = _super.call(this) || this;
        _this.waitsByNamespace = waitsByNamespace || {};
        return _this;
    }
    RenderQueue.prototype.queue = function (taskFunc, namespace, type) {
        var task = {
            func: taskFunc,
            namespace: namespace,
            type: type
        };
        var waitMs;
        if (namespace) {
            waitMs = this.waitsByNamespace[namespace];
        }
        if (this.waitNamespace) {
            if (namespace === this.waitNamespace && waitMs != null) {
                this.delayWait(waitMs);
            }
            else {
                this.clearWait();
                this.tryStart();
            }
        }
        if (this.compoundTask(task)) {
            if (!this.waitNamespace && waitMs != null) {
                this.startWait(namespace, waitMs);
            }
            else {
                this.tryStart();
            }
        }
    };
    RenderQueue.prototype.startWait = function (namespace, waitMs) {
        this.waitNamespace = namespace;
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.delayWait = function (waitMs) {
        clearTimeout(this.waitId);
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.spawnWait = function (waitMs) {
        var _this = this;
        this.waitId = setTimeout(function () {
            _this.waitNamespace = null;
            _this.tryStart();
        }, waitMs);
    };
    RenderQueue.prototype.clearWait = function () {
        if (this.waitNamespace) {
            clearTimeout(this.waitId);
            this.waitId = null;
            this.waitNamespace = null;
        }
    };
    RenderQueue.prototype.canRunNext = function () {
        if (!_super.prototype.canRunNext.call(this)) {
            return false;
        }
        // waiting for a certain namespace to stop receiving tasks?
        if (this.waitNamespace) {
            // if there was a different namespace task in the meantime,
            // that forces all previously-waiting tasks to suddenly execute.
            // TODO: find a way to do this in constant time.
            for (var q = this.q, i = 0; i < q.length; i++) {
                if (q[i].namespace !== this.waitNamespace) {
                    return true; // allow execution
                }
            }
            return false;
        }
        return true;
    };
    RenderQueue.prototype.runTask = function (task) {
        task.func();
    };
    RenderQueue.prototype.compoundTask = function (newTask) {
        var q = this.q;
        var shouldAppend = true;
        var i, task;
        if (newTask.namespace && newTask.type === 'destroy') {
            // remove all init/add/remove ops with same namespace, regardless of order
            for (i = q.length - 1; i >= 0; i--) {
                task = q[i];
                switch (task.type) {
                    case 'init':
                        shouldAppend = false;
                    // the latest destroy is cancelled out by not doing the init
                    // and fallthrough....
                    case 'add':
                    case 'remove':
                        q.splice(i, 1); // remove task
                }
            }
        }
        if (shouldAppend) {
            q.push(newTask);
        }
        return shouldAppend;
    };
    return RenderQueue;
}(TaskQueue_1.default));
exports.default = RenderQueue;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var moment_ext_1 = __webpack_require__(9);
var date_formatting_1 = __webpack_require__(37);
var Component_1 = __webpack_require__(80);
var util_2 = __webpack_require__(23);
var DateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DateComponent, _super);
    function DateComponent(_view, _options) {
        var _this = _super.call(this) || this;
        _this.isRTL = false; // frequently accessed options
        _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits
        _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?
        _this.isDatesRendered = false;
        // hack to set options prior to the this.opt calls
        if (_view) {
            _this['view'] = _view;
        }
        if (_options) {
            _this['options'] = _options;
        }
        _this.uid = String(DateComponent.guid++);
        _this.childrenByUid = {};
        _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));
        _this.isRTL = _this.opt('isRTL');
        if (_this.fillRendererClass) {
            _this.fillRenderer = new _this.fillRendererClass(_this);
        }
        if (_this.eventRendererClass) {
            _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);
        }
        if (_this.helperRendererClass && _this.eventRenderer) {
            _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);
        }
        if (_this.businessHourRendererClass && _this.fillRenderer) {
            _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);
        }
        return _this;
    }
    DateComponent.prototype.addChild = function (child) {
        if (!this.childrenByUid[child.uid]) {
            this.childrenByUid[child.uid] = child;
            return true;
        }
        return false;
    };
    DateComponent.prototype.removeChild = function (child) {
        if (this.childrenByUid[child.uid]) {
            delete this.childrenByUid[child.uid];
            return true;
        }
        return false;
    };
    // TODO: only do if isInDom?
    // TODO: make part of Component, along with children/batch-render system?
    DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        this.callChildren('updateSize', arguments);
    };
    // Options
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.opt = function (name) {
        return this._getView().opt(name); // default implementation
    };
    DateComponent.prototype.publiclyTrigger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.publiclyTrigger.apply(calendar, args);
    };
    DateComponent.prototype.hasPublicHandlers = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.hasPublicHandlers.apply(calendar, args);
    };
    // Date
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeDateRender = function (dateProfile) {
        this.dateProfile = dateProfile; // for rendering
        this.renderDates(dateProfile);
        this.isDatesRendered = true;
        this.callChildren('executeDateRender', arguments);
    };
    DateComponent.prototype.executeDateUnrender = function () {
        this.callChildren('executeDateUnrender', arguments);
        this.dateProfile = null;
        this.unrenderDates();
        this.isDatesRendered = false;
    };
    // date-cell content only
    DateComponent.prototype.renderDates = function (dateProfile) {
        // subclasses should implement
    };
    // date-cell content only
    DateComponent.prototype.unrenderDates = function () {
        // subclasses should override
    };
    // Now-Indicator
    // -----------------------------------------------------------------------------------------------------------------
    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.
    DateComponent.prototype.getNowIndicatorUnit = function () {
        // subclasses should implement
    };
    // Renders a current time indicator at the given datetime
    DateComponent.prototype.renderNowIndicator = function (date) {
        this.callChildren('renderNowIndicator', arguments);
    };
    // Undoes the rendering actions from renderNowIndicator
    DateComponent.prototype.unrenderNowIndicator = function () {
        this.callChildren('unrenderNowIndicator', arguments);
    };
    // Business Hours
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {
        if (this.businessHourRenderer) {
            this.businessHourRenderer.render(businessHourGenerator);
        }
        this.callChildren('renderBusinessHours', arguments);
    };
    // Unrenders previously-rendered business-hours
    DateComponent.prototype.unrenderBusinessHours = function () {
        this.callChildren('unrenderBusinessHours', arguments);
        if (this.businessHourRenderer) {
            this.businessHourRenderer.unrender();
        }
    };
    // Event Displaying
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeEventRender = function (eventsPayload) {
        if (this.eventRenderer) {
            this.eventRenderer.rangeUpdated(); // poorly named now
            this.eventRenderer.render(eventsPayload);
        }
        else if (this['renderEvents']) {
            this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));
        }
        this.callChildren('executeEventRender', arguments);
    };
    DateComponent.prototype.executeEventUnrender = function () {
        this.callChildren('executeEventUnrender', arguments);
        if (this.eventRenderer) {
            this.eventRenderer.unrender();
        }
        else if (this['destroyEvents']) {
            this['destroyEvents']();
        }
    };
    DateComponent.prototype.getBusinessHourSegs = function () {
        var segs = this.getOwnBusinessHourSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getBusinessHourSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnBusinessHourSegs = function () {
        if (this.businessHourRenderer) {
            return this.businessHourRenderer.getSegs();
        }
        return [];
    };
    DateComponent.prototype.getEventSegs = function () {
        var segs = this.getOwnEventSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getEventSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnEventSegs = function () {
        if (this.eventRenderer) {
            return this.eventRenderer.getSegs();
        }
        return [];
    };
    // Event Rendering Triggering
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.triggerAfterEventsRendered = function () {
        this.triggerAfterEventSegsRendered(this.getEventSegs());
        this.publiclyTrigger('eventAfterAllRender', {
            context: this,
            args: [this]
        });
    };
    DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {
        var _this = this;
        // an optimization, because getEventLegacy is expensive
        if (this.hasPublicHandlers('eventAfterRender')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) {
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventAfterRender', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    DateComponent.prototype.triggerBeforeEventsDestroyed = function () {
        this.triggerBeforeEventSegsDestroyed(this.getEventSegs());
    };
    DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {
        var _this = this;
        if (this.hasPublicHandlers('eventDestroy')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) {
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventDestroy', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    // Event Rendering Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Hides all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.showEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', '');
            }
        });
        this.callChildren('showEventsWithId', arguments);
    };
    // Shows all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.hideEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', 'hidden');
            }
        });
        this.callChildren('hideEventsWithId', arguments);
    };
    // Drag-n-Drop Rendering (for both events and external elements)
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of a event or external-element drag over the given drop zone.
    // If an external-element, seg will be `null`.
    // Must return elements used for any mock events.
    DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var renderedHelper = false;
        this.iterChildren(function (child) {
            if (child.renderDrag(eventFootprints, seg, isTouch)) {
                renderedHelper = true;
            }
        });
        return renderedHelper;
    };
    // Unrenders a visual indication of an event or external-element being dragged.
    DateComponent.prototype.unrenderDrag = function () {
        this.callChildren('unrenderDrag', arguments);
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of an event being resized.
    DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.callChildren('renderEventResize', arguments);
    };
    // Unrenders a visual indication of an event being resized.
    DateComponent.prototype.unrenderEventResize = function () {
        this.callChildren('unrenderEventResize', arguments);
    };
    // Selection
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of the selection
    // TODO: rename to `renderSelection` after legacy is gone
    DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {
        this.renderHighlight(componentFootprint);
        this.callChildren('renderSelectionFootprint', arguments);
    };
    // Unrenders a visual indication of selection
    DateComponent.prototype.unrenderSelection = function () {
        this.unrenderHighlight();
        this.callChildren('unrenderSelection', arguments);
    };
    // Highlight
    // ---------------------------------------------------------------------------------------------------------------
    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
    DateComponent.prototype.renderHighlight = function (componentFootprint) {
        if (this.fillRenderer) {
            this.fillRenderer.renderFootprint('highlight', componentFootprint, {
                getClasses: function () {
                    return ['fc-highlight'];
                }
            });
        }
        this.callChildren('renderHighlight', arguments);
    };
    // Unrenders the emphasis on a date range
    DateComponent.prototype.unrenderHighlight = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('highlight');
        }
        this.callChildren('unrenderHighlight', arguments);
    };
    // Hit Areas
    // ---------------------------------------------------------------------------------------------------------------
    // just because all DateComponents support this interface
    // doesn't mean they need to have their own internal coord system. they can defer to sub-components.
    DateComponent.prototype.hitsNeeded = function () {
        if (!(this.hitsNeededDepth++)) {
            this.prepareHits();
        }
        this.callChildren('hitsNeeded', arguments);
    };
    DateComponent.prototype.hitsNotNeeded = function () {
        if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
            this.releaseHits();
        }
        this.callChildren('hitsNotNeeded', arguments);
    };
    DateComponent.prototype.prepareHits = function () {
        // subclasses can implement
    };
    DateComponent.prototype.releaseHits = function () {
        // subclasses can implement
    };
    // Given coordinates from the topleft of the document, return data about the date-related area underneath.
    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
    // Must have a `grid` property, a reference to this current grid. TODO: avoid this
    // The returned object will be processed by getHitFootprint and getHitEl.
    DateComponent.prototype.queryHit = function (leftOffset, topOffset) {
        var childrenByUid = this.childrenByUid;
        var uid;
        var hit;
        for (uid in childrenByUid) {
            hit = childrenByUid[uid].queryHit(leftOffset, topOffset);
            if (hit) {
                break;
            }
        }
        return hit;
    };
    DateComponent.prototype.getSafeHitFootprint = function (hit) {
        var footprint = this.getHitFootprint(hit);
        if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {
            return null;
        }
        return footprint;
    };
    DateComponent.prototype.getHitFootprint = function (hit) {
        // what about being abstract!?
    };
    // Given position-level information about a date-related area within the grid,
    // should return a jQuery element that best represents it. passed to dayClick callback.
    DateComponent.prototype.getHitEl = function (hit) {
        // what about being abstract!?
    };
    /* Converting eventRange -> eventFootprint
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var eventFootprints = [];
        var i;
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// append
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_2.eventRangeToEventFootprint(eventRange)];
    };
    /* Converting componentFootprint/eventFootprint -> segs
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {
        var segs = [];
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));
        }
        return segs;
    };
    // Given an event's span (unzoned start/end and other misc data), and the event itself,
    // slices into segments and attaches event-derived properties to them.
    // eventSpan - { start, end, isStart, isEnd, otherthings... }
    DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {
        var unzonedRange = eventFootprint.componentFootprint.unzonedRange;
        var segs;
        var i, seg;
        segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (!unzonedRange.isStart) {
                seg.isStart = false;
            }
            if (!unzonedRange.isEnd) {
                seg.isEnd = false;
            }
            seg.footprint = eventFootprint;
            // TODO: rename to seg.eventFootprint
        }
        return segs;
    };
    DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {
        return [];
    };
    // Utils
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.callChildren = function (methodName, args) {
        this.iterChildren(function (child) {
            child[methodName].apply(child, args);
        });
    };
    DateComponent.prototype.iterChildren = function (func) {
        var childrenByUid = this.childrenByUid;
        var uid;
        for (uid in childrenByUid) {
            func(childrenByUid[uid]);
        }
    };
    DateComponent.prototype._getCalendar = function () {
        var t = this;
        return t.calendar || t.view.calendar;
    };
    DateComponent.prototype._getView = function () {
        return this.view;
    };
    DateComponent.prototype._getDateProfile = function () {
        return this._getView().get('dateProfile');
    };
    // Generates HTML for an anchor to another view into the calendar.
    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
    // `gotoOptions` can either be a moment input, or an object with the form:
    // { date, type, forceOff }
    // `type` is a view-type like "day" or "week". default value is "day".
    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
    DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {
        var date, type, forceOff;
        var finalOptions;
        if ($.isPlainObject(gotoOptions)) {
            date = gotoOptions.date;
            type = gotoOptions.type;
            forceOff = gotoOptions.forceOff;
        }
        else {
            date = gotoOptions; // a single moment input
        }
        date = moment_ext_1.default(date); // if a string, parse it
        finalOptions = {
            date: date.format('YYYY-MM-DD'),
            type: type || 'day'
        };
        if (typeof attrs === 'string') {
            innerHtml = attrs;
            attrs = null;
        }
        attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space
        innerHtml = innerHtml || '';
        if (!forceOff && this.opt('navLinks')) {
            return '<a' + attrs +
                ' data-goto="' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '">' +
                innerHtml +
                '</a>';
        }
        else {
            return '<span' + attrs + '>' +
                innerHtml +
                '</span>';
        }
    };
    DateComponent.prototype.getAllDayHtml = function () {
        return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));
    };
    // Computes HTML classNames for a single-day element
    DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {
        var view = this._getView();
        var classes = [];
        var today;
        if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {
            classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
        }
        else {
            classes.push('fc-' + util_1.dayIDs[date.day()]);
            if (view.isDateInOtherMonth(date, this.dateProfile)) {
                classes.push('fc-other-month');
            }
            today = view.calendar.getNow();
            if (date.isSame(today, 'day')) {
                classes.push('fc-today');
                if (noThemeHighlight !== true) {
                    classes.push(view.calendar.theme.getClass('today'));
                }
            }
            else if (date < today) {
                classes.push('fc-past');
            }
            else {
                classes.push('fc-future');
            }
        }
        return classes;
    };
    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
    // The timezones of the dates within `range` will be respected.
    DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {
        var end = range.end;
        if (isAllDay) {
            end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
        }
        return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);
    };
    // Compute the number of the give units in the "current" range.
    // Will return a floating-point number. Won't round.
    DateComponent.prototype.currentRangeAs = function (unit) {
        return this._getDateProfile().currentUnzonedRange.as(unit);
    };
    // Returns the date range of the full days the given range visually appears to occupy.
    // Returns a plain object with start/end, NOT an UnzonedRange!
    DateComponent.prototype.computeDayRange = function (unzonedRange) {
        var calendar = this._getCalendar();
        var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts
        var end = calendar.msToUtcMoment(unzonedRange.endMs);
        var endTimeMS = +end.time(); // # of milliseconds into `endDay`
        var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
            endDay.add(1, 'days');
        }
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
        if (endDay <= startDay) {
            endDay = startDay.clone().add(1, 'days');
        }
        return { start: startDay, end: endDay };
    };
    // Does the given range visually appear to occupy more than one day?
    DateComponent.prototype.isMultiDayRange = function (unzonedRange) {
        var dayRange = this.computeDayRange(unzonedRange);
        return dayRange.end.diff(dayRange.start, 'days') > 1;
    };
    DateComponent.guid = 0; // TODO: better system for this?
    return DateComponent;
}(Component_1.default));
exports.default = DateComponent;
// legacy
function convertEventsPayloadToLegacyArray(eventsPayload) {
    var eventDefId;
    var eventInstances;
    var legacyEvents = [];
    var i;
    for (eventDefId in eventsPayload) {
        eventInstances = eventsPayload[eventDefId].eventInstances;
        for (i = 0; i < eventInstances.length; i++) {
            legacyEvents.push(eventInstances[i].toLegacy());
        }
    }
    return legacyEvents;
}


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(4);
var DateProfileGenerator = /** @class */ (function () {
    function DateProfileGenerator(_view) {
        this._view = _view;
    }
    DateProfileGenerator.prototype.opt = function (name) {
        return this._view.opt(name);
    };
    DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {
        return this._view.trimHiddenDays(unzonedRange);
    };
    DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {
        return this._view.calendar.msToUtcMoment(ms, forceAllDay);
    };
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds a structure with info about what the dates/ranges will be for the "prev" view.
    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {
        var prevDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .subtract(currentDateProfile.dateIncrement);
        return this.build(prevDate, -1);
    };
    // Builds a structure with info about what the dates/ranges will be for the "next" view.
    DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {
        var nextDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .add(currentDateProfile.dateIncrement);
        return this.build(nextDate, 1);
    };
    // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).
    DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {
        if (forceToValid === void 0) { forceToValid = false; }
        var isDateAllDay = !date.hasTime();
        var validUnzonedRange;
        var minTime = null;
        var maxTime = null;
        var currentInfo;
        var isRangeAllDay;
        var renderUnzonedRange;
        var activeUnzonedRange;
        var isValid;
        validUnzonedRange = this.buildValidRange();
        validUnzonedRange = this.trimHiddenDays(validUnzonedRange);
        if (forceToValid) {
            date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        currentInfo = this.buildCurrentRangeInfo(date, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);
        renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);
        activeUnzonedRange = renderUnzonedRange.clone();
        if (!this.opt('showNonCurrentDates')) {
            activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);
        }
        minTime = moment.duration(this.opt('minTime'));
        maxTime = moment.duration(this.opt('maxTime'));
        activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);
        activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null
        if (activeUnzonedRange) {
            date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.
        isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);
        return {
            // constraint for where prev/next operations can go and where events can be dragged/resized to.
            // an object with optional start and end properties.
            validUnzonedRange: validUnzonedRange,
            // range the view is formally responsible for.
            // for example, a month view might have 1st-31st, excluding padded dates
            currentUnzonedRange: currentInfo.unzonedRange,
            // name of largest unit being displayed, like "month" or "week"
            currentRangeUnit: currentInfo.unit,
            isRangeAllDay: isRangeAllDay,
            // dates that display events and accept drag-n-drop
            // will be `null` if no dates accept events
            activeUnzonedRange: activeUnzonedRange,
            // date range with a rendered skeleton
            // includes not-active days that need some sort of DOM
            renderUnzonedRange: renderUnzonedRange,
            // Duration object that denotes the first visible time of any given day
            minTime: minTime,
            // Duration object that denotes the exclusive visible end time of any given day
            maxTime: maxTime,
            isValid: isValid,
            date: date,
            // how far the current date will move for a prev/next operation
            dateIncrement: this.buildDateIncrement(currentInfo.duration)
            // pass a fallback (might be null) ^
        };
    };
    // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildValidRange = function () {
        return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||
            new UnzonedRange_1.default(); // completely open-ended
    };
    // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
        var viewSpec = this._view.viewSpec;
        var duration = null;
        var unit = null;
        var unzonedRange = null;
        var dayCount;
        if (viewSpec.duration) {
            duration = viewSpec.duration;
            unit = viewSpec.durationUnit;
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        else if ((dayCount = this.opt('dayCount'))) {
            unit = 'day';
            unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);
        }
        else if ((unzonedRange = this.buildCustomVisibleRange(date))) {
            unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());
        }
        else {
            duration = this.getFallbackDuration();
            unit = util_1.computeGreatestUnit(duration);
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        return { duration: duration, unit: unit, unzonedRange: unzonedRange };
    };
    DateProfileGenerator.prototype.getFallbackDuration = function () {
        return moment.duration({ days: 1 });
    };
    // Returns a new activeUnzonedRange to have time values (un-ambiguate)
    // minTime or maxTime causes the range to expand.
    DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {
        var start = unzonedRange.getStart();
        var end = unzonedRange.getEnd();
        if (this._view.usesMinMaxTime) {
            if (minTime < 0) {
                start.time(0).add(minTime);
            }
            if (maxTime > 24 * 60 * 60 * 1000) {
                end.time(maxTime - (24 * 60 * 60 * 1000));
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed computeGreatestUnit value of duration.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
        var alignment = this.opt('dateAlignment');
        var dateIncrementInput;
        var dateIncrementDuration;
        var start;
        var end;
        var res;
        // compute what the alignment should be
        if (!alignment) {
            dateIncrementInput = this.opt('dateIncrement');
            if (dateIncrementInput) {
                dateIncrementDuration = moment.duration(dateIncrementInput);
                // use the smaller of the two units
                if (dateIncrementDuration < duration) {
                    alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
                }
                else {
                    alignment = unit;
                }
            }
            else {
                alignment = unit;
            }
        }
        // if the view displays a single day or smaller
        if (duration.as('days') <= 1) {
            if (this._view.isHiddenDay(start)) {
                start = this._view.skipHiddenDays(start, direction);
                start.startOf('day');
            }
        }
        function computeRes() {
            start = date.clone().startOf(alignment);
            end = start.clone().add(duration);
            res = new UnzonedRange_1.default(start, end);
        }
        computeRes();
        // if range is completely enveloped by hidden days, go past the hidden days
        if (!this.trimHiddenDays(res)) {
            date = this._view.skipHiddenDays(date, direction);
            computeRes();
        }
        return res;
    };
    // Builds the "current" range when a dayCount is specified.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
        var customAlignment = this.opt('dateAlignment');
        var runningCount = 0;
        var start = date.clone();
        var end;
        if (customAlignment) {
            start.startOf(customAlignment);
        }
        start.startOf('day');
        start = this._view.skipHiddenDays(start, direction);
        end = start.clone();
        do {
            end.add(1, 'day');
            if (!this._view.isHiddenDay(end)) {
                runningCount++;
            }
        } while (runningCount < dayCount);
        return new UnzonedRange_1.default(start, end);
    };
    // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
        var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations
        );
        if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {
            return null;
        }
        return visibleUnzonedRange;
    };
    // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        return currentUnzonedRange.clone();
    };
    // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.
    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
        var dateIncrementInput = this.opt('dateIncrement');
        var customAlignment;
        if (dateIncrementInput) {
            return moment.duration(dateIncrementInput);
        }
        else if ((customAlignment = this.opt('dateAlignment'))) {
            return moment.duration(1, customAlignment);
        }
        else if (fallback) {
            return fallback;
        }
        else {
            return moment.duration({ days: 1 });
        }
    };
    return DateProfileGenerator;
}());
exports.default = DateProfileGenerator;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var namespace_hooks_1 = __webpack_require__(7);
var util_1 = __webpack_require__(2);
var moment_ext_1 = __webpack_require__(9);
var ListenerMixin_1 = __webpack_require__(6);
var HitDragListener_1 = __webpack_require__(18);
var SingleEventDef_1 = __webpack_require__(11);
var EventInstanceGroup_1 = __webpack_require__(17);
var EventSource_1 = __webpack_require__(5);
var Interaction_1 = __webpack_require__(13);
var ExternalDropping = /** @class */ (function (_super) {
    tslib_1.__extends(ExternalDropping, _super);
    function ExternalDropping() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDragging = false; // jqui-dragging an external element? boolean
        return _this;
    }
    /*
    component impements:
        - eventRangesToEventFootprints
        - isEventInstanceGroupAllowed
        - isExternalInstanceGroupAllowed
        - renderDrag
        - unrenderDrag
    */
    ExternalDropping.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    ExternalDropping.prototype.bindToDocument = function () {
        this.listenTo($(document), {
            dragstart: this.handleDragStart,
            sortstart: this.handleDragStart // jqui
        });
    };
    ExternalDropping.prototype.unbindFromDocument = function () {
        this.stopListeningTo($(document));
    };
    // Called when a jQuery UI drag is initiated anywhere in the DOM
    ExternalDropping.prototype.handleDragStart = function (ev, ui) {
        var el;
        var accept;
        if (this.opt('droppable')) {
            el = $((ui ? ui.item : null) || ev.target);
            // Test that the dragged element passes the dropAccept selector or filter function.
            // FYI, the default is "*" (matches all)
            accept = this.opt('dropAccept');
            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                if (!this.isDragging) {
                    this.listenToExternalDrag(el, ev, ui);
                }
            }
        }
    };
    // Called when a jQuery UI drag starts and it needs to be monitored for dropping
    ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
        var singleEventDef; // a null value signals an unsuccessful drag
        // listener that tracks mouse movement over date-associated pixel regions
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            interactionStart: function () {
                _this.isDragging = true;
            },
            hitOver: function (hit) {
                var isAllowed = true;
                var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid
                var mutatedEventInstanceGroup;
                if (hitFootprint) {
                    singleEventDef = _this.computeExternalDrop(hitFootprint, meta);
                    if (singleEventDef) {
                        mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());
                        isAllowed = meta.eventProps ? // isEvent?
                            component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :
                            component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    singleEventDef = null;
                    util_1.disableCursor();
                }
                if (singleEventDef) {
                    component.renderDrag(// called without a seg parameter
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));
                }
            },
            hitOut: function () {
                singleEventDef = null; // signal unsuccessful
            },
            hitDone: function () {
                util_1.enableCursor();
                component.unrenderDrag();
            },
            interactionEnd: function (ev) {
                if (singleEventDef) {
                    view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent
                    Boolean(meta.stick), // isSticky
                    el, ev, ui);
                }
                _this.isDragging = false;
                _this.dragListener = null;
            }
        });
        dragListener.startDrag(ev); // start listening immediately
    };
    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
    // Returning a null value signals an invalid drop hit.
    // DOES NOT consider overlap/constraint.
    // Assumes both footprints are non-open-ended.
    ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {
        var calendar = this.view.calendar;
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();
        var end;
        var eventDef;
        if (componentFootprint.isAllDay) {
            // if dropped on an all-day span, and element's metadata specified a time, set it
            if (meta.startTime) {
                start.time(meta.startTime);
            }
            else {
                start.stripTime();
            }
        }
        if (meta.duration) {
            end = start.clone().add(meta.duration);
        }
        start = calendar.applyTimezone(start);
        if (end) {
            end = calendar.applyTimezone(end);
        }
        eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {
            start: start,
            end: end
        }), new EventSource_1.default(calendar));
        return eventDef;
    };
    return ExternalDropping;
}(Interaction_1.default));
exports.default = ExternalDropping;
ListenerMixin_1.default.mixInto(ExternalDropping);
/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/
// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
    var prefix = namespace_hooks_1.default.dataAttrPrefix;
    var eventProps; // properties for creating the event, not related to date/time
    var startTime; // a Duration
    var duration;
    var stick;
    if (prefix) {
        prefix += '-';
    }
    eventProps = el.data(prefix + 'event') || null;
    if (eventProps) {
        if (typeof eventProps === 'object') {
            eventProps = $.extend({}, eventProps); // make a copy
        }
        else {
            eventProps = {};
        }
        // pluck special-cased date/time properties
        startTime = eventProps.start;
        if (startTime == null) {
            startTime = eventProps.time;
        } // accept 'time' as well
        duration = eventProps.duration;
        stick = eventProps.stick;
        delete eventProps.start;
        delete eventProps.time;
        delete eventProps.duration;
        delete eventProps.stick;
    }
    // fallback to standalone attribute values for each of the date/time properties
    if (startTime == null) {
        startTime = el.data(prefix + 'start');
    }
    if (startTime == null) {
        startTime = el.data(prefix + 'time');
    } // accept 'time' as well
    if (duration == null) {
        duration = el.data(prefix + 'duration');
    }
    if (stick == null) {
        stick = el.data(prefix + 'stick');
    }
    // massage into correct data types
    startTime = startTime != null ? moment.duration(startTime) : null;
    duration = duration != null ? moment.duration(duration) : null;
    stick = Boolean(stick);
    return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventDefMutation_1 = __webpack_require__(26);
var EventDefDateMutation_1 = __webpack_require__(35);
var HitDragListener_1 = __webpack_require__(18);
var Interaction_1 = __webpack_require__(13);
var EventResizing = /** @class */ (function (_super) {
    tslib_1.__extends(EventResizing, _super);
    /*
    component impements:
        - bindSegHandlerToEl
        - publiclyTrigger
        - diffDates
        - eventRangesToEventFootprints
        - isEventInstanceGroupAllowed
        - getSafeHitFootprint
    */
    function EventResizing(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isResizing = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventResizing.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventResizing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventResizing.prototype.handleMouseDown = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev, { distance: 5 });
        }
    };
    EventResizing.prototype.handleTouchStart = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev);
        }
    };
    // Creates a listener that tracks the user as they resize an event segment.
    // Generic enough to work with any type of Grid.
    EventResizing.prototype.buildDragListener = function (seg, isStart) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance;
        var isDragging;
        var resizeMutation; // zoned event date properties. falsy if invalid resize
        // Tracks mouse movement over the *grid's* coordinate map
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            interactionStart: function () {
                isDragging = false;
            },
            dragStart: function (ev) {
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segResizeStart(seg, ev);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origHitFootprint = component.getSafeHitFootprint(origHit);
                var hitFootprint = component.getSafeHitFootprint(hit);
                var mutatedEventInstanceGroup;
                if (origHitFootprint && hitFootprint) {
                    resizeMutation = isStart ?
                        _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :
                        _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);
                    if (resizeMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    resizeMutation = null;
                    util_1.disableCursor();
                }
                else if (resizeMutation.isEmpty()) {
                    // no change. (FYI, event dates might have zones)
                    resizeMutation = null;
                }
                if (resizeMutation) {
                    view.hideEventsWithId(seg.footprint.eventDef.id);
                    view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);
                }
            },
            hitOut: function () {
                resizeMutation = null;
            },
            hitDone: function () {
                view.unrenderEventResize(seg);
                view.showEventsWithId(seg.footprint.eventDef.id);
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                if (isDragging) {
                    _this.segResizeStop(seg, ev);
                }
                if (resizeMutation) {
                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                    view.reportEventResize(eventInstance, resizeMutation, el, ev);
                }
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment resizing starts
    EventResizing.prototype.segResizeStart = function (seg, ev) {
        this.isResizing = true;
        this.component.publiclyTrigger('eventResizeStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment resizing stops
    EventResizing.prototype.segResizeStop = function (seg, ev) {
        this.isResizing = false;
        this.component.publiclyTrigger('eventResizeStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Returns new date-information for an event segment being resized from its start
    EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getStart().add(startDelta) < origRange.getEnd()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setStartDelta(startDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    // Returns new date-information for an event segment being resized from its end
    EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getEnd().add(endDelta) > origRange.getStart()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setEndDelta(endDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    return EventResizing;
}(Interaction_1.default));
exports.default = EventResizing;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var EventDefMutation_1 = __webpack_require__(26);
var EventDefDateMutation_1 = __webpack_require__(35);
var DragListener_1 = __webpack_require__(39);
var HitDragListener_1 = __webpack_require__(18);
var MouseFollower_1 = __webpack_require__(81);
var Interaction_1 = __webpack_require__(13);
var EventDragging = /** @class */ (function (_super) {
    tslib_1.__extends(EventDragging, _super);
    /*
    component implements:
        - bindSegHandlerToEl
        - publiclyTrigger
        - diffDates
        - eventRangesToEventFootprints
        - isEventInstanceGroupAllowed
    */
    function EventDragging(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isDragging = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventDragging.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventDragging.prototype.getSelectionDelay = function () {
        var delay = this.opt('eventLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    EventDragging.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventDragging.prototype.handleMousedown = function (seg, ev) {
        if (this.component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, { distance: 5 });
        }
    };
    EventDragging.prototype.handleTouchStart = function (seg, ev) {
        var component = this.component;
        var settings = {
            delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?
                0 : this.getSelectionDelay()
        };
        if (component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, settings);
        }
        else if (component.canStartSelection(seg, ev)) {
            this.buildSelectListener(seg).startInteraction(ev, settings);
        }
    };
    // seg isn't draggable, but let's use a generic DragListener
    // simply for the delay, so it can be selected.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildSelectListener = function (seg) {
        var _this = this;
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        if (this.dragListener) {
            return this.dragListener;
        }
        var dragListener = this.dragListener = new DragListener_1.default({
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
            },
            interactionEnd: function (ev) {
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Builds a listener that will track user-dragging on an event segment.
    // Generic enough to work with any type of Grid.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildDragListener = function (seg) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        var isDragging;
        var mouseFollower; // A clone of the original element that will move with the mouse
        var eventDefMutation;
        if (this.dragListener) {
            return this.dragListener;
        }
        // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
        // of the view.
        var dragListener = this.dragListener = new HitDragListener_1.default(view, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            subjectCenter: true,
            interactionStart: function (ev) {
                seg.component = component; // for renderDrag
                isDragging = false;
                mouseFollower = new MouseFollower_1.default(seg.el, {
                    additionalClass: 'fc-dragging',
                    parentEl: view.el,
                    opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),
                    revertDuration: _this.opt('dragRevertDuration'),
                    zIndex: 2 // one above the .fc-view
                });
                mouseFollower.hide(); // don't show until we know this is a real drag
                mouseFollower.start(ev);
            },
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segDragStart(seg, ev);
                view.hideEventsWithId(seg.footprint.eventDef.id);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origFootprint;
                var footprint;
                var mutatedEventInstanceGroup;
                // starting hit could be forced (DayGrid.limit)
                if (seg.hit) {
                    origHit = seg.hit;
                }
                // hit might not belong to this grid, so query origin grid
                origFootprint = origHit.component.getSafeHitFootprint(origHit);
                footprint = hit.component.getSafeHitFootprint(hit);
                if (origFootprint && footprint) {
                    eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);
                    if (eventDefMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    eventDefMutation = null;
                    util_1.disableCursor();
                }
                // if a valid drop location, have the subclass render a visual indication
                if (eventDefMutation &&
                    view.renderDrag(// truthy if rendered something
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {
                    mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
                }
                else {
                    mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
                }
                if (isOrig) {
                    // needs to have moved hits to be a valid drop
                    eventDefMutation = null;
                }
            },
            hitOut: function () {
                view.unrenderDrag(seg); // unrender whatever was done in renderDrag
                mouseFollower.show(); // show in case we are moving out of all hits
                eventDefMutation = null;
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                delete seg.component; // prevent side effects
                // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
                mouseFollower.stop(!eventDefMutation, function () {
                    if (isDragging) {
                        view.unrenderDrag(seg);
                        _this.segDragStop(seg, ev);
                    }
                    view.showEventsWithId(seg.footprint.eventDef.id);
                    if (eventDefMutation) {
                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                        view.reportEventDrop(eventInstance, eventDefMutation, el, ev);
                    }
                });
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment dragging starts
    EventDragging.prototype.segDragStart = function (seg, ev) {
        this.isDragging = true;
        this.component.publiclyTrigger('eventDragStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment dragging stops
    EventDragging.prototype.segDragStop = function (seg, ev) {
        this.isDragging = false;
        this.component.publiclyTrigger('eventDragStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // DOES NOT consider overlap/constraint
    EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {
        var eventDefMutation = new EventDefMutation_1.default();
        eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));
        return eventDefMutation;
    };
    EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {
        var date0 = startFootprint.unzonedRange.getStart();
        var date1 = endFootprint.unzonedRange.getStart();
        var clearEnd = false;
        var forceTimed = false;
        var forceAllDay = false;
        var dateDelta;
        var dateMutation;
        if (startFootprint.isAllDay !== endFootprint.isAllDay) {
            clearEnd = true;
            if (endFootprint.isAllDay) {
                forceAllDay = true;
                date0.stripTime();
            }
            else {
                forceTimed = true;
            }
        }
        dateDelta = this.component.diffDates(date1, date0);
        dateMutation = new EventDefDateMutation_1.default();
        dateMutation.clearEnd = clearEnd;
        dateMutation.forceTimed = forceTimed;
        dateMutation.forceAllDay = forceAllDay;
        dateMutation.setDateDelta(dateDelta);
        return dateMutation;
    };
    return EventDragging;
}(Interaction_1.default));
exports.default = EventDragging;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var HitDragListener_1 = __webpack_require__(18);
var ComponentFootprint_1 = __webpack_require__(10);
var UnzonedRange_1 = __webpack_require__(4);
var Interaction_1 = __webpack_require__(13);
var DateSelecting = /** @class */ (function (_super) {
    tslib_1.__extends(DateSelecting, _super);
    /*
    component must implement:
        - bindDateHandlerToEl
        - getSafeHitFootprint
        - renderHighlight
        - unrenderHighlight
    */
    function DateSelecting(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateSelecting.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateSelecting.prototype.getDelay = function () {
        var delay = this.opt('selectLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    DateSelecting.prototype.bindToEl = function (el) {
        var _this = this;
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev, {
                    distance: _this.opt('selectMinDistance')
                });
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev, {
                    delay: _this.getDelay()
                });
            }
        });
        util_1.preventSelection(el);
    };
    // Creates a listener that tracks the user's drag across day elements, for day selecting.
    DateSelecting.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var selectionFootprint; // null if invalid selection
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                selectionFootprint = null;
            },
            dragStart: function (ev) {
                _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one
            },
            hitOver: function (hit, isOrig, origHit) {
                var origHitFootprint;
                var hitFootprint;
                if (origHit) {
                    origHitFootprint = component.getSafeHitFootprint(origHit);
                    hitFootprint = component.getSafeHitFootprint(hit);
                    if (origHitFootprint && hitFootprint) {
                        selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);
                    }
                    else {
                        selectionFootprint = null;
                    }
                    if (selectionFootprint) {
                        component.renderSelectionFootprint(selectionFootprint);
                    }
                    else if (selectionFootprint === false) {
                        util_1.disableCursor();
                    }
                }
            },
            hitOut: function () {
                selectionFootprint = null;
                component.unrenderSelection();
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev, isCancelled) {
                if (!isCancelled && selectionFootprint) {
                    // the selection will already have been rendered. just report it
                    _this.view.reportSelection(selectionFootprint, ev);
                }
            }
        });
        return dragListener;
    };
    // Given the first and last date-spans of a selection, returns another date-span object.
    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().
    // Will return false if the selection is invalid and this should be indicated to the user.
    // Will return null/undefined if a selection invalid but no error should be reported.
    DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {
        var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);
        if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {
            return false;
        }
        return wholeFootprint;
    };
    // Given two spans, must return the combination of the two.
    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
    // Assumes both footprints are non-open-ended.
    DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {
        var ms = [
            footprint0.unzonedRange.startMs,
            footprint0.unzonedRange.endMs,
            footprint1.unzonedRange.startMs,
            footprint1.unzonedRange.endMs
        ];
        ms.sort(util_1.compareNumbers);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);
    };
    DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&
            this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);
    };
    return DateSelecting;
}(Interaction_1.default));
exports.default = DateSelecting;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Scroller_1 = __webpack_require__(28);
var View_1 = __webpack_require__(30);
var TimeGrid_1 = __webpack_require__(68);
var DayGrid_1 = __webpack_require__(46);
var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
var AgendaView = /** @class */ (function (_super) {
    tslib_1.__extends(AgendaView, _super);
    function AgendaView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering
        _this.timeGrid = _this.instantiateTimeGrid();
        _this.addChild(_this.timeGrid);
        if (_this.opt('allDaySlot')) {
            _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view
            _this.addChild(_this.dayGrid);
        }
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
    AgendaView.prototype.instantiateTimeGrid = function () {
        var SubClass = makeTimeGridSubclass(this.timeGridClass);
        return new SubClass(this);
    };
    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
    AgendaView.prototype.instantiateDayGrid = function () {
        var SubClass = makeDayGridSubclass(this.dayGridClass);
        return new SubClass(this);
    };
    /* Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.renderSkeleton = function () {
        var timeGridWrapEl;
        var timeGridEl;
        this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
        timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
        this.el.find('.fc-body > tr > td').append(timeGridWrapEl);
        this.timeGrid.headContainerEl = this.el.find('.fc-head-container');
        this.timeGrid.setElement(timeGridEl);
        if (this.dayGrid) {
            this.dayGrid.setElement(this.el.find('.fc-day-grid'));
            // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
        }
    };
    AgendaView.prototype.unrenderSkeleton = function () {
        this.timeGrid.removeElement();
        if (this.dayGrid) {
            this.dayGrid.removeElement();
        }
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid and time-grid components will render inside containers defined by this HTML.
    AgendaView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '">' +
            (this.dayGrid ?
                '<div class="fc-day-grid"/>' +
                    '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '"/>' :
                '') +
            '</td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the axis, if it is known
    AgendaView.prototype.axisStyleAttr = function () {
        if (this.axisWidth != null) {
            return 'style="width:' + this.axisWidth + 'px"';
        }
        return '';
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.getNowIndicatorUnit = function () {
        return this.timeGrid.getNowIndicatorUnit();
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Adjusts the vertical dimensions of the view to the specified values
    AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit;
        var scrollerHeight;
        var scrollbarWidths;
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        // make all axis cells line up, and record the width so newly created axis cells will have it
        this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));
        // hack to give the view some height prior to timeGrid's columns being rendered
        // TODO: separate setting height from scroller VS timeGrid.
        if (!this.timeGrid.colEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        // set of fake row elements that must compensate when scroller has scrollbars
        var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');
        // reset all dimensions back to the original state
        this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
        this.scroller.clear(); // sets height to 'auto' and clears overflow
        util_1.uncompensateScroll(noScrollRowEls);
        // limit number of events in the all-day area
        if (this.dayGrid) {
            this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
            eventLimit = this.opt('eventLimit');
            if (eventLimit && typeof eventLimit !== 'number') {
                eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
            }
            if (eventLimit) {
                this.dayGrid.limitRows(eventLimit);
            }
        }
        if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) {
                // make the all-day and header rows lines up
                util_1.compensateScroll(noScrollRowEls, scrollbarWidths);
                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                // and reapply the desired height to the scroller.
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
            // if there's any space below the slats, show the horizontal rule.
            // this won't cause any new overflow, because lockOverflow already called.
            if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                this.timeGrid.bottomRuleEl.show();
            }
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    AgendaView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes the initial pre-configured scroll state prior to allowing the user to change it
    AgendaView.prototype.computeInitialDateScroll = function () {
        var scrollTime = moment.duration(this.opt('scrollTime'));
        var top = this.timeGrid.computeTimeTop(scrollTime);
        // zoom can give weird floating-point values. rather scroll a little bit further
        top = Math.ceil(top);
        if (top) {
            top++; // to overcome top border that slots beyond the first have. looks better
        }
        return { top: top };
    };
    AgendaView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    AgendaView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    /* Hit Areas
    ------------------------------------------------------------------------------------------------------------------*/
    // forward all hit-related method calls to the grids (dayGrid might not be defined)
    AgendaView.prototype.getHitFootprint = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitFootprint(hit);
    };
    AgendaView.prototype.getHitEl = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitEl(hit);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.executeEventRender = function (eventsPayload) {
        var dayEventsPayload = {};
        var timedEventsPayload = {};
        var id, eventInstanceGroup;
        // separate the events into all-day and timed
        for (id in eventsPayload) {
            eventInstanceGroup = eventsPayload[id];
            if (eventInstanceGroup.getEventDef().isAllDay()) {
                dayEventsPayload[id] = eventInstanceGroup;
            }
            else {
                timedEventsPayload[id] = eventInstanceGroup;
            }
        }
        this.timeGrid.executeEventRender(timedEventsPayload);
        if (this.dayGrid) {
            this.dayGrid.executeEventRender(dayEventsPayload);
        }
    };
    /* Dragging/Resizing Routing
    ------------------------------------------------------------------------------------------------------------------*/
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        var renderedHelper = false;
        renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;
        }
        return renderedHelper;
    };
    AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        this.timeGrid.renderEventResize(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);
        }
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection
    AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (!componentFootprint.isAllDay) {
            this.timeGrid.renderSelectionFootprint(componentFootprint);
        }
        else if (this.dayGrid) {
            this.dayGrid.renderSelectionFootprint(componentFootprint);
        }
    };
    return AgendaView;
}(View_1.default));
exports.default = AgendaView;
AgendaView.prototype.timeGridClass = TimeGrid_1.default;
AgendaView.prototype.dayGridClass = DayGrid_1.default;
// Will customize the rendering behavior of the AgendaView's timeGrid
function makeTimeGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Generates the HTML that will go before the day-of week header cells
        SubClass.prototype.renderHeadIntroHtml = function () {
            var view = this.view;
            var calendar = view.calendar;
            var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);
            var weekText;
            if (this.opt('weekNumbers')) {
                weekText = weekStart.format(this.opt('smallWeekFormat'));
                return '' +
                    '<th class="fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '>' +
                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                    { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML
                    ) +
                    '</th>';
            }
            else {
                return '<th class="fc-axis ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '></th>';
            }
        };
        // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            return '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '></td>';
        };
        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        };
        return SubClass;
    }(SuperClass));
}
;
// Will customize the rendering behavior of the AgendaView's dayGrid
function makeDayGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        // Generates the HTML that goes before the all-day cells
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            return '' +
                '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
                '<span>' + // needed for matchCellWidths
                view.getAllDayHtml() +
                '</span>' +
                '</td>';
        };
        // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        };
        return SubClass;
    }(SuperClass));
}
;
function groupEventFootprintsByAllDay(eventFootprints) {
    var allDay = [];
    var timed = [];
    var i;
    for (i = 0; i < eventFootprints.length; i++) {
        if (eventFootprints[i].componentFootprint.isAllDay) {
            allDay.push(eventFootprints[i]);
        }
        else {
            timed.push(eventFootprints[i]);
        }
    }
    return { allDay: allDay, timed: timed };
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var InteractiveDateComponent_1 = __webpack_require__(29);
var BusinessHourRenderer_1 = __webpack_require__(41);
var StandardInteractionsMixin_1 = __webpack_require__(45);
var DayTableMixin_1 = __webpack_require__(40);
var CoordCache_1 = __webpack_require__(38);
var UnzonedRange_1 = __webpack_require__(4);
var ComponentFootprint_1 = __webpack_require__(10);
var TimeGridEventRenderer_1 = __webpack_require__(83);
var TimeGridHelperRenderer_1 = __webpack_require__(84);
var TimeGridFillRenderer_1 = __webpack_require__(85);
/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days
// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
    { hours: 1 },
    { minutes: 30 },
    { minutes: 15 },
    { seconds: 30 },
    { seconds: 15 }
];
var TimeGrid = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGrid, _super);
    function TimeGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.processOptions();
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);
        var i;
        for (i = 0; i < segs.length; i++) {
            if (this.isRTL) {
                segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
            }
            else {
                segs[i].col = segs[i].dayIndex;
            }
        }
        return segs;
    };
    /* Date Handling
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {
        var segs = [];
        var segRange;
        var dayIndex;
        for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
            segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);
            if (segRange) {
                segs.push({
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                });
            }
        }
        return segs;
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Parses various options into properties of this object
    TimeGrid.prototype.processOptions = function () {
        var slotDuration = this.opt('slotDuration');
        var snapDuration = this.opt('snapDuration');
        var input;
        slotDuration = moment.duration(slotDuration);
        snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
        this.slotDuration = slotDuration;
        this.snapDuration = snapDuration;
        this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?
        // might be an array value (for TimelineView).
        // if so, getting the most granular entry (the last one probably).
        input = this.opt('slotLabelFormat');
        if ($.isArray(input)) {
            input = input[input.length - 1];
        }
        this.labelFormat = input ||
            this.opt('smallTimeFormat'); // the computed default
        input = this.opt('slotLabelInterval');
        this.labelInterval = input ?
            moment.duration(input) :
            this.computeLabelInterval(slotDuration);
    };
    // Computes an automatic value for slotLabelInterval
    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
        var i;
        var labelInterval;
        var slotsPerLabel;
        // find the smallest stock label interval that results in more than one slots-per-label
        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
            slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);
            if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {
                return labelInterval;
            }
        }
        return moment.duration(slotDuration); // fall back. clone
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderSlats();
        this.renderColumns();
    };
    TimeGrid.prototype.unrenderDates = function () {
        //this.unrenderSlats(); // don't need this because repeated .html() calls clear
        this.unrenderColumns();
    };
    TimeGrid.prototype.renderSkeleton = function () {
        var theme = this.view.calendar.theme;
        this.el.html('<div class="fc-bg"></div>' +
            '<div class="fc-slats"></div>' +
            '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" style="display:none" />');
        this.bottomRuleEl = this.el.find('hr');
    };
    TimeGrid.prototype.renderSlats = function () {
        var theme = this.view.calendar.theme;
        this.slatContainerEl = this.el.find('> .fc-slats')
            .html(// avoids needing ::unrenderSlats()
        '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderSlatRowHtml() +
            '</table>');
        this.slatEls = this.slatContainerEl.find('tr');
        this.slatCoordCache = new CoordCache_1.default({
            els: this.slatEls,
            isVertical: true
        });
    };
    // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
    TimeGrid.prototype.renderSlatRowHtml = function () {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var isRTL = this.isRTL;
        var dateProfile = this.dateProfile;
        var html = '';
        var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations
        var slotIterator = moment.duration(0);
        var slotDate; // will be on the view's first day, but we only care about its time
        var isLabeled;
        var axisHtml;
        // Calculate the time for each slot
        while (slotTime < dateProfile.maxTime) {
            slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);
            isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));
            axisHtml =
                '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
                    (isLabeled ?
                        '<span>' + // for matchCellWidths
                            util_1.htmlEscape(slotDate.format(this.labelFormat)) +
                            '</span>' :
                        '') +
                    '</td>';
            html +=
                '<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
                    (isLabeled ? '' : ' class="fc-minor"') +
                    '>' +
                    (!isRTL ? axisHtml : '') +
                    '<td class="' + theme.getClass('widgetContent') + '"/>' +
                    (isRTL ? axisHtml : '') +
                    "</tr>";
            slotTime.add(this.slotDuration);
            slotIterator.add(this.slotDuration);
        }
        return html;
    };
    TimeGrid.prototype.renderColumns = function () {
        var dateProfile = this.dateProfile;
        var theme = this.view.calendar.theme;
        this.dayRanges = this.dayDates.map(function (dayDate) {
            return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));
        });
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        this.el.find('> .fc-bg').html('<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(0) + // row=0
            '</table>');
        this.colEls = this.el.find('.fc-day, .fc-disabled-day');
        this.colCoordCache = new CoordCache_1.default({
            els: this.colEls,
            isHorizontal: true
        });
        this.renderContentSkeleton();
    };
    TimeGrid.prototype.unrenderColumns = function () {
        this.unrenderContentSkeleton();
    };
    /* Content Skeleton
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders the DOM that the view's content will live in
    TimeGrid.prototype.renderContentSkeleton = function () {
        var cellHtml = '';
        var i;
        var skeletonEl;
        for (i = 0; i < this.colCnt; i++) {
            cellHtml +=
                '<td>' +
                    '<div class="fc-content-col">' +
                    '<div class="fc-event-container fc-helper-container"></div>' +
                    '<div class="fc-event-container"></div>' +
                    '<div class="fc-highlight-container"></div>' +
                    '<div class="fc-bgevent-container"></div>' +
                    '<div class="fc-business-container"></div>' +
                    '</div>' +
                    '</td>';
        }
        skeletonEl = this.contentSkeletonEl = $('<div class="fc-content-skeleton">' +
            '<table>' +
            '<tr>' + cellHtml + '</tr>' +
            '</table>' +
            '</div>');
        this.colContainerEls = skeletonEl.find('.fc-content-col');
        this.helperContainerEls = skeletonEl.find('.fc-helper-container');
        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
        this.businessContainerEls = skeletonEl.find('.fc-business-container');
        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
        this.el.append(skeletonEl);
    };
    TimeGrid.prototype.unrenderContentSkeleton = function () {
        this.contentSkeletonEl.remove();
        this.contentSkeletonEl = null;
        this.colContainerEls = null;
        this.helperContainerEls = null;
        this.fgContainerEls = null;
        this.bgContainerEls = null;
        this.highlightContainerEls = null;
        this.businessContainerEls = null;
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
    TimeGrid.prototype.groupSegsByCol = function (segs) {
        var segsByCol = [];
        var i;
        for (i = 0; i < this.colCnt; i++) {
            segsByCol.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segsByCol[segs[i].col].push(segs[i]);
        }
        return segsByCol;
    };
    // Given segments grouped by column, insert the segments' elements into a parallel array of container
    // elements, each living within a column.
    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
        var col;
        var segs;
        var i;
        for (col = 0; col < this.colCnt; col++) {
            segs = segsByCol[col];
            for (i = 0; i < segs.length; i++) {
                containerEls.eq(col).append(segs[i].el);
            }
        }
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.getNowIndicatorUnit = function () {
        return 'minute'; // will refresh on the minute
    };
    TimeGrid.prototype.renderNowIndicator = function (date) {
        // HACK: if date columns not ready for some reason (scheduler)
        if (!this.colContainerEls) {
            return;
        }
        // seg system might be overkill, but it handles scenario where line needs to be rendered
        //  more than once because of columns with the same date (resources columns for example)
        var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range
        false // all-day
        ));
        var top = this.computeDateTop(date, date);
        var nodes = [];
        var i;
        // render lines within the columns
        for (i = 0; i < segs.length; i++) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
                .css('top', top)
                .appendTo(this.colContainerEls.eq(segs[i].col))[0]);
        }
        // render an arrow over the axis
        if (segs.length > 0) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
                .css('top', top)
                .appendTo(this.el.find('.fc-content-skeleton'))[0]);
        }
        this.nowIndicatorEls = $(nodes);
    };
    TimeGrid.prototype.unrenderNowIndicator = function () {
        if (this.nowIndicatorEls) {
            this.nowIndicatorEls.remove();
            this.nowIndicatorEls = null;
        }
    };
    /* Coordinates
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        this.slatCoordCache.build();
        if (isResize) {
            this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));
        }
    };
    TimeGrid.prototype.getTotalSlatHeight = function () {
        return this.slatContainerEl.outerHeight();
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // `ms` can be a millisecond UTC time OR a UTC moment.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
    TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {
        return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
    TimeGrid.prototype.computeTimeTop = function (time) {
        var len = this.slatEls.length;
        var dateProfile = this.dateProfile;
        var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered
        var slatIndex;
        var slatRemainder;
        // compute a floating-point number for how many slats should be progressed through.
        // from 0 to number of slats (inclusive)
        // constrained because minTime/maxTime might be customized.
        slatCoverage = Math.max(0, slatCoverage);
        slatCoverage = Math.min(len, slatCoverage);
        // an integer index of the furthest whole slat
        // from 0 to number slats (*exclusive*, so len-1)
        slatIndex = Math.floor(slatCoverage);
        slatIndex = Math.min(slatIndex, len - 1);
        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
        // could be 1.0 if slatCoverage is covering *all* the slots
        slatRemainder = slatCoverage - slatIndex;
        return this.slatCoordCache.getTopPosition(slatIndex) +
            this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
    };
    // Refreshes the CSS top/bottom coordinates for each segment element.
    // Works when called after initial render, after a window resize/zoom for example.
    TimeGrid.prototype.updateSegVerticals = function (segs) {
        this.computeSegVerticals(segs);
        this.assignSegVerticals(segs);
    };
    // For each segment in an array, computes and assigns its top and bottom properties
    TimeGrid.prototype.computeSegVerticals = function (segs) {
        var eventMinHeight = this.opt('agendaEventMinHeight');
        var i, seg;
        var dayDate;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            dayDate = this.dayDates[seg.dayIndex];
            seg.top = this.computeDateTop(seg.startMs, dayDate);
            seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));
        }
    };
    // Given segments that already have their top/bottom properties computed, applies those values to
    // the segments' elements.
    TimeGrid.prototype.assignSegVerticals = function (segs) {
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateSegVerticalCss(seg));
        }
    };
    // Generates an object with CSS properties for the top/bottom coordinates of a segment element
    TimeGrid.prototype.generateSegVerticalCss = function (seg) {
        return {
            top: seg.top,
            bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
        };
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.slatCoordCache.build();
    };
    TimeGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
    };
    TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {
        var snapsPerSlot = this.snapsPerSlot;
        var colCoordCache = this.colCoordCache;
        var slatCoordCache = this.slatCoordCache;
        if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
            var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
            var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
            if (colIndex != null && slatIndex != null) {
                var slatTop = slatCoordCache.getTopOffset(slatIndex);
                var slatHeight = slatCoordCache.getHeight(slatIndex);
                var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
                var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;
                return {
                    col: colIndex,
                    snap: snapIndex,
                    component: this,
                    left: colCoordCache.getLeftOffset(colIndex),
                    right: colCoordCache.getRightOffset(colIndex),
                    top: snapTop,
                    bottom: snapBottom
                };
            }
        }
    };
    TimeGrid.prototype.getHitFootprint = function (hit) {
        var start = this.getCellDate(0, hit.col); // row=0
        var time = this.computeSnapTime(hit.snap); // pass in the snap-index
        var end;
        start.time(time);
        end = start.clone().add(this.snapDuration);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?
        );
    };
    // Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
    TimeGrid.prototype.computeSnapTime = function (snapIndex) {
        return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);
    };
    TimeGrid.prototype.getHitEl = function (hit) {
        return this.colEls.eq(hit.col);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being dragged over the specified date(s).
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        if (seg) {
            if (eventFootprints.length) {
                this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
                // signal that a helper has been rendered
                return true;
            }
        }
        else {
            for (i = 0; i < eventFootprints.length; i++) {
                this.renderHighlight(eventFootprints[i].componentFootprint);
            }
        }
    };
    // Unrenders any visual indication of an event being dragged
    TimeGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders any visual indication of an event being resized
    TimeGrid.prototype.unrenderEventResize = function () {
        this.helperRenderer.unrender();
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
    TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (this.opt('selectHelper')) {
            this.helperRenderer.renderComponentFootprint(componentFootprint);
        }
        else {
            this.renderHighlight(componentFootprint);
        }
    };
    // Unrenders any visual indication of a selection
    TimeGrid.prototype.unrenderSelection = function () {
        this.helperRenderer.unrender();
        this.unrenderHighlight();
    };
    return TimeGrid;
}(InteractiveDateComponent_1.default));
exports.default = TimeGrid;
TimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;
TimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
TimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;
TimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(TimeGrid);
DayTableMixin_1.default.mixInto(TimeGrid);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var UnzonedRange_1 = __webpack_require__(4);
var DateProfileGenerator_1 = __webpack_require__(62);
var BasicViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(BasicViewDateProfileGenerator, _super);
    function BasicViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        // year and month views should be aligned with weeks. this is already done for week
        if (/^(year|month)$/.test(currentRangeUnit)) {
            start.startOf('week');
            // make end-of-week if not already
            if (end.weekday()) {
                end.add(1, 'week').startOf('week'); // exclusively move backwards
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    return BasicViewDateProfileGenerator;
}(DateProfileGenerator_1.default));
exports.default = BasicViewDateProfileGenerator;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var moment = __webpack_require__(3);
var util_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(4);
var BasicView_1 = __webpack_require__(47);
var BasicViewDateProfileGenerator_1 = __webpack_require__(69);
/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/
var MonthViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(MonthViewDateProfileGenerator, _super);
    function MonthViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        var rowCnt;
        // ensure 6 weeks
        if (this.opt('fixedWeekCount')) {
            rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
            end.diff(start, 'weeks', true) // dontRound=true
            );
            end.add(6 - rowCnt, 'weeks');
        }
        return new UnzonedRange_1.default(start, end);
    };
    return MonthViewDateProfileGenerator;
}(BasicViewDateProfileGenerator_1.default));
var MonthView = /** @class */ (function (_super) {
    tslib_1.__extends(MonthView, _super);
    function MonthView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Overrides the default BasicView behavior to have special multi-week auto-height logic
    MonthView.prototype.setGridHeight = function (height, isAuto) {
        // if auto, make the height of each row the height that it would be if there were 6 weeks
        if (isAuto) {
            height *= this.dayGrid.rowCnt / 6;
        }
        util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
    };
    MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize
    };
    return MonthView;
}(BasicView_1.default));
exports.default = MonthView;
MonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(4);
var View_1 = __webpack_require__(30);
var Scroller_1 = __webpack_require__(28);
var ListEventRenderer_1 = __webpack_require__(90);
var ListEventPointing_1 = __webpack_require__(91);
/*
Responsible for the scroller, and forwarding event-related actions into the "grid".
*/
var ListView = /** @class */ (function (_super) {
    tslib_1.__extends(ListView, _super);
    function ListView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.segSelector = '.fc-list-item'; // which elements accept event actions
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    ListView.prototype.renderSkeleton = function () {
        this.el.addClass('fc-list-view ' +
            this.calendar.theme.getClass('listView'));
        this.scroller.render();
        this.scroller.el.appendTo(this.el);
        this.contentEl = this.scroller.scrollEl; // shortcut
    };
    ListView.prototype.unrenderSkeleton = function () {
        this.scroller.destroy(); // will remove the Grid too
    };
    ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
    };
    ListView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    ListView.prototype.renderDates = function (dateProfile) {
        var calendar = this.calendar;
        var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);
        var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);
        var dayDates = [];
        var dayRanges = [];
        while (dayStart < viewEnd) {
            dayDates.push(dayStart.clone());
            dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));
            dayStart.add(1, 'day');
        }
        this.dayDates = dayDates;
        this.dayRanges = dayRanges;
        // all real rendering happens in EventRenderer
    };
    // slices by day
    ListView.prototype.componentFootprintToSegs = function (footprint) {
        var dayRanges = this.dayRanges;
        var dayIndex;
        var segRange;
        var seg;
        var segs = [];
        for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {
            segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);
            if (segRange) {
                seg = {
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                };
                segs.push(seg);
                // detect when footprint won't go fully into the next day,
                // and mutate the latest seg to the be the end.
                if (!seg.isEnd && !footprint.isAllDay &&
                    dayIndex + 1 < dayRanges.length &&
                    footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {
                    seg.endMs = footprint.unzonedRange.endMs;
                    seg.isEnd = true;
                    break;
                }
            }
        }
        return segs;
    };
    ListView.prototype.renderEmptyMessage = function () {
        this.contentEl.html('<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
            '<div class="fc-list-empty-wrap1">' +
            '<div class="fc-list-empty">' +
            util_1.htmlEscape(this.opt('noEventsMessage')) +
            '</div>' +
            '</div>' +
            '</div>');
    };
    // render the event segments in the view
    ListView.prototype.renderSegList = function (allSegs) {
        var segsByDay = this.groupSegsByDay(allSegs); // sparse array
        var dayIndex;
        var daySegs;
        var i;
        var tableEl = $('<table class="fc-list-table ' + this.calendar.theme.getClass('tableList') + '"><tbody/></table>');
        var tbodyEl = tableEl.find('tbody');
        for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
            daySegs = segsByDay[dayIndex];
            if (daySegs) {
                // append a day header
                tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));
                this.eventRenderer.sortEventSegs(daySegs);
                for (i = 0; i < daySegs.length; i++) {
                    tbodyEl.append(daySegs[i].el); // append event row
                }
            }
        }
        this.contentEl.empty().append(tableEl);
    };
    // Returns a sparse array of arrays, segs grouped by their dayIndex
    ListView.prototype.groupSegsByDay = function (segs) {
        var segsByDay = []; // sparse array
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
                .push(seg);
        }
        return segsByDay;
    };
    // generates the HTML for the day headers that live amongst the event rows
    ListView.prototype.dayHeaderHtml = function (dayDate) {
        var mainFormat = this.opt('listDayFormat');
        var altFormat = this.opt('listDayAltFormat');
        return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
            '<td class="' + this.calendar.theme.getClass('widgetHeader') + '" colspan="3">' +
            (mainFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML
                ) :
                '') +
            (altFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML
                ) :
                '') +
            '</td>' +
            '</tr>';
    };
    return ListView;
}(View_1.default));
exports.default = ListView;
ListView.prototype.eventRendererClass = ListEventRenderer_1.default;
ListView.prototype.eventPointingClass = ListEventPointing_1.default;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var namespace_hooks_1 = __webpack_require__(7);
var namespaceExports = __webpack_require__(73);
var util_1 = __webpack_require__(2);
var Calendar_1 = __webpack_require__(48);
// for intentional side-effects
__webpack_require__(9);
__webpack_require__(37);
__webpack_require__(92);
__webpack_require__(93);
__webpack_require__(95);
__webpack_require__(96);
__webpack_require__(97);
$.fullCalendar = $.extend(namespace_hooks_1.default, namespaceExports); // graft over the original hooks object
$.fn.fullCalendar = function (options) {
    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
    var res = this; // what this function will return (this jQuery object by default)
    this.each(function (i, _element) {
        var element = $(_element);
        var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
        var singleRes; // the returned value of this single method call
        // a method call
        if (typeof options === 'string') {
            if (options === 'getCalendar') {
                if (!i) {
                    res = calendar;
                }
            }
            else if (options === 'destroy') {
                if (calendar) {
                    calendar.destroy();
                    element.removeData('fullCalendar');
                }
            }
            else if (!calendar) {
                util_1.warn("Attempting to call a FullCalendar method on an element with no calendar.");
            }
            else if ($.isFunction(calendar[options])) {
                singleRes = calendar[options].apply(calendar, args);
                if (!i) {
                    res = singleRes; // record the first method call result
                }
                if (options === 'destroy') {
                    element.removeData('fullCalendar');
                }
            }
            else {
                util_1.warn("'" + options + "' is an unknown FullCalendar method.");
            }
        }
        else if (!calendar) {
            calendar = new Calendar_1.default(element, options);
            element.data('fullCalendar', calendar);
            calendar.render();
        }
    });
    return res;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// TODO: linter?
// after merge: put MonthViewDateProfileGenerator after
// "abstract" issue
// ensure $ always gets a local module reference
// better UMD solution
Object.defineProperty(exports, "__esModule", { value: true });
var Calendar_1 = __webpack_require__(48);
exports.Calendar = Calendar_1.default;
var options_1 = __webpack_require__(19);
Calendar_1.default.defaults = options_1.globalDefaults;
Calendar_1.default.englishDefaults = options_1.englishDefaults;
Calendar_1.default.rtlDefaults = options_1.rtlDefaults;
var util_1 = __webpack_require__(2);
exports.applyAll = util_1.applyAll;
exports.debounce = util_1.debounce;
exports.isInt = util_1.isInt;
exports.htmlEscape = util_1.htmlEscape;
exports.cssToStr = util_1.cssToStr;
exports.proxy = util_1.proxy;
exports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;
exports.getOuterRect = util_1.getOuterRect;
exports.getClientRect = util_1.getClientRect;
exports.getContentRect = util_1.getContentRect;
exports.getScrollbarWidths = util_1.getScrollbarWidths;
exports.preventDefault = util_1.preventDefault;
exports.parseFieldSpecs = util_1.parseFieldSpecs;
exports.compareByFieldSpecs = util_1.compareByFieldSpecs;
exports.compareByFieldSpec = util_1.compareByFieldSpec;
exports.flexibleCompare = util_1.flexibleCompare;
exports.computeGreatestUnit = util_1.computeGreatestUnit;
exports.divideRangeByDuration = util_1.divideRangeByDuration;
exports.divideDurationByDuration = util_1.divideDurationByDuration;
exports.multiplyDuration = util_1.multiplyDuration;
exports.durationHasTime = util_1.durationHasTime;
exports.log = util_1.log;
exports.warn = util_1.warn;
exports.removeExact = util_1.removeExact;
exports.intersectRects = util_1.intersectRects;
var date_formatting_1 = __webpack_require__(37);
exports.formatDate = date_formatting_1.formatDate;
exports.formatRange = date_formatting_1.formatRange;
exports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;
var locale_1 = __webpack_require__(20);
exports.datepickerLocale = locale_1.datepickerLocale;
exports.locale = locale_1.locale;
var moment_ext_1 = __webpack_require__(9);
exports.moment = moment_ext_1.default;
var EmitterMixin_1 = __webpack_require__(8);
exports.EmitterMixin = EmitterMixin_1.default;
var ListenerMixin_1 = __webpack_require__(6);
exports.ListenerMixin = ListenerMixin_1.default;
var Model_1 = __webpack_require__(32);
exports.Model = Model_1.default;
var Constraints_1 = __webpack_require__(49);
exports.Constraints = Constraints_1.default;
var UnzonedRange_1 = __webpack_require__(4);
exports.UnzonedRange = UnzonedRange_1.default;
var ComponentFootprint_1 = __webpack_require__(10);
exports.ComponentFootprint = ComponentFootprint_1.default;
var BusinessHourGenerator_1 = __webpack_require__(54);
exports.BusinessHourGenerator = BusinessHourGenerator_1.default;
var EventDef_1 = __webpack_require__(22);
exports.EventDef = EventDef_1.default;
var EventDefMutation_1 = __webpack_require__(26);
exports.EventDefMutation = EventDefMutation_1.default;
var EventSourceParser_1 = __webpack_require__(25);
exports.EventSourceParser = EventSourceParser_1.default;
var EventSource_1 = __webpack_require__(5);
exports.EventSource = EventSource_1.default;
var ThemeRegistry_1 = __webpack_require__(36);
exports.ThemeRegistry = ThemeRegistry_1.default;
var EventInstanceGroup_1 = __webpack_require__(17);
exports.EventInstanceGroup = EventInstanceGroup_1.default;
var ArrayEventSource_1 = __webpack_require__(34);
exports.ArrayEventSource = ArrayEventSource_1.default;
var FuncEventSource_1 = __webpack_require__(57);
exports.FuncEventSource = FuncEventSource_1.default;
var JsonFeedEventSource_1 = __webpack_require__(58);
exports.JsonFeedEventSource = JsonFeedEventSource_1.default;
var EventFootprint_1 = __webpack_require__(24);
exports.EventFootprint = EventFootprint_1.default;
var Class_1 = __webpack_require__(21);
exports.Class = Class_1.default;
var Mixin_1 = __webpack_require__(12);
exports.Mixin = Mixin_1.default;
var CoordCache_1 = __webpack_require__(38);
exports.CoordCache = CoordCache_1.default;
var DragListener_1 = __webpack_require__(39);
exports.DragListener = DragListener_1.default;
var Promise_1 = __webpack_require__(16);
exports.Promise = Promise_1.default;
var TaskQueue_1 = __webpack_require__(59);
exports.TaskQueue = TaskQueue_1.default;
var RenderQueue_1 = __webpack_require__(60);
exports.RenderQueue = RenderQueue_1.default;
var Scroller_1 = __webpack_require__(28);
exports.Scroller = Scroller_1.default;
var Theme_1 = __webpack_require__(27);
exports.Theme = Theme_1.default;
var DateComponent_1 = __webpack_require__(61);
exports.DateComponent = DateComponent_1.default;
var InteractiveDateComponent_1 = __webpack_require__(29);
exports.InteractiveDateComponent = InteractiveDateComponent_1.default;
var View_1 = __webpack_require__(30);
exports.View = View_1.default;
var DayTableMixin_1 = __webpack_require__(40);
exports.DayTableMixin = DayTableMixin_1.default;
var BusinessHourRenderer_1 = __webpack_require__(41);
exports.BusinessHourRenderer = BusinessHourRenderer_1.default;
var EventRenderer_1 = __webpack_require__(31);
exports.EventRenderer = EventRenderer_1.default;
var FillRenderer_1 = __webpack_require__(42);
exports.FillRenderer = FillRenderer_1.default;
var HelperRenderer_1 = __webpack_require__(43);
exports.HelperRenderer = HelperRenderer_1.default;
var ExternalDropping_1 = __webpack_require__(63);
exports.ExternalDropping = ExternalDropping_1.default;
var EventResizing_1 = __webpack_require__(64);
exports.EventResizing = EventResizing_1.default;
var EventPointing_1 = __webpack_require__(44);
exports.EventPointing = EventPointing_1.default;
var EventDragging_1 = __webpack_require__(65);
exports.EventDragging = EventDragging_1.default;
var DateSelecting_1 = __webpack_require__(66);
exports.DateSelecting = DateSelecting_1.default;
var StandardInteractionsMixin_1 = __webpack_require__(45);
exports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;
var AgendaView_1 = __webpack_require__(67);
exports.AgendaView = AgendaView_1.default;
var TimeGrid_1 = __webpack_require__(68);
exports.TimeGrid = TimeGrid_1.default;
var DayGrid_1 = __webpack_require__(46);
exports.DayGrid = DayGrid_1.default;
var BasicView_1 = __webpack_require__(47);
exports.BasicView = BasicView_1.default;
var MonthView_1 = __webpack_require__(70);
exports.MonthView = MonthView_1.default;
var ListView_1 = __webpack_require__(71);
exports.ListView = ListView_1.default;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Iterator = /** @class */ (function () {
    function Iterator(items) {
        this.items = items || [];
    }
    /* Calls a method on every item passing the arguments through */
    Iterator.prototype.proxyCall = function (methodName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var results = [];
        this.items.forEach(function (item) {
            results.push(item[methodName].apply(item, args));
        });
        return results;
    };
    return Iterator;
}());
exports.default = Iterator;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/
var Toolbar = /** @class */ (function () {
    function Toolbar(calendar, toolbarOptions) {
        this.el = null; // mirrors local `el`
        this.viewsWithButtons = [];
        this.calendar = calendar;
        this.toolbarOptions = toolbarOptions;
    }
    // method to update toolbar-specific options, not calendar-wide options
    Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {
        this.toolbarOptions = newToolbarOptions;
    };
    // can be called repeatedly and will rerender
    Toolbar.prototype.render = function () {
        var sections = this.toolbarOptions.layout;
        var el = this.el;
        if (sections) {
            if (!el) {
                el = this.el = $("<div class='fc-toolbar " + this.toolbarOptions.extraClasses + "'/>");
            }
            else {
                el.empty();
            }
            el.append(this.renderSection('left'))
                .append(this.renderSection('right'))
                .append(this.renderSection('center'))
                .append('<div class="fc-clear"/>');
        }
        else {
            this.removeElement();
        }
    };
    Toolbar.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    Toolbar.prototype.renderSection = function (position) {
        var _this = this;
        var calendar = this.calendar;
        var theme = calendar.theme;
        var optionsManager = calendar.optionsManager;
        var viewSpecManager = calendar.viewSpecManager;
        var sectionEl = $('<div class="fc-' + position + '"/>');
        var buttonStr = this.toolbarOptions.layout[position];
        var calendarCustomButtons = optionsManager.get('customButtons') || {};
        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
        var calendarButtonText = optionsManager.get('buttonText') || {};
        if (buttonStr) {
            $.each(buttonStr.split(' '), function (i, buttonGroupStr) {
                var groupChildren = $();
                var isOnlyButtons = true;
                var groupEl;
                $.each(buttonGroupStr.split(','), function (j, buttonName) {
                    var customButtonProps;
                    var viewSpec;
                    var buttonClick;
                    var buttonIcon; // only one of these will be set
                    var buttonText; // "
                    var buttonInnerHtml;
                    var buttonClasses;
                    var buttonEl;
                    if (buttonName == 'title') {
                        groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
                        isOnlyButtons = false;
                    }
                    else {
                        if ((customButtonProps = calendarCustomButtons[buttonName])) {
                            buttonClick = function (ev) {
                                if (customButtonProps.click) {
                                    customButtonProps.click.call(buttonEl[0], ev);
                                }
                            };
                            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = customButtonProps.text);
                        }
                        else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {
                            _this.viewsWithButtons.push(buttonName);
                            buttonClick = function () {
                                calendar.changeView(buttonName);
                            };
                            (buttonText = viewSpec.buttonTextOverride) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = viewSpec.buttonTextDefault);
                        }
                        else if (calendar[buttonName]) {
                            buttonClick = function () {
                                calendar[buttonName]();
                            };
                            (buttonText = calendarButtonTextOverrides[buttonName]) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = calendarButtonText[buttonName]);
                            //            ^ everything else is considered default
                        }
                        if (buttonClick) {
                            buttonClasses = [
                                'fc-' + buttonName + '-button',
                                theme.getClass('button'),
                                theme.getClass('stateDefault')
                            ];
                            if (buttonText) {
                                buttonInnerHtml = util_1.htmlEscape(buttonText);
                            }
                            else if (buttonIcon) {
                                buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                            }
                            buttonEl = $(// type="button" so that it doesn't submit a form
                            '<button type="button" class="' + buttonClasses.join(' ') + '">' +
                                buttonInnerHtml +
                                '</button>')
                                .click(function (ev) {
                                // don't process clicks for disabled buttons
                                if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                    buttonClick(ev);
                                    // after the click action, if the button becomes the "active" tab, or disabled,
                                    // it should never have a hover class, so remove it now.
                                    if (buttonEl.hasClass(theme.getClass('stateActive')) ||
                                        buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                        buttonEl.removeClass(theme.getClass('stateHover'));
                                    }
                                }
                            })
                                .mousedown(function () {
                                // the *down* effect (mouse pressed in).
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateDown'));
                            })
                                .mouseup(function () {
                                // undo the *down* effect
                                buttonEl.removeClass(theme.getClass('stateDown'));
                            })
                                .hover(function () {
                                // the *hover* effect.
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateHover'));
                            }, function () {
                                // undo the *hover* effect
                                buttonEl
                                    .removeClass(theme.getClass('stateHover'))
                                    .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup
                            });
                            groupChildren = groupChildren.add(buttonEl);
                        }
                    }
                });
                if (isOnlyButtons) {
                    groupChildren
                        .first().addClass(theme.getClass('cornerLeft')).end()
                        .last().addClass(theme.getClass('cornerRight')).end();
                }
                if (groupChildren.length > 1) {
                    groupEl = $('<div/>');
                    if (isOnlyButtons) {
                        groupEl.addClass(theme.getClass('buttonGroup'));
                    }
                    groupEl.append(groupChildren);
                    sectionEl.append(groupEl);
                }
                else {
                    sectionEl.append(groupChildren); // 1 or 0 children
                }
            });
        }
        return sectionEl;
    };
    Toolbar.prototype.updateTitle = function (text) {
        if (this.el) {
            this.el.find('h2').text(text);
        }
    };
    Toolbar.prototype.activateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .addClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.deactivateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .removeClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.disableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', true)
                .addClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.enableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', false)
                .removeClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.getViewsWithButtons = function () {
        return this.viewsWithButtons;
    };
    return Toolbar;
}());
exports.default = Toolbar;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var options_1 = __webpack_require__(19);
var locale_1 = __webpack_require__(20);
var Model_1 = __webpack_require__(32);
var OptionsManager = /** @class */ (function (_super) {
    tslib_1.__extends(OptionsManager, _super);
    function OptionsManager(_calendar, overrides) {
        var _this = _super.call(this) || this;
        _this._calendar = _calendar;
        _this.overrides = $.extend({}, overrides); // make a copy
        _this.dynamicOverrides = {};
        _this.compute();
        return _this;
    }
    OptionsManager.prototype.add = function (newOptionHash) {
        var optionCnt = 0;
        var optionName;
        this.recordOverrides(newOptionHash); // will trigger this model's watchers
        for (optionName in newOptionHash) {
            optionCnt++;
        }
        // special-case handling of single option change.
        // if only one option change, `optionName` will be its name.
        if (optionCnt === 1) {
            if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
                this._calendar.updateViewSize(true); // isResize=true
                return;
            }
            else if (optionName === 'defaultDate') {
                return; // can't change date this way. use gotoDate instead
            }
            else if (optionName === 'businessHours') {
                return; // this model already reacts to this
            }
            else if (optionName === 'timezone') {
                this._calendar.view.flash('initialEvents');
                return;
            }
        }
        // catch-all. rerender the header and footer and rebuild/rerender the current view
        this._calendar.renderHeader();
        this._calendar.renderFooter();
        // even non-current views will be affected by this option change. do before rerender
        // TODO: detangle
        this._calendar.viewsByType = {};
        this._calendar.reinitView();
    };
    // Computes the flattened options hash for the calendar and assigns to `this.options`.
    // Assumes this.overrides and this.dynamicOverrides have already been initialized.
    OptionsManager.prototype.compute = function () {
        var locale, localeDefaults;
        var isRTL, dirDefaults;
        var rawOptions;
        locale = util_1.firstDefined(// explicit locale option given?
        this.dynamicOverrides.locale, this.overrides.locale);
        localeDefaults = locale_1.localeOptionHash[locale];
        if (!localeDefaults) {
            locale = options_1.globalDefaults.locale;
            localeDefaults = locale_1.localeOptionHash[locale] || {};
        }
        isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?
        this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);
        dirDefaults = isRTL ? options_1.rtlDefaults : {};
        this.dirDefaults = dirDefaults;
        this.localeDefaults = localeDefaults;
        rawOptions = options_1.mergeOptions([
            options_1.globalDefaults,
            dirDefaults,
            localeDefaults,
            this.overrides,
            this.dynamicOverrides
        ]);
        locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options
        this.reset(rawOptions);
    };
    // stores the new options internally, but does not rerender anything.
    OptionsManager.prototype.recordOverrides = function (newOptionHash) {
        var optionName;
        for (optionName in newOptionHash) {
            this.dynamicOverrides[optionName] = newOptionHash[optionName];
        }
        this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it
        this.compute(); // this.options needs to be recomputed after the dynamic override
    };
    return OptionsManager;
}(Model_1.default));
exports.default = OptionsManager;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(3);
var $ = __webpack_require__(1);
var namespace_hooks_1 = __webpack_require__(7);
var util_1 = __webpack_require__(2);
var options_1 = __webpack_require__(19);
var locale_1 = __webpack_require__(20);
var ViewSpecManager = /** @class */ (function () {
    function ViewSpecManager(optionsManager, _calendar) {
        this.optionsManager = optionsManager;
        this._calendar = _calendar;
        this.clearCache();
    }
    ViewSpecManager.prototype.clearCache = function () {
        this.viewSpecCache = {};
    };
    // Gets information about how to create a view. Will use a cache.
    ViewSpecManager.prototype.getViewSpec = function (viewType) {
        var cache = this.viewSpecCache;
        return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
    };
    // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.
    ViewSpecManager.prototype.getUnitViewSpec = function (unit) {
        var viewTypes;
        var i;
        var spec;
        if ($.inArray(unit, util_1.unitsDesc) != -1) {
            // put views that have buttons first. there will be duplicates, but oh well
            viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?
            $.each(namespace_hooks_1.default.views, function (viewType) {
                viewTypes.push(viewType);
            });
            for (i = 0; i < viewTypes.length; i++) {
                spec = this.getViewSpec(viewTypes[i]);
                if (spec) {
                    if (spec.singleUnit == unit) {
                        return spec;
                    }
                }
            }
        }
    };
    // Builds an object with information on how to create a given view
    ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {
        var viewOverrides = this.optionsManager.overrides.views || {};
        var specChain = []; // for the view. lowest to highest priority
        var defaultsChain = []; // for the view. lowest to highest priority
        var overridesChain = []; // for the view. lowest to highest priority
        var viewType = requestedViewType;
        var spec; // for the view
        var overrides; // for the view
        var durationInput;
        var duration;
        var unit;
        // iterate from the specific view definition to a more general one until we hit an actual View class
        while (viewType) {
            spec = namespace_hooks_1.default.views[viewType];
            overrides = viewOverrides[viewType];
            viewType = null; // clear. might repopulate for another iteration
            if (typeof spec === 'function') {
                spec = { 'class': spec };
            }
            if (spec) {
                specChain.unshift(spec);
                defaultsChain.unshift(spec.defaults || {});
                durationInput = durationInput || spec.duration;
                viewType = viewType || spec.type;
            }
            if (overrides) {
                overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
                durationInput = durationInput || overrides.duration;
                viewType = viewType || overrides.type;
            }
        }
        spec = util_1.mergeProps(specChain);
        spec.type = requestedViewType;
        if (!spec['class']) {
            return false;
        }
        // fall back to top-level `duration` option
        durationInput = durationInput ||
            this.optionsManager.dynamicOverrides.duration ||
            this.optionsManager.overrides.duration;
        if (durationInput) {
            duration = moment.duration(durationInput);
            if (duration.valueOf()) {
                unit = util_1.computeDurationGreatestUnit(duration, durationInput);
                spec.duration = duration;
                spec.durationUnit = unit;
                // view is a single-unit duration, like "week" or "day"
                // incorporate options for this. lowest priority
                if (duration.as(unit) === 1) {
                    spec.singleUnit = unit;
                    overridesChain.unshift(viewOverrides[unit] || {});
                }
            }
        }
        spec.defaults = options_1.mergeOptions(defaultsChain);
        spec.overrides = options_1.mergeOptions(overridesChain);
        this.buildViewSpecOptions(spec);
        this.buildViewSpecButtonText(spec, requestedViewType);
        return spec;
    };
    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides
    ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {
        var optionsManager = this.optionsManager;
        spec.options = options_1.mergeOptions([
            options_1.globalDefaults,
            spec.defaults,
            optionsManager.dirDefaults,
            optionsManager.localeDefaults,
            optionsManager.overrides,
            spec.overrides,
            optionsManager.dynamicOverrides // dynamically set via setter. highest precedence
        ]);
        locale_1.populateInstanceComputableOptions(spec.options);
    };
    // Computes and assigns a view spec's buttonText-related options
    ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {
        var optionsManager = this.optionsManager;
        // given an options object with a possible `buttonText` hash, lookup the buttonText for the
        // requested view, falling back to a generic unit entry like "week" or "day"
        function queryButtonText(options) {
            var buttonText = options.buttonText || {};
            return buttonText[requestedViewType] ||
                // view can decide to look up a certain key
                (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
                // a key like "month"
                (spec.singleUnit ? buttonText[spec.singleUnit] : null);
        }
        // highest to lowest priority
        spec.buttonTextOverride =
            queryButtonText(optionsManager.dynamicOverrides) ||
                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
                spec.overrides.buttonText; // `buttonText` for view-specific options is a string
        // highest to lowest priority. mirrors buildViewSpecOptions
        spec.buttonTextDefault =
            queryButtonText(optionsManager.localeDefaults) ||
                queryButtonText(optionsManager.dirDefaults) ||
                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
                queryButtonText(options_1.globalDefaults) ||
                (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like "3 days"
                requestedViewType; // fall back to given view name
    };
    return ViewSpecManager;
}());
exports.default = ViewSpecManager;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventPeriod_1 = __webpack_require__(79);
var ArrayEventSource_1 = __webpack_require__(34);
var EventSource_1 = __webpack_require__(5);
var EventSourceParser_1 = __webpack_require__(25);
var SingleEventDef_1 = __webpack_require__(11);
var EventInstanceGroup_1 = __webpack_require__(17);
var EmitterMixin_1 = __webpack_require__(8);
var ListenerMixin_1 = __webpack_require__(6);
var EventManager = /** @class */ (function () {
    function EventManager(calendar) {
        this.calendar = calendar;
        this.stickySource = new ArrayEventSource_1.default(calendar);
        this.otherSources = [];
    }
    EventManager.prototype.requestEvents = function (start, end, timezone, force) {
        if (force ||
            !this.currentPeriod ||
            !this.currentPeriod.isWithinRange(start, end) ||
            timezone !== this.currentPeriod.timezone) {
            this.setPeriod(// will change this.currentPeriod
            new EventPeriod_1.default(start, end, timezone));
        }
        return this.currentPeriod.whenReleased();
    };
    // Source Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.addSource = function (eventSource) {
        this.otherSources.push(eventSource);
        if (this.currentPeriod) {
            this.currentPeriod.requestSource(eventSource); // might release
        }
    };
    EventManager.prototype.removeSource = function (doomedSource) {
        util_1.removeExact(this.otherSources, doomedSource);
        if (this.currentPeriod) {
            this.currentPeriod.purgeSource(doomedSource); // might release
        }
    };
    EventManager.prototype.removeAllSources = function () {
        this.otherSources = [];
        if (this.currentPeriod) {
            this.currentPeriod.purgeAllSources(); // might release
        }
    };
    // Source Refetching
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.refetchSource = function (eventSource) {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeSource(eventSource);
            currentPeriod.requestSource(eventSource);
            currentPeriod.thaw();
        }
    };
    EventManager.prototype.refetchAllSources = function () {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeAllSources();
            currentPeriod.requestSources(this.getSources());
            currentPeriod.thaw();
        }
    };
    // Source Querying
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getSources = function () {
        return [this.stickySource].concat(this.otherSources);
    };
    // like querySources, but accepts multple match criteria (like multiple IDs)
    EventManager.prototype.multiQuerySources = function (matchInputs) {
        // coerce into an array
        if (!matchInputs) {
            matchInputs = [];
        }
        else if (!$.isArray(matchInputs)) {
            matchInputs = [matchInputs];
        }
        var matchingSources = [];
        var i;
        // resolve raw inputs to real event source objects
        for (i = 0; i < matchInputs.length; i++) {
            matchingSources.push.apply(// append
            matchingSources, this.querySources(matchInputs[i]));
        }
        return matchingSources;
    };
    // matchInput can either by a real event source object, an ID, or the function/URL for the source.
    // returns an array of matching source objects.
    EventManager.prototype.querySources = function (matchInput) {
        var sources = this.otherSources;
        var i, source;
        // given a proper event source object
        for (i = 0; i < sources.length; i++) {
            source = sources[i];
            if (source === matchInput) {
                return [source];
            }
        }
        // an ID match
        source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));
        if (source) {
            return [source];
        }
        // parse as an event source
        matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);
        if (matchInput) {
            return $.grep(sources, function (source) {
                return isSourcesEquivalent(matchInput, source);
            });
        }
    };
    /*
    ID assumed to already be normalized
    */
    EventManager.prototype.getSourceById = function (id) {
        return $.grep(this.otherSources, function (source) {
            return source.id && source.id === id;
        })[0];
    };
    // Event-Period
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.setPeriod = function (eventPeriod) {
        if (this.currentPeriod) {
            this.unbindPeriod(this.currentPeriod);
            this.currentPeriod = null;
        }
        this.currentPeriod = eventPeriod;
        this.bindPeriod(eventPeriod);
        eventPeriod.requestSources(this.getSources());
    };
    EventManager.prototype.bindPeriod = function (eventPeriod) {
        this.listenTo(eventPeriod, 'release', function (eventsPayload) {
            this.trigger('release', eventsPayload);
        });
    };
    EventManager.prototype.unbindPeriod = function (eventPeriod) {
        this.stopListeningTo(eventPeriod);
    };
    // Event Getting/Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getEventDefByUid = function (uid) {
        if (this.currentPeriod) {
            return this.currentPeriod.getEventDefByUid(uid);
        }
    };
    EventManager.prototype.addEventDef = function (eventDef, isSticky) {
        if (isSticky) {
            this.stickySource.addEventDef(eventDef);
        }
        if (this.currentPeriod) {
            this.currentPeriod.addEventDef(eventDef); // might release
        }
    };
    EventManager.prototype.removeEventDefsById = function (eventId) {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeEventDefsById(eventId);
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeEventDefsById(eventId); // might release
        }
    };
    EventManager.prototype.removeAllEventDefs = function () {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeAllEventDefs();
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeAllEventDefs();
        }
    };
    // Event Mutating
    // -----------------------------------------------------------------------------------------------------------------
    /*
    Returns an undo function.
    */
    EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {
        var currentPeriod = this.currentPeriod;
        var eventDefs;
        var undoFuncs = [];
        if (currentPeriod) {
            currentPeriod.freeze();
            eventDefs = currentPeriod.getEventDefsById(eventDefId);
            eventDefs.forEach(function (eventDef) {
                // add/remove esp because id might change
                currentPeriod.removeEventDef(eventDef);
                undoFuncs.push(eventDefMutation.mutateSingle(eventDef));
                currentPeriod.addEventDef(eventDef);
            });
            currentPeriod.thaw();
            return function () {
                currentPeriod.freeze();
                for (var i = 0; i < eventDefs.length; i++) {
                    currentPeriod.removeEventDef(eventDefs[i]);
                    undoFuncs[i]();
                    currentPeriod.addEventDef(eventDefs[i]);
                }
                currentPeriod.thaw();
            };
        }
        return function () { };
    };
    /*
    copies and then mutates
    */
    EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {
        var eventDefs = this.getEventDefsById(eventDefId);
        var i;
        var defCopy;
        var allInstances = [];
        for (i = 0; i < eventDefs.length; i++) {
            defCopy = eventDefs[i].clone();
            if (defCopy instanceof SingleEventDef_1.default) {
                eventDefMutation.mutateSingle(defCopy);
                allInstances.push.apply(allInstances, // append
                defCopy.buildInstances());
            }
        }
        return new EventInstanceGroup_1.default(allInstances);
    };
    // Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.freeze = function () {
        if (this.currentPeriod) {
            this.currentPeriod.freeze();
        }
    };
    EventManager.prototype.thaw = function () {
        if (this.currentPeriod) {
            this.currentPeriod.thaw();
        }
    };
    // methods that simply forward to EventPeriod
    EventManager.prototype.getEventDefsById = function (eventDefId) {
        return this.currentPeriod.getEventDefsById(eventDefId);
    };
    EventManager.prototype.getEventInstances = function () {
        return this.currentPeriod.getEventInstances();
    };
    EventManager.prototype.getEventInstancesWithId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithId(eventDefId);
    };
    EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithoutId(eventDefId);
    };
    return EventManager;
}());
exports.default = EventManager;
EmitterMixin_1.default.mixInto(EventManager);
ListenerMixin_1.default.mixInto(EventManager);
function isSourcesEquivalent(source0, source1) {
    return source0.getPrimitive() == source1.getPrimitive();
}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var Promise_1 = __webpack_require__(16);
var EmitterMixin_1 = __webpack_require__(8);
var UnzonedRange_1 = __webpack_require__(4);
var EventInstanceGroup_1 = __webpack_require__(17);
var EventPeriod = /** @class */ (function () {
    function EventPeriod(start, end, timezone) {
        this.pendingCnt = 0;
        this.freezeDepth = 0;
        this.stuntedReleaseCnt = 0;
        this.releaseCnt = 0;
        this.start = start;
        this.end = end;
        this.timezone = timezone;
        this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());
        this.requestsByUid = {};
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
    }
    EventPeriod.prototype.isWithinRange = function (start, end) {
        // TODO: use a range util function?
        return !start.isBefore(this.start) && !end.isAfter(this.end);
    };
    // Requesting and Purging
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.requestSources = function (sources) {
        this.freeze();
        for (var i = 0; i < sources.length; i++) {
            this.requestSource(sources[i]);
        }
        this.thaw();
    };
    EventPeriod.prototype.requestSource = function (source) {
        var _this = this;
        var request = { source: source, status: 'pending', eventDefs: null };
        this.requestsByUid[source.uid] = request;
        this.pendingCnt += 1;
        source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {
            if (request.status !== 'cancelled') {
                request.status = 'completed';
                request.eventDefs = eventDefs;
                _this.addEventDefs(eventDefs);
                _this.pendingCnt--;
                _this.tryRelease();
            }
        }, function () {
            if (request.status !== 'cancelled') {
                request.status = 'failed';
                _this.pendingCnt--;
                _this.tryRelease();
            }
        });
    };
    EventPeriod.prototype.purgeSource = function (source) {
        var request = this.requestsByUid[source.uid];
        if (request) {
            delete this.requestsByUid[source.uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
                this.pendingCnt--;
                this.tryRelease();
            }
            else if (request.status === 'completed') {
                request.eventDefs.forEach(this.removeEventDef.bind(this));
            }
        }
    };
    EventPeriod.prototype.purgeAllSources = function () {
        var requestsByUid = this.requestsByUid;
        var uid, request;
        var completedCnt = 0;
        for (uid in requestsByUid) {
            request = requestsByUid[uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
            }
            else if (request.status === 'completed') {
                completedCnt++;
            }
        }
        this.requestsByUid = {};
        this.pendingCnt = 0;
        if (completedCnt) {
            this.removeAllEventDefs(); // might release
        }
    };
    // Event Definitions
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {
        return this.eventDefsByUid[eventDefUid];
    };
    EventPeriod.prototype.getEventDefsById = function (eventDefId) {
        var a = this.eventDefsById[eventDefId];
        if (a) {
            return a.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.addEventDefs = function (eventDefs) {
        for (var i = 0; i < eventDefs.length; i++) {
            this.addEventDef(eventDefs[i]);
        }
    };
    EventPeriod.prototype.addEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefId = eventDef.id;
        var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);
        var eventInstances = eventDef.buildInstances(this.unzonedRange);
        var i;
        eventDefs.push(eventDef);
        this.eventDefsByUid[eventDef.uid] = eventDef;
        for (i = 0; i < eventInstances.length; i++) {
            this.addEventInstance(eventInstances[i], eventDefId);
        }
    };
    EventPeriod.prototype.removeEventDefsById = function (eventDefId) {
        var _this = this;
        this.getEventDefsById(eventDefId).forEach(function (eventDef) {
            _this.removeEventDef(eventDef);
        });
    };
    EventPeriod.prototype.removeAllEventDefs = function () {
        var isEmpty = $.isEmptyObject(this.eventDefsByUid);
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
        if (!isEmpty) {
            this.tryRelease();
        }
    };
    EventPeriod.prototype.removeEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefs = eventDefsById[eventDef.id];
        delete this.eventDefsByUid[eventDef.uid];
        if (eventDefs) {
            util_1.removeExact(eventDefs, eventDef);
            if (!eventDefs.length) {
                delete eventDefsById[eventDef.id];
            }
            this.removeEventInstancesForDef(eventDef);
        }
    };
    // Event Instances
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventInstances = function () {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            eventInstances.push.apply(eventInstances, // append
            eventInstanceGroupsById[id].eventInstances);
        }
        return eventInstances;
    };
    EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {
        var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];
        if (eventInstanceGroup) {
            return eventInstanceGroup.eventInstances.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var matchingInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            if (id !== eventDefId) {
                matchingInstances.push.apply(matchingInstances, // append
                eventInstanceGroupsById[id].eventInstances);
            }
        }
        return matchingInstances;
    };
    EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||
            (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());
        eventInstanceGroup.eventInstances.push(eventInstance);
        this.tryRelease();
    };
    EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];
        var removeCnt;
        if (eventInstanceGroup) {
            removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {
                return currentEventInstance.def === eventDef;
            });
            if (!eventInstanceGroup.eventInstances.length) {
                delete eventInstanceGroupsById[eventDef.id];
            }
            if (removeCnt) {
                this.tryRelease();
            }
        }
    };
    // Releasing and Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.tryRelease = function () {
        if (!this.pendingCnt) {
            if (!this.freezeDepth) {
                this.release();
            }
            else {
                this.stuntedReleaseCnt++;
            }
        }
    };
    EventPeriod.prototype.release = function () {
        this.releaseCnt++;
        this.trigger('release', this.eventInstanceGroupsById);
    };
    EventPeriod.prototype.whenReleased = function () {
        var _this = this;
        if (this.releaseCnt) {
            return Promise_1.default.resolve(this.eventInstanceGroupsById);
        }
        else {
            return Promise_1.default.construct(function (onResolve) {
                _this.one('release', onResolve);
            });
        }
    };
    EventPeriod.prototype.freeze = function () {
        if (!(this.freezeDepth++)) {
            this.stuntedReleaseCnt = 0;
        }
    };
    EventPeriod.prototype.thaw = function () {
        if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {
            this.release();
        }
    };
    return EventPeriod;
}());
exports.default = EventPeriod;
EmitterMixin_1.default.mixInto(EventPeriod);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Model_1 = __webpack_require__(32);
var Component = /** @class */ (function (_super) {
    tslib_1.__extends(Component, _super);
    function Component() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Component.prototype.setElement = function (el) {
        this.el = el;
        this.bindGlobalHandlers();
        this.renderSkeleton();
        this.set('isInDom', true);
    };
    Component.prototype.removeElement = function () {
        this.unset('isInDom');
        this.unrenderSkeleton();
        this.unbindGlobalHandlers();
        this.el.remove();
        // NOTE: don't null-out this.el in case the View was destroyed within an API callback.
        // We don't null-out the View's other jQuery element references upon destroy,
        //  so we shouldn't kill this.el either.
    };
    Component.prototype.bindGlobalHandlers = function () {
    };
    Component.prototype.unbindGlobalHandlers = function () {
    };
    /*
    NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender
    */
    // Renders the basic structure of the view before any content is rendered
    Component.prototype.renderSkeleton = function () {
        // subclasses should implement
    };
    // Unrenders the basic structure of the view
    Component.prototype.unrenderSkeleton = function () {
        // subclasses should implement
    };
    return Component;
}(Model_1.default));
exports.default = Component;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var ListenerMixin_1 = __webpack_require__(6);
/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/
var MouseFollower = /** @class */ (function () {
    function MouseFollower(sourceEl, options) {
        this.isFollowing = false;
        this.isHidden = false;
        this.isAnimating = false; // doing the revert animation?
        this.options = options = options || {};
        this.sourceEl = sourceEl;
        this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
    }
    // Causes the element to start following the mouse
    MouseFollower.prototype.start = function (ev) {
        if (!this.isFollowing) {
            this.isFollowing = true;
            this.y0 = util_1.getEvY(ev);
            this.x0 = util_1.getEvX(ev);
            this.topDelta = 0;
            this.leftDelta = 0;
            if (!this.isHidden) {
                this.updatePosition();
            }
            if (util_1.getEvIsTouch(ev)) {
                this.listenTo($(document), 'touchmove', this.handleMove);
            }
            else {
                this.listenTo($(document), 'mousemove', this.handleMove);
            }
        }
    };
    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
    MouseFollower.prototype.stop = function (shouldRevert, callback) {
        var _this = this;
        var revertDuration = this.options.revertDuration;
        var complete = function () {
            _this.isAnimating = false;
            _this.removeElement();
            _this.top0 = _this.left0 = null; // reset state for future updatePosition calls
            if (callback) {
                callback();
            }
        };
        if (this.isFollowing && !this.isAnimating) {
            this.isFollowing = false;
            this.stopListeningTo($(document));
            if (shouldRevert && revertDuration && !this.isHidden) {
                this.isAnimating = true;
                this.el.animate({
                    top: this.top0,
                    left: this.left0
                }, {
                    duration: revertDuration,
                    complete: complete
                });
            }
            else {
                complete();
            }
        }
    };
    // Gets the tracking element. Create it if necessary
    MouseFollower.prototype.getEl = function () {
        var el = this.el;
        if (!el) {
            el = this.el = this.sourceEl.clone()
                .addClass(this.options.additionalClass || '')
                .css({
                position: 'absolute',
                visibility: '',
                display: this.isHidden ? 'none' : '',
                margin: 0,
                right: 'auto',
                bottom: 'auto',
                width: this.sourceEl.width(),
                height: this.sourceEl.height(),
                opacity: this.options.opacity || '',
                zIndex: this.options.zIndex
            });
            // we don't want long taps or any mouse interaction causing selection/menus.
            // would use preventSelection(), but that prevents selectstart, causing problems.
            el.addClass('fc-unselectable');
            el.appendTo(this.parentEl);
        }
        return el;
    };
    // Removes the tracking element if it has already been created
    MouseFollower.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    // Update the CSS position of the tracking element
    MouseFollower.prototype.updatePosition = function () {
        var sourceOffset;
        var origin;
        this.getEl(); // ensure this.el
        // make sure origin info was computed
        if (this.top0 == null) {
            sourceOffset = this.sourceEl.offset();
            origin = this.el.offsetParent().offset();
            this.top0 = sourceOffset.top - origin.top;
            this.left0 = sourceOffset.left - origin.left;
        }
        this.el.css({
            top: this.top0 + this.topDelta,
            left: this.left0 + this.leftDelta
        });
    };
    // Gets called when the user moves the mouse
    MouseFollower.prototype.handleMove = function (ev) {
        this.topDelta = util_1.getEvY(ev) - this.y0;
        this.leftDelta = util_1.getEvX(ev) - this.x0;
        if (!this.isHidden) {
            this.updatePosition();
        }
    };
    // Temporarily makes the tracking element invisible. Can be called before following starts
    MouseFollower.prototype.hide = function () {
        if (!this.isHidden) {
            this.isHidden = true;
            if (this.el) {
                this.el.hide();
            }
        }
    };
    // Show the tracking element after it has been temporarily hidden
    MouseFollower.prototype.show = function () {
        if (this.isHidden) {
            this.isHidden = false;
            this.updatePosition();
            this.getEl().show();
        }
    };
    return MouseFollower;
}());
exports.default = MouseFollower;
ListenerMixin_1.default.mixInto(MouseFollower);


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var HitDragListener_1 = __webpack_require__(18);
var Interaction_1 = __webpack_require__(13);
var DateClicking = /** @class */ (function (_super) {
    tslib_1.__extends(DateClicking, _super);
    /*
    component must implement:
        - bindDateHandlerToEl
        - getSafeHitFootprint
        - getHitEl
    */
    function DateClicking(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateClicking.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateClicking.prototype.bindToEl = function (el) {
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (!component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev);
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (!component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev);
            }
        });
    };
    // Creates a listener that tracks the user's drag across day elements, for day clicking.
    DateClicking.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var dayClickHit; // null if invalid dayClick
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                dayClickHit = dragListener.origHit;
            },
            hitOver: function (hit, isOrig, origHit) {
                // if user dragged to another cell at any point, it can no longer be a dayClick
                if (!isOrig) {
                    dayClickHit = null;
                }
            },
            hitOut: function () {
                dayClickHit = null;
            },
            interactionEnd: function (ev, isCancelled) {
                var componentFootprint;
                if (!isCancelled && dayClickHit) {
                    componentFootprint = component.getSafeHitFootprint(dayClickHit);
                    if (componentFootprint) {
                        _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);
                    }
                }
            }
        });
        // because dragListener won't be called with any time delay, "dragging" will begin immediately,
        // which will kill any touchmoving/scrolling. Prevent this.
        dragListener.shouldCancelTouchScroll = false;
        dragListener.scrollAlwaysKills = true;
        return dragListener;
    };
    return DateClicking;
}(Interaction_1.default));
exports.default = DateClicking;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var EventRenderer_1 = __webpack_require__(31);
/*
Only handles foreground segs.
Does not own rendering. Use for low-level util methods by TimeGrid.
*/
var TimeGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridEventRenderer, _super);
    function TimeGridEventRenderer(timeGrid, fillRenderer) {
        var _this = _super.call(this, timeGrid, fillRenderer) || this;
        _this.timeGrid = timeGrid;
        return _this;
    }
    TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {
        this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);
    };
    // Given an array of foreground segments, render a DOM element for each, computes position,
    // and attaches to the column inner-container elements.
    TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {
        var segsByCol;
        var col;
        segsByCol = this.timeGrid.groupSegsByCol(segs);
        for (col = 0; col < this.timeGrid.colCnt; col++) {
            this.updateFgSegCoords(segsByCol[col]);
        }
        this.timeGrid.attachSegsByCol(segsByCol, containerEls);
    };
    TimeGridEventRenderer.prototype.unrenderFgSegs = function () {
        if (this.fgSegs) {
            this.fgSegs.forEach(function (seg) {
                seg.el.remove();
            });
        }
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    // Renders the HTML for a single event segment's default rendering
    TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var calendar = view.calendar;
        var componentFootprint = seg.footprint.componentFootprint;
        var isAllDay = componentFootprint.isAllDay;
        var eventDef = seg.footprint.eventDef;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeText;
        var fullTimeText; // more verbose time text. for the print stylesheet
        var startTimeText; // just the start time text
        classes.unshift('fc-time-grid-event', 'fc-v-event');
        // if the event appears to span more than one day...
        if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            // Don't display time text on segments that run entirely through a day.
            // That would appear as midnight-midnight and would look dumb.
            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
            if (seg.isStart || seg.isEnd) {
                var zonedStart = calendar.msToMoment(seg.startMs);
                var zonedEnd = calendar.msToMoment(seg.endMs);
                timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);
                fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');
                startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeText = this.getTimeText(seg.footprint);
            fullTimeText = this.getTimeText(seg.footprint, 'LT');
            startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false
        }
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (timeText ?
                '<div class="fc-time"' +
                    ' data-start="' + util_1.htmlEscape(startTimeText) + '"' +
                    ' data-full="' + util_1.htmlEscape(fullTimeText) + '"' +
                    '>' +
                    '<span>' + util_1.htmlEscape(timeText) + '</span>' +
                    '</div>' :
                '') +
            (eventDef.title ?
                '<div class="fc-title">' +
                    util_1.htmlEscape(eventDef.title) +
                    '</div>' :
                '') +
            '</div>' +
            '<div class="fc-bg"/>' +
            /* TODO: write CSS for this
            (isResizableFromStart ?
                '<div class="fc-resizer fc-start-resizer" />' :
                ''
                ) +
            */
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                '') +
            '</a>';
    };
    // Given segments that are assumed to all live in the *same column*,
    // compute their verical/horizontal coordinates and assign to their elements.
    TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {
        this.timeGrid.computeSegVerticals(segs); // horizontals relies on this
        this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
        this.timeGrid.assignSegVerticals(segs);
        this.assignFgSegHorizontals(segs);
    };
    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
    // NOTE: Also reorders the given array by date!
    TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {
        var levels;
        var level0;
        var i;
        this.sortEventSegs(segs); // order by certain criteria
        levels = buildSlotSegLevels(segs);
        computeForwardSlotSegs(levels);
        if ((level0 = levels[0])) {
            for (i = 0; i < level0.length; i++) {
                computeSlotSegPressures(level0[i]);
            }
            for (i = 0; i < level0.length; i++) {
                this.computeFgSegForwardBack(level0[i], 0, 0);
            }
        }
    };
    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
    // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
    //
    // The segment might be part of a "series", which means consecutive segments with the same pressure
    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
    // coordinate of the first segment in the series.
    TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
        var forwardSegs = seg.forwardSegs;
        var i;
        if (seg.forwardCoord === undefined) {
            if (!forwardSegs.length) {
                // if there are no forward segments, this segment should butt up against the edge
                seg.forwardCoord = 1;
            }
            else {
                // sort highest pressure first
                this.sortForwardSegs(forwardSegs);
                // this segment's forwardCoord will be calculated from the backwardCoord of the
                // highest-pressure forward segment.
                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                seg.forwardCoord = forwardSegs[0].backwardCoord;
            }
            // calculate the backwardCoord from the forwardCoord. consider the series
            seg.backwardCoord = seg.forwardCoord -
                (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                    (seriesBackwardPressure + 1); // # of segments in the series
            // use this segment's coordinates to computed the coordinates of the less-pressurized
            // forward segments
            for (i = 0; i < forwardSegs.length; i++) {
                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
            }
        }
    };
    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
        forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));
    };
    // A cmp function for determining which forward segment to rely on more when computing coordinates.
    TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {
        // put higher-pressure first
        return seg2.forwardPressure - seg1.forwardPressure ||
            // put segments that are closer to initial edge first (and favor ones with no coords yet)
            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
            // do normal sorting...
            this.compareEventSegs(seg1, seg2);
    };
    // Given foreground event segments that have already had their position coordinates computed,
    // assigns position-related CSS values to their elements.
    TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {
        var i, seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateFgSegHorizontalCss(seg));
            // if the height is short, add a className for alternate styling
            if (seg.bottom - seg.top < 30) {
                seg.el.addClass('fc-short');
            }
        }
    };
    // Generates an object with CSS properties/values that should be applied to an event segment element.
    // Contains important positioning-related properties that should be applied to any event element, customized or not.
    TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {
        var shouldOverlap = this.opt('slotEventOverlap');
        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first
        var isRTL = this.timeGrid.isRTL;
        var left; // amount of space from left edge, a fraction of the total width
        var right; // amount of space from right edge, a fraction of the total width
        if (shouldOverlap) {
            // double the width, but don't go beyond the maximum forward coordinate (1.0)
            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
        }
        if (isRTL) {
            left = 1 - forwardCoord;
            right = backwardCoord;
        }
        else {
            left = backwardCoord;
            right = 1 - forwardCoord;
        }
        props.zIndex = seg.level + 1; // convert from 0-base to 1-based
        props.left = left * 100 + '%';
        props.right = right * 100 + '%';
        if (shouldOverlap && seg.forwardPressure) {
            // add padding to the edge so that forward stacked events don't cover the resizer's icon
            props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
        }
        return props;
    };
    return TimeGridEventRenderer;
}(EventRenderer_1.default));
exports.default = TimeGridEventRenderer;
// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
    var levels = [];
    var i, seg;
    var j;
    for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        // go through all the levels and stop on the first level where there are no collisions
        for (j = 0; j < levels.length; j++) {
            if (!computeSlotSegCollisions(seg, levels[j]).length) {
                break;
            }
        }
        seg.level = j;
        (levels[j] || (levels[j] = [])).push(seg);
    }
    return levels;
}
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
    var i, level;
    var j, seg;
    var k;
    for (i = 0; i < levels.length; i++) {
        level = levels[i];
        for (j = 0; j < level.length; j++) {
            seg = level[j];
            seg.forwardSegs = [];
            for (k = i + 1; k < levels.length; k++) {
                computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
            }
        }
    }
}
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
    var forwardSegs = seg.forwardSegs;
    var forwardPressure = 0;
    var i, forwardSeg;
    if (seg.forwardPressure === undefined) {
        for (i = 0; i < forwardSegs.length; i++) {
            forwardSeg = forwardSegs[i];
            // figure out the child's maximum forward path
            computeSlotSegPressures(forwardSeg);
            // either use the existing maximum, or use the child's forward pressure
            // plus one (for the forwardSeg itself)
            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
        }
        seg.forwardPressure = forwardPressure;
    }
}
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
    if (results === void 0) { results = []; }
    for (var i = 0; i < otherSegs.length; i++) {
        if (isSlotSegCollision(seg, otherSegs[i])) {
            results.push(otherSegs[i]);
        }
    }
    return results;
}
// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var HelperRenderer_1 = __webpack_require__(43);
var TimeGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridHelperRenderer, _super);
    function TimeGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var i, seg;
        var sourceEl;
        // TODO: not good to call eventRenderer this way
        this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);
        // Try to make the segment that is in the same row as sourceSeg look the same
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (sourceSeg && sourceSeg.col === seg.col) {
                sourceEl = sourceSeg.el;
                seg.el.css({
                    left: sourceEl.css('left'),
                    right: sourceEl.css('right'),
                    'margin-left': sourceEl.css('margin-left'),
                    'margin-right': sourceEl.css('margin-right')
                });
            }
            helperNodes.push(seg.el[0]);
        }
        return $(helperNodes); // must return the elements rendered
    };
    return TimeGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = TimeGridHelperRenderer;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var FillRenderer_1 = __webpack_require__(42);
var TimeGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridFillRenderer, _super);
    function TimeGridFillRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var timeGrid = this.component;
        var containerEls;
        // TODO: more efficient lookup
        if (type === 'bgEvent') {
            containerEls = timeGrid.bgContainerEls;
        }
        else if (type === 'businessHours') {
            containerEls = timeGrid.businessContainerEls;
        }
        else if (type === 'highlight') {
            containerEls = timeGrid.highlightContainerEls;
        }
        timeGrid.updateSegVerticals(segs);
        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
        return segs.map(function (seg) {
            return seg.el[0];
        });
    };
    return TimeGridFillRenderer;
}(FillRenderer_1.default));
exports.default = TimeGridFillRenderer;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
    - className (string)
    - content (HTML string or jQuery element set)
    - parentEl
    - top
    - left
    - right (the x coord of where the right edge should be. not a "CSS" right)
    - autoHide (boolean)
    - show (callback)
    - hide (callback)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var ListenerMixin_1 = __webpack_require__(6);
var Popover = /** @class */ (function () {
    function Popover(options) {
        this.isHidden = true;
        this.margin = 10; // the space required between the popover and the edges of the scroll container
        this.options = options || {};
    }
    // Shows the popover on the specified position. Renders it if not already
    Popover.prototype.show = function () {
        if (this.isHidden) {
            if (!this.el) {
                this.render();
            }
            this.el.show();
            this.position();
            this.isHidden = false;
            this.trigger('show');
        }
    };
    // Hides the popover, through CSS, but does not remove it from the DOM
    Popover.prototype.hide = function () {
        if (!this.isHidden) {
            this.el.hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    };
    // Creates `this.el` and renders content inside of it
    Popover.prototype.render = function () {
        var _this = this;
        var options = this.options;
        this.el = $('<div class="fc-popover"/>')
            .addClass(options.className || '')
            .css({
            // position initially to the top left to avoid creating scrollbars
            top: 0,
            left: 0
        })
            .append(options.content)
            .appendTo(options.parentEl);
        // when a click happens on anything inside with a 'fc-close' className, hide the popover
        this.el.on('click', '.fc-close', function () {
            _this.hide();
        });
        if (options.autoHide) {
            this.listenTo($(document), 'mousedown', this.documentMousedown);
        }
    };
    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
    Popover.prototype.documentMousedown = function (ev) {
        // only hide the popover if the click happened outside the popover
        if (this.el && !$(ev.target).closest(this.el).length) {
            this.hide();
        }
    };
    // Hides and unregisters any handlers
    Popover.prototype.removeElement = function () {
        this.hide();
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
        this.stopListeningTo($(document), 'mousedown');
    };
    // Positions the popover optimally, using the top/left/right options
    Popover.prototype.position = function () {
        var options = this.options;
        var origin = this.el.offsetParent().offset();
        var width = this.el.outerWidth();
        var height = this.el.outerHeight();
        var windowEl = $(window);
        var viewportEl = util_1.getScrollParent(this.el);
        var viewportTop;
        var viewportLeft;
        var viewportOffset;
        var top; // the "position" (not "offset") values for the popover
        var left; //
        // compute top and left
        top = options.top || 0;
        if (options.left !== undefined) {
            left = options.left;
        }
        else if (options.right !== undefined) {
            left = options.right - width; // derive the left value from the right value
        }
        else {
            left = 0;
        }
        if (viewportEl.is(window) || viewportEl.is(document)) {
            viewportEl = windowEl;
            viewportTop = 0; // the window is always at the top left
            viewportLeft = 0; // (and .offset() won't work if called here)
        }
        else {
            viewportOffset = viewportEl.offset();
            viewportTop = viewportOffset.top;
            viewportLeft = viewportOffset.left;
        }
        // if the window is scrolled, it causes the visible area to be further down
        viewportTop += windowEl.scrollTop();
        viewportLeft += windowEl.scrollLeft();
        // constrain to the view port. if constrained by two edges, give precedence to top/left
        if (options.viewportConstrain !== false) {
            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
            top = Math.max(top, viewportTop + this.margin);
            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
            left = Math.max(left, viewportLeft + this.margin);
        }
        this.el.css({
            top: top - origin.top,
            left: left - origin.left
        });
    };
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    // TODO: better code reuse for this. Repeat code
    Popover.prototype.trigger = function (name) {
        if (this.options[name]) {
            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
        }
    };
    return Popover;
}());
exports.default = Popover;
ListenerMixin_1.default.mixInto(Popover);


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var util_1 = __webpack_require__(2);
var EventRenderer_1 = __webpack_require__(31);
/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/
var DayGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridEventRenderer, _super);
    function DayGridEventRenderer(dayGrid, fillRenderer) {
        var _this = _super.call(this, dayGrid, fillRenderer) || this;
        _this.dayGrid = dayGrid;
        return _this;
    }
    DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {
        // don't render timed background events
        eventRanges = $.grep(eventRanges, function (eventRange) {
            return eventRange.eventDef.isAllDay();
        });
        _super.prototype.renderBgRanges.call(this, eventRanges);
    };
    // Renders the given foreground event segments onto the grid
    DayGridEventRenderer.prototype.renderFgSegs = function (segs) {
        var rowStructs = this.rowStructs = this.renderSegRows(segs);
        // append to each row's content skeleton
        this.dayGrid.rowEls.each(function (i, rowNode) {
            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);
        });
    };
    // Unrenders all currently rendered foreground event segments
    DayGridEventRenderer.prototype.unrenderFgSegs = function () {
        var rowStructs = this.rowStructs || [];
        var rowStruct;
        while ((rowStruct = rowStructs.pop())) {
            rowStruct.tbodyEl.remove();
        }
        this.rowStructs = null;
    };
    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
    DayGridEventRenderer.prototype.renderSegRows = function (segs) {
        var rowStructs = [];
        var segRows;
        var row;
        segRows = this.groupSegRows(segs); // group into nested arrays
        // iterate each row of segment groupings
        for (row = 0; row < segRows.length; row++) {
            rowStructs.push(this.renderSegRow(row, segRows[row]));
        }
        return rowStructs;
    };
    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
    // the segments. Returns object with a bunch of internal data about how the render was calculated.
    // NOTE: modifies rowSegs
    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
        var colCnt = this.dayGrid.colCnt;
        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
        var tbody = $('<tbody/>');
        var segMatrix = []; // lookup for which segments are rendered into which level+col cells
        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
        var i, levelSegs;
        var col;
        var tr;
        var j, seg;
        var td;
        // populates empty cells from the current column (`col`) to `endCol`
        function emptyCellsUntil(endCol) {
            while (col < endCol) {
                // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                td = (loneCellMatrix[i - 1] || [])[col];
                if (td) {
                    td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);
                }
                else {
                    td = $('<td/>');
                    tr.append(td);
                }
                cellMatrix[i][col] = td;
                loneCellMatrix[i][col] = td;
                col++;
            }
        }
        for (i = 0; i < levelCnt; i++) {
            levelSegs = segLevels[i];
            col = 0;
            tr = $('<tr/>');
            segMatrix.push([]);
            cellMatrix.push([]);
            loneCellMatrix.push([]);
            // levelCnt might be 1 even though there are no actual levels. protect against this.
            // this single empty row is useful for styling.
            if (levelSegs) {
                for (j = 0; j < levelSegs.length; j++) {
                    seg = levelSegs[j];
                    emptyCellsUntil(seg.leftCol);
                    // create a container that occupies or more columns. append the event element.
                    td = $('<td class="fc-event-container"/>').append(seg.el);
                    if (seg.leftCol != seg.rightCol) {
                        td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                    }
                    else {
                        loneCellMatrix[i][col] = td;
                    }
                    while (col <= seg.rightCol) {
                        cellMatrix[i][col] = td;
                        segMatrix[i][col] = seg;
                        col++;
                    }
                    tr.append(td);
                }
            }
            emptyCellsUntil(colCnt); // finish off the row
            this.dayGrid.bookendCells(tr);
            tbody.append(tr);
        }
        return {
            row: row,
            tbodyEl: tbody,
            cellMatrix: cellMatrix,
            segMatrix: segMatrix,
            segLevels: segLevels,
            segs: rowSegs
        };
    };
    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
    // NOTE: modifies segs
    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
        var levels = [];
        var i, seg;
        var j;
        // Give preference to elements with certain criteria, so they have
        // a chance to be closer to the top.
        this.sortEventSegs(segs);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
            for (j = 0; j < levels.length; j++) {
                if (!isDaySegCollision(seg, levels[j])) {
                    break;
                }
            }
            // `j` now holds the desired subrow index
            seg.level = j;
            // create new level array if needed and append segment
            (levels[j] || (levels[j] = [])).push(seg);
        }
        // order segments left-to-right. very important if calendar is RTL
        for (j = 0; j < levels.length; j++) {
            levels[j].sort(compareDaySegCols);
        }
        return levels;
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
    DayGridEventRenderer.prototype.groupSegRows = function (segs) {
        var segRows = [];
        var i;
        for (i = 0; i < this.dayGrid.rowCnt; i++) {
            segRows.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segRows[segs[i].row].push(segs[i]);
        }
        return segRows;
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    DayGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
    };
    // Builds the HTML to be used for the default element for an individual segment
    DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var isAllDay = seg.footprint.componentFootprint.isAllDay;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && isAllDay &&
            seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && isAllDay &&
            seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeHtml = '';
        var timeText;
        var titleHtml;
        classes.unshift('fc-day-grid-event', 'fc-h-event');
        // Only display a timed events time if it is the starting segment
        if (seg.isStart) {
            timeText = this.getTimeText(seg.footprint);
            if (timeText) {
                timeHtml = '<span class="fc-time">' + util_1.htmlEscape(timeText) + '</span>';
            }
        }
        titleHtml =
            '<span class="fc-title">' +
                (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height
                '</span>';
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (this.dayGrid.isRTL ?
                titleHtml + ' ' + timeHtml : // put a natural space in between
                timeHtml + ' ' + titleHtml //
            ) +
            '</div>' +
            (isResizableFromStart ?
                '<div class="fc-resizer fc-start-resizer" />' :
                '') +
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer" />' :
                '') +
            '</a>';
    };
    return DayGridEventRenderer;
}(EventRenderer_1.default));
exports.default = DayGridEventRenderer;
// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
    var i, otherSeg;
    for (i = 0; i < otherSegs.length; i++) {
        otherSeg = otherSegs[i];
        if (otherSeg.leftCol <= seg.rightCol &&
            otherSeg.rightCol >= seg.leftCol) {
            return true;
        }
    }
    return false;
}
// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
    return a.leftCol - b.leftCol;
}


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var HelperRenderer_1 = __webpack_require__(43);
var DayGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridHelperRenderer, _super);
    function DayGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
    DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var rowStructs;
        // TODO: not good to call eventRenderer this way
        rowStructs = this.eventRenderer.renderSegRows(segs);
        // inject each new event skeleton into each associated row
        this.component.rowEls.each(function (row, rowNode) {
            var rowEl = $(rowNode); // the .fc-row
            var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
            var skeletonTopEl;
            var skeletonTop;
            // If there is an original segment, match the top position. Otherwise, put it at the row's top level
            if (sourceSeg && sourceSeg.row === row) {
                skeletonTop = sourceSeg.el.position().top;
            }
            else {
                skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');
                if (!skeletonTopEl.length) {
                    skeletonTopEl = rowEl.find('.fc-content-skeleton table');
                }
                skeletonTop = skeletonTopEl.position().top;
            }
            skeletonEl.css('top', skeletonTop)
                .find('table')
                .append(rowStructs[row].tbodyEl);
            rowEl.append(skeletonEl);
            helperNodes.push(skeletonEl[0]);
        });
        return $(helperNodes); // must return the elements rendered
    };
    return DayGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = DayGridHelperRenderer;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var FillRenderer_1 = __webpack_require__(42);
var DayGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridFillRenderer, _super);
    function DayGridFillRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fillSegTag = 'td'; // override the default tag name
        return _this;
    }
    DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var nodes = [];
        var i, seg;
        var skeletonEl;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            skeletonEl = this.renderFillRow(type, seg);
            this.component.rowEls.eq(seg.row).append(skeletonEl);
            nodes.push(skeletonEl[0]);
        }
        return nodes;
    };
    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
        var colCnt = this.component.colCnt;
        var startCol = seg.leftCol;
        var endCol = seg.rightCol + 1;
        var className;
        var skeletonEl;
        var trEl;
        if (type === 'businessHours') {
            className = 'bgevent';
        }
        else {
            className = type.toLowerCase();
        }
        skeletonEl = $('<div class="fc-' + className + '-skeleton">' +
            '<table><tr/></table>' +
            '</div>');
        trEl = skeletonEl.find('tr');
        if (startCol > 0) {
            trEl.append('<td colspan="' + startCol + '"/>');
        }
        trEl.append(seg.el.attr('colspan', endCol - startCol));
        if (endCol < colCnt) {
            trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
        }
        this.component.bookendCells(trEl);
        return skeletonEl;
    };
    return DayGridFillRenderer;
}(FillRenderer_1.default));
exports.default = DayGridFillRenderer;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var util_1 = __webpack_require__(2);
var EventRenderer_1 = __webpack_require__(31);
var ListEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventRenderer, _super);
    function ListEventRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListEventRenderer.prototype.renderFgSegs = function (segs) {
        if (!segs.length) {
            this.component.renderEmptyMessage();
        }
        else {
            this.component.renderSegList(segs);
        }
    };
    // generates the HTML for a single event row
    ListEventRenderer.prototype.fgSegHtml = function (seg) {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var eventFootprint = seg.footprint;
        var eventDef = eventFootprint.eventDef;
        var componentFootprint = eventFootprint.componentFootprint;
        var url = eventDef.url;
        var classes = ['fc-list-item'].concat(this.getClasses(eventDef));
        var bgColor = this.getBgColor(eventDef);
        var timeHtml;
        if (componentFootprint.isAllDay) {
            timeHtml = view.getAllDayHtml();
        }
        else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            if (seg.isStart || seg.isEnd) {
                timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));
            }
            else {
                timeHtml = view.getAllDayHtml();
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));
        }
        if (url) {
            classes.push('fc-has-url');
        }
        return '<tr class="' + classes.join(' ') + '">' +
            (this.displayEventTime ?
                '<td class="fc-list-item-time ' + theme.getClass('widgetContent') + '">' +
                    (timeHtml || '') +
                    '</td>' :
                '') +
            '<td class="fc-list-item-marker ' + theme.getClass('widgetContent') + '">' +
            '<span class="fc-event-dot"' +
            (bgColor ?
                ' style="background-color:' + bgColor + '"' :
                '') +
            '></span>' +
            '</td>' +
            '<td class="fc-list-item-title ' + theme.getClass('widgetContent') + '">' +
            '<a' + (url ? ' href="' + util_1.htmlEscape(url) + '"' : '') + '>' +
            util_1.htmlEscape(eventDef.title || '') +
            '</a>' +
            '</td>' +
            '</tr>';
    };
    // like "4:00am"
    ListEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('mediumTimeFormat');
    };
    return ListEventRenderer;
}(EventRenderer_1.default));
exports.default = ListEventRenderer;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var $ = __webpack_require__(1);
var EventPointing_1 = __webpack_require__(44);
var ListEventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventPointing, _super);
    function ListEventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // for events with a url, the whole <tr> should be clickable,
    // but it's impossible to wrap with an <a> tag. simulate this.
    ListEventPointing.prototype.handleClick = function (seg, ev) {
        var url;
        _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action
        // not clicking on or within an <a> with an href
        if (!$(ev.target).closest('a[href]').length) {
            url = seg.footprint.eventDef.url;
            if (url && !ev.isDefaultPrevented()) {
                window.location.href = url; // simulate link click
            }
        }
    };
    return ListEventPointing;
}(EventPointing_1.default));
exports.default = ListEventPointing;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventSourceParser_1 = __webpack_require__(25);
var ArrayEventSource_1 = __webpack_require__(34);
var FuncEventSource_1 = __webpack_require__(57);
var JsonFeedEventSource_1 = __webpack_require__(58);
EventSourceParser_1.default.registerClass(ArrayEventSource_1.default);
EventSourceParser_1.default.registerClass(FuncEventSource_1.default);
EventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ThemeRegistry_1 = __webpack_require__(36);
var StandardTheme_1 = __webpack_require__(55);
var JqueryUiTheme_1 = __webpack_require__(56);
var BootstrapTheme_1 = __webpack_require__(94);
ThemeRegistry_1.default.register('standard', StandardTheme_1.default);
ThemeRegistry_1.default.register('jquery-ui', JqueryUiTheme_1.default);
ThemeRegistry_1.default.register('bootstrap3', BootstrapTheme_1.default);


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Theme_1 = __webpack_require__(27);
var BootstrapTheme = /** @class */ (function (_super) {
    tslib_1.__extends(BootstrapTheme, _super);
    function BootstrapTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BootstrapTheme;
}(Theme_1.default));
exports.default = BootstrapTheme;
BootstrapTheme.prototype.classes = {
    widget: 'fc-bootstrap3',
    tableGrid: 'table-bordered',
    tableList: 'table table-striped',
    buttonGroup: 'btn-group',
    button: 'btn btn-default',
    stateActive: 'active',
    stateDisabled: 'disabled',
    today: 'alert alert-info',
    popover: 'panel panel-default',
    popoverHeader: 'panel-heading',
    popoverContent: 'panel-body',
    // day grid
    headerRow: 'panel-default',
    dayRow: 'panel-default',
    // list view
    listView: 'panel panel-default'
};
BootstrapTheme.prototype.baseIconClass = 'glyphicon';
BootstrapTheme.prototype.iconClasses = {
    close: 'glyphicon-remove',
    prev: 'glyphicon-chevron-left',
    next: 'glyphicon-chevron-right',
    prevYear: 'glyphicon-backward',
    nextYear: 'glyphicon-forward'
};
BootstrapTheme.prototype.iconOverrideOption = 'bootstrapGlyphicons';
BootstrapTheme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';
BootstrapTheme.prototype.iconOverridePrefix = 'glyphicon-';


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var namespace_hooks_1 = __webpack_require__(7);
var BasicView_1 = __webpack_require__(47);
var MonthView_1 = __webpack_require__(70);
var views = namespace_hooks_1.default.views;
views.basic = {
    'class': BasicView_1.default
};
views.basicDay = {
    type: 'basic',
    duration: { days: 1 }
};
views.basicWeek = {
    type: 'basic',
    duration: { weeks: 1 }
};
views.month = {
    'class': MonthView_1.default,
    duration: { months: 1 },
    defaults: {
        fixedWeekCount: true
    }
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var namespace_hooks_1 = __webpack_require__(7);
var AgendaView_1 = __webpack_require__(67);
var views = namespace_hooks_1.default.views;
views.agenda = {
    'class': AgendaView_1.default,
    defaults: {
        allDaySlot: true,
        slotDuration: '00:30:00',
        slotEventOverlap: true // a bad name. confused with overlap/constraint system
    }
};
views.agendaDay = {
    type: 'agenda',
    duration: { days: 1 }
};
views.agendaWeek = {
    type: 'agenda',
    duration: { weeks: 1 }
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var namespace_hooks_1 = __webpack_require__(7);
var ListView_1 = __webpack_require__(71);
var views = namespace_hooks_1.default.views;
views.list = {
    'class': ListView_1.default,
    buttonTextKey: 'list',
    defaults: {
        buttonText: 'list',
        listDayFormat: 'LL',
        noEventsMessage: 'No events to display'
    }
};
views.listDay = {
    type: 'list',
    duration: { days: 1 },
    defaults: {
        listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
    }
};
views.listWeek = {
    type: 'list',
    duration: { weeks: 1 },
    defaults: {
        listDayFormat: 'dddd',
        listDayAltFormat: 'LL'
    }
};
views.listMonth = {
    type: 'list',
    duration: { month: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
};
views.listYear = {
    type: 'list',
    duration: { year: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
};


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/moment/locale recursive ^\\.\\/.*$":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "./node_modules/moment/locale/af.js",
	"./af.js": "./node_modules/moment/locale/af.js",
	"./ar": "./node_modules/moment/locale/ar.js",
	"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
	"./ar.js": "./node_modules/moment/locale/ar.js",
	"./az": "./node_modules/moment/locale/az.js",
	"./az.js": "./node_modules/moment/locale/az.js",
	"./be": "./node_modules/moment/locale/be.js",
	"./be.js": "./node_modules/moment/locale/be.js",
	"./bg": "./node_modules/moment/locale/bg.js",
	"./bg.js": "./node_modules/moment/locale/bg.js",
	"./bm": "./node_modules/moment/locale/bm.js",
	"./bm.js": "./node_modules/moment/locale/bm.js",
	"./bn": "./node_modules/moment/locale/bn.js",
	"./bn.js": "./node_modules/moment/locale/bn.js",
	"./bo": "./node_modules/moment/locale/bo.js",
	"./bo.js": "./node_modules/moment/locale/bo.js",
	"./br": "./node_modules/moment/locale/br.js",
	"./br.js": "./node_modules/moment/locale/br.js",
	"./bs": "./node_modules/moment/locale/bs.js",
	"./bs.js": "./node_modules/moment/locale/bs.js",
	"./ca": "./node_modules/moment/locale/ca.js",
	"./ca.js": "./node_modules/moment/locale/ca.js",
	"./cs": "./node_modules/moment/locale/cs.js",
	"./cs.js": "./node_modules/moment/locale/cs.js",
	"./cv": "./node_modules/moment/locale/cv.js",
	"./cv.js": "./node_modules/moment/locale/cv.js",
	"./cy": "./node_modules/moment/locale/cy.js",
	"./cy.js": "./node_modules/moment/locale/cy.js",
	"./da": "./node_modules/moment/locale/da.js",
	"./da.js": "./node_modules/moment/locale/da.js",
	"./de": "./node_modules/moment/locale/de.js",
	"./de-at": "./node_modules/moment/locale/de-at.js",
	"./de-at.js": "./node_modules/moment/locale/de-at.js",
	"./de-ch": "./node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
	"./de.js": "./node_modules/moment/locale/de.js",
	"./dv": "./node_modules/moment/locale/dv.js",
	"./dv.js": "./node_modules/moment/locale/dv.js",
	"./el": "./node_modules/moment/locale/el.js",
	"./el.js": "./node_modules/moment/locale/el.js",
	"./en-au": "./node_modules/moment/locale/en-au.js",
	"./en-au.js": "./node_modules/moment/locale/en-au.js",
	"./en-ca": "./node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
	"./en-gb": "./node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
	"./en-ie": "./node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
	"./en-nz": "./node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
	"./eo": "./node_modules/moment/locale/eo.js",
	"./eo.js": "./node_modules/moment/locale/eo.js",
	"./es": "./node_modules/moment/locale/es.js",
	"./es-do": "./node_modules/moment/locale/es-do.js",
	"./es-do.js": "./node_modules/moment/locale/es-do.js",
	"./es-us": "./node_modules/moment/locale/es-us.js",
	"./es-us.js": "./node_modules/moment/locale/es-us.js",
	"./es.js": "./node_modules/moment/locale/es.js",
	"./et": "./node_modules/moment/locale/et.js",
	"./et.js": "./node_modules/moment/locale/et.js",
	"./eu": "./node_modules/moment/locale/eu.js",
	"./eu.js": "./node_modules/moment/locale/eu.js",
	"./fa": "./node_modules/moment/locale/fa.js",
	"./fa.js": "./node_modules/moment/locale/fa.js",
	"./fi": "./node_modules/moment/locale/fi.js",
	"./fi.js": "./node_modules/moment/locale/fi.js",
	"./fo": "./node_modules/moment/locale/fo.js",
	"./fo.js": "./node_modules/moment/locale/fo.js",
	"./fr": "./node_modules/moment/locale/fr.js",
	"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
	"./fr.js": "./node_modules/moment/locale/fr.js",
	"./fy": "./node_modules/moment/locale/fy.js",
	"./fy.js": "./node_modules/moment/locale/fy.js",
	"./gd": "./node_modules/moment/locale/gd.js",
	"./gd.js": "./node_modules/moment/locale/gd.js",
	"./gl": "./node_modules/moment/locale/gl.js",
	"./gl.js": "./node_modules/moment/locale/gl.js",
	"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
	"./gu": "./node_modules/moment/locale/gu.js",
	"./gu.js": "./node_modules/moment/locale/gu.js",
	"./he": "./node_modules/moment/locale/he.js",
	"./he.js": "./node_modules/moment/locale/he.js",
	"./hi": "./node_modules/moment/locale/hi.js",
	"./hi.js": "./node_modules/moment/locale/hi.js",
	"./hr": "./node_modules/moment/locale/hr.js",
	"./hr.js": "./node_modules/moment/locale/hr.js",
	"./hu": "./node_modules/moment/locale/hu.js",
	"./hu.js": "./node_modules/moment/locale/hu.js",
	"./hy-am": "./node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
	"./id": "./node_modules/moment/locale/id.js",
	"./id.js": "./node_modules/moment/locale/id.js",
	"./is": "./node_modules/moment/locale/is.js",
	"./is.js": "./node_modules/moment/locale/is.js",
	"./it": "./node_modules/moment/locale/it.js",
	"./it.js": "./node_modules/moment/locale/it.js",
	"./ja": "./node_modules/moment/locale/ja.js",
	"./ja.js": "./node_modules/moment/locale/ja.js",
	"./jv": "./node_modules/moment/locale/jv.js",
	"./jv.js": "./node_modules/moment/locale/jv.js",
	"./ka": "./node_modules/moment/locale/ka.js",
	"./ka.js": "./node_modules/moment/locale/ka.js",
	"./kk": "./node_modules/moment/locale/kk.js",
	"./kk.js": "./node_modules/moment/locale/kk.js",
	"./km": "./node_modules/moment/locale/km.js",
	"./km.js": "./node_modules/moment/locale/km.js",
	"./kn": "./node_modules/moment/locale/kn.js",
	"./kn.js": "./node_modules/moment/locale/kn.js",
	"./ko": "./node_modules/moment/locale/ko.js",
	"./ko.js": "./node_modules/moment/locale/ko.js",
	"./ky": "./node_modules/moment/locale/ky.js",
	"./ky.js": "./node_modules/moment/locale/ky.js",
	"./lb": "./node_modules/moment/locale/lb.js",
	"./lb.js": "./node_modules/moment/locale/lb.js",
	"./lo": "./node_modules/moment/locale/lo.js",
	"./lo.js": "./node_modules/moment/locale/lo.js",
	"./lt": "./node_modules/moment/locale/lt.js",
	"./lt.js": "./node_modules/moment/locale/lt.js",
	"./lv": "./node_modules/moment/locale/lv.js",
	"./lv.js": "./node_modules/moment/locale/lv.js",
	"./me": "./node_modules/moment/locale/me.js",
	"./me.js": "./node_modules/moment/locale/me.js",
	"./mi": "./node_modules/moment/locale/mi.js",
	"./mi.js": "./node_modules/moment/locale/mi.js",
	"./mk": "./node_modules/moment/locale/mk.js",
	"./mk.js": "./node_modules/moment/locale/mk.js",
	"./ml": "./node_modules/moment/locale/ml.js",
	"./ml.js": "./node_modules/moment/locale/ml.js",
	"./mr": "./node_modules/moment/locale/mr.js",
	"./mr.js": "./node_modules/moment/locale/mr.js",
	"./ms": "./node_modules/moment/locale/ms.js",
	"./ms-my": "./node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
	"./ms.js": "./node_modules/moment/locale/ms.js",
	"./my": "./node_modules/moment/locale/my.js",
	"./my.js": "./node_modules/moment/locale/my.js",
	"./nb": "./node_modules/moment/locale/nb.js",
	"./nb.js": "./node_modules/moment/locale/nb.js",
	"./ne": "./node_modules/moment/locale/ne.js",
	"./ne.js": "./node_modules/moment/locale/ne.js",
	"./nl": "./node_modules/moment/locale/nl.js",
	"./nl-be": "./node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
	"./nl.js": "./node_modules/moment/locale/nl.js",
	"./nn": "./node_modules/moment/locale/nn.js",
	"./nn.js": "./node_modules/moment/locale/nn.js",
	"./pa-in": "./node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
	"./pl": "./node_modules/moment/locale/pl.js",
	"./pl.js": "./node_modules/moment/locale/pl.js",
	"./pt": "./node_modules/moment/locale/pt.js",
	"./pt-br": "./node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
	"./pt.js": "./node_modules/moment/locale/pt.js",
	"./ro": "./node_modules/moment/locale/ro.js",
	"./ro.js": "./node_modules/moment/locale/ro.js",
	"./ru": "./node_modules/moment/locale/ru.js",
	"./ru.js": "./node_modules/moment/locale/ru.js",
	"./sd": "./node_modules/moment/locale/sd.js",
	"./sd.js": "./node_modules/moment/locale/sd.js",
	"./se": "./node_modules/moment/locale/se.js",
	"./se.js": "./node_modules/moment/locale/se.js",
	"./si": "./node_modules/moment/locale/si.js",
	"./si.js": "./node_modules/moment/locale/si.js",
	"./sk": "./node_modules/moment/locale/sk.js",
	"./sk.js": "./node_modules/moment/locale/sk.js",
	"./sl": "./node_modules/moment/locale/sl.js",
	"./sl.js": "./node_modules/moment/locale/sl.js",
	"./sq": "./node_modules/moment/locale/sq.js",
	"./sq.js": "./node_modules/moment/locale/sq.js",
	"./sr": "./node_modules/moment/locale/sr.js",
	"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "./node_modules/moment/locale/sr.js",
	"./ss": "./node_modules/moment/locale/ss.js",
	"./ss.js": "./node_modules/moment/locale/ss.js",
	"./sv": "./node_modules/moment/locale/sv.js",
	"./sv.js": "./node_modules/moment/locale/sv.js",
	"./sw": "./node_modules/moment/locale/sw.js",
	"./sw.js": "./node_modules/moment/locale/sw.js",
	"./ta": "./node_modules/moment/locale/ta.js",
	"./ta.js": "./node_modules/moment/locale/ta.js",
	"./te": "./node_modules/moment/locale/te.js",
	"./te.js": "./node_modules/moment/locale/te.js",
	"./tet": "./node_modules/moment/locale/tet.js",
	"./tet.js": "./node_modules/moment/locale/tet.js",
	"./th": "./node_modules/moment/locale/th.js",
	"./th.js": "./node_modules/moment/locale/th.js",
	"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
	"./tlh": "./node_modules/moment/locale/tlh.js",
	"./tlh.js": "./node_modules/moment/locale/tlh.js",
	"./tr": "./node_modules/moment/locale/tr.js",
	"./tr.js": "./node_modules/moment/locale/tr.js",
	"./tzl": "./node_modules/moment/locale/tzl.js",
	"./tzl.js": "./node_modules/moment/locale/tzl.js",
	"./tzm": "./node_modules/moment/locale/tzm.js",
	"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "./node_modules/moment/locale/tzm.js",
	"./uk": "./node_modules/moment/locale/uk.js",
	"./uk.js": "./node_modules/moment/locale/uk.js",
	"./ur": "./node_modules/moment/locale/ur.js",
	"./ur.js": "./node_modules/moment/locale/ur.js",
	"./uz": "./node_modules/moment/locale/uz.js",
	"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
	"./uz.js": "./node_modules/moment/locale/uz.js",
	"./vi": "./node_modules/moment/locale/vi.js",
	"./vi.js": "./node_modules/moment/locale/vi.js",
	"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
	"./yo": "./node_modules/moment/locale/yo.js",
	"./yo.js": "./node_modules/moment/locale/yo.js",
	"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
	"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/moment/locale recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/moment/locale/af.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var af = moment.defineLocale('af', {
    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM : function (input) {
        return /^nm$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'vm' : 'VM';
        } else {
            return isLower ? 'nm' : 'NM';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Vandag om] LT',
        nextDay : '[Mre om] LT',
        nextWeek : 'dddd [om] LT',
        lastDay : '[Gister om] LT',
        lastWeek : '[Laas] dddd [om] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'oor %s',
        past : '%s gelede',
        s : '\'n paar sekondes',
        m : '\'n minuut',
        mm : '%d minute',
        h : '\'n uur',
        hh : '%d ure',
        d : '\'n dag',
        dd : '%d dae',
        M : '\'n maand',
        MM : '%d maande',
        y : '\'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week : {
        dow : 1, // Maandag is die eerste dag van die week.
        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
    }
});

return af;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-dz.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arDz = moment.defineLocale('ar-dz', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 4  // The week that contains Jan 1st is the first week of the year.
    }
});

return arDz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-kw.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arKw = moment.defineLocale('ar-kw', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return arKw;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-ly.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    '0': '0'
};
var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals = {
    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
};
var pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
            str = plurals[u][pluralForm(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var arLy = moment.defineLocale('ar-ly', {
    months : months,
    monthsShort : months,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : pluralize('s'),
        m : pluralize('m'),
        mm : pluralize('m'),
        h : pluralize('h'),
        hh : pluralize('h'),
        d : pluralize('d'),
        dd : pluralize('d'),
        M : pluralize('M'),
        MM : pluralize('M'),
        y : pluralize('y'),
        yy : pluralize('y')
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return arLy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-ma.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arMa = moment.defineLocale('ar-ma', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return arMa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-sa.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var arSa = moment.defineLocale('ar-sa', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return arSa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-tn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var arTn = moment.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: ' %s',
        past: ' %s',
        s: '',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

return arTn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};
var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals = {
    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
};
var pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
            str = plurals[u][pluralForm(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months = [
    '  ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    ' ',
    '  ',
    '  ',
    '  '
];

var ar = moment.defineLocale('ar', {
    months : months,
    monthsShort : months,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay: '[  ] LT',
        nextDay: '[  ] LT',
        nextWeek: 'dddd [ ] LT',
        lastDay: '[  ] LT',
        lastWeek: 'dddd [ ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : pluralize('s'),
        m : pluralize('m'),
        mm : pluralize('m'),
        h : pluralize('h'),
        hh : pluralize('h'),
        d : pluralize('d'),
        dd : pluralize('d'),
        M : pluralize('M'),
        MM : pluralize('M'),
        y : pluralize('y'),
        yy : pluralize('y')
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return ar;

})));


/***/ }),

/***/ "./node_modules/moment/locale/az.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
};

var az = moment.defineLocale('az', {
    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugn saat] LT',
        nextDay : '[sabah saat] LT',
        nextWeek : '[gln hft] dddd [saat] LT',
        lastDay : '[dnn] LT',
        lastWeek : '[ken hft] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s vvl',
        s : 'birne saniyy',
        m : 'bir dqiq',
        mm : '%d dqiq',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gn',
        dd : '%d gn',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir il',
        yy : '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM : function (input) {
        return /^(gndz|axam)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'gec';
        } else if (hour < 12) {
            return 'shr';
        } else if (hour < 17) {
            return 'gndz';
        } else {
            return 'axam';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '-nc';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return az;

})));


/***/ }),

/***/ "./node_modules/moment/locale/be.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else if (key === 'h') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}

var be = moment.defineLocale('be', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : {
        format: '______'.split('_'),
        standalone: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        lastDay: '[ ] LT',
        nextWeek: function () {
            return '[] dddd [] LT';
        },
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : relativeTimeWithPlural,
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM : function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return be;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bg.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var bg = moment.defineLocale('bg', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-';
        } else if (last2Digits === 0) {
            return number + '-';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-';
        } else if (lastDigit === 1) {
            return number + '-';
        } else if (lastDigit === 2) {
            return number + '-';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-';
        } else {
            return number + '-';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return bg;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bm.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

// Language contact person : Abdoufata Kane : https://github.com/abdoufata

var bm = moment.defineLocale('bm', {
    months : 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort : 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
    weekdays : 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort : 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin : 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'MMMM [tile] D [san] YYYY',
        LLL : 'MMMM [tile] D [san] YYYY [lr] HH:mm',
        LLLL : 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
    },
    calendar : {
        sameDay : '[Bi lr] LT',
        nextDay : '[Sini lr] LT',
        nextWeek : 'dddd [don lr] LT',
        lastDay : '[Kunu lr] LT',
        lastWeek : 'dddd [tmnen lr] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s kn',
        past : 'a b %s b',
        s : 'sanga dama dama',
        m : 'miniti kelen',
        mm : 'miniti %d',
        h : 'lr kelen',
        hh : 'lr %d',
        d : 'tile kelen',
        dd : 'tile %d',
        M : 'kalo kelen',
        MM : 'kalo %d',
        y : 'san kelen',
        yy : 'san %d'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return bm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var bn = moment.defineLocale('bn', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                (meridiem === '' && hour < 5) ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return bn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var bo = moment.defineLocale('bo', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[], LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                (meridiem === '' && hour < 5) ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return bo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/br.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
        'mm': 'munutenn',
        'MM': 'miz',
        'dd': 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
}
function specialMutationForYears(number) {
    switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
    }
}
function lastNumber(number) {
    if (number > 9) {
        return lastNumber(number % 10);
    }
    return number;
}
function mutation(text, number) {
    if (number === 2) {
        return softMutation(text);
    }
    return text;
}
function softMutation(text) {
    var mutationTable = {
        'm': 'v',
        'b': 'v',
        'd': 'z'
    };
    if (mutationTable[text.charAt(0)] === undefined) {
        return text;
    }
    return mutationTable[text.charAt(0)] + text.substring(1);
}

var br = moment.defineLocale('br', {
    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h[e]mm A',
        LTS : 'h[e]mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [a viz] MMMM YYYY',
        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
    },
    calendar : {
        sameDay : '[Hiziv da] LT',
        nextDay : '[Warc\'hoazh da] LT',
        nextWeek : 'dddd [da] LT',
        lastDay : '[Dec\'h da] LT',
        lastWeek : 'dddd [paset da] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'a-benn %s',
        past : '%s \'zo',
        s : 'un nebeud segondenno',
        m : 'ur vunutenn',
        mm : relativeTimeWithMutation,
        h : 'un eur',
        hh : '%d eur',
        d : 'un devezh',
        dd : relativeTimeWithMutation,
        M : 'ur miz',
        MM : relativeTimeWithMutation,
        y : 'ur bloaz',
        yy : specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal : function (number) {
        var output = (number === 1) ? 'a' : 'vet';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return br;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bs.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

var bs = moment.defineLocale('bs', {
    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate,
        mm     : translate,
        h      : translate,
        hh     : translate,
        d      : 'dan',
        dd     : translate,
        M      : 'mjesec',
        MM     : translate,
        y      : 'godinu',
        yy     : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return bs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ca.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ca = moment.defineLocale('ca', {
    months : {
        standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
        isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort : 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin : 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM [de] YYYY',
        ll : 'D MMM YYYY',
        LLL : 'D MMMM [de] YYYY [a les] H:mm',
        lll : 'D MMM YYYY, H:mm',
        LLLL : 'dddd D MMMM [de] YYYY [a les] H:mm',
        llll : 'ddd D MMM YYYY, H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextDay : function () {
            return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastDay : function () {
            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'd\'aqu %s',
        past : 'fa %s',
        s : 'uns segons',
        m : 'un minut',
        mm : '%d minuts',
        h : 'una hora',
        hh : '%d hores',
        d : 'un dia',
        dd : '%d dies',
        M : 'un mes',
        MM : '%d mesos',
        y : 'un any',
        yy : '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal : function (number, period) {
        var output = (number === 1) ? 'r' :
            (number === 2) ? 'n' :
            (number === 3) ? 'r' :
            (number === 4) ? 't' : '';
        if (period === 'w' || period === 'W') {
            output = 'a';
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ca;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cs.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
function plural(n) {
    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dny' : 'dn');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'msce' : 'msc');
            } else {
                return result + 'msci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
    }
}

var cs = moment.defineLocale('cs', {
    months : months,
    monthsShort : monthsShort,
    monthsParse : (function (months, monthsShort) {
        var i, _monthsParse = [];
        for (i = 0; i < 12; i++) {
            // use custom parser to solve problem with July (ervenec)
            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
        }
        return _monthsParse;
    }(months, monthsShort)),
    shortMonthsParse : (function (monthsShort) {
        var i, _shortMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
        }
        return _shortMonthsParse;
    }(monthsShort)),
    longMonthsParse : (function (months) {
        var i, _longMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
        }
        return _longMonthsParse;
    }(months)),
    weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm',
        l : 'D. M. YYYY'
    },
    calendar : {
        sameDay: '[dnes v] LT',
        nextDay: '[ztra v] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve stedu v] LT';
                case 4:
                    return '[ve tvrtek v] LT';
                case 5:
                    return '[v ptek v] LT';
                case 6:
                    return '[v sobotu v] LT';
            }
        },
        lastDay: '[vera v] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minulou nedli v] LT';
                case 1:
                case 2:
                    return '[minul] dddd [v] LT';
                case 3:
                    return '[minulou stedu v] LT';
                case 4:
                case 5:
                    return '[minul] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'ped %s',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse : /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return cs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var cv = moment.defineLocale('cv', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'YYYY [] MMMM [] D[-]',
        LLL : 'YYYY [] MMMM [] D[-], HH:mm',
        LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar : {
        sameDay: '[] LT []',
        nextDay: '[] LT []',
        lastDay: '[] LT []',
        nextWeek: '[] dddd LT []',
        lastWeek: '[] dddd LT []',
        sameElse: 'L'
    },
    relativeTime : {
        future : function (output) {
            var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
            return output + affix;
        },
        past : '%s ',
        s : '- ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal : '%d-',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return cv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cy.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    // time formats are the same as en-gb
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[Heddiw am] LT',
        nextDay: '[Yfory am] LT',
        nextWeek: 'dddd [am] LT',
        lastDay: '[Ddoe am] LT',
        lastWeek: 'dddd [diwethaf am] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'mewn %s',
        past: '%s yn l',
        s: 'ychydig eiliadau',
        m: 'munud',
        mm: '%d munud',
        h: 'awr',
        hh: '%d awr',
        d: 'diwrnod',
        dd: '%d diwrnod',
        M: 'mis',
        MM: '%d mis',
        y: 'blwyddyn',
        yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
        var b = number,
            output = '',
            lookup = [
                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
            ];
        if (b > 20) {
            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                output = 'fed'; // not 30ain, 70ain or 90ain
            } else {
                output = 'ain';
            }
        } else if (b > 0) {
            output = lookup[b];
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return cy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/da.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var da = moment.defineLocale('da', {
    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay : '[i dag kl.] LT',
        nextDay : '[i morgen kl.] LT',
        nextWeek : 'p dddd [kl.] LT',
        lastDay : '[i gr kl.] LT',
        lastWeek : '[i] dddd[s kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'f sekunder',
        m : 'et minut',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dage',
        M : 'en mned',
        MM : '%d mneder',
        y : 'et r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return da;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de-at.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var deAt = moment.defineLocale('de-at', {
    months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return deAt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de-ch.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


// based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var deCh = moment.defineLocale('de-ch', {
    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH.mm',
        LTS: 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH.mm',
        LLLL : 'dddd, D. MMMM YYYY HH.mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return deCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var de = moment.defineLocale('de', {
    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return de;

})));


/***/ }),

/***/ "./node_modules/moment/locale/dv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var weekdays = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var dv = moment.defineLocale('dv', {
    months : months,
    monthsShort : months,
    weekdays : weekdays,
    weekdaysShort : weekdays,
    weekdaysMin : '______'.split('_'),
    longDateFormat : {

        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/M/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : '',
        m : '',
        mm : ' %d',
        h : '',
        hh : ' %d',
        d : '',
        dd : ' %d',
        M : '',
        MM : ' %d',
        y : '',
        yy : ' %d'
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 7,  // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return dv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/el.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}


var el = moment.defineLocale('el', {
    monthsNominativeEl : '___________'.split('_'),
    monthsGenitiveEl : '___________'.split('_'),
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return this._monthsNominativeEl;
        } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
            return this._monthsGenitiveEl[momentToFormat.month()];
        } else {
            return this._monthsNominativeEl[momentToFormat.month()];
        }
    },
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? '' : '';
        } else {
            return isLower ? '' : '';
        }
    },
    isPM : function (input) {
        return ((input + '').toLowerCase()[0] === '');
    },
    meridiemParse : /[]\.??\.?/i,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl : {
        sameDay : '[ {}] LT',
        nextDay : '[ {}] LT',
        nextWeek : 'dddd [{}] LT',
        lastDay : '[ {}] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 6:
                    return '[ ] dddd [{}] LT';
                default:
                    return '[ ] dddd [{}] LT';
            }
        },
        sameElse : 'L'
    },
    calendar : function (key, mom) {
        var output = this._calendarEl[key],
            hours = mom && mom.hours();
        if (isFunction(output)) {
            output = output.apply(mom);
        }
        return output.replace('{}', (hours % 12 === 1 ? '' : ''));
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4st is the first week of the year.
    }
});

return el;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-au.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enAu = moment.defineLocale('en-au', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enAu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-ca.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enCa = moment.defineLocale('en-ca', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'YYYY-MM-DD',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

return enCa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-gb.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enGb = moment.defineLocale('en-gb', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enGb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-ie.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enIe = moment.defineLocale('en-ie', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enIe;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-nz.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var enNz = moment.defineLocale('en-nz', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return enNz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/eo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var eo = moment.defineLocale('eo', {
    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
    weekdays : 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort : 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin : 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D[-a de] MMMM, YYYY',
        LLL : 'D[-a de] MMMM, YYYY HH:mm',
        LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
        return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p.t.m.' : 'P.T.M.';
        } else {
            return isLower ? 'a.t.m.' : 'A.T.M.';
        }
    },
    calendar : {
        sameDay : '[Hodia je] LT',
        nextDay : '[Morga je] LT',
        nextWeek : 'dddd [je] LT',
        lastDay : '[Hiera je] LT',
        lastWeek : '[pasinta] dddd [je] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'post %s',
        past : 'anta %s',
        s : 'sekundoj',
        m : 'minuto',
        mm : '%d minutoj',
        h : 'horo',
        hh : '%d horoj',
        d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
        dd : '%d tagoj',
        M : 'monato',
        MM : '%d monatoj',
        y : 'jaro',
        yy : '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal : '%da',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return eo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-do.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

var esDo = moment.defineLocale('es-do', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY h:mm A',
        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return esDo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-us.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish(United State) [es-us]
//! author : bustta : https://github.com/bustta

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

var esUs = moment.defineLocale('es-us', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'MM/DD/YYYY',
        LL : 'MMMM [de] D [de] YYYY',
        LLL : 'MMMM [de] D [de] YYYY H:mm',
        LLLL : 'dddd, MMMM [de] D [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return esUs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

var es = moment.defineLocale('es', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsRegex : monthsRegex,
    monthsShortRegex : monthsRegex,
    monthsStrictRegex : /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex : /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,
    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ao',
        yy : '%d aos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return es;

})));


/***/ }),

/***/ "./node_modules/moment/locale/et.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
        'm' : ['he minuti', 'ks minut'],
        'mm': [number + ' minuti', number + ' minutit'],
        'h' : ['he tunni', 'tund aega', 'ks tund'],
        'hh': [number + ' tunni', number + ' tundi'],
        'd' : ['he peva', 'ks pev'],
        'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
        'MM': [number + ' kuu', number + ' kuud'],
        'y' : ['he aasta', 'aasta', 'ks aasta'],
        'yy': [number + ' aasta', number + ' aastat']
    };
    if (withoutSuffix) {
        return format[key][2] ? format[key][2] : format[key][1];
    }
    return isFuture ? format[key][0] : format[key][1];
}

var et = moment.defineLocale('et', {
    months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat : {
        LT   : 'H:mm',
        LTS : 'H:mm:ss',
        L    : 'DD.MM.YYYY',
        LL   : 'D. MMMM YYYY',
        LLL  : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[Tna,] LT',
        nextDay  : '[Homme,] LT',
        nextWeek : '[Jrgmine] dddd LT',
        lastDay  : '[Eile,] LT',
        lastWeek : '[Eelmine] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s prast',
        past   : '%s tagasi',
        s      : processRelativeTime,
        m      : processRelativeTime,
        mm     : processRelativeTime,
        h      : processRelativeTime,
        hh     : processRelativeTime,
        d      : processRelativeTime,
        dd     : '%d peva',
        M      : processRelativeTime,
        MM     : processRelativeTime,
        y      : processRelativeTime,
        yy     : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return et;

})));


/***/ }),

/***/ "./node_modules/moment/locale/eu.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var eu = moment.defineLocale('eu', {
    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact : true,
    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY[ko] MMMM[ren] D[a]',
        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
        l : 'YYYY-M-D',
        ll : 'YYYY[ko] MMM D[a]',
        lll : 'YYYY[ko] MMM D[a] HH:mm',
        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar : {
        sameDay : '[gaur] LT[etan]',
        nextDay : '[bihar] LT[etan]',
        nextWeek : 'dddd LT[etan]',
        lastDay : '[atzo] LT[etan]',
        lastWeek : '[aurreko] dddd LT[etan]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s barru',
        past : 'duela %s',
        s : 'segundo batzuk',
        m : 'minutu bat',
        mm : '%d minutu',
        h : 'ordu bat',
        hh : '%d ordu',
        d : 'egun bat',
        dd : '%d egun',
        M : 'hilabete bat',
        MM : '%d hilabete',
        y : 'urte bat',
        yy : '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return eu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fa.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var fa = moment.defineLocale('fa', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function (input) {
        return /  /.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '  ';
        } else {
            return '  ';
        }
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : 'dddd [] [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[-]/g, function (match) {
            return numberMap[match];
        }).replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12 // The week that contains Jan 1st is the first week of the year.
    }
});

return fa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
var numbersFuture = [
        'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
        numbersPast[7], numbersPast[8], numbersPast[9]
    ];
function translate(number, withoutSuffix, key, isFuture) {
    var result = '';
    switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'pivn' : 'piv';
        case 'dd':
            result = isFuture ? 'pivn' : 'piv';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
    }
    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
}
function verbalNumber(number, isFuture) {
    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
}

var fi = moment.defineLocale('fi', {
    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'Do MMMM[ta] YYYY',
        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
        l : 'D.M.YYYY',
        ll : 'Do MMM YYYY',
        lll : 'Do MMM YYYY, [klo] HH.mm',
        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar : {
        sameDay : '[tnn] [klo] LT',
        nextDay : '[huomenna] [klo] LT',
        nextWeek : 'dddd [klo] LT',
        lastDay : '[eilen] [klo] LT',
        lastWeek : '[viime] dddd[na] [klo] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s pst',
        past : '%s sitten',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var fo = moment.defineLocale('fo', {
    months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ dag kl.] LT',
        nextDay : '[ morgin kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[ gjr kl.] LT',
        lastWeek : '[sstu] dddd [kl] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'um %s',
        past : '%s sani',
        s : 'f sekund',
        m : 'ein minutt',
        mm : '%d minuttir',
        h : 'ein tmi',
        hh : '%d tmar',
        d : 'ein dagur',
        dd : '%d dagar',
        M : 'ein mnai',
        MM : '%d mnair',
        y : 'eitt r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr-ca.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var frCa = moment.defineLocale('fr-ca', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    }
});

return frCa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr-ch.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var frCh = moment.defineLocale('fr-ch', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return frCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var fr = moment.defineLocale('fr', {
    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourdhui ] LT',
        nextDay : '[Demain ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[Hier ] LT',
        lastWeek : 'dddd [dernier ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal : function (number, period) {
        switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case 'D':
                return number + (number === 1 ? 'er' : '');

            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fy.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

var fy = moment.defineLocale('fy', {
    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[hjoed om] LT',
        nextDay: '[moarn om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[juster om] LT',
        lastWeek: '[frne] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'oer %s',
        past : '%s lyn',
        s : 'in pear sekonden',
        m : 'ien mint',
        mm : '%d minuten',
        h : 'ien oere',
        hh : '%d oeren',
        d : 'ien dei',
        dd : '%d dagen',
        M : 'ien moanne',
        MM : '%d moannen',
        y : 'ien jier',
        yy : '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gd.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
];

var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];

var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];

var gd = moment.defineLocale('gd', {
    months : months,
    monthsShort : monthsShort,
    monthsParseExact : true,
    weekdays : weekdays,
    weekdaysShort : weekdaysShort,
    weekdaysMin : weekdaysMin,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[An-diugh aig] LT',
        nextDay : '[A-mireach aig] LT',
        nextWeek : 'dddd [aig] LT',
        lastDay : '[An-d aig] LT',
        lastWeek : 'dddd [seo chaidh] [aig] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ann an %s',
        past : 'bho chionn %s',
        s : 'beagan diogan',
        m : 'mionaid',
        mm : '%d mionaidean',
        h : 'uair',
        hh : '%d uairean',
        d : 'latha',
        dd : '%d latha',
        M : 'mos',
        MM : '%d mosan',
        y : 'bliadhna',
        yy : '%d bliadhna'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
    ordinal : function (number) {
        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return gd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var gl = moment.defineLocale('gl', {
    months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
        },
        lastDay : function () {
            return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
        },
        lastWeek : function () {
            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : function (str) {
            if (str.indexOf('un') === 0) {
                return 'n' + str;
            }
            return 'en ' + str;
        },
        past : 'hai %s',
        s : 'uns segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'unha hora',
        hh : '%d horas',
        d : 'un da',
        dd : '%d das',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return gl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gom-latn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['thodde secondanim', 'thodde second'],
        'm': ['eka mintan', 'ek minute'],
        'mm': [number + ' mintanim', number + ' mintam'],
        'h': ['eka horan', 'ek hor'],
        'hh': [number + ' horanim', number + ' hor'],
        'd': ['eka disan', 'ek dis'],
        'dd': [number + ' disanim', number + ' dis'],
        'M': ['eka mhoinean', 'ek mhoino'],
        'MM': [number + ' mhoineanim', number + ' mhoine'],
        'y': ['eka vorsan', 'ek voros'],
        'yy': [number + ' vorsanim', number + ' vorsam']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

var gomLatn = moment.defineLocale('gom-latn', {
    months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
    monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
    weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm [vazta]',
        LTS : 'A h:mm:ss [vazta]',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY A h:mm [vazta]',
        LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
        llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar : {
        sameDay: '[Aiz] LT',
        nextDay: '[Faleam] LT',
        nextWeek: '[Ieta to] dddd[,] LT',
        lastDay: '[Kal] LT',
        lastWeek: '[Fatlo] dddd[,] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s adim',
        s : processRelativeTime,
        m : processRelativeTime,
        mm : processRelativeTime,
        h : processRelativeTime,
        hh : processRelativeTime,
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
    ordinal : function (number, period) {
        switch (period) {
            // the ordinal 'er' only applies to day of the month
            case 'D':
                return number + 'er';
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
            case 'w':
            case 'W':
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    },
    meridiemParse: /rati|sokalli|donparam|sanje/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'rati') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'sokalli') {
            return hour;
        } else if (meridiem === 'donparam') {
            return hour > 12 ? hour : hour + 12;
        } else if (meridiem === 'sanje') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'rati';
        } else if (hour < 12) {
            return 'sokalli';
        } else if (hour < 16) {
            return 'donparam';
        } else if (hour < 20) {
            return 'sanje';
        } else {
            return 'rati';
        }
    }
});

return gomLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gu.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    };
var numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

var gu = moment.defineLocale('gu', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
        LT: 'A h:mm ',
        LTS: 'A h:mm:ss ',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY, A h:mm ',
        LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
        sameDay: '[] LT',
        nextDay: '[] LT',
        nextWeek: 'dddd, LT',
        lastDay: '[] LT',
        lastWeek: '[] dddd, LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: '%s ',
        past: '%s ',
        s: ' ',
        m: ' ',
        mm: '%d ',
        h: ' ',
        hh: '%d ',
        d: ' ',
        dd: '%d ',
        M: ' ',
        MM: '%d ',
        y: ' ',
        yy: '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem: function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week: {
        dow: 0, // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 1st is the first week of the year.
    }
});

return gu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/he.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var he = moment.defineLocale('he', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D []MMMM YYYY',
        LLL : 'D []MMMM YYYY HH:mm',
        LLLL : 'dddd, D []MMMM YYYY HH:mm',
        l : 'D/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ]LT',
        nextDay : '[ ]LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ]LT',
        lastWeek : '[] dddd [ ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        d : '',
        dd : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        M : '',
        MM : function (number) {
            if (number === 2) {
                return '';
            }
            return number + ' ';
        },
        y : '',
        yy : function (number) {
            if (number === 2) {
                return '';
            } else if (number % 10 === 0 && number !== 10) {
                return number + ' ';
            }
            return number + ' ';
        }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM : function (input) {
        return /^("| |)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 5) {
            return ' ';
        } else if (hour < 10) {
            return '';
        } else if (hour < 12) {
            return isLower ? '"' : ' ';
        } else if (hour < 18) {
            return isLower ? '"' : ' ';
        } else {
            return '';
        }
    }
});

return he;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var hi = moment.defineLocale('hi', {
    months : '___________'.split('_'),
    monthsShort : '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return hi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

var hr = moment.defineLocale('hr', {
    months : {
        format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
        standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate,
        mm     : translate,
        h      : translate,
        hh     : translate,
        d      : 'dan',
        dd     : translate,
        M      : 'mjesec',
        MM     : translate,
        y      : 'godinu',
        yy     : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return hr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hu.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
function translate(number, withoutSuffix, key, isFuture) {
    var num = number,
        suffix;
    switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }
    return '';
}
function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
}

var hu = moment.defineLocale('hu', {
    months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
    weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'YYYY.MM.DD.',
        LL : 'YYYY. MMMM D.',
        LLL : 'YYYY. MMMM D. H:mm',
        LLLL : 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
        return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower === true ? 'de' : 'DE';
        } else {
            return isLower === true ? 'du' : 'DU';
        }
    },
    calendar : {
        sameDay : '[ma] LT[-kor]',
        nextDay : '[holnap] LT[-kor]',
        nextWeek : function () {
            return week.call(this, true);
        },
        lastDay : '[tegnap] LT[-kor]',
        lastWeek : function () {
            return week.call(this, false);
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s mlva',
        past : '%s',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return hu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hy-am.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var hyAm = moment.defineLocale('hy-am', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[] LT',
        nextDay: '[] LT',
        lastDay: '[] LT',
        nextWeek: function () {
            return 'dddd [ ] LT';
        },
        lastWeek: function () {
            return '[] dddd [ ] LT';
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    meridiemParse: /|||/,
    isPM: function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-';
                }
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return hyAm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/id.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var id = moment.defineLocale('id', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'siang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sore' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'siang';
        } else if (hours < 19) {
            return 'sore';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Besok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kemarin pukul] LT',
        lastWeek : 'dddd [lalu pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lalu',
        s : 'beberapa detik',
        m : 'semenit',
        mm : '%d menit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return id;

})));


/***/ }),

/***/ "./node_modules/moment/locale/is.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(n) {
    if (n % 100 === 11) {
        return true;
    } else if (n % 10 === 1) {
        return false;
    }
    return true;
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
        case 'm':
            return withoutSuffix ? 'mnta' : 'mntu';
        case 'mm':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
            } else if (withoutSuffix) {
                return result + 'mnta';
            }
            return result + 'mntu';
        case 'hh':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dgum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mnuur';
            }
            return isFuture ? 'mnu' : 'mnui';
        case 'MM':
            if (plural(number)) {
                if (withoutSuffix) {
                    return result + 'mnuir';
                }
                return result + (isFuture ? 'mnui' : 'mnuum');
            } else if (withoutSuffix) {
                return result + 'mnuur';
            }
            return result + (isFuture ? 'mnu' : 'mnui');
        case 'y':
            return withoutSuffix || isFuture ? 'r' : 'ri';
        case 'yy':
            if (plural(number)) {
                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
            }
            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
}

var is = moment.defineLocale('is', {
    months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar : {
        sameDay : '[ dag kl.] LT',
        nextDay : '[ morgun kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[ gr kl.] LT',
        lastWeek : '[sasta] dddd [kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'eftir %s',
        past : 'fyrir %s san',
        s : translate,
        m : translate,
        mm : translate,
        h : 'klukkustund',
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return is;

})));


/***/ }),

/***/ "./node_modules/moment/locale/it.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var it = moment.defineLocale('it', {
    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays : 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Oggi alle] LT',
        nextDay: '[Domani alle] LT',
        nextWeek: 'dddd [alle] LT',
        lastDay: '[Ieri alle] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[la scorsa] dddd [alle] LT';
                default:
                    return '[lo scorso] dddd [alle] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : function (s) {
            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
        },
        past : '%s fa',
        s : 'alcuni secondi',
        m : 'un minuto',
        mm : '%d minuti',
        h : 'un\'ora',
        hh : '%d ore',
        d : 'un giorno',
        dd : '%d giorni',
        M : 'un mese',
        MM : '%d mesi',
        y : 'un anno',
        yy : '%d anni'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return it;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ja.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ja = moment.defineLocale('ja', {
    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYYMD',
        LLL : 'YYYYMD HH:mm',
        LLLL : 'YYYYMD HH:mm dddd',
        l : 'YYYY/MM/DD',
        ll : 'YYYYMD',
        lll : 'YYYYMD HH:mm',
        llll : 'YYYYMD HH:mm dddd'
    },
    meridiemParse: /|/i,
    isPM : function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[]dddd LT',
        lastDay : '[] LT',
        lastWeek : '[]dddd LT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1',
        mm : '%d',
        h : '1',
        hh : '%d',
        d : '1',
        dd : '%d',
        M : '1',
        MM : '%d',
        y : '1',
        yy : '%d'
    }
});

return ja;

})));


/***/ }),

/***/ "./node_modules/moment/locale/jv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var jv = moment.defineLocale('jv', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'enjing') {
            return hour;
        } else if (meridiem === 'siyang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'enjing';
        } else if (hours < 15) {
            return 'siyang';
        } else if (hours < 19) {
            return 'sonten';
        } else {
            return 'ndalu';
        }
    },
    calendar : {
        sameDay : '[Dinten puniko pukul] LT',
        nextDay : '[Mbenjang pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kala wingi pukul] LT',
        lastWeek : 'dddd [kepengker pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'wonten ing %s',
        past : '%s ingkang kepengker',
        s : 'sawetawis detik',
        m : 'setunggal menit',
        mm : '%d menit',
        h : 'setunggal jam',
        hh : '%d jam',
        d : 'sedinten',
        dd : '%d dinten',
        M : 'sewulan',
        MM : '%d wulan',
        y : 'setaun',
        yy : '%d taun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return jv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ka.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ka = moment.defineLocale('ka', {
    months : {
        standalone: '___________'.split('_'),
        format: '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /(|)/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[] LT[-]',
        nextDay : '[] LT[-]',
        lastDay : '[] LT[-]',
        nextWeek : '[] dddd LT[-]',
        lastWeek : '[] dddd LT-',
        sameElse : 'L'
    },
    relativeTime : {
        future : function (s) {
            return (/(|||)/).test(s) ?
                s.replace(/$/, '') :
                s + '';
        },
        past : function (s) {
            if ((/(||||)/).test(s)) {
                return s.replace(/(|)$/, ' ');
            }
            if ((//).test(s)) {
                return s.replace(/$/, ' ');
            }
        },
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal : function (number) {
        if (number === 0) {
            return number;
        }
        if (number === 1) {
            return number + '-';
        }
        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
            return '-' + number;
        }
        return number + '-';
    },
    week : {
        dow : 1,
        doy : 7
    }
});

return ka;

})));


/***/ }),

/***/ "./node_modules/moment/locale/kk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
};

var kk = moment.defineLocale('kk', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : '[ ] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return kk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/km.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var km = moment.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[ ] LT',
        lastWeek: 'dddd [] [] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: '%s',
        past: '%s',
        s: '',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

return km;

})));


/***/ }),

/***/ "./node_modules/moment/locale/kn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var kn = moment.defineLocale('kn', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal : function (number) {
        return number + '';
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return kn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ko.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ko = moment.defineLocale('ko', {
    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'YYYY.MM.DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D A h:mm',
        LLLL : 'YYYY MMMM D dddd A h:mm',
        l : 'YYYY.MM.DD',
        ll : 'YYYY MMMM D',
        lll : 'YYYY MMMM D A h:mm',
        llll : 'YYYY MMMM D dddd A h:mm'
    },
    calendar : {
        sameDay : ' LT',
        nextDay : ' LT',
        nextWeek : 'dddd LT',
        lastDay : ' LT',
        lastWeek : ' dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        ss : '%d',
        m : '1',
        mm : '%d',
        h : ' ',
        hh : '%d',
        d : '',
        dd : '%d',
        M : ' ',
        MM : '%d',
        y : ' ',
        yy : '%d'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
        }
    },
    meridiemParse : /|/,
    isPM : function (token) {
        return token === '';
    },
    meridiem : function (hour, minute, isUpper) {
        return hour < 12 ? '' : '';
    }
});

return ko;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ky.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
};

var ky = moment.defineLocale('ky', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : '[ ] dddd [] [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return ky;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lb.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eng Minutt', 'enger Minutt'],
        'h': ['eng Stonn', 'enger Stonn'],
        'd': ['een Dag', 'engem Dag'],
        'M': ['ee Mount', 'engem Mount'],
        'y': ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}
function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'a ' + string;
    }
    return 'an ' + string;
}
function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'viru ' + string;
    }
    return 'virun ' + string;
}
/**
 * Returns true if the word before the given number loses the '-n' ending.
 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
 *
 * @param number {integer}
 * @returns {boolean}
 */
function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);
    if (isNaN(number)) {
        return false;
    }
    if (number < 0) {
        // Negative Number --> always true
        return true;
    } else if (number < 10) {
        // Only 1 digit
        if (4 <= number && number <= 7) {
            return true;
        }
        return false;
    } else if (number < 100) {
        // 2 digits
        var lastDigit = number % 10, firstDigit = number / 10;
        if (lastDigit === 0) {
            return eifelerRegelAppliesToNumber(firstDigit);
        }
        return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
        // 3 or 4 digits --> recursively check first digit
        while (number >= 10) {
            number = number / 10;
        }
        return eifelerRegelAppliesToNumber(number);
    } else {
        // Anything larger than 4 digits: recursively check first n-3 digits
        number = number / 1000;
        return eifelerRegelAppliesToNumber(number);
    }
}

var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm [Auer]',
        LTS: 'H:mm:ss [Auer]',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm [Auer]',
        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
        sameDay: '[Haut um] LT',
        sameElse: 'L',
        nextDay: '[Muer um] LT',
        nextWeek: 'dddd [um] LT',
        lastDay: '[Gschter um] LT',
        lastWeek: function () {
            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
            switch (this.day()) {
                case 2:
                case 4:
                    return '[Leschten] dddd [um] LT';
                default:
                    return '[Leschte] dddd [um] LT';
            }
        }
    },
    relativeTime : {
        future : processFutureTime,
        past : processPastTime,
        s : 'e puer Sekonnen',
        m : processRelativeTime,
        mm : '%d Minutten',
        h : processRelativeTime,
        hh : '%d Stonnen',
        d : processRelativeTime,
        dd : '%d Deeg',
        M : processRelativeTime,
        MM : '%d Mint',
        y : processRelativeTime,
        yy : '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return lb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var lo = moment.defineLocale('lo', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[]dddd[] LT',
        lastDay : '[] LT',
        lastWeek : '[]dddd[] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal : function (number) {
        return '' + number;
    }
});

return lo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lt.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var units = {
    'm' : 'minut_minuts_minut',
    'mm': 'minuts_minui_minutes',
    'h' : 'valanda_valandos_valand',
    'hh': 'valandos_valand_valandas',
    'd' : 'diena_dienos_dien',
    'dd': 'dienos_dien_dienas',
    'M' : 'mnuo_mnesio_mnes',
    'MM': 'mnesiai_mnesi_mnesius',
    'y' : 'metai_met_metus',
    'yy': 'metai_met_metus'
};
function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
        return 'kelios sekunds';
    } else {
        return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
}
function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
}
function special(number) {
    return number % 10 === 0 || (number > 10 && number < 20);
}
function forms(key) {
    return units[key].split('_');
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    if (number === 1) {
        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
        if (isFuture) {
            return result + forms(key)[1];
        } else {
            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
        }
    }
}
var lt = moment.defineLocale('lt', {
    months : {
        format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
        standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays : {
        format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
        standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
        isFormat: /dddd HH:mm/
    },
    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY [m.] MMMM D [d.]',
        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
        l : 'YYYY-MM-DD',
        ll : 'YYYY [m.] MMMM D [d.]',
        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar : {
        sameDay : '[iandien] LT',
        nextDay : '[Rytoj] LT',
        nextWeek : 'dddd LT',
        lastDay : '[Vakar] LT',
        lastWeek : '[Prajus] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'po %s',
        past : 'prie %s',
        s : translateSeconds,
        m : translateSingular,
        mm : translate,
        h : translateSingular,
        hh : translate,
        d : translateSingular,
        dd : translate,
        M : translateSingular,
        MM : translate,
        y : translateSingular,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal : function (number) {
        return number + '-oji';
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return lt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var units = {
    'm': 'mintes_mintm_minte_mintes'.split('_'),
    'mm': 'mintes_mintm_minte_mintes'.split('_'),
    'h': 'stundas_stundm_stunda_stundas'.split('_'),
    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
    'd': 'dienas_dienm_diena_dienas'.split('_'),
    'dd': 'dienas_dienm_diena_dienas'.split('_'),
    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'y': 'gada_gadiem_gads_gadi'.split('_'),
    'yy': 'gada_gadiem_gads_gadi'.split('_')
};
/**
 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
 */
function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
        // E.g. "21 minte", "3 mintes".
        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
        // E.g. "21 mintes" as in "pc 21 mintes".
        // E.g. "3 mintm" as in "pc 3 mintm".
        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
}
function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
}
function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
}

var lv = moment.defineLocale('lv', {
    months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY.',
        LL : 'YYYY. [gada] D. MMMM',
        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar : {
        sameDay : '[odien pulksten] LT',
        nextDay : '[Rt pulksten] LT',
        nextWeek : 'dddd [pulksten] LT',
        lastDay : '[Vakar pulksten] LT',
        lastWeek : '[Pagju] dddd [pulksten] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'pc %s',
        past : 'pirms %s',
        s : relativeSeconds,
        m : relativeTimeWithSingular,
        mm : relativeTimeWithPlural,
        h : relativeTimeWithSingular,
        hh : relativeTimeWithPlural,
        d : relativeTimeWithSingular,
        dd : relativeTimeWithPlural,
        M : relativeTimeWithSingular,
        MM : relativeTimeWithPlural,
        y : relativeTimeWithSingular,
        yy : relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return lv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/me.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var translator = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jednog minuta'],
        mm: ['minut', 'minuta', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mjesec', 'mjeseca', 'mjeseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact : true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sjutra u] LT',

        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jue u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prole] [nedjelje] [u] LT',
                '[prolog] [ponedjeljka] [u] LT',
                '[prolog] [utorka] [u] LT',
                '[prole] [srijede] [u] LT',
                '[prolog] [etvrtka] [u] LT',
                '[prolog] [petka] [u] LT',
                '[prole] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'nekoliko sekundi',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : 'dan',
        dd     : translator.translate,
        M      : 'mjesec',
        MM     : translator.translate,
        y      : 'godinu',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return me;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var mi = moment.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY [i] HH:mm',
        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
        sameDay: '[i teie mahana, i] LT',
        nextDay: '[apopo i] LT',
        nextWeek: 'dddd [i] LT',
        lastDay: '[inanahi i] LT',
        lastWeek: 'dddd [whakamutunga i] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'i roto i %s',
        past: '%s i mua',
        s: 'te hkona ruarua',
        m: 'he meneti',
        mm: '%d meneti',
        h: 'te haora',
        hh: '%d haora',
        d: 'he ra',
        dd: '%d ra',
        M: 'he marama',
        MM: '%d marama',
        y: 'he tau',
        yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return mi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var mk = moment.defineLocale('mk', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : 'e_o_____a'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : '[] dddd [] LT',
        lastDay : '[ ] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : ' %s',
        s : ' ',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d ',
        M : '',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-';
        } else if (last2Digits === 0) {
            return number + '-';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-';
        } else if (lastDigit === 1) {
            return number + '-';
        } else if (lastDigit === 2) {
            return number + '-';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-';
        } else {
            return number + '-';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return mk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ml.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ml = moment.defineLocale('ml', {
    months : '___________'.split('_'),
    monthsShort : '._._._.___._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm -',
        LTS : 'A h:mm:ss -',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm -',
        LLLL : 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === '' && hour >= 4) ||
                meridiem === ' ' ||
                meridiem === '') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return ' ';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    }
});

return ml;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

function relativeTimeMr(number, withoutSuffix, string, isFuture)
{
    var output = '';
    if (withoutSuffix) {
        switch (string) {
            case 's': output = ' '; break;
            case 'm': output = ' '; break;
            case 'mm': output = '%d '; break;
            case 'h': output = ' '; break;
            case 'hh': output = '%d '; break;
            case 'd': output = ' '; break;
            case 'dd': output = '%d '; break;
            case 'M': output = ' '; break;
            case 'MM': output = '%d '; break;
            case 'y': output = ' '; break;
            case 'yy': output = '%d '; break;
        }
    }
    else {
        switch (string) {
            case 's': output = ' '; break;
            case 'm': output = ' '; break;
            case 'mm': output = '%d '; break;
            case 'h': output = ' '; break;
            case 'hh': output = '%d '; break;
            case 'd': output = ' '; break;
            case 'dd': output = '%d '; break;
            case 'M': output = ' '; break;
            case 'MM': output = '%d '; break;
            case 'y': output = ' '; break;
            case 'yy': output = '%d '; break;
        }
    }
    return output.replace(/%d/i, number);
}

var mr = moment.defineLocale('mr', {
    months : '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek: '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future: '%s',
        past: '%s',
        s: relativeTimeMr,
        m: relativeTimeMr,
        mm: relativeTimeMr,
        h: relativeTimeMr,
        hh: relativeTimeMr,
        d: relativeTimeMr,
        dd: relativeTimeMr,
        M: relativeTimeMr,
        MM: relativeTimeMr,
        y: relativeTimeMr,
        yy: relativeTimeMr
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem: function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return mr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ms-my.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var msMy = moment.defineLocale('ms-my', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return msMy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ms.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ms = moment.defineLocale('ms', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return ms;

})));


/***/ }),

/***/ "./node_modules/moment/locale/my.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var my = moment.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),

    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[.] LT []',
        nextDay: '[] LT []',
        nextWeek: 'dddd LT []',
        lastDay: '[.] LT []',
        lastWeek: '[] dddd LT []',
        sameElse: 'L'
    },
    relativeTime: {
        future: ' %s ',
        past: ' %s ',
        s: '.',
        m: '',
        mm: '%d ',
        h: '',
        hh: '%d ',
        d: '',
        dd: '%d ',
        M: '',
        MM: '%d ',
        y: '',
        yy: '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 1st is the first week of the year.
    }
});

return my;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nb.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var nb = moment.defineLocale('nb', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[i dag kl.] LT',
        nextDay: '[i morgen kl.] LT',
        nextWeek: 'dddd [kl.] LT',
        lastDay: '[i gr kl.] LT',
        lastWeek: '[forrige] dddd [kl.] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'noen sekunder',
        m : 'ett minutt',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dager',
        M : 'en mned',
        MM : '%d mneder',
        y : 'ett r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ne.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var ne = moment.defineLocale('ne', {
    months : '___________'.split('_'),
    monthsShort : '._.__.___._._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '._._._._._._.'.split('_'),
    weekdaysMin : '._._._._._._.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 3) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 16) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : '[] dddd[,] LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd[,] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return ne;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nl-be.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

var nlBe = moment.defineLocale('nl-be', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },

    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'n minuut',
        mm : '%d minuten',
        h : 'n uur',
        hh : '%d uur',
        d : 'n dag',
        dd : '%d dagen',
        M : 'n maand',
        MM : '%d maanden',
        y : 'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nlBe;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

var nl = moment.defineLocale('nl', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },

    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'n minuut',
        mm : '%d minuten',
        h : 'n uur',
        hh : '%d uur',
        d : 'n dag',
        dd : '%d dagen',
        M : 'n maand',
        MM : '%d maanden',
        y : 'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! author : https://github.com/mechuwind

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var nn = moment.defineLocale('nn', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
    weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[I dag klokka] LT',
        nextDay: '[I morgon klokka] LT',
        nextWeek: 'dddd [klokka] LT',
        lastDay: '[I gr klokka] LT',
        lastWeek: '[Fregande] dddd [klokka] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s sidan',
        s : 'nokre sekund',
        m : 'eit minutt',
        mm : '%d minutt',
        h : 'ein time',
        hh : '%d timar',
        d : 'ein dag',
        dd : '%d dagar',
        M : 'ein mnad',
        MM : '%d mnader',
        y : 'eit r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return nn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pa-in.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ',
        LTS : 'A h:mm:ss ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return paIn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
function plural(n) {
    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
}
function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minut';
        case 'mm':
            return result + (plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzin';
        case 'hh':
            return result + (plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural(number) ? 'miesice' : 'miesicy');
        case 'yy':
            return result + (plural(number) ? 'lata' : 'lat');
    }
}

var pl = moment.defineLocale('pl', {
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return monthsNominative;
        } else if (format === '') {
            // Hack: if format empty we know this is used to generate
            // RegExp by moment. Give then back both valid forms of months
            // in RegExp ready format.
            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
        } else if (/D MMMM/.test(format)) {
            return monthsSubjective[momentToFormat.month()];
        } else {
            return monthsNominative[momentToFormat.month()];
        }
    },
    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Dzi o] LT',
        nextDay: '[Jutro o] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[W niedziel o] LT';

                case 2:
                    return '[We wtorek o] LT';

                case 3:
                    return '[W rod o] LT';

                case 6:
                    return '[W sobot o] LT';

                default:
                    return '[W] dddd [o] LT';
            }
        },
        lastDay: '[Wczoraj o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[W zesz niedziel o] LT';
                case 3:
                    return '[W zesz rod o] LT';
                case 6:
                    return '[W zesz sobot o] LT';
                default:
                    return '[W zeszy] dddd [o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : '%s temu',
        s : 'kilka sekund',
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : '1 dzie',
        dd : '%d dni',
        M : 'miesic',
        MM : translate,
        y : 'rok',
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return pl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pt-br.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var ptBr = moment.defineLocale('pt-br', {
    months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar : {
        sameDay: '[Hoje s] LT',
        nextDay: '[Amanh s] LT',
        nextWeek: 'dddd [s] LT',
        lastDay: '[Ontem s] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : '%s atrs',
        s : 'poucos segundos',
        ss : '%d segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um ms',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d'
});

return ptBr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pt.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var pt = moment.defineLocale('pt', {
    months : 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort : 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin : 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hoje s] LT',
        nextDay: '[Amanh s] LT',
        nextWeek: 'dddd [s] LT',
        lastDay: '[Ontem s] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[ltimo] dddd [s] LT' : // Saturday + Sunday
                '[ltima] dddd [s] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : 'h %s',
        s : 'segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um ms',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return pt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ro.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
            'mm': 'minute',
            'hh': 'ore',
            'dd': 'zile',
            'MM': 'luni',
            'yy': 'ani'
        },
        separator = ' ';
    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
        separator = ' de ';
    }
    return number + separator + format[key];
}

var ro = moment.defineLocale('ro', {
    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[azi la] LT',
        nextDay: '[mine la] LT',
        nextWeek: 'dddd [la] LT',
        lastDay: '[ieri la] LT',
        lastWeek: '[fosta] dddd [la] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'peste %s',
        past : '%s n urm',
        s : 'cteva secunde',
        m : 'un minut',
        mm : relativeTimeWithPlural,
        h : 'o or',
        hh : relativeTimeWithPlural,
        d : 'o zi',
        dd : relativeTimeWithPlural,
        M : 'o lun',
        MM : relativeTimeWithPlural,
        y : 'un an',
        yy : relativeTimeWithPlural
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return ro;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ru.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}
var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

// http://new.gramota.ru/spravka/rules/139-prop :  103
//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
var ru = moment.defineLocale('ru', {
    months : {
        format: '___________'.split('_'),
        standalone: '___________'.split('_')
    },
    monthsShort : {
        //  CLDR  "."  ".",        ?
        format: '._._._.____._._._._.'.split('_'),
        standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays : {
        standalone: '______'.split('_'),
        format: '______'.split('_'),
        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
    },
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,

    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,

    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        lastDay: '[ ] LT',
        nextWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[] dddd [] LT';
                } else {
                    return '[] dddd [] LT';
                }
            }
        },
        lastWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[] dddd [] LT';
                } else {
                    return '[] dddd [] LT';
                }
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : '',
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    meridiemParse: /|||/i,
    isPM : function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ru;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sd.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var days = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var sd = moment.defineLocale('sd', {
    months : months,
    monthsShort : months,
    weekdays : days,
    weekdaysShort : days,
    weekdaysMin : days,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        }
        return '';
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd [  ] LT',
        lastDay : '[] LT',
        lastWeek : '[ ] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/se.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



var se = moment.defineLocale('se', {
    months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'MMMM D. [b.] YYYY',
        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar : {
        sameDay: '[otne ti] LT',
        nextDay: '[ihttin ti] LT',
        nextWeek: 'dddd [ti] LT',
        lastDay: '[ikte ti] LT',
        lastWeek: '[ovddit] dddd [ti] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s geaes',
        past : 'mait %s',
        s : 'moadde sekunddat',
        m : 'okta minuhta',
        mm : '%d minuhtat',
        h : 'okta diimmu',
        hh : '%d diimmut',
        d : 'okta beaivi',
        dd : '%d beaivvit',
        M : 'okta mnnu',
        MM : '%d mnut',
        y : 'okta jahki',
        yy : '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return se;

})));


/***/ }),

/***/ "./node_modules/moment/locale/si.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


/*jshint -W100*/
var si = moment.defineLocale('si', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'a h:mm',
        LTS : 'a h:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D, a h:mm',
        LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar : {
        sameDay : '[] LT[]',
        nextDay : '[] LT[]',
        nextWeek : 'dddd LT[]',
        lastDay : '[] LT[]',
        lastWeek : '[] dddd LT[]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s ',
        s : ' ',
        m : '',
        mm : ' %d',
        h : '',
        hh : ' %d',
        d : '',
        dd : ' %d',
        M : '',
        MM : ' %d',
        y : '',
        yy : ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal : function (number) {
        return number + ' ';
    },
    meridiemParse : / | |.|../,
    isPM : function (input) {
        return input === '..' || input === ' ';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? '..' : ' ';
        } else {
            return isLower ? '..' : ' ';
        }
    }
});

return si;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
function plural(n) {
    return (n > 1) && (n < 5);
}
function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'minty' : 'mint');
            } else {
                return result + 'mintami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'hodiny' : 'hodn');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de' : 'dom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'dni' : 'dn');
            } else {
                return result + 'dami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
    }
}

var sk = moment.defineLocale('sk', {
    months : months,
    monthsShort : monthsShort,
    weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[dnes o] LT',
        nextDay: '[zajtra o] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedeu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
            }
        },
        lastDay: '[vera o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minul nedeu o] LT';
                case 1:
                case 2:
                    return '[minul] dddd [o] LT';
                case 3:
                    return '[minul stredu o] LT';
                case 4:
                case 5:
                    return '[minul] dddd [o] LT';
                case 6:
                    return '[minul sobotu o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'pred %s',
        s : translate,
        m : translate,
        mm : translate,
        h : translate,
        hh : translate,
        d : translate,
        dd : translate,
        M : translate,
        MM : translate,
        y : translate,
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
    }
}

var sl = moment.defineLocale('sl', {
    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danes ob] LT',
        nextDay  : '[jutri ob] LT',

        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
            }
        },
        lastDay  : '[veraj ob] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[prejnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejnji] dddd [ob] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ez %s',
        past   : 'pred %s',
        s      : processRelativeTime,
        m      : processRelativeTime,
        mm     : processRelativeTime,
        h      : processRelativeTime,
        hh     : processRelativeTime,
        d      : processRelativeTime,
        dd     : processRelativeTime,
        M      : processRelativeTime,
        MM     : processRelativeTime,
        y      : processRelativeTime,
        yy     : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return sl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sq.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var sq = moment.defineLocale('sq', {
    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
        return input.charAt(0) === 'M';
    },
    meridiem : function (hours, minutes, isLower) {
        return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Sot n] LT',
        nextDay : '[Nesr n] LT',
        nextWeek : 'dddd [n] LT',
        lastDay : '[Dje n] LT',
        lastWeek : 'dddd [e kaluar n] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'n %s',
        past : '%s m par',
        s : 'disa sekonda',
        m : 'nj minut',
        mm : '%d minuta',
        h : 'nj or',
        hh : '%d or',
        d : 'nj dit',
        dd : '%d dit',
        M : 'nj muaj',
        MM : '%d muaj',
        y : 'nj vit',
        yy : '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sq;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sr-cyrl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var translator = {
    words: { //Different grammatical cases
        m: [' ', ' '],
        mm: ['', '', ''],
        h: [' ', ' '],
        hh: ['', '', ''],
        dd: ['', '', ''],
        MM: ['', '', ''],
        yy: ['', '', '']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

var srCyrl = moment.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[] [] [] LT';
                case 3:
                    return '[] [] [] LT';
                case 6:
                    return '[] [] [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
            }
        },
        lastDay  : '[ ] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT',
                '[] [] [] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past   : ' %s',
        s      : ' ',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : '',
        dd     : translator.translate,
        M      : '',
        MM     : translator.translate,
        y      : '',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return srCyrl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var translator = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jedne minute'],
        mm: ['minut', 'minute', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mesec', 'meseca', 'meseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sutra u] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jue u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prole] [nedelje] [u] LT',
                '[prolog] [ponedeljka] [u] LT',
                '[prolog] [utorka] [u] LT',
                '[prole] [srede] [u] LT',
                '[prolog] [etvrtka] [u] LT',
                '[prolog] [petka] [u] LT',
                '[prole] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'pre %s',
        s      : 'nekoliko sekundi',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : 'dan',
        dd     : translator.translate,
        M      : 'mesec',
        MM     : translator.translate,
        y      : 'godinu',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return sr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ss.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';



var ss = moment.defineLocale('ss', {
    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Namuhla nga] LT',
        nextDay : '[Kusasa nga] LT',
        nextWeek : 'dddd [nga] LT',
        lastDay : '[Itolo nga] LT',
        lastWeek : 'dddd [leliphelile] [nga] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'nga %s',
        past : 'wenteka nga %s',
        s : 'emizuzwana lomcane',
        m : 'umzuzu',
        mm : '%d emizuzu',
        h : 'lihora',
        hh : '%d emahora',
        d : 'lilanga',
        dd : '%d emalanga',
        M : 'inyanga',
        MM : '%d tinyanga',
        y : 'umnyaka',
        yy : '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'ekuseni';
        } else if (hours < 15) {
            return 'emini';
        } else if (hours < 19) {
            return 'entsambama';
        } else {
            return 'ebusuku';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'ekuseni') {
            return hour;
        } else if (meridiem === 'emini') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
            if (hour === 0) {
                return 0;
            }
            return hour + 12;
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ss;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sv.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var sv = moment.defineLocale('sv', {
    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Idag] LT',
        nextDay: '[Imorgon] LT',
        lastDay: '[Igr] LT',
        nextWeek: '[P] dddd LT',
        lastWeek: '[I] dddd[s] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : 'fr %s sedan',
        s : 'ngra sekunder',
        m : 'en minut',
        mm : '%d minuter',
        h : 'en timme',
        hh : '%d timmar',
        d : 'en dag',
        dd : '%d dagar',
        M : 'en mnad',
        MM : '%d mnader',
        y : 'ett r',
        yy : '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'e' :
            (b === 1) ? 'a' :
            (b === 2) ? 'a' :
            (b === 3) ? 'e' : 'e';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return sv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sw.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var sw = moment.defineLocale('sw', {
    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[leo saa] LT',
        nextDay : '[kesho saa] LT',
        nextWeek : '[wiki ijayo] dddd [saat] LT',
        lastDay : '[jana] LT',
        lastWeek : '[wiki iliyopita] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s baadaye',
        past : 'tokea %s',
        s : 'hivi punde',
        m : 'dakika moja',
        mm : 'dakika %d',
        h : 'saa limoja',
        hh : 'masaa %d',
        d : 'siku moja',
        dd : 'masiku %d',
        M : 'mwezi mmoja',
        MM : 'miezi %d',
        y : 'mwaka mmoja',
        yy : 'miaka %d'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return sw;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ta.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var symbolMap = {
    '1': '',
    '2': '',
    '3': '',
    '4': '',
    '5': '',
    '6': '',
    '7': '',
    '8': '',
    '9': '',
    '0': ''
};
var numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
};

var ta = moment.defineLocale('ta', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, HH:mm',
        LLLL : 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[ ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : '  ',
        m : ' ',
        mm : '%d ',
        h : '  ',
        hh : '%d  ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number + '';
    },
    preparse: function (string) {
        return string.replace(/[]/g, function (match) {
            return numberMap[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem : function (hour, minute, isLower) {
        if (hour < 2) {
            return ' ';
        } else if (hour < 6) {
            return ' ';  // 
        } else if (hour < 10) {
            return ' '; // 
        } else if (hour < 14) {
            return ' '; // 
        } else if (hour < 18) {
            return ' '; // 
        } else if (hour < 22) {
            return ' '; // 
        } else {
            return ' ';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 2 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else {
            return hour + 12;
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return ta;

})));


/***/ }),

/***/ "./node_modules/moment/locale/te.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var te = moment.defineLocale('te', {
    months : '___________'.split('_'),
    monthsShort : '._.__.____._._._._.'.split('_'),
    monthsParseExact : true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[] LT',
        nextDay : '[] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[] LT',
        lastWeek : '[] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    dayOfMonthOrdinalParse : /\d{1,2}/,
    ordinal : '%d',
    meridiemParse: /|||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 10) {
            return '';
        } else if (hour < 17) {
            return '';
        } else if (hour < 20) {
            return '';
        } else {
            return '';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

return te;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tet.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tet = moment.defineLocale('tet', {
    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Ohin iha] LT',
        nextDay: '[Aban iha] LT',
        nextWeek: 'dddd [iha] LT',
        lastDay: '[Horiseik iha] LT',
        lastWeek: 'dddd [semana kotuk] [iha] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'iha %s',
        past : '%s liuba',
        s : 'minutu balun',
        m : 'minutu ida',
        mm : 'minutus %d',
        h : 'horas ida',
        hh : 'horas %d',
        d : 'loron ida',
        dd : 'loron %d',
        M : 'fulan ida',
        MM : 'fulan %d',
        y : 'tinan ida',
        yy : 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return tet;

})));


/***/ }),

/***/ "./node_modules/moment/locale/th.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var th = moment.defineLocale('th', {
    months : '___________'.split('_'),
    monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'), // yes, three characters difference
    weekdaysMin : '._._._._._._.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY  H:mm',
        LLLL : 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
        return input === '';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd[ ] LT',
        lastDay : '[ ] LT',
        lastWeek : '[]dddd[ ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

return th;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tl-ph.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tlPh = moment.defineLocale('tl-ph', {
    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'MM/D/YYYY',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY HH:mm',
        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar : {
        sameDay: 'LT [ngayong araw]',
        nextDay: '[Bukas ng] LT',
        nextWeek: 'LT [sa susunod na] dddd',
        lastDay: 'LT [kahapon]',
        lastWeek: 'LT [noong nakaraang] dddd',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'sa loob ng %s',
        past : '%s ang nakalipas',
        s : 'ilang segundo',
        m : 'isang minuto',
        mm : '%d minuto',
        h : 'isang oras',
        hh : '%d oras',
        d : 'isang araw',
        dd : '%d araw',
        M : 'isang buwan',
        MM : '%d buwan',
        y : 'isang taon',
        yy : '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return tlPh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tlh.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

function translateFuture(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'leS' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'waQ' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'nem' :
    time + ' pIq';
    return time;
}

function translatePast(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'Hu' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'wen' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'ben' :
    time + ' ret';
    return time;
}

function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);
    switch (string) {
        case 'mm':
            return numberNoun + ' tup';
        case 'hh':
            return numberNoun + ' rep';
        case 'dd':
            return numberNoun + ' jaj';
        case 'MM':
            return numberNoun + ' jar';
        case 'yy':
            return numberNoun + ' DIS';
    }
}

function numberAsNoun(number) {
    var hundred = Math.floor((number % 1000) / 100),
    ten = Math.floor((number % 100) / 10),
    one = number % 10,
    word = '';
    if (hundred > 0) {
        word += numbersNouns[hundred] + 'vatlh';
    }
    if (ten > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
    }
    if (one > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
    }
    return (word === '') ? 'pagh' : word;
}

var tlh = moment.defineLocale('tlh', {
    months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact : true,
    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[DaHjaj] LT',
        nextDay: '[waleS] LT',
        nextWeek: 'LLL',
        lastDay: '[waHu] LT',
        lastWeek: 'LLL',
        sameElse: 'L'
    },
    relativeTime : {
        future : translateFuture,
        past : translatePast,
        s : 'puS lup',
        m : 'wa tup',
        mm : translate,
        h : 'wa rep',
        hh : translate,
        d : 'wa jaj',
        dd : translate,
        M : 'wa jar',
        MM : translate,
        y : 'wa DIS',
        yy : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return tlh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tr.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var suffixes = {
    1: '\'inci',
    5: '\'inci',
    8: '\'inci',
    70: '\'inci',
    80: '\'inci',
    2: '\'nci',
    7: '\'nci',
    20: '\'nci',
    50: '\'nci',
    3: '\'nc',
    4: '\'nc',
    100: '\'nc',
    6: '\'nc',
    9: '\'uncu',
    10: '\'uncu',
    30: '\'uncu',
    60: '\'nc',
    90: '\'nc'
};

var tr = moment.defineLocale('tr', {
    months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
    weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugn saat] LT',
        nextDay : '[yarn saat] LT',
        nextWeek : '[gelecek] dddd [saat] LT',
        lastDay : '[dn] LT',
        lastWeek : '[geen] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s nce',
        s : 'birka saniye',
        m : 'bir dakika',
        mm : '%d dakika',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gn',
        dd : '%d gn',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir yl',
        yy : '%d yl'
    },
    dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '\'nc';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return tr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzl.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
// This is currently too difficult (maybe even impossible) to add.
var tzl = moment.defineLocale('tzl', {
    months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM [dallas] YYYY',
        LLL : 'D. MMMM [dallas] YYYY HH.mm',
        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM : function (input) {
        return 'd\'o' === input.toLowerCase();
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'd\'o' : 'D\'O';
        } else {
            return isLower ? 'd\'a' : 'D\'A';
        }
    },
    calendar : {
        sameDay : '[oxhi ] LT',
        nextDay : '[dem ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[ieiri ] LT',
        lastWeek : '[sr el] dddd [lasteu ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'osprei %s',
        past : 'ja%s',
        s : processRelativeTime,
        m : processRelativeTime,
        mm : processRelativeTime,
        h : processRelativeTime,
        hh : processRelativeTime,
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['viensas secunds', '\'iensas secunds'],
        'm': ['\'n mut', '\'iens mut'],
        'mm': [number + ' muts', '' + number + ' muts'],
        'h': ['\'n ora', '\'iensa ora'],
        'hh': [number + ' oras', '' + number + ' oras'],
        'd': ['\'n ziua', '\'iensa ziua'],
        'dd': [number + ' ziuas', '' + number + ' ziuas'],
        'M': ['\'n mes', '\'iens mes'],
        'MM': [number + ' mesen', '' + number + ' mesen'],
        'y': ['\'n ar', '\'iens ar'],
        'yy': [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
}

return tzl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzm-latn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tzmLatn = moment.defineLocale('tzm-latn', {
    months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[asdkh g] LT',
        nextDay: '[aska g] LT',
        nextWeek: 'dddd [g] LT',
        lastDay: '[assant g] LT',
        lastWeek: 'dddd [g] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'dadkh s yan %s',
        past : 'yan %s',
        s : 'imik',
        m : 'minu',
        mm : '%d minu',
        h : 'saa',
        hh : '%d tassain',
        d : 'ass',
        dd : '%d ossan',
        M : 'ayowr',
        MM : '%d iyyirn',
        y : 'asgas',
        yy : '%d isgasn'
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return tzmLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzm.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var tzm = moment.defineLocale('tzm', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[ ] LT',
        nextDay: '[ ] LT',
        nextWeek: 'dddd [] LT',
        lastDay: '[ ] LT',
        lastWeek: 'dddd [] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '   %s',
        past : ' %s',
        s : '',
        m : '',
        mm : '%d ',
        h : '',
        hh : '%d ',
        d : '',
        dd : '%d o',
        M : 'o',
        MM : '%d ',
        y : '',
        yy : '%d '
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

return tzm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? '__' : '__',
        'hh': withoutSuffix ? '__' : '__',
        'dd': '__',
        'MM': '__',
        'yy': '__'
    };
    if (key === 'm') {
        return withoutSuffix ? '' : '';
    }
    else if (key === 'h') {
        return withoutSuffix ? '' : '';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}
function weekdaysCaseReplace(m, format) {
    var weekdays = {
        'nominative': '______'.split('_'),
        'accusative': '______'.split('_'),
        'genitive': '______'.split('_')
    };

    if (!m) {
        return weekdays['nominative'];
    }

    var nounCase = (/(\[[]\]) ?dddd/).test(format) ?
        'accusative' :
        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
            'genitive' :
            'nominative');
    return weekdays[nounCase][m.day()];
}
function processHoursFunction(str) {
    return function () {
        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
}

var uk = moment.defineLocale('uk', {
    months : {
        'format': '___________'.split('_'),
        'standalone': '___________'.split('_')
    },
    monthsShort : '___________'.split('_'),
    weekdays : weekdaysCaseReplace,
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY .',
        LLL : 'D MMMM YYYY ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar : {
        sameDay: processHoursFunction('[ '),
        nextDay: processHoursFunction('[ '),
        lastDay: processHoursFunction('[ '),
        nextWeek: processHoursFunction('[] dddd ['),
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[] dddd [').call(this);
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : ' %s',
        past : '%s ',
        s : ' ',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : '',
        hh : relativeTimeWithPlural,
        d : '',
        dd : relativeTimeWithPlural,
        M : '',
        MM : relativeTimeWithPlural,
        y : '',
        yy : relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function (input) {
        return /^(|)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return '';
        } else if (hour < 12) {
            return '';
        } else if (hour < 17) {
            return '';
        } else {
            return '';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return uk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ur.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var months = [
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];
var days = [
    '',
    '',
    '',
    '',
    '',
    '',
    ''
];

var ur = moment.defineLocale('ur', {
    months : months,
    monthsShort : months,
    weekdays : days,
    weekdaysShort : days,
    weekdaysMin : days,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM : function (input) {
        return '' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '';
        }
        return '';
    },
    calendar : {
        sameDay : '[ ] LT',
        nextDay : '[ ] LT',
        nextWeek : 'dddd [] LT',
        lastDay : '[  ] LT',
        lastWeek : '[] dddd [] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ',
        past : '%s ',
        s : ' ',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    preparse: function (string) {
        return string.replace(//g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return ur;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uz-latn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var uzLatn = moment.defineLocale('uz-latn', {
    months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[Bugun soat] LT [da]',
        nextDay : '[Ertaga] LT [da]',
        nextWeek : 'dddd [kuni soat] LT [da]',
        lastDay : '[Kecha soat] LT [da]',
        lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'Yaqin %s ichida',
        past : 'Bir necha %s oldin',
        s : 'soniya',
        m : 'bir daqiqa',
        mm : '%d daqiqa',
        h : 'bir soat',
        hh : '%d soat',
        d : 'bir kun',
        dd : '%d kun',
        M : 'bir oy',
        MM : '%d oy',
        y : 'bir yil',
        yy : '%d yil'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

return uzLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uz.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var uz = moment.defineLocale('uz', {
    months : '___________'.split('_'),
    monthsShort : '___________'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[ ] LT []',
        nextDay : '[] LT []',
        nextWeek : 'dddd [ ] LT []',
        lastDay : '[ ] LT []',
        lastWeek : '[] dddd [ ] LT []',
        sameElse : 'L'
    },
    relativeTime : {
        future : ' %s ',
        past : '  %s ',
        s : '',
        m : ' ',
        mm : '%d ',
        h : ' ',
        hh : '%d ',
        d : ' ',
        dd : '%d ',
        M : ' ',
        MM : '%d ',
        y : ' ',
        yy : '%d '
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 4th is the first week of the year.
    }
});

return uz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/vi.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var vi = moment.defineLocale('vi', {
    months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
    monthsParseExact : true,
    weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /sa|ch/i,
    isPM : function (input) {
        return /^ch$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'sa' : 'SA';
        } else {
            return isLower ? 'ch' : 'CH';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM [nm] YYYY',
        LLL : 'D MMMM [nm] YYYY HH:mm',
        LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
        l : 'DD/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hm nay lc] LT',
        nextDay: '[Ngy mai lc] LT',
        nextWeek: 'dddd [tun ti lc] LT',
        lastDay: '[Hm qua lc] LT',
        lastWeek: 'dddd [tun ri lc] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s ti',
        past : '%s trc',
        s : 'vi giy',
        m : 'mt pht',
        mm : '%d pht',
        h : 'mt gi',
        hh : '%d gi',
        d : 'mt ngy',
        dd : '%d ngy',
        M : 'mt thng',
        MM : '%d thng',
        y : 'mt nm',
        yy : '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return vi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/x-pseudo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var xPseudo = moment.defineLocale('x-pseudo', {
    months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact : true,
    weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[T~d~ t] LT',
        nextDay : '[T~m~rr~w t] LT',
        nextWeek : 'dddd [t] LT',
        lastDay : '[~st~rd~ t] LT',
        lastWeek : '[L~st] dddd [t] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '~ %s',
        past : '%s ~g',
        s : ' ~fw ~sc~ds',
        m : ' ~m~t',
        mm : '%d m~~ts',
        h : '~ h~r',
        hh : '%d h~rs',
        d : ' ~d',
        dd : '%d d~s',
        M : ' ~m~th',
        MM : '%d m~t~hs',
        y : ' ~r',
        yy : '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return xPseudo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/yo.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var yo = moment.defineLocale('yo', {
    months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Oni ni] LT',
        nextDay : '[la ni] LT',
        nextWeek : 'dddd [s ton\'b] [ni] LT',
        lastDay : '[Ana ni] LT',
        lastWeek : 'dddd [s tol] [ni] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ni %s',
        past : '%s kja',
        s : 'isju aaya die',
        m : 'isju kan',
        mm : 'isju %d',
        h : 'wakati kan',
        hh : 'wakati %d',
        d : 'j kan',
        dd : 'j %d',
        M : 'osu kan',
        MM : 'osu %d',
        y : 'dun kan',
        yy : 'dun %d'
    },
    dayOfMonthOrdinalParse : /j\s\d{1,2}/,
    ordinal : 'j %d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4 // The week that contains Jan 4th is the first week of the year.
    }
});

return yo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-cn.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var zhCn = moment.defineLocale('zh-cn', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMDAhmm',
        LLLL : 'YYYYMMMDddddAhmm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' ||
                meridiem === '') {
            return hour;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        } else {
            // ''
            return hour >= 11 ? hour : hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    },
    week : {
        // GB/T 7408-1994ISO 8601:1988
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return zhCn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-hk.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var zhHk = moment.defineLocale('zh-hk', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMD HH:mm',
        LLLL : 'YYYYMMMDdddd HH:mm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

return zhHk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-tw.js":
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

;(function (global, factory) {
    true ? factory(__webpack_require__("./node_modules/moment/moment.js")) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var zhTw = moment.defineLocale('zh-tw', {
    months : '___________'.split('_'),
    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays : '______'.split('_'),
    weekdaysShort : '______'.split('_'),
    weekdaysMin : '______'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYYMMMD',
        LL : 'YYYYMMMD',
        LLL : 'YYYYMMMD HH:mm',
        LLLL : 'YYYYMMMDdddd HH:mm',
        l : 'YYYYMMMD',
        ll : 'YYYYMMMD',
        lll : 'YYYYMMMD HH:mm',
        llll : 'YYYYMMMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '' || meridiem === '' || meridiem === '') {
            return hour;
        } else if (meridiem === '') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '' || meridiem === '') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '';
        } else if (hm < 900) {
            return '';
        } else if (hm < 1130) {
            return '';
        } else if (hm < 1230) {
            return '';
        } else if (hm < 1800) {
            return '';
        } else {
            return '';
        }
    },
    calendar : {
        sameDay : '[]LT',
        nextDay : '[]LT',
        nextWeek : '[]ddddLT',
        lastDay : '[]LT',
        lastWeek : '[]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s',
        past : '%s',
        s : '',
        m : '1 ',
        mm : '%d ',
        h : '1 ',
        hh : '%d ',
        d : '1 ',
        dd : '%d ',
        M : '1 ',
        MM : '%d ',
        y : '1 ',
        yy : '%d '
    }
});

return zhTw;

})));


/***/ }),

/***/ "./node_modules/moment/moment.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js
//! version : 2.19.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            __webpack_require__("./node_modules/moment/locale recursive ^\\.\\/.*$")("./" + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== config._d.getDay()) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.19.2';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

},["./app/Resources/assets/js/pages/dayOff.js"]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvUmVzb3VyY2VzL2Fzc2V0cy9qcy9wYWdlcy9kYXlPZmYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC1kYXRlcGlja2VyL2Rpc3QvanMvYm9vdHN0cmFwLWRhdGVwaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGVyYW5nZXBpY2tlci9kYXRlcmFuZ2VwaWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSBeXFwuXFwvLiokIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWR6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWt3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLW1hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXRuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2F6LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2R2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWllLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLXVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2Z5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dvbS1sYXRuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2d1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2phLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2thLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2trLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ttLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2t5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xiLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21pLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLW15LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL215LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLWJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BhLWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3J1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsLXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLWxhdG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LWxhdG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveC1wc2V1ZG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtdHcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyJdLCJuYW1lcyI6WyJjb25zb2xlIiwibG9nIiwiYXJyYXkiLCJmcmVlRGF5cyIsImRheXNPZmYiLCJldmVudCIsIiQiLCJkYXRlcmFuZ2VwaWNrZXIiLCJkYXRlc0Rpc2FibGVkIiwiSlNPTiIsInBhcnNlIiwibG9jYWxlIiwiZm9ybWF0IiwiZGF5c09mV2Vla0Rpc2FibGVkIiwidG9kYXlIaWdobGlnaHQiLCJkZWZhdWx0RGF0ZSIsIkRhdGUiLCJpc0ludmFsaWREYXRlIiwiZGF0ZSIsImRheSIsImluQXJyYXkiLCJmdWxsQ2FsZW5kYXIiLCJldmVudFNvdXJjZXMiLCJldmVudHMiLCJjb2xvciIsInRleHRDb2xvciIsImV2ZW50Q2xpY2siLCJqc0V2ZW50IiwidmlldyIsImlkIiwidW5kZWZpbmVkIiwibW9kYWwiLCJhdHRyIiwid2Vla2VuZHMiLCJlYWNoIiwia2V5IiwidmFsdWUiLCJldmVudDEiLCJhbGxEYXkiLCJuZXh0RGF5VGhyZXNob2xkIiwiZGF0ZXBpY2tlciIsImF1dG9jbG9zZSIsIm1pbkRhdGUiLCJvbiIsImUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBQSxRQUFRQyxHQUFSLENBQVlDLEtBQVo7QUFDQUYsUUFBUUMsR0FBUixDQUFZRSxRQUFaO0FBQ0FILFFBQVFDLEdBQVIsQ0FBWUcsT0FBWjtBQUNBLElBQUlDLFFBQVEsRUFBWjs7QUFHQSw4Q0FBQUMsQ0FBRSxZQUFZO0FBQ1ZBLElBQUEsOENBQUFBLENBQUUseUJBQUYsRUFBNkJDLGVBQTdCLENBQ0k7QUFDSUMsdUJBQWVDLEtBQUtDLEtBQUwsQ0FBV1IsS0FBWCxDQURuQjtBQUVJUyxnQkFBUTtBQUNKQyxvQkFBUSxZQURKO0FBRUpDLGdDQUFvQixJQUZoQjtBQUdKQyw0QkFBZ0IsSUFIWjtBQUlKQyx5QkFBYSxJQUFJQyxJQUFKO0FBSlQsU0FGWjtBQVFJQyx1QkFBZSx1QkFBVUMsSUFBVixFQUFnQjtBQUMzQixnQkFBSUEsS0FBS0MsR0FBTCxPQUFlLENBQWYsSUFBb0JELEtBQUtDLEdBQUwsT0FBZSxDQUFuQyxJQUF3Qyw4Q0FBQWIsQ0FBRWMsT0FBRixDQUFVRixLQUFLTixNQUFMLENBQVksWUFBWixDQUFWLEVBQXFDSCxLQUFLQyxLQUFMLENBQVdSLEtBQVgsQ0FBckMsTUFBNEQsQ0FBQyxDQUF6RyxFQUE0RztBQUN4Ryx1QkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFaTCxLQURKO0FBa0JILENBbkJEO0FBb0JBLDhDQUFBSSxDQUFFLFlBQVk7QUFDVkEsSUFBQSw4Q0FBQUEsQ0FBRSxXQUFGLEVBQWVlLFlBQWYsQ0FBNEI7O0FBRXBCQyxzQkFBYyxDQUNWO0FBQ0lDLG9CQUFRZCxLQUFLQyxLQUFMLENBQVdQLFFBQVgsQ0FEWjtBQUVJcUIsbUJBQU8sU0FGWCxFQUUwQjtBQUN0QkMsdUJBQVcsT0FIZixDQUd1Qjs7QUFIdkIsU0FEVSxDQUZNOztBQVdwQkMsb0JBQVksb0JBQVVyQixLQUFWLEVBQWlCc0IsT0FBakIsRUFBMEJDLElBQTFCLEVBQWdDO0FBQ3hDLGdCQUFJQyxLQUFLeEIsTUFBTXdCLEVBQWY7QUFDQSxnQkFBSUEsT0FBT0MsU0FBWCxFQUFzQjtBQUNsQix1QkFBTyxLQUFQO0FBQ0gsYUFGRCxNQUdLO0FBQ0R4QixnQkFBQSw4Q0FBQUEsQ0FBRSxXQUFGLEVBQWV5QixLQUFmO0FBQ0F6QixnQkFBQSw4Q0FBQUEsQ0FBRSxlQUFGLEVBQW1CMEIsSUFBbkIsQ0FBd0IsU0FBeEIsRUFBbUMsNEJBQTRCSCxFQUE1QixHQUFpQyxHQUFwRTtBQUNIO0FBQ0osU0FwQm1CO0FBcUJwQkksa0JBQVU7QUFyQlUsS0FBNUI7O0FBeUJBM0IsSUFBQSw4Q0FBQUEsQ0FBRTRCLElBQUYsQ0FBT3pCLEtBQUtDLEtBQUwsQ0FBV04sT0FBWCxDQUFQLEVBQTRCLFVBQVUrQixHQUFWLEVBQWVDLEtBQWYsRUFBc0I7QUFDOUMsWUFBSUMsU0FBUztBQUNUZCxvQkFBUWEsTUFBTSxTQUFOLENBREM7QUFFVEUsb0JBQVEsSUFGQztBQUdUQyw4QkFBa0IsVUFIVDtBQUlUZixtQkFBT1ksTUFBTSxPQUFOLENBSkUsRUFJa0I7QUFDM0JYLHVCQUFXLE9BTEYsQ0FLVTs7QUFMVixTQUFiOztBQVNBbkIsUUFBQSw4Q0FBQUEsQ0FBRSxXQUFGLEVBQWVlLFlBQWYsQ0FBNEIsZ0JBQTVCLEVBQThDZ0IsTUFBOUM7QUFDSCxLQVhEO0FBWUgsQ0F0Q0Q7O0FBd0NBLDhDQUFBL0IsQ0FBRSxZQUFZO0FBQ1ZOLFlBQVFDLEdBQVIsQ0FBWUMsS0FBWjtBQUNBSSxJQUFBLDhDQUFBQSxDQUFFLFdBQUYsRUFBZWtDLFVBQWYsQ0FBMEI7QUFDUkMsbUJBQVcsSUFESCxFQUNZO0FBQ3BCN0IsZ0JBQVEsWUFGQTtBQUdSSix1QkFBZUMsS0FBS0MsS0FBTCxDQUFXUixLQUFYLENBSFA7QUFJUlcsNEJBQW9CLElBSlo7QUFLUkMsd0JBQWdCLElBTFI7QUFNUjRCLGlCQUFTOztBQU5ELEtBQTFCLEVBVWVDLEVBVmYsQ0FVa0IsWUFWbEIsRUFVZ0MsVUFBVUMsQ0FBVixFQUFhLENBQzlCLENBWGY7QUFZSCxDQWRELEU7Ozs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEIsNkJBQTZCO0FBQ3ZEO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxzQ0FBc0MsMEJBQTBCO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQixNQUFNO0FBQ04sZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUNBQW1DLGFBQWEsRUFBRTtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixDQUFDOzs7Ozs7OztBQzcrREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQUE7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsNkNBQTZDLElBQUk7O0FBRTNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFNBQVM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELHNCQUFzQixFQUFFOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0UsY0FBYyxFQUFFOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxbEREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQy9FO0FBQ0Esa0JBQWtCLHVEQUF1RDs7QUFFekU7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELGlGQUFpRjtBQUNqRixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseURBQXlEO0FBQ3pELGNBQWMseUJBQXlCLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBNEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0JBQStCO0FBQ3RFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEMsbUNBQW1DLEVBQUU7QUFDckMsK0JBQStCO0FBQy9CO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxnREFBZ0Q7QUFDaEQsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQW1EO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCw4RUFBOEU7QUFDOUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLDhEQUE4RDtBQUM5RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNDQUFzQztBQUN0QztBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVEsMEJBQTBCO0FBQ2xDLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVEseUJBQXlCO0FBQ2pDLFFBQVEsd0JBQXdCO0FBQ2hDLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdHQUF3RztBQUMzSDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0dBQWdHO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUNqRSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUNqRSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QixxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVEQUF1RDtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixjQUFjO0FBQ25DLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQixHQUFHLDRCQUE0QjtBQUN4RztBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkJBQTJCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QjtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw2Q0FBNkM7QUFDN0MsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUE2RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELFNBQVM7QUFDVDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrREFBa0Q7OztBQUdsRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQSxvQ0FBb0M7QUFDcEMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0M7QUFDdEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUNBQXFDO0FBQ3JDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUNBQXVDO0FBQ3ZDLHFDQUFxQztBQUNyQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDO0FBQ3hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUEyRDtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXO0FBQ2hCLEtBQUssY0FBYztBQUNuQixLQUFLLGNBQWM7QUFDbkIsS0FBSyxjQUFjO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUNBQWlDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0Esd0RBQXdEO0FBQ3hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUUsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsNENBQTRDO0FBQzVDLDhEQUE4RDtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQscURBQXFEO0FBQ3JEO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLENBQUMsRTs7Ozs7OztBQzUyY0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0U7Ozs7Ozs7QUM1UEE7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQSx3RkFBd0Y7QUFDeEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxREQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3SEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4R0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFERDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3SUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4R0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDcklEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxREQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3RIRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDdEhEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0dEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUlEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDdkZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzS0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUREO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2hGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0VEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbkdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7QUFFNUI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdHQUFnRztBQUN6RztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNuR0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN4RUQ7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNGRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDL0VEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNqRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxR0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0VEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbEZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDMUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzVFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN6SEQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMzSEQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNoSkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDNUdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUksSUFBSSxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlGRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNsRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzlIRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDckVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxJQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDL0VEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMENBQTBDLElBQUksSUFBSSxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDeEZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDdEZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM3SEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbEZEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7OztBQUk1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3ZGRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDeElEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3JFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNwSEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDaEdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZELHlEQUF5RCxJQUFJO0FBQzdELHdEQUF3RCxJQUFJO0FBQzVELDhEQUE4RCxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMvREQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN6RkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDaEZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1Qyx3Q0FBd0M7QUFDeEMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1Qyw2Q0FBNkM7QUFDN0MsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0MsNENBQTRDO0FBQzVDLDZDQUE2QztBQUM3Qyw4Q0FBOEM7QUFDOUMsMkNBQTJDO0FBQzNDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDakZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQy9GRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxSEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDdkZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3ZGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNIRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDM0hEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNoRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3RMRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2pHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7Ozs7QUFJNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzVERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3RFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3JKRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDaktEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNyRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzdHRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0dEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7OztBQUk1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hGRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNwRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzFERDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCLFNBQVM7QUFDVCw4QkFBOEI7QUFDOUIsU0FBUztBQUNULDhCQUE4QjtBQUM5QixTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2pJRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hGRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbkVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDN0REO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDdkhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN6RkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUMxRkQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN6REQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUN6REQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELFFBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7OztBQUc1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3RKRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDbEdEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDekREO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7O0FDOUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUNuRUQ7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCxRQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCOzs7QUFHNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUMsSUFBSTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQzNERDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUM5R0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7OztBQ3hHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsUUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjs7O0FBRzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOzs7Ozs7Ozs4Q0N2R0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUI7O0FBRXRCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsSUFBSTs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0xBQXdMLElBQUk7O0FBRTVMLGlFQUFpRSxJQUFJOztBQUVyRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIseUJBQXlCLEVBQUUsRUFBRTtBQUM3Qix5QkFBeUIsRUFBRSxFQUFFO0FBQzdCLDhCQUE4QixFQUFFLEVBQUU7QUFDbEMsNkJBQTZCO0FBQzdCLGlDQUFpQztBQUNqQyxxQ0FBcUM7QUFDckMseUJBQXlCLElBQUksRUFBRTtBQUMvQix5QkFBeUIsSUFBSSxFQUFFO0FBQy9CLDhCQUE4QixJQUFJLEVBQUU7O0FBRXBDLDJCQUEyQjtBQUMzQixnQ0FBZ0M7O0FBRWhDLDBDQUEwQztBQUMxQyxpREFBaUQ7O0FBRWpELG9DQUFvQyxJQUFJLElBQUk7O0FBRTVDO0FBQ0E7QUFDQSw0SEFBNEgsSUFBSTs7O0FBR2hJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBOztBQUVBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxFQUFFLElBQUksRUFBRTtBQUMvQyxvQ0FBb0MsRUFBRSxJQUFJLEVBQUU7O0FBRTVDOztBQUVBO0FBQ0EsNkJBQTZCLEVBQUU7QUFDL0IsdUJBQXVCLEVBQUU7QUFDekIseUJBQXlCLEVBQUU7QUFDM0IsdUJBQXVCLEVBQUU7QUFDekIscUJBQXFCLEVBQUUsSUFBSSxFQUFFO0FBQzdCLG9CQUFvQixFQUFFO0FBQ3RCLDJCQUEyQixHQUFHO0FBQzlCLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0EsdUJBQXVCLEVBQUUsSUFBSSxFQUFFO0FBQy9CLHNCQUFzQixFQUFFLElBQUksRUFBRTtBQUM5QixvQkFBb0IsRUFBRTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBELElBQUksMERBQTBELElBQUkscUVBQXFFLEVBQUU7O0FBRW5NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw2QkFBNkI7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxxREFBcUQ7QUFDckQsMkRBQTJEO0FBQzNELG9EQUFvRCxPQUFPO0FBQzNELG9EQUFvRCxPQUFPO0FBQzNELG1EQUFtRCxPQUFPO0FBQzFELCtEQUErRCxPQUFPO0FBQ3RFLGlFQUFpRSxPQUFPO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7Ozs7OztBQ2w2SUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImRheU9mZi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XHJcbmltcG9ydCAnYm9vdHN0cmFwLXNhc3MnO1xyXG5pbXBvcnQgJ2Jvb3RzdHJhcC1kYXRlcGlja2VyJztcclxuaW1wb3J0ICdkYXRlcmFuZ2VwaWNrZXInO1xyXG5pbXBvcnQgJ2Z1bGxjYWxlbmRhcic7XHJcblxyXG4vL2RlbGV0ZSBjb25zb2xlIGxvZyBhdCB0aGUgZW5kXHJcbmNvbnNvbGUubG9nKGFycmF5KTtcclxuY29uc29sZS5sb2coZnJlZURheXMpO1xyXG5jb25zb2xlLmxvZyhkYXlzT2ZmKTtcclxudmFyIGV2ZW50ID0gW107XHJcblxyXG5cclxuJChmdW5jdGlvbiAoKSB7XHJcbiAgICAkKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlXCJdJykuZGF0ZXJhbmdlcGlja2VyKFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZGF0ZXNEaXNhYmxlZDogSlNPTi5wYXJzZShhcnJheSksXHJcbiAgICAgICAgICAgIGxvY2FsZToge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnTU0vREQvWVlZWScsXHJcbiAgICAgICAgICAgICAgICBkYXlzT2ZXZWVrRGlzYWJsZWQ6ICcwNicsXHJcbiAgICAgICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHREYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc0ludmFsaWREYXRlOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGUuZGF5KCkgPT09IDAgfHwgZGF0ZS5kYXkoKSA9PT0gNiB8fCAkLmluQXJyYXkoZGF0ZS5mb3JtYXQoJ01NL0REL1lZWVknKSwgSlNPTi5wYXJzZShhcnJheSkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB9XHJcbiAgICApO1xyXG59KTtcclxuJChmdW5jdGlvbiAoKSB7XHJcbiAgICAkKCcjY2FsZW5kYXInKS5mdWxsQ2FsZW5kYXIoe1xyXG5cclxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBKU09OLnBhcnNlKGZyZWVEYXlzKSxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNhOTQ0NDInLCAgICAgLy8gYW4gb3B0aW9uIVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJ3doaXRlJywvLyBhbiBvcHRpb24hXHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuXHJcbiAgICAgICAgICAgIGV2ZW50Q2xpY2s6IGZ1bmN0aW9uIChldmVudCwganNFdmVudCwgdmlldykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gZXZlbnQuaWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICQoJyNhZGRNb2RhbCcpLm1vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgJCgnI21vZGFsU2F2ZUJ0bicpLmF0dHIoJ29uY2xpY2snLCAnamF2YXNjcmlwdDptb3ZlRnJlZURheSgnICsgaWQgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3ZWVrZW5kczogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgJC5lYWNoKEpTT04ucGFyc2UoZGF5c09mZiksIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50MSA9IHtcclxuICAgICAgICAgICAgZXZlbnRzOiB2YWx1ZVsnZGF5c09mZiddLFxyXG4gICAgICAgICAgICBhbGxEYXk6IHRydWUsXHJcbiAgICAgICAgICAgIG5leHREYXlUaHJlc2hvbGQ6IFwiMDA6MDA6MDBcIixcclxuICAgICAgICAgICAgY29sb3I6IHZhbHVlWydjb2xvciddLCAgICAgLy8gYW4gb3B0aW9uIVxyXG4gICAgICAgICAgICB0ZXh0Q29sb3I6ICd3aGl0ZScgLy8gYW4gb3B0aW9uIVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkKCcjY2FsZW5kYXInKS5mdWxsQ2FsZW5kYXIoJ2FkZEV2ZW50U291cmNlJywgZXZlbnQxKTtcclxuICAgIH0pO1xyXG59KTtcclxuXHJcbiQoZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc29sZS5sb2coYXJyYXkpO1xyXG4gICAgJCgnI2RhdGV0aW1lJykuZGF0ZXBpY2tlcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICBhdXRvY2xvc2U6IHRydWUsICAgIC8vIEl0IGlzIGZhbHNlLCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdtbS9kZC95eXl5JyxcclxuICAgICAgICAgICAgICAgICAgICAgIGRhdGVzRGlzYWJsZWQ6IEpTT04ucGFyc2UoYXJyYXkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGF5c09mV2Vla0Rpc2FibGVkOiAnMDYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdG9kYXlIaWdobGlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtaW5EYXRlOiAwXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgLm9uKCdjaGFuZ2VEYXRlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgfSk7XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvUmVzb3VyY2VzL2Fzc2V0cy9qcy9wYWdlcy9kYXlPZmYuanMiLCIvKiFcclxuICogRGF0ZXBpY2tlciBmb3IgQm9vdHN0cmFwIHYxLjcuMSAoaHR0cHM6Ly9naXRodWIuY29tL3V4c29sdXRpb25zL2Jvb3RzdHJhcC1kYXRlcGlja2VyKVxyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgdjIuMCAoaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wKVxyXG4gKi9cclxuXHJcbihmdW5jdGlvbihmYWN0b3J5KXtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xyXG4gICAgfVxyXG59KGZ1bmN0aW9uKCQsIHVuZGVmaW5lZCl7XHJcblx0ZnVuY3Rpb24gVVRDRGF0ZSgpe1xyXG5cdFx0cmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KERhdGUsIGFyZ3VtZW50cykpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBVVENUb2RheSgpe1xyXG5cdFx0dmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcclxuXHRcdHJldHVybiBVVENEYXRlKHRvZGF5LmdldEZ1bGxZZWFyKCksIHRvZGF5LmdldE1vbnRoKCksIHRvZGF5LmdldERhdGUoKSk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGlzVVRDRXF1YWxzKGRhdGUxLCBkYXRlMikge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0ZGF0ZTEuZ2V0VVRDRnVsbFllYXIoKSA9PT0gZGF0ZTIuZ2V0VVRDRnVsbFllYXIoKSAmJlxyXG5cdFx0XHRkYXRlMS5nZXRVVENNb250aCgpID09PSBkYXRlMi5nZXRVVENNb250aCgpICYmXHJcblx0XHRcdGRhdGUxLmdldFVUQ0RhdGUoKSA9PT0gZGF0ZTIuZ2V0VVRDRGF0ZSgpXHJcblx0XHQpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBhbGlhcyhtZXRob2QsIGRlcHJlY2F0aW9uTXNnKXtcclxuXHRcdHJldHVybiBmdW5jdGlvbigpe1xyXG5cdFx0XHRpZiAoZGVwcmVjYXRpb25Nc2cgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdCQuZm4uZGF0ZXBpY2tlci5kZXByZWNhdGVkKGRlcHJlY2F0aW9uTXNnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gaXNWYWxpZERhdGUoZCkge1xyXG5cdFx0cmV0dXJuIGQgJiYgIWlzTmFOKGQuZ2V0VGltZSgpKTtcclxuXHR9XHJcblxyXG5cdHZhciBEYXRlQXJyYXkgPSAoZnVuY3Rpb24oKXtcclxuXHRcdHZhciBleHRyYXMgPSB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24oaSl7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2xpY2UoaSlbMF07XHJcblx0XHRcdH0sXHJcblx0XHRcdGNvbnRhaW5zOiBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHQvLyBBcnJheS5pbmRleE9mIGlzIG5vdCBjcm9zcy1icm93c2VyO1xyXG5cdFx0XHRcdC8vICQuaW5BcnJheSBkb2Vzbid0IHdvcmsgd2l0aCBEYXRlc1xyXG5cdFx0XHRcdHZhciB2YWwgPSBkICYmIGQudmFsdWVPZigpO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MCwgbD10aGlzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgIC8vIFVzZSBkYXRlIGFyaXRobWV0aWMgdG8gYWxsb3cgZGF0ZXMgd2l0aCBkaWZmZXJlbnQgdGltZXMgdG8gbWF0Y2hcclxuICAgICAgICAgIGlmICgwIDw9IHRoaXNbaV0udmFsdWVPZigpIC0gdmFsICYmIHRoaXNbaV0udmFsdWVPZigpIC0gdmFsIDwgMTAwMCo2MCo2MCoyNClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGk7XHJcblx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKGkpe1xyXG5cdFx0XHRcdHRoaXMuc3BsaWNlKGksMSk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHJlcGxhY2U6IGZ1bmN0aW9uKG5ld19hcnJheSl7XHJcblx0XHRcdFx0aWYgKCFuZXdfYXJyYXkpXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0aWYgKCEkLmlzQXJyYXkobmV3X2FycmF5KSlcclxuXHRcdFx0XHRcdG5ld19hcnJheSA9IFtuZXdfYXJyYXldO1xyXG5cdFx0XHRcdHRoaXMuY2xlYXIoKTtcclxuXHRcdFx0XHR0aGlzLnB1c2guYXBwbHkodGhpcywgbmV3X2FycmF5KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0Y2xlYXI6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0dGhpcy5sZW5ndGggPSAwO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjb3B5OiBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdHZhciBhID0gbmV3IERhdGVBcnJheSgpO1xyXG5cdFx0XHRcdGEucmVwbGFjZSh0aGlzKTtcclxuXHRcdFx0XHRyZXR1cm4gYTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGEgPSBbXTtcclxuXHRcdFx0YS5wdXNoLmFwcGx5KGEsIGFyZ3VtZW50cyk7XHJcblx0XHRcdCQuZXh0ZW5kKGEsIGV4dHJhcyk7XHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0fTtcclxuXHR9KSgpO1xyXG5cclxuXHJcblx0Ly8gUGlja2VyIG9iamVjdFxyXG5cclxuXHR2YXIgRGF0ZXBpY2tlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpe1xyXG5cdFx0JC5kYXRhKGVsZW1lbnQsICdkYXRlcGlja2VyJywgdGhpcyk7XHJcblx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMob3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5kYXRlcyA9IG5ldyBEYXRlQXJyYXkoKTtcclxuXHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm8uZGVmYXVsdFZpZXdEYXRlO1xyXG5cdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcblx0XHR0aGlzLmlzSW5wdXQgPSB0aGlzLmVsZW1lbnQuaXMoJ2lucHV0Jyk7XHJcblx0XHR0aGlzLmlucHV0RmllbGQgPSB0aGlzLmlzSW5wdXQgPyB0aGlzLmVsZW1lbnQgOiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKTtcclxuXHRcdHRoaXMuY29tcG9uZW50ID0gdGhpcy5lbGVtZW50Lmhhc0NsYXNzKCdkYXRlJykgPyB0aGlzLmVsZW1lbnQuZmluZCgnLmFkZC1vbiwgLmlucHV0LWdyb3VwLWFkZG9uLCAuYnRuJykgOiBmYWxzZTtcclxuXHRcdGlmICh0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmNvbXBvbmVudC5sZW5ndGggPT09IDApXHJcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzSW5saW5lID0gIXRoaXMuY29tcG9uZW50ICYmIHRoaXMuZWxlbWVudC5pcygnZGl2Jyk7XHJcblxyXG5cdFx0dGhpcy5waWNrZXIgPSAkKERQR2xvYmFsLnRlbXBsYXRlKTtcclxuXHJcblx0XHQvLyBDaGVja2luZyB0ZW1wbGF0ZXMgYW5kIGluc2VydGluZ1xyXG5cdFx0aWYgKHRoaXMuX2NoZWNrX3RlbXBsYXRlKHRoaXMuby50ZW1wbGF0ZXMubGVmdEFycm93KSkge1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLmh0bWwodGhpcy5vLnRlbXBsYXRlcy5sZWZ0QXJyb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLl9jaGVja190ZW1wbGF0ZSh0aGlzLm8udGVtcGxhdGVzLnJpZ2h0QXJyb3cpKSB7XHJcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5uZXh0JykuaHRtbCh0aGlzLm8udGVtcGxhdGVzLnJpZ2h0QXJyb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2J1aWxkRXZlbnRzKCk7XHJcblx0XHR0aGlzLl9hdHRhY2hFdmVudHMoKTtcclxuXHJcblx0XHRpZiAodGhpcy5pc0lubGluZSl7XHJcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWlubGluZScpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItZHJvcGRvd24gZHJvcGRvd24tbWVudScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm8ucnRsKXtcclxuXHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItcnRsJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuby5jYWxlbmRhcldlZWtzKSB7XHJcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgLmRhdGVwaWNrZXItc3dpdGNoLCB0aGVhZCAuZGF0ZXBpY2tlci10aXRsZSwgdGZvb3QgLnRvZGF5LCB0Zm9vdCAuY2xlYXInKVxyXG5cdFx0XHRcdC5hdHRyKCdjb2xzcGFuJywgZnVuY3Rpb24oaSwgdmFsKXtcclxuXHRcdFx0XHRcdHJldHVybiBOdW1iZXIodmFsKSArIDE7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtcclxuXHRcdFx0c3RhcnREYXRlOiB0aGlzLl9vLnN0YXJ0RGF0ZSxcclxuXHRcdFx0ZW5kRGF0ZTogdGhpcy5fby5lbmREYXRlLFxyXG5cdFx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQsXHJcblx0XHRcdGRheXNPZldlZWtIaWdobGlnaHRlZDogdGhpcy5vLmRheXNPZldlZWtIaWdobGlnaHRlZCxcclxuXHRcdFx0ZGF0ZXNEaXNhYmxlZDogdGhpcy5vLmRhdGVzRGlzYWJsZWRcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuX2FsbG93X3VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5zZXRWaWV3TW9kZSh0aGlzLm8uc3RhcnRWaWV3KTtcclxuXHRcdHRoaXMuX2FsbG93X3VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5maWxsRG93KCk7XHJcblx0XHR0aGlzLmZpbGxNb250aHMoKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmICh0aGlzLmlzSW5saW5lKXtcclxuXHRcdFx0dGhpcy5zaG93KCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0RGF0ZXBpY2tlci5wcm90b3R5cGUgPSB7XHJcblx0XHRjb25zdHJ1Y3RvcjogRGF0ZXBpY2tlcixcclxuXHJcblx0XHRfcmVzb2x2ZVZpZXdOYW1lOiBmdW5jdGlvbih2aWV3KXtcclxuXHRcdFx0JC5lYWNoKERQR2xvYmFsLnZpZXdNb2RlcywgZnVuY3Rpb24oaSwgdmlld01vZGUpe1xyXG5cdFx0XHRcdGlmICh2aWV3ID09PSBpIHx8ICQuaW5BcnJheSh2aWV3LCB2aWV3TW9kZS5uYW1lcykgIT09IC0xKXtcclxuXHRcdFx0XHRcdHZpZXcgPSBpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmlldztcclxuXHRcdH0sXHJcblxyXG5cdFx0X3Jlc29sdmVEYXlzT2ZXZWVrOiBmdW5jdGlvbihkYXlzT2ZXZWVrKXtcclxuXHRcdFx0aWYgKCEkLmlzQXJyYXkoZGF5c09mV2VlaykpXHJcblx0XHRcdFx0ZGF5c09mV2VlayA9IGRheXNPZldlZWsuc3BsaXQoL1ssXFxzXSovKTtcclxuXHRcdFx0cmV0dXJuICQubWFwKGRheXNPZldlZWssIE51bWJlcik7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9jaGVja190ZW1wbGF0ZTogZnVuY3Rpb24odG1wKXtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHQvLyBJZiBlbXB0eVxyXG5cdFx0XHRcdGlmICh0bXAgPT09IHVuZGVmaW5lZCB8fCB0bXAgPT09IFwiXCIpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gSWYgbm8gaHRtbCwgZXZlcnl0aGluZyBva1xyXG5cdFx0XHRcdGlmICgodG1wLm1hdGNoKC9bPD5dL2cpIHx8IFtdKS5sZW5ndGggPD0gMCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIENoZWNraW5nIGlmIGh0bWwgaXMgZmluZVxyXG5cdFx0XHRcdHZhciBqRG9tID0gJCh0bXApO1xyXG5cdFx0XHRcdHJldHVybiBqRG9tLmxlbmd0aCA+IDA7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2F0Y2ggKGV4KSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdF9wcm9jZXNzX29wdGlvbnM6IGZ1bmN0aW9uKG9wdHMpe1xyXG5cdFx0XHQvLyBTdG9yZSByYXcgb3B0aW9ucyBmb3IgcmVmZXJlbmNlXHJcblx0XHRcdHRoaXMuX28gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbywgb3B0cyk7XHJcblx0XHRcdC8vIFByb2Nlc3NlZCBvcHRpb25zXHJcblx0XHRcdHZhciBvID0gdGhpcy5vID0gJC5leHRlbmQoe30sIHRoaXMuX28pO1xyXG5cclxuXHRcdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXHJcblx0XHRcdC8vIGZhbGxiYWNrIHRvIDIgbGV0dGVyIGNvZGUgZWcgXCJkZVwiXHJcblx0XHRcdHZhciBsYW5nID0gby5sYW5ndWFnZTtcclxuXHRcdFx0aWYgKCFkYXRlc1tsYW5nXSl7XHJcblx0XHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXTtcclxuXHRcdFx0XHRpZiAoIWRhdGVzW2xhbmddKVxyXG5cdFx0XHRcdFx0bGFuZyA9IGRlZmF1bHRzLmxhbmd1YWdlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG8ubGFuZ3VhZ2UgPSBsYW5nO1xyXG5cclxuXHRcdFx0Ly8gUmV0cmlldmUgdmlldyBpbmRleCBmcm9tIGFueSBhbGlhc2VzXHJcblx0XHRcdG8uc3RhcnRWaWV3ID0gdGhpcy5fcmVzb2x2ZVZpZXdOYW1lKG8uc3RhcnRWaWV3KTtcclxuXHRcdFx0by5taW5WaWV3TW9kZSA9IHRoaXMuX3Jlc29sdmVWaWV3TmFtZShvLm1pblZpZXdNb2RlKTtcclxuXHRcdFx0by5tYXhWaWV3TW9kZSA9IHRoaXMuX3Jlc29sdmVWaWV3TmFtZShvLm1heFZpZXdNb2RlKTtcclxuXHJcblx0XHRcdC8vIENoZWNrIHZpZXcgaXMgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG5cdFx0XHRvLnN0YXJ0VmlldyA9IE1hdGgubWF4KHRoaXMuby5taW5WaWV3TW9kZSwgTWF0aC5taW4odGhpcy5vLm1heFZpZXdNb2RlLCBvLnN0YXJ0VmlldykpO1xyXG5cclxuXHRcdFx0Ly8gdHJ1ZSwgZmFsc2UsIG9yIE51bWJlciA+IDBcclxuXHRcdFx0aWYgKG8ubXVsdGlkYXRlICE9PSB0cnVlKXtcclxuXHRcdFx0XHRvLm11bHRpZGF0ZSA9IE51bWJlcihvLm11bHRpZGF0ZSkgfHwgZmFsc2U7XHJcblx0XHRcdFx0aWYgKG8ubXVsdGlkYXRlICE9PSBmYWxzZSlcclxuXHRcdFx0XHRcdG8ubXVsdGlkYXRlID0gTWF0aC5tYXgoMCwgby5tdWx0aWRhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG8ubXVsdGlkYXRlU2VwYXJhdG9yID0gU3RyaW5nKG8ubXVsdGlkYXRlU2VwYXJhdG9yKTtcclxuXHJcblx0XHRcdG8ud2Vla1N0YXJ0ICU9IDc7XHJcblx0XHRcdG8ud2Vla0VuZCA9IChvLndlZWtTdGFydCArIDYpICUgNztcclxuXHJcblx0XHRcdHZhciBmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChvLmZvcm1hdCk7XHJcblx0XHRcdGlmIChvLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5KXtcclxuXHRcdFx0XHRpZiAoISFvLnN0YXJ0RGF0ZSl7XHJcblx0XHRcdFx0XHRpZiAoby5zdGFydERhdGUgaW5zdGFuY2VvZiBEYXRlKVxyXG5cdFx0XHRcdFx0XHRvLnN0YXJ0RGF0ZSA9IHRoaXMuX2xvY2FsX3RvX3V0Yyh0aGlzLl96ZXJvX3RpbWUoby5zdGFydERhdGUpKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0by5zdGFydERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5zdGFydERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSwgby5hc3N1bWVOZWFyYnlZZWFyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRvLnN0YXJ0RGF0ZSA9IC1JbmZpbml0eTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG8uZW5kRGF0ZSAhPT0gSW5maW5pdHkpe1xyXG5cdFx0XHRcdGlmICghIW8uZW5kRGF0ZSl7XHJcblx0XHRcdFx0XHRpZiAoby5lbmREYXRlIGluc3RhbmNlb2YgRGF0ZSlcclxuXHRcdFx0XHRcdFx0by5lbmREYXRlID0gdGhpcy5fbG9jYWxfdG9fdXRjKHRoaXMuX3plcm9fdGltZShvLmVuZERhdGUpKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0by5lbmREYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKG8uZW5kRGF0ZSwgZm9ybWF0LCBvLmxhbmd1YWdlLCBvLmFzc3VtZU5lYXJieVllYXIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdG8uZW5kRGF0ZSA9IEluZmluaXR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSB0aGlzLl9yZXNvbHZlRGF5c09mV2VlayhvLmRheXNPZldlZWtEaXNhYmxlZHx8W10pO1xyXG5cdFx0XHRvLmRheXNPZldlZWtIaWdobGlnaHRlZCA9IHRoaXMuX3Jlc29sdmVEYXlzT2ZXZWVrKG8uZGF5c09mV2Vla0hpZ2hsaWdodGVkfHxbXSk7XHJcblxyXG5cdFx0XHRvLmRhdGVzRGlzYWJsZWQgPSBvLmRhdGVzRGlzYWJsZWR8fFtdO1xyXG5cdFx0XHRpZiAoISQuaXNBcnJheShvLmRhdGVzRGlzYWJsZWQpKSB7XHJcblx0XHRcdFx0by5kYXRlc0Rpc2FibGVkID0gby5kYXRlc0Rpc2FibGVkLnNwbGl0KCcsJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0by5kYXRlc0Rpc2FibGVkID0gJC5tYXAoby5kYXRlc0Rpc2FibGVkLCBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHRyZXR1cm4gRFBHbG9iYWwucGFyc2VEYXRlKGQsIGZvcm1hdCwgby5sYW5ndWFnZSwgby5hc3N1bWVOZWFyYnlZZWFyKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR2YXIgcGxjID0gU3RyaW5nKG8ub3JpZW50YXRpb24pLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvZyksXHJcblx0XHRcdFx0X3BsYyA9IG8ub3JpZW50YXRpb24udG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0cGxjID0gJC5ncmVwKHBsYywgZnVuY3Rpb24od29yZCl7XHJcblx0XHRcdFx0cmV0dXJuIC9eYXV0b3xsZWZ0fHJpZ2h0fHRvcHxib3R0b20kLy50ZXN0KHdvcmQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0by5vcmllbnRhdGlvbiA9IHt4OiAnYXV0bycsIHk6ICdhdXRvJ307XHJcblx0XHRcdGlmICghX3BsYyB8fCBfcGxjID09PSAnYXV0bycpXHJcblx0XHRcdFx0OyAvLyBubyBhY3Rpb25cclxuXHRcdFx0ZWxzZSBpZiAocGxjLmxlbmd0aCA9PT0gMSl7XHJcblx0XHRcdFx0c3dpdGNoIChwbGNbMF0pe1xyXG5cdFx0XHRcdFx0Y2FzZSAndG9wJzpcclxuXHRcdFx0XHRcdGNhc2UgJ2JvdHRvbSc6XHJcblx0XHRcdFx0XHRcdG8ub3JpZW50YXRpb24ueSA9IHBsY1swXTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdsZWZ0JzpcclxuXHRcdFx0XHRcdGNhc2UgJ3JpZ2h0JzpcclxuXHRcdFx0XHRcdFx0by5vcmllbnRhdGlvbi54ID0gcGxjWzBdO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0X3BsYyA9ICQuZ3JlcChwbGMsIGZ1bmN0aW9uKHdvcmQpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIC9ebGVmdHxyaWdodCQvLnRlc3Qod29yZCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0by5vcmllbnRhdGlvbi54ID0gX3BsY1swXSB8fCAnYXV0byc7XHJcblxyXG5cdFx0XHRcdF9wbGMgPSAkLmdyZXAocGxjLCBmdW5jdGlvbih3b3JkKXtcclxuXHRcdFx0XHRcdHJldHVybiAvXnRvcHxib3R0b20kLy50ZXN0KHdvcmQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdG8ub3JpZW50YXRpb24ueSA9IF9wbGNbMF0gfHwgJ2F1dG8nO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChvLmRlZmF1bHRWaWV3RGF0ZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG8uZGVmYXVsdFZpZXdEYXRlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdG8uZGVmYXVsdFZpZXdEYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKG8uZGVmYXVsdFZpZXdEYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UsIG8uYXNzdW1lTmVhcmJ5WWVhcik7XHJcblx0XHRcdH0gZWxzZSBpZiAoby5kZWZhdWx0Vmlld0RhdGUpIHtcclxuXHRcdFx0XHR2YXIgeWVhciA9IG8uZGVmYXVsdFZpZXdEYXRlLnllYXIgfHwgbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xyXG5cdFx0XHRcdHZhciBtb250aCA9IG8uZGVmYXVsdFZpZXdEYXRlLm1vbnRoIHx8IDA7XHJcblx0XHRcdFx0dmFyIGRheSA9IG8uZGVmYXVsdFZpZXdEYXRlLmRheSB8fCAxO1xyXG5cdFx0XHRcdG8uZGVmYXVsdFZpZXdEYXRlID0gVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvLmRlZmF1bHRWaWV3RGF0ZSA9IFVUQ1RvZGF5KCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRfZXZlbnRzOiBbXSxcclxuXHRcdF9zZWNvbmRhcnlFdmVudHM6IFtdLFxyXG5cdFx0X2FwcGx5RXZlbnRzOiBmdW5jdGlvbihldnMpe1xyXG5cdFx0XHRmb3IgKHZhciBpPTAsIGVsLCBjaCwgZXY7IGkgPCBldnMubGVuZ3RoOyBpKyspe1xyXG5cdFx0XHRcdGVsID0gZXZzW2ldWzBdO1xyXG5cdFx0XHRcdGlmIChldnNbaV0ubGVuZ3RoID09PSAyKXtcclxuXHRcdFx0XHRcdGNoID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0ZXYgPSBldnNbaV1bMV07XHJcblx0XHRcdFx0fSBlbHNlIGlmIChldnNbaV0ubGVuZ3RoID09PSAzKXtcclxuXHRcdFx0XHRcdGNoID0gZXZzW2ldWzFdO1xyXG5cdFx0XHRcdFx0ZXYgPSBldnNbaV1bMl07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsLm9uKGV2LCBjaCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRfdW5hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcclxuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgZXYsIGNoOyBpIDwgZXZzLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHRlbCA9IGV2c1tpXVswXTtcclxuXHRcdFx0XHRpZiAoZXZzW2ldLmxlbmd0aCA9PT0gMil7XHJcblx0XHRcdFx0XHRjaCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZXZzW2ldLmxlbmd0aCA9PT0gMyl7XHJcblx0XHRcdFx0XHRjaCA9IGV2c1tpXVsxXTtcclxuXHRcdFx0XHRcdGV2ID0gZXZzW2ldWzJdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbC5vZmYoZXYsIGNoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdF9idWlsZEV2ZW50czogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgIGtleXVwOiAkLnByb3h5KGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoZS5rZXlDb2RlLCBbMjcsIDM3LCAzOSwgMzgsIDQwLCAzMiwgMTMsIDldKSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSxcclxuICAgICAgICAgICAgICAgIGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgIHBhc3RlOiAkLnByb3h5KHRoaXMucGFzdGUsIHRoaXMpXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vLnNob3dPbkZvY3VzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMuZm9jdXMgPSAkLnByb3h5KHRoaXMuc2hvdywgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXQpIHsgLy8gc2luZ2xlIGlucHV0XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuZWxlbWVudCwgZXZlbnRzXVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQ6IGlucHV0ICsgYnV0dG9uXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuaW5wdXRGaWVsZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVhZG9ubHksIGFsbG93IGtleWJvYXJkIG5hdlxyXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLmlucHV0RmllbGQsIGV2ZW50c10sXHJcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMuY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcylcclxuICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXHJcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XHJcblx0XHRcdFx0XHRcdGNsaWNrOiAkLnByb3h5KHRoaXMuc2hvdywgdGhpcyksXHJcblx0XHRcdFx0XHRcdGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxyXG5cdFx0XHRcdFx0fV1cclxuXHRcdFx0XHRdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2V2ZW50cy5wdXNoKFxyXG5cdFx0XHRcdC8vIENvbXBvbmVudDogbGlzdGVuIGZvciBibHVyIG9uIGVsZW1lbnQgZGVzY2VuZGFudHNcclxuXHRcdFx0XHRbdGhpcy5lbGVtZW50LCAnKicsIHtcclxuXHRcdFx0XHRcdGJsdXI6ICQucHJveHkoZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2ZvY3VzZWRfZnJvbSA9IGUudGFyZ2V0O1xyXG5cdFx0XHRcdFx0fSwgdGhpcylcclxuXHRcdFx0XHR9XSxcclxuXHRcdFx0XHQvLyBJbnB1dDogbGlzdGVuIGZvciBibHVyIG9uIGVsZW1lbnRcclxuXHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XHJcblx0XHRcdFx0XHRibHVyOiAkLnByb3h5KGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9mb2N1c2VkX2Zyb20gPSBlLnRhcmdldDtcclxuXHRcdFx0XHRcdH0sIHRoaXMpXHJcblx0XHRcdFx0fV1cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm8uaW1tZWRpYXRlVXBkYXRlcykge1xyXG5cdFx0XHRcdC8vIFRyaWdnZXIgaW5wdXQgdXBkYXRlcyBpbW1lZGlhdGVseSBvbiBjaGFuZ2VkIHllYXIvbW9udGhcclxuXHRcdFx0XHR0aGlzLl9ldmVudHMucHVzaChbdGhpcy5lbGVtZW50LCB7XHJcblx0XHRcdFx0XHQnY2hhbmdlWWVhciBjaGFuZ2VNb250aCc6ICQucHJveHkoZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKGUuZGF0ZSk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKVxyXG5cdFx0XHRcdH1dKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fc2Vjb25kYXJ5RXZlbnRzID0gW1xyXG5cdFx0XHRcdFt0aGlzLnBpY2tlciwge1xyXG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5jbGljaywgdGhpcylcclxuXHRcdFx0XHR9XSxcclxuXHRcdFx0XHRbdGhpcy5waWNrZXIsICcucHJldiwgLm5leHQnLCB7XHJcblx0XHRcdFx0XHRjbGljazogJC5wcm94eSh0aGlzLm5hdkFycm93c0NsaWNrLCB0aGlzKVxyXG5cdFx0XHRcdH1dLFxyXG5cdFx0XHRcdFt0aGlzLnBpY2tlciwgJy5kYXk6bm90KC5kaXNhYmxlZCknLCB7XHJcblx0XHRcdFx0XHRjbGljazogJC5wcm94eSh0aGlzLmRheUNlbGxDbGljaywgdGhpcylcclxuXHRcdFx0XHR9XSxcclxuXHRcdFx0XHRbJCh3aW5kb3cpLCB7XHJcblx0XHRcdFx0XHRyZXNpemU6ICQucHJveHkodGhpcy5wbGFjZSwgdGhpcylcclxuXHRcdFx0XHR9XSxcclxuXHRcdFx0XHRbJChkb2N1bWVudCksIHtcclxuXHRcdFx0XHRcdCdtb3VzZWRvd24gdG91Y2hzdGFydCc6ICQucHJveHkoZnVuY3Rpb24oZSl7XHJcblx0XHRcdFx0XHRcdC8vIENsaWNrZWQgb3V0c2lkZSB0aGUgZGF0ZXBpY2tlciwgaGlkZSBpdFxyXG5cdFx0XHRcdFx0XHRpZiAoIShcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuaXMoZS50YXJnZXQpIHx8XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCB8fFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmlzKGUudGFyZ2V0KSB8fFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoZS50YXJnZXQpLmxlbmd0aCB8fFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuaXNJbmxpbmVcclxuXHRcdFx0XHRcdFx0KSl7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0sIHRoaXMpXHJcblx0XHRcdFx0fV1cclxuXHRcdFx0XTtcclxuXHRcdH0sXHJcblx0XHRfYXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGlzLl9kZXRhY2hFdmVudHMoKTtcclxuXHRcdFx0dGhpcy5fYXBwbHlFdmVudHModGhpcy5fZXZlbnRzKTtcclxuXHRcdH0sXHJcblx0XHRfZGV0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGlzLl91bmFwcGx5RXZlbnRzKHRoaXMuX2V2ZW50cyk7XHJcblx0XHR9LFxyXG5cdFx0X2F0dGFjaFNlY29uZGFyeUV2ZW50czogZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XHJcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX3NlY29uZGFyeUV2ZW50cyk7XHJcblx0XHR9LFxyXG5cdFx0X2RldGFjaFNlY29uZGFyeUV2ZW50czogZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xyXG5cdFx0fSxcclxuXHRcdF90cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgYWx0ZGF0ZSl7XHJcblx0XHRcdHZhciBkYXRlID0gYWx0ZGF0ZSB8fCB0aGlzLmRhdGVzLmdldCgtMSksXHJcblx0XHRcdFx0bG9jYWxfZGF0ZSA9IHRoaXMuX3V0Y190b19sb2NhbChkYXRlKTtcclxuXHJcblx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VyKHtcclxuXHRcdFx0XHR0eXBlOiBldmVudCxcclxuXHRcdFx0XHRkYXRlOiBsb2NhbF9kYXRlLFxyXG5cdFx0XHRcdHZpZXdNb2RlOiB0aGlzLnZpZXdNb2RlLFxyXG5cdFx0XHRcdGRhdGVzOiAkLm1hcCh0aGlzLmRhdGVzLCB0aGlzLl91dGNfdG9fbG9jYWwpLFxyXG5cdFx0XHRcdGZvcm1hdDogJC5wcm94eShmdW5jdGlvbihpeCwgZm9ybWF0KXtcclxuXHRcdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKXtcclxuXHRcdFx0XHRcdFx0aXggPSB0aGlzLmRhdGVzLmxlbmd0aCAtIDE7XHJcblx0XHRcdFx0XHRcdGZvcm1hdCA9IHRoaXMuby5mb3JtYXQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpeCA9PT0gJ3N0cmluZycpe1xyXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSBpeDtcclxuXHRcdFx0XHRcdFx0aXggPSB0aGlzLmRhdGVzLmxlbmd0aCAtIDE7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5vLmZvcm1hdDtcclxuXHRcdFx0XHRcdHZhciBkYXRlID0gdGhpcy5kYXRlcy5nZXQoaXgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIERQR2xvYmFsLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpO1xyXG5cdFx0XHRcdH0sIHRoaXMpXHJcblx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzaG93OiBmdW5jdGlvbigpe1xyXG5cdFx0XHRpZiAodGhpcy5pbnB1dEZpZWxkLnByb3AoJ2Rpc2FibGVkJykgfHwgKHRoaXMuaW5wdXRGaWVsZC5wcm9wKCdyZWFkb25seScpICYmIHRoaXMuby5lbmFibGVPblJlYWRvbmx5ID09PSBmYWxzZSkpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNJbmxpbmUpXHJcblx0XHRcdFx0dGhpcy5waWNrZXIuYXBwZW5kVG8odGhpcy5vLmNvbnRhaW5lcik7XHJcblx0XHRcdHRoaXMucGxhY2UoKTtcclxuXHRcdFx0dGhpcy5waWNrZXIuc2hvdygpO1xyXG5cdFx0XHR0aGlzLl9hdHRhY2hTZWNvbmRhcnlFdmVudHMoKTtcclxuXHRcdFx0dGhpcy5fdHJpZ2dlcignc2hvdycpO1xyXG5cdFx0XHRpZiAoKHdpbmRvdy5uYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyB8fCAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudCkgJiYgdGhpcy5vLmRpc2FibGVUb3VjaEtleWJvYXJkKSB7XHJcblx0XHRcdFx0JCh0aGlzLmVsZW1lbnQpLmJsdXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0aGlkZTogZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYgKHRoaXMuaXNJbmxpbmUgfHwgIXRoaXMucGlja2VyLmlzKCc6dmlzaWJsZScpKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR0aGlzLmZvY3VzRGF0ZSA9IG51bGw7XHJcblx0XHRcdHRoaXMucGlja2VyLmhpZGUoKS5kZXRhY2goKTtcclxuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XHJcblx0XHRcdHRoaXMuc2V0Vmlld01vZGUodGhpcy5vLnN0YXJ0Vmlldyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vLmZvcmNlUGFyc2UgJiYgdGhpcy5pbnB1dEZpZWxkLnZhbCgpKVxyXG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcclxuXHRcdFx0dGhpcy5fdHJpZ2dlcignaGlkZScpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKXtcclxuXHRcdFx0dGhpcy5oaWRlKCk7XHJcblx0XHRcdHRoaXMuX2RldGFjaEV2ZW50cygpO1xyXG5cdFx0XHR0aGlzLl9kZXRhY2hTZWNvbmRhcnlFdmVudHMoKTtcclxuXHRcdFx0dGhpcy5waWNrZXIucmVtb3ZlKCk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XHJcblx0XHRcdGlmICghdGhpcy5pc0lucHV0KXtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRwYXN0ZTogZnVuY3Rpb24oZSl7XHJcblx0XHRcdHZhciBkYXRlU3RyaW5nO1xyXG5cdFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEgJiYgZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEudHlwZXNcclxuXHRcdFx0XHQmJiAkLmluQXJyYXkoJ3RleHQvcGxhaW4nLCBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS50eXBlcykgIT09IC0xKSB7XHJcblx0XHRcdFx0ZGF0ZVN0cmluZyA9IGUub3JpZ2luYWxFdmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcclxuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cuY2xpcGJvYXJkRGF0YSkge1xyXG5cdFx0XHRcdGRhdGVTdHJpbmcgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCdUZXh0Jyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuc2V0RGF0ZShkYXRlU3RyaW5nKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfdXRjX3RvX2xvY2FsOiBmdW5jdGlvbih1dGMpe1xyXG5cdFx0XHRpZiAoIXV0Yykge1xyXG5cdFx0XHRcdHJldHVybiB1dGM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBsb2NhbCA9IG5ldyBEYXRlKHV0Yy5nZXRUaW1lKCkgKyAodXRjLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkpO1xyXG5cclxuXHRcdFx0aWYgKGxvY2FsLmdldFRpbWV6b25lT2Zmc2V0KCkgIT09IHV0Yy5nZXRUaW1lem9uZU9mZnNldCgpKSB7XHJcblx0XHRcdFx0bG9jYWwgPSBuZXcgRGF0ZSh1dGMuZ2V0VGltZSgpICsgKGxvY2FsLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbG9jYWw7XHJcblx0XHR9LFxyXG5cdFx0X2xvY2FsX3RvX3V0YzogZnVuY3Rpb24obG9jYWwpe1xyXG5cdFx0XHRyZXR1cm4gbG9jYWwgJiYgbmV3IERhdGUobG9jYWwuZ2V0VGltZSgpIC0gKGxvY2FsLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDApKTtcclxuXHRcdH0sXHJcblx0XHRfemVyb190aW1lOiBmdW5jdGlvbihsb2NhbCl7XHJcblx0XHRcdHJldHVybiBsb2NhbCAmJiBuZXcgRGF0ZShsb2NhbC5nZXRGdWxsWWVhcigpLCBsb2NhbC5nZXRNb250aCgpLCBsb2NhbC5nZXREYXRlKCkpO1xyXG5cdFx0fSxcclxuXHRcdF96ZXJvX3V0Y190aW1lOiBmdW5jdGlvbih1dGMpe1xyXG5cdFx0XHRyZXR1cm4gdXRjICYmIFVUQ0RhdGUodXRjLmdldFVUQ0Z1bGxZZWFyKCksIHV0Yy5nZXRVVENNb250aCgpLCB1dGMuZ2V0VVRDRGF0ZSgpKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0RGF0ZXM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHJldHVybiAkLm1hcCh0aGlzLmRhdGVzLCB0aGlzLl91dGNfdG9fbG9jYWwpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRVVENEYXRlczogZnVuY3Rpb24oKXtcclxuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuZGF0ZXMsIGZ1bmN0aW9uKGQpe1xyXG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZShkKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGdldERhdGU6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHJldHVybiB0aGlzLl91dGNfdG9fbG9jYWwodGhpcy5nZXRVVENEYXRlKCkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRVVENEYXRlOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgc2VsZWN0ZWRfZGF0ZSA9IHRoaXMuZGF0ZXMuZ2V0KC0xKTtcclxuXHRcdFx0aWYgKHNlbGVjdGVkX2RhdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgRGF0ZShzZWxlY3RlZF9kYXRlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRjbGVhckRhdGVzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR0aGlzLmlucHV0RmllbGQudmFsKCcnKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UpIHtcclxuXHRcdFx0XHR0aGlzLmhpZGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREYXRlczogZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGFyZ3MgPSAkLmlzQXJyYXkoYXJndW1lbnRzWzBdKSA/IGFyZ3VtZW50c1swXSA6IGFyZ3VtZW50cztcclxuXHRcdFx0dGhpcy51cGRhdGUuYXBwbHkodGhpcywgYXJncyk7XHJcblx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcclxuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0VVRDRGF0ZXM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHZhciBhcmdzID0gJC5pc0FycmF5KGFyZ3VtZW50c1swXSkgPyBhcmd1bWVudHNbMF0gOiBhcmd1bWVudHM7XHJcblx0XHRcdHRoaXMuc2V0RGF0ZXMuYXBwbHkodGhpcywgJC5tYXAoYXJncywgdGhpcy5fdXRjX3RvX2xvY2FsKSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREYXRlOiBhbGlhcygnc2V0RGF0ZXMnKSxcclxuXHRcdHNldFVUQ0RhdGU6IGFsaWFzKCdzZXRVVENEYXRlcycpLFxyXG5cdFx0cmVtb3ZlOiBhbGlhcygnZGVzdHJveScsICdNZXRob2QgYHJlbW92ZWAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMi4wLiBVc2UgYGRlc3Ryb3lgIGluc3RlYWQnKSxcclxuXHJcblx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpO1xyXG5cdFx0XHR0aGlzLmlucHV0RmllbGQudmFsKGZvcm1hdHRlZCk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRGb3JtYXR0ZWREYXRlOiBmdW5jdGlvbihmb3JtYXQpe1xyXG5cdFx0XHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0Zm9ybWF0ID0gdGhpcy5vLmZvcm1hdDtcclxuXHJcblx0XHRcdHZhciBsYW5nID0gdGhpcy5vLmxhbmd1YWdlO1xyXG5cdFx0XHRyZXR1cm4gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7XHJcblx0XHRcdFx0cmV0dXJuIERQR2xvYmFsLmZvcm1hdERhdGUoZCwgZm9ybWF0LCBsYW5nKTtcclxuXHRcdFx0fSkuam9pbih0aGlzLm8ubXVsdGlkYXRlU2VwYXJhdG9yKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0U3RhcnREYXRlOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vLnN0YXJ0RGF0ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0U3RhcnREYXRlOiBmdW5jdGlvbihzdGFydERhdGUpe1xyXG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe3N0YXJ0RGF0ZTogc3RhcnREYXRlfSk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdHRoaXMudXBkYXRlTmF2QXJyb3dzKCk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRFbmREYXRlOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vLmVuZERhdGU7XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEVuZERhdGU6IGZ1bmN0aW9uKGVuZERhdGUpe1xyXG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2VuZERhdGU6IGVuZERhdGV9KTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldERheXNPZldlZWtEaXNhYmxlZDogZnVuY3Rpb24oZGF5c09mV2Vla0Rpc2FibGVkKXtcclxuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtkYXlzT2ZXZWVrRGlzYWJsZWQ6IGRheXNPZldlZWtEaXNhYmxlZH0pO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RGF5c09mV2Vla0hpZ2hsaWdodGVkOiBmdW5jdGlvbihkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQpe1xyXG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RheXNPZldlZWtIaWdobGlnaHRlZDogZGF5c09mV2Vla0hpZ2hsaWdodGVkfSk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREYXRlc0Rpc2FibGVkOiBmdW5jdGlvbihkYXRlc0Rpc2FibGVkKXtcclxuXHRcdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKHtkYXRlc0Rpc2FibGVkOiBkYXRlc0Rpc2FibGVkfSk7XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fSxcclxuXHJcblx0XHRwbGFjZTogZnVuY3Rpb24oKXtcclxuXHRcdFx0aWYgKHRoaXMuaXNJbmxpbmUpXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdHZhciBjYWxlbmRhcldpZHRoID0gdGhpcy5waWNrZXIub3V0ZXJXaWR0aCgpLFxyXG5cdFx0XHRcdGNhbGVuZGFySGVpZ2h0ID0gdGhpcy5waWNrZXIub3V0ZXJIZWlnaHQoKSxcclxuXHRcdFx0XHR2aXN1YWxQYWRkaW5nID0gMTAsXHJcblx0XHRcdFx0Y29udGFpbmVyID0gJCh0aGlzLm8uY29udGFpbmVyKSxcclxuXHRcdFx0XHR3aW5kb3dXaWR0aCA9IGNvbnRhaW5lci53aWR0aCgpLFxyXG5cdFx0XHRcdHNjcm9sbFRvcCA9IHRoaXMuby5jb250YWluZXIgPT09ICdib2R5JyA/ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDogY29udGFpbmVyLnNjcm9sbFRvcCgpLFxyXG5cdFx0XHRcdGFwcGVuZE9mZnNldCA9IGNvbnRhaW5lci5vZmZzZXQoKTtcclxuXHJcblx0XHRcdHZhciBwYXJlbnRzWmluZGV4ID0gWzBdO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnQucGFyZW50cygpLmVhY2goZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR2YXIgaXRlbVpJbmRleCA9ICQodGhpcykuY3NzKCd6LWluZGV4Jyk7XHJcblx0XHRcdFx0aWYgKGl0ZW1aSW5kZXggIT09ICdhdXRvJyAmJiBOdW1iZXIoaXRlbVpJbmRleCkgIT09IDApIHBhcmVudHNaaW5kZXgucHVzaChOdW1iZXIoaXRlbVpJbmRleCkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dmFyIHpJbmRleCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHBhcmVudHNaaW5kZXgpICsgdGhpcy5vLnpJbmRleE9mZnNldDtcclxuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQucGFyZW50KCkub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XHJcblx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmNvbXBvbmVudCA/IHRoaXMuY29tcG9uZW50Lm91dGVySGVpZ2h0KHRydWUpIDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KGZhbHNlKTtcclxuXHRcdFx0dmFyIHdpZHRoID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlcldpZHRoKHRydWUpIDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoZmFsc2UpO1xyXG5cdFx0XHR2YXIgbGVmdCA9IG9mZnNldC5sZWZ0IC0gYXBwZW5kT2Zmc2V0LmxlZnQ7XHJcblx0XHRcdHZhciB0b3AgPSBvZmZzZXQudG9wIC0gYXBwZW5kT2Zmc2V0LnRvcDtcclxuXHJcblx0XHRcdGlmICh0aGlzLm8uY29udGFpbmVyICE9PSAnYm9keScpIHtcclxuXHRcdFx0XHR0b3AgKz0gc2Nyb2xsVG9wO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnBpY2tlci5yZW1vdmVDbGFzcyhcclxuXHRcdFx0XHQnZGF0ZXBpY2tlci1vcmllbnQtdG9wIGRhdGVwaWNrZXItb3JpZW50LWJvdHRvbSAnK1xyXG5cdFx0XHRcdCdkYXRlcGlja2VyLW9yaWVudC1yaWdodCBkYXRlcGlja2VyLW9yaWVudC1sZWZ0J1xyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuby5vcmllbnRhdGlvbi54ICE9PSAnYXV0bycpe1xyXG5cdFx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLW9yaWVudC0nICsgdGhpcy5vLm9yaWVudGF0aW9uLngpO1xyXG5cdFx0XHRcdGlmICh0aGlzLm8ub3JpZW50YXRpb24ueCA9PT0gJ3JpZ2h0JylcclxuXHRcdFx0XHRcdGxlZnQgLT0gY2FsZW5kYXJXaWR0aCAtIHdpZHRoO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGF1dG8geCBvcmllbnRhdGlvbiBpcyBiZXN0LXBsYWNlbWVudDogaWYgaXQgY3Jvc3NlcyBhIHdpbmRvd1xyXG5cdFx0XHQvLyBlZGdlLCBmdWRnZSBpdCBzaWRld2F5c1xyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRpZiAob2Zmc2V0LmxlZnQgPCAwKSB7XHJcblx0XHRcdFx0XHQvLyBjb21wb25lbnQgaXMgb3V0c2lkZSB0aGUgd2luZG93IG9uIHRoZSBsZWZ0IHNpZGUuIE1vdmUgaXQgaW50byB2aXNpYmxlIHJhbmdlXHJcblx0XHRcdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1vcmllbnQtbGVmdCcpO1xyXG5cdFx0XHRcdFx0bGVmdCAtPSBvZmZzZXQubGVmdCAtIHZpc3VhbFBhZGRpbmc7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChsZWZ0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvd1dpZHRoKSB7XHJcblx0XHRcdFx0XHQvLyB0aGUgY2FsZW5kYXIgcGFzc2VzIHRoZSB3aWRvdyByaWdodCBlZGdlLiBBbGlnbiBpdCB0byBjb21wb25lbnQgcmlnaHQgc2lkZVxyXG5cdFx0XHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LXJpZ2h0Jyk7XHJcblx0XHRcdFx0XHRsZWZ0ICs9IHdpZHRoIC0gY2FsZW5kYXJXaWR0aDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuby5ydGwpIHtcclxuXHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCB0byByaWdodFxyXG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIERlZmF1bHQgdG8gbGVmdFxyXG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1vcmllbnQtbGVmdCcpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYXV0byB5IG9yaWVudGF0aW9uIGlzIGJlc3Qtc2l0dWF0aW9uOiB0b3Agb3IgYm90dG9tLCBubyBmdWRnaW5nLFxyXG5cdFx0XHQvLyBkZWNpc2lvbiBiYXNlZCBvbiB3aGljaCBzaG93cyBtb3JlIG9mIHRoZSBjYWxlbmRhclxyXG5cdFx0XHR2YXIgeW9yaWVudCA9IHRoaXMuby5vcmllbnRhdGlvbi55LFxyXG5cdFx0XHRcdHRvcF9vdmVyZmxvdztcclxuXHRcdFx0aWYgKHlvcmllbnQgPT09ICdhdXRvJyl7XHJcblx0XHRcdFx0dG9wX292ZXJmbG93ID0gLXNjcm9sbFRvcCArIHRvcCAtIGNhbGVuZGFySGVpZ2h0O1xyXG5cdFx0XHRcdHlvcmllbnQgPSB0b3Bfb3ZlcmZsb3cgPCAwID8gJ2JvdHRvbScgOiAndG9wJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5waWNrZXIuYWRkQ2xhc3MoJ2RhdGVwaWNrZXItb3JpZW50LScgKyB5b3JpZW50KTtcclxuXHRcdFx0aWYgKHlvcmllbnQgPT09ICd0b3AnKVxyXG5cdFx0XHRcdHRvcCAtPSBjYWxlbmRhckhlaWdodCArIHBhcnNlSW50KHRoaXMucGlja2VyLmNzcygncGFkZGluZy10b3AnKSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0b3AgKz0gaGVpZ2h0O1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuby5ydGwpIHtcclxuXHRcdFx0XHR2YXIgcmlnaHQgPSB3aW5kb3dXaWR0aCAtIChsZWZ0ICsgd2lkdGgpO1xyXG5cdFx0XHRcdHRoaXMucGlja2VyLmNzcyh7XHJcblx0XHRcdFx0XHR0b3A6IHRvcCxcclxuXHRcdFx0XHRcdHJpZ2h0OiByaWdodCxcclxuXHRcdFx0XHRcdHpJbmRleDogekluZGV4XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5waWNrZXIuY3NzKHtcclxuXHRcdFx0XHRcdHRvcDogdG9wLFxyXG5cdFx0XHRcdFx0bGVmdDogbGVmdCxcclxuXHRcdFx0XHRcdHpJbmRleDogekluZGV4XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9LFxyXG5cclxuXHRcdF9hbGxvd191cGRhdGU6IHRydWUsXHJcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdGlmICghdGhpcy5fYWxsb3dfdXBkYXRlKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIG9sZERhdGVzID0gdGhpcy5kYXRlcy5jb3B5KCksXHJcblx0XHRcdFx0ZGF0ZXMgPSBbXSxcclxuXHRcdFx0XHRmcm9tQXJncyA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCl7XHJcblx0XHRcdFx0JC5lYWNoKGFyZ3VtZW50cywgJC5wcm94eShmdW5jdGlvbihpLCBkYXRlKXtcclxuXHRcdFx0XHRcdGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcclxuXHRcdFx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2xvY2FsX3RvX3V0YyhkYXRlKTtcclxuXHRcdFx0XHRcdGRhdGVzLnB1c2goZGF0ZSk7XHJcblx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRcdGZyb21BcmdzID0gdHJ1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkYXRlcyA9IHRoaXMuaXNJbnB1dFxyXG5cdFx0XHRcdFx0XHQ/IHRoaXMuZWxlbWVudC52YWwoKVxyXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZWxlbWVudC5kYXRhKCdkYXRlJykgfHwgdGhpcy5pbnB1dEZpZWxkLnZhbCgpO1xyXG5cdFx0XHRcdGlmIChkYXRlcyAmJiB0aGlzLm8ubXVsdGlkYXRlKVxyXG5cdFx0XHRcdFx0ZGF0ZXMgPSBkYXRlcy5zcGxpdCh0aGlzLm8ubXVsdGlkYXRlU2VwYXJhdG9yKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRkYXRlcyA9IFtkYXRlc107XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGF0ZXMgPSAkLm1hcChkYXRlcywgJC5wcm94eShmdW5jdGlvbihkYXRlKXtcclxuXHRcdFx0XHRyZXR1cm4gRFBHbG9iYWwucGFyc2VEYXRlKGRhdGUsIHRoaXMuby5mb3JtYXQsIHRoaXMuby5sYW5ndWFnZSwgdGhpcy5vLmFzc3VtZU5lYXJieVllYXIpO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHRcdGRhdGVzID0gJC5ncmVwKGRhdGVzLCAkLnByb3h5KGZ1bmN0aW9uKGRhdGUpe1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHQhdGhpcy5kYXRlV2l0aGluUmFuZ2UoZGF0ZSkgfHxcclxuXHRcdFx0XHRcdCFkYXRlXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSwgdGhpcyksIHRydWUpO1xyXG5cdFx0XHR0aGlzLmRhdGVzLnJlcGxhY2UoZGF0ZXMpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuby51cGRhdGVWaWV3RGF0ZSkge1xyXG5cdFx0XHRcdGlmICh0aGlzLmRhdGVzLmxlbmd0aClcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGVzLmdldCgtMSkpO1xyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMudmlld0RhdGUgPCB0aGlzLm8uc3RhcnREYXRlKVxyXG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuby5zdGFydERhdGUpO1xyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMudmlld0RhdGUgPiB0aGlzLm8uZW5kRGF0ZSlcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uZW5kRGF0ZSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMuby5kZWZhdWx0Vmlld0RhdGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChmcm9tQXJncyl7XHJcblx0XHRcdFx0Ly8gc2V0dGluZyBkYXRlIGJ5IGNsaWNraW5nXHJcblx0XHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudC5jaGFuZ2UoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0aGlzLmRhdGVzLmxlbmd0aCl7XHJcblx0XHRcdFx0Ly8gc2V0dGluZyBkYXRlIGJ5IHR5cGluZ1xyXG5cdFx0XHRcdGlmIChTdHJpbmcob2xkRGF0ZXMpICE9PSBTdHJpbmcodGhpcy5kYXRlcykgJiYgZnJvbUFyZ3MpIHtcclxuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcclxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudC5jaGFuZ2UoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCF0aGlzLmRhdGVzLmxlbmd0aCAmJiBvbGREYXRlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjbGVhckRhdGUnKTtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuY2hhbmdlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0ZmlsbERvdzogZnVuY3Rpb24oKXtcclxuICAgICAgaWYgKHRoaXMuby5zaG93V2Vla0RheXMpIHtcclxuXHRcdFx0dmFyIGRvd0NudCA9IHRoaXMuby53ZWVrU3RhcnQsXHJcblx0XHRcdFx0aHRtbCA9ICc8dHI+JztcclxuXHRcdFx0aWYgKHRoaXMuby5jYWxlbmRhcldlZWtzKXtcclxuXHRcdFx0XHRodG1sICs9ICc8dGggY2xhc3M9XCJjd1wiPiYjMTYwOzwvdGg+JztcclxuXHRcdFx0fVxyXG5cdFx0XHR3aGlsZSAoZG93Q250IDwgdGhpcy5vLndlZWtTdGFydCArIDcpe1xyXG5cdFx0XHRcdGh0bWwgKz0gJzx0aCBjbGFzcz1cImRvdyc7XHJcbiAgICAgICAgaWYgKCQuaW5BcnJheShkb3dDbnQsIHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQpICE9PSAtMSlcclxuICAgICAgICAgIGh0bWwgKz0gJyBkaXNhYmxlZCc7XHJcbiAgICAgICAgaHRtbCArPSAnXCI+JytkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLmRheXNNaW5bKGRvd0NudCsrKSU3XSsnPC90aD4nO1xyXG5cdFx0XHR9XHJcblx0XHRcdGh0bWwgKz0gJzwvdHI+JztcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0aGVhZCcpLmFwcGVuZChodG1sKTtcclxuICAgICAgfVxyXG5cdFx0fSxcclxuXHJcblx0XHRmaWxsTW9udGhzOiBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgbG9jYWxEYXRlID0gdGhpcy5fdXRjX3RvX2xvY2FsKHRoaXMudmlld0RhdGUpO1xyXG5cdFx0XHR2YXIgaHRtbCA9ICcnO1xyXG5cdFx0XHR2YXIgZm9jdXNlZDtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKXtcclxuXHRcdFx0XHRmb2N1c2VkID0gbG9jYWxEYXRlICYmIGxvY2FsRGF0ZS5nZXRNb250aCgpID09PSBpID8gJyBmb2N1c2VkJyA6ICcnO1xyXG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwibW9udGgnICsgZm9jdXNlZCArICdcIj4nICsgZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5tb250aHNTaG9ydFtpXSArICc8L3NwYW4+JztcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5odG1sKGh0bWwpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2Upe1xyXG5cdFx0XHRpZiAoIXJhbmdlIHx8ICFyYW5nZS5sZW5ndGgpXHJcblx0XHRcdFx0ZGVsZXRlIHRoaXMucmFuZ2U7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aGlzLnJhbmdlID0gJC5tYXAocmFuZ2UsIGZ1bmN0aW9uKGQpe1xyXG5cdFx0XHRcdFx0cmV0dXJuIGQudmFsdWVPZigpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Q2xhc3NOYW1lczogZnVuY3Rpb24oZGF0ZSl7XHJcblx0XHRcdHZhciBjbHMgPSBbXSxcclxuXHRcdFx0XHR5ZWFyID0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpLFxyXG5cdFx0XHRcdG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpLFxyXG5cdFx0XHRcdHRvZGF5ID0gVVRDVG9kYXkoKTtcclxuXHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA8IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PT0geWVhciAmJiBkYXRlLmdldFVUQ01vbnRoKCkgPCBtb250aCkpe1xyXG5cdFx0XHRcdGNscy5wdXNoKCdvbGQnKTtcclxuXHRcdFx0fSBlbHNlIGlmIChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPiB5ZWFyIHx8IChkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgPT09IHllYXIgJiYgZGF0ZS5nZXRVVENNb250aCgpID4gbW9udGgpKXtcclxuXHRcdFx0XHRjbHMucHVzaCgnbmV3Jyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuZm9jdXNEYXRlICYmIGRhdGUudmFsdWVPZigpID09PSB0aGlzLmZvY3VzRGF0ZS52YWx1ZU9mKCkpXHJcblx0XHRcdFx0Y2xzLnB1c2goJ2ZvY3VzZWQnKTtcclxuXHRcdFx0Ly8gQ29tcGFyZSBpbnRlcm5hbCBVVEMgZGF0ZSB3aXRoIFVUQyB0b2RheSwgbm90IGxvY2FsIHRvZGF5XHJcblx0XHRcdGlmICh0aGlzLm8udG9kYXlIaWdobGlnaHQgJiYgaXNVVENFcXVhbHMoZGF0ZSwgdG9kYXkpKSB7XHJcblx0XHRcdFx0Y2xzLnB1c2goJ3RvZGF5Jyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuZGF0ZXMuY29udGFpbnMoZGF0ZSkgIT09IC0xKVxyXG5cdFx0XHRcdGNscy5wdXNoKCdhY3RpdmUnKTtcclxuXHRcdFx0aWYgKCF0aGlzLmRhdGVXaXRoaW5SYW5nZShkYXRlKSl7XHJcblx0XHRcdFx0Y2xzLnB1c2goJ2Rpc2FibGVkJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRoaXMuZGF0ZUlzRGlzYWJsZWQoZGF0ZSkpe1xyXG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcsICdkaXNhYmxlZC1kYXRlJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCQuaW5BcnJheShkYXRlLmdldFVUQ0RheSgpLCB0aGlzLm8uZGF5c09mV2Vla0hpZ2hsaWdodGVkKSAhPT0gLTEpe1xyXG5cdFx0XHRcdGNscy5wdXNoKCdoaWdobGlnaHRlZCcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5yYW5nZSl7XHJcblx0XHRcdFx0aWYgKGRhdGUgPiB0aGlzLnJhbmdlWzBdICYmIGRhdGUgPCB0aGlzLnJhbmdlW3RoaXMucmFuZ2UubGVuZ3RoLTFdKXtcclxuXHRcdFx0XHRcdGNscy5wdXNoKCdyYW5nZScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoJC5pbkFycmF5KGRhdGUudmFsdWVPZigpLCB0aGlzLnJhbmdlKSAhPT0gLTEpe1xyXG5cdFx0XHRcdFx0Y2xzLnB1c2goJ3NlbGVjdGVkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChkYXRlLnZhbHVlT2YoKSA9PT0gdGhpcy5yYW5nZVswXSl7XHJcbiAgICAgICAgICBjbHMucHVzaCgncmFuZ2Utc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGUudmFsdWVPZigpID09PSB0aGlzLnJhbmdlW3RoaXMucmFuZ2UubGVuZ3RoLTFdKXtcclxuICAgICAgICAgIGNscy5wdXNoKCdyYW5nZS1lbmQnKTtcclxuICAgICAgICB9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGNscztcclxuXHRcdH0sXHJcblxyXG5cdFx0X2ZpbGxfeWVhcnNWaWV3OiBmdW5jdGlvbihzZWxlY3RvciwgY3NzQ2xhc3MsIGZhY3RvciwgeWVhciwgc3RhcnRZZWFyLCBlbmRZZWFyLCBiZWZvcmVGbil7XHJcblx0XHRcdHZhciBodG1sID0gJyc7XHJcblx0XHRcdHZhciBzdGVwID0gZmFjdG9yIC8gMTA7XHJcblx0XHRcdHZhciB2aWV3ID0gdGhpcy5waWNrZXIuZmluZChzZWxlY3Rvcik7XHJcblx0XHRcdHZhciBzdGFydFZhbCA9IE1hdGguZmxvb3IoeWVhciAvIGZhY3RvcikgKiBmYWN0b3I7XHJcblx0XHRcdHZhciBlbmRWYWwgPSBzdGFydFZhbCArIHN0ZXAgKiA5O1xyXG5cdFx0XHR2YXIgZm9jdXNlZFZhbCA9IE1hdGguZmxvb3IodGhpcy52aWV3RGF0ZS5nZXRGdWxsWWVhcigpIC8gc3RlcCkgKiBzdGVwO1xyXG5cdFx0XHR2YXIgc2VsZWN0ZWQgPSAkLm1hcCh0aGlzLmRhdGVzLCBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihkLmdldFVUQ0Z1bGxZZWFyKCkgLyBzdGVwKSAqIHN0ZXA7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dmFyIGNsYXNzZXMsIHRvb2x0aXAsIGJlZm9yZTtcclxuXHRcdFx0Zm9yICh2YXIgY3VyclZhbCA9IHN0YXJ0VmFsIC0gc3RlcDsgY3VyclZhbCA8PSBlbmRWYWwgKyBzdGVwOyBjdXJyVmFsICs9IHN0ZXApIHtcclxuXHRcdFx0XHRjbGFzc2VzID0gW2Nzc0NsYXNzXTtcclxuXHRcdFx0XHR0b29sdGlwID0gbnVsbDtcclxuXHJcblx0XHRcdFx0aWYgKGN1cnJWYWwgPT09IHN0YXJ0VmFsIC0gc3RlcCkge1xyXG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCdvbGQnKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJWYWwgPT09IGVuZFZhbCArIHN0ZXApIHtcclxuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnbmV3Jyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICgkLmluQXJyYXkoY3VyclZhbCwgc2VsZWN0ZWQpICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCdhY3RpdmUnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGN1cnJWYWwgPCBzdGFydFllYXIgfHwgY3VyclZhbCA+IGVuZFllYXIpIHtcclxuXHRcdFx0XHRcdGNsYXNzZXMucHVzaCgnZGlzYWJsZWQnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGN1cnJWYWwgPT09IGZvY3VzZWRWYWwpIHtcclxuXHRcdFx0XHQgIGNsYXNzZXMucHVzaCgnZm9jdXNlZCcpO1xyXG4gICAgICAgIH1cclxuXHJcblx0XHRcdFx0aWYgKGJlZm9yZUZuICE9PSAkLm5vb3ApIHtcclxuXHRcdFx0XHRcdGJlZm9yZSA9IGJlZm9yZUZuKG5ldyBEYXRlKGN1cnJWYWwsIDAsIDEpKTtcclxuXHRcdFx0XHRcdGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7fTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGJlZm9yZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcblx0XHRcdFx0XHRcdGJlZm9yZSA9IHtlbmFibGVkOiBiZWZvcmV9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7Y2xhc3NlczogYmVmb3JlfTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChiZWZvcmUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKCdkaXNhYmxlZCcpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5jbGFzc2VzKSB7XHJcblx0XHRcdFx0XHRcdGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChiZWZvcmUuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcCkge1xyXG5cdFx0XHRcdFx0XHR0b29sdGlwID0gYmVmb3JlLnRvb2x0aXA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyAodG9vbHRpcCA/ICcgdGl0bGU9XCInICsgdG9vbHRpcCArICdcIicgOiAnJykgKyAnPicgKyBjdXJyVmFsICsgJzwvc3Bhbj4nO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2aWV3LmZpbmQoJy5kYXRlcGlja2VyLXN3aXRjaCcpLnRleHQoc3RhcnRWYWwgKyAnLScgKyBlbmRWYWwpO1xyXG5cdFx0XHR2aWV3LmZpbmQoJ3RkJykuaHRtbChodG1sKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0ZmlsbDogZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcclxuXHRcdFx0XHR5ZWFyID0gZC5nZXRVVENGdWxsWWVhcigpLFxyXG5cdFx0XHRcdG1vbnRoID0gZC5nZXRVVENNb250aCgpLFxyXG5cdFx0XHRcdHN0YXJ0WWVhciA9IHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSA/IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IC1JbmZpbml0eSxcclxuXHRcdFx0XHRzdGFydE1vbnRoID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpIDogLUluZmluaXR5LFxyXG5cdFx0XHRcdGVuZFllYXIgPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENGdWxsWWVhcigpIDogSW5maW5pdHksXHJcblx0XHRcdFx0ZW5kTW9udGggPSB0aGlzLm8uZW5kRGF0ZSAhPT0gSW5maW5pdHkgPyB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpIDogSW5maW5pdHksXHJcblx0XHRcdFx0dG9kYXl0eHQgPSBkYXRlc1t0aGlzLm8ubGFuZ3VhZ2VdLnRvZGF5IHx8IGRhdGVzWydlbiddLnRvZGF5IHx8ICcnLFxyXG5cdFx0XHRcdGNsZWFydHh0ID0gZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5jbGVhciB8fCBkYXRlc1snZW4nXS5jbGVhciB8fCAnJyxcclxuXHRcdFx0XHR0aXRsZUZvcm1hdCA9IGRhdGVzW3RoaXMuby5sYW5ndWFnZV0udGl0bGVGb3JtYXQgfHwgZGF0ZXNbJ2VuJ10udGl0bGVGb3JtYXQsXHJcblx0XHRcdFx0dG9vbHRpcCxcclxuXHRcdFx0XHRiZWZvcmU7XHJcblx0XHRcdGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIC5kYXRlcGlja2VyLXN3aXRjaCcpXHJcblx0XHRcdFx0XHRcdC50ZXh0KERQR2xvYmFsLmZvcm1hdERhdGUoZCwgdGl0bGVGb3JtYXQsIHRoaXMuby5sYW5ndWFnZSkpO1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCAudG9kYXknKVxyXG5cdFx0XHRcdFx0XHQudGV4dCh0b2RheXR4dClcclxuXHRcdFx0XHRcdFx0LmNzcygnZGlzcGxheScsIHRoaXMuby50b2RheUJ0biA9PT0gdHJ1ZSB8fCB0aGlzLm8udG9kYXlCdG4gPT09ICdsaW5rZWQnID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnKTtcclxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgLmNsZWFyJylcclxuXHRcdFx0XHRcdFx0LnRleHQoY2xlYXJ0eHQpXHJcblx0XHRcdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCB0aGlzLm8uY2xlYXJCdG4gPT09IHRydWUgPyAndGFibGUtY2VsbCcgOiAnbm9uZScpO1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0aGVhZCAuZGF0ZXBpY2tlci10aXRsZScpXHJcblx0XHRcdFx0XHRcdC50ZXh0KHRoaXMuby50aXRsZSlcclxuXHRcdFx0XHRcdFx0LmNzcygnZGlzcGxheScsIHR5cGVvZiB0aGlzLm8udGl0bGUgPT09ICdzdHJpbmcnICYmIHRoaXMuby50aXRsZSAhPT0gJycgPyAndGFibGUtY2VsbCcgOiAnbm9uZScpO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xyXG5cdFx0XHR0aGlzLmZpbGxNb250aHMoKTtcclxuXHRcdFx0dmFyIHByZXZNb250aCA9IFVUQ0RhdGUoeWVhciwgbW9udGgsIDApLFxyXG5cdFx0XHRcdGRheSA9IHByZXZNb250aC5nZXRVVENEYXRlKCk7XHJcblx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKGRheSAtIChwcmV2TW9udGguZ2V0VVRDRGF5KCkgLSB0aGlzLm8ud2Vla1N0YXJ0ICsgNyklNyk7XHJcblx0XHRcdHZhciBuZXh0TW9udGggPSBuZXcgRGF0ZShwcmV2TW9udGgpO1xyXG5cdFx0XHRpZiAocHJldk1vbnRoLmdldFVUQ0Z1bGxZZWFyKCkgPCAxMDApe1xyXG4gICAgICAgIG5leHRNb250aC5zZXRVVENGdWxsWWVhcihwcmV2TW9udGguZ2V0VVRDRnVsbFllYXIoKSk7XHJcbiAgICAgIH1cclxuXHRcdFx0bmV4dE1vbnRoLnNldFVUQ0RhdGUobmV4dE1vbnRoLmdldFVUQ0RhdGUoKSArIDQyKTtcclxuXHRcdFx0bmV4dE1vbnRoID0gbmV4dE1vbnRoLnZhbHVlT2YoKTtcclxuXHRcdFx0dmFyIGh0bWwgPSBbXTtcclxuXHRcdFx0dmFyIHdlZWtEYXksIGNsc05hbWU7XHJcblx0XHRcdHdoaWxlIChwcmV2TW9udGgudmFsdWVPZigpIDwgbmV4dE1vbnRoKXtcclxuXHRcdFx0XHR3ZWVrRGF5ID0gcHJldk1vbnRoLmdldFVUQ0RheSgpO1xyXG5cdFx0XHRcdGlmICh3ZWVrRGF5ID09PSB0aGlzLm8ud2Vla1N0YXJ0KXtcclxuXHRcdFx0XHRcdGh0bWwucHVzaCgnPHRyPicpO1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuby5jYWxlbmRhcldlZWtzKXtcclxuXHRcdFx0XHRcdFx0Ly8gSVNPIDg2MDE6IEZpcnN0IHdlZWsgY29udGFpbnMgZmlyc3QgdGh1cnNkYXkuXHJcblx0XHRcdFx0XHRcdC8vIElTTyBhbHNvIHN0YXRlcyB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksIGJ1dCB3ZSBjYW4gYmUgbW9yZSBhYnN0cmFjdCBoZXJlLlxyXG5cdFx0XHRcdFx0XHR2YXJcclxuXHRcdFx0XHRcdFx0XHQvLyBTdGFydCBvZiBjdXJyZW50IHdlZWs6IGJhc2VkIG9uIHdlZWtzdGFydC9jdXJyZW50IGRhdGVcclxuXHRcdFx0XHRcdFx0XHR3cyA9IG5ldyBEYXRlKCtwcmV2TW9udGggKyAodGhpcy5vLndlZWtTdGFydCAtIHdlZWtEYXkgLSA3KSAlIDcgKiA4NjRlNSksXHJcblx0XHRcdFx0XHRcdFx0Ly8gVGh1cnNkYXkgb2YgdGhpcyB3ZWVrXHJcblx0XHRcdFx0XHRcdFx0dGggPSBuZXcgRGF0ZShOdW1iZXIod3MpICsgKDcgKyA0IC0gd3MuZ2V0VVRDRGF5KCkpICUgNyAqIDg2NGU1KSxcclxuXHRcdFx0XHRcdFx0XHQvLyBGaXJzdCBUaHVyc2RheSBvZiB5ZWFyLCB5ZWFyIGZyb20gdGh1cnNkYXlcclxuXHRcdFx0XHRcdFx0XHR5dGggPSBuZXcgRGF0ZShOdW1iZXIoeXRoID0gVVRDRGF0ZSh0aC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkgKyAoNyArIDQgLSB5dGguZ2V0VVRDRGF5KCkpICUgNyAqIDg2NGU1KSxcclxuXHRcdFx0XHRcdFx0XHQvLyBDYWxlbmRhciB3ZWVrOiBtcyBiZXR3ZWVuIHRodXJzZGF5cywgZGl2IG1zIHBlciBkYXksIGRpdiA3IGRheXNcclxuXHRcdFx0XHRcdFx0XHRjYWxXZWVrID0gKHRoIC0geXRoKSAvIDg2NGU1IC8gNyArIDE7XHJcblx0XHRcdFx0XHRcdGh0bWwucHVzaCgnPHRkIGNsYXNzPVwiY3dcIj4nKyBjYWxXZWVrICsnPC90ZD4nKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2xzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyhwcmV2TW9udGgpO1xyXG5cdFx0XHRcdGNsc05hbWUucHVzaCgnZGF5Jyk7XHJcblxyXG5cdFx0XHRcdHZhciBjb250ZW50ID0gcHJldk1vbnRoLmdldFVUQ0RhdGUoKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuby5iZWZvcmVTaG93RGF5ICE9PSAkLm5vb3Ape1xyXG5cdFx0XHRcdFx0YmVmb3JlID0gdGhpcy5vLmJlZm9yZVNob3dEYXkodGhpcy5fdXRjX3RvX2xvY2FsKHByZXZNb250aCkpO1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7fTtcclxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBiZWZvcmUgPT09ICdib29sZWFuJylcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnc3RyaW5nJylcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2NsYXNzZXM6IGJlZm9yZX07XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmVuYWJsZWQgPT09IGZhbHNlKVxyXG5cdFx0XHRcdFx0XHRjbHNOYW1lLnB1c2goJ2Rpc2FibGVkJyk7XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmNsYXNzZXMpXHJcblx0XHRcdFx0XHRcdGNsc05hbWUgPSBjbHNOYW1lLmNvbmNhdChiZWZvcmUuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pKTtcclxuXHRcdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcClcclxuXHRcdFx0XHRcdFx0dG9vbHRpcCA9IGJlZm9yZS50b29sdGlwO1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZS5jb250ZW50KVxyXG5cdFx0XHRcdFx0XHRjb250ZW50ID0gYmVmb3JlLmNvbnRlbnQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL0NoZWNrIGlmIHVuaXF1ZVNvcnQgZXhpc3RzIChzdXBwb3J0ZWQgYnkganF1ZXJ5ID49MS4xMiBhbmQgPj0yLjIpXHJcblx0XHRcdFx0Ly9GYWxsYmFjayB0byB1bmlxdWUgZnVuY3Rpb24gZm9yIG9sZGVyIGpxdWVyeSB2ZXJzaW9uc1xyXG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oJC51bmlxdWVTb3J0KSkge1xyXG5cdFx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlU29ydChjbHNOYW1lKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlKGNsc05hbWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aHRtbC5wdXNoKCc8dGQgY2xhc3M9XCInK2Nsc05hbWUuam9pbignICcpKydcIicgKyAodG9vbHRpcCA/ICcgdGl0bGU9XCInK3Rvb2x0aXArJ1wiJyA6ICcnKSArICcgZGF0YS1kYXRlPVwiJyArIHByZXZNb250aC5nZXRUaW1lKCkudG9TdHJpbmcoKSArICdcIj4nICsgY29udGVudCArICc8L3RkPicpO1xyXG5cdFx0XHRcdHRvb2x0aXAgPSBudWxsO1xyXG5cdFx0XHRcdGlmICh3ZWVrRGF5ID09PSB0aGlzLm8ud2Vla0VuZCl7XHJcblx0XHRcdFx0XHRodG1sLnB1c2goJzwvdHI+Jyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKHByZXZNb250aC5nZXRVVENEYXRlKCkgKyAxKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1kYXlzIHRib2R5JykuaHRtbChodG1sLmpvaW4oJycpKTtcclxuXHJcblx0XHRcdHZhciBtb250aHNUaXRsZSA9IGRhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzVGl0bGUgfHwgZGF0ZXNbJ2VuJ10ubW9udGhzVGl0bGUgfHwgJ01vbnRocyc7XHJcblx0XHRcdHZhciBtb250aHMgPSB0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMnKVxyXG5cdFx0XHRcdFx0XHQuZmluZCgnLmRhdGVwaWNrZXItc3dpdGNoJylcclxuXHRcdFx0XHRcdFx0XHQudGV4dCh0aGlzLm8ubWF4Vmlld01vZGUgPCAyID8gbW9udGhzVGl0bGUgOiB5ZWFyKVxyXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxyXG5cdFx0XHRcdFx0XHQuZmluZCgndGJvZHkgc3BhbicpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuXHJcblx0XHRcdCQuZWFjaCh0aGlzLmRhdGVzLCBmdW5jdGlvbihpLCBkKXtcclxuXHRcdFx0XHRpZiAoZC5nZXRVVENGdWxsWWVhcigpID09PSB5ZWFyKVxyXG5cdFx0XHRcdFx0bW9udGhzLmVxKGQuZ2V0VVRDTW9udGgoKSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmICh5ZWFyIDwgc3RhcnRZZWFyIHx8IHllYXIgPiBlbmRZZWFyKXtcclxuXHRcdFx0XHRtb250aHMuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHllYXIgPT09IHN0YXJ0WWVhcil7XHJcblx0XHRcdFx0bW9udGhzLnNsaWNlKDAsIHN0YXJ0TW9udGgpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh5ZWFyID09PSBlbmRZZWFyKXtcclxuXHRcdFx0XHRtb250aHMuc2xpY2UoZW5kTW9udGgrMSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aGlzLm8uYmVmb3JlU2hvd01vbnRoICE9PSAkLm5vb3Ape1xyXG5cdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdFx0XHQkLmVhY2gobW9udGhzLCBmdW5jdGlvbihpLCBtb250aCl7XHJcbiAgICAgICAgICB2YXIgbW9EYXRlID0gbmV3IERhdGUoeWVhciwgaSwgMSk7XHJcbiAgICAgICAgICB2YXIgYmVmb3JlID0gdGhhdC5vLmJlZm9yZVNob3dNb250aChtb0RhdGUpO1xyXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0XHRiZWZvcmUgPSB7fTtcclxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBiZWZvcmUgPT09ICdib29sZWFuJylcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgYmVmb3JlID09PSAnc3RyaW5nJylcclxuXHRcdFx0XHRcdFx0YmVmb3JlID0ge2NsYXNzZXM6IGJlZm9yZX07XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLmVuYWJsZWQgPT09IGZhbHNlICYmICEkKG1vbnRoKS5oYXNDbGFzcygnZGlzYWJsZWQnKSlcclxuXHRcdFx0XHRcdCAgICAkKG1vbnRoKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcclxuXHRcdFx0XHRcdGlmIChiZWZvcmUuY2xhc3NlcylcclxuXHRcdFx0XHRcdCAgICAkKG1vbnRoKS5hZGRDbGFzcyhiZWZvcmUuY2xhc3Nlcyk7XHJcblx0XHRcdFx0XHRpZiAoYmVmb3JlLnRvb2x0aXApXHJcblx0XHRcdFx0XHQgICAgJChtb250aCkucHJvcCgndGl0bGUnLCBiZWZvcmUudG9vbHRpcCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEdlbmVyYXRpbmcgZGVjYWRlL3llYXJzIHBpY2tlclxyXG5cdFx0XHR0aGlzLl9maWxsX3llYXJzVmlldyhcclxuXHRcdFx0XHQnLmRhdGVwaWNrZXIteWVhcnMnLFxyXG5cdFx0XHRcdCd5ZWFyJyxcclxuXHRcdFx0XHQxMCxcclxuXHRcdFx0XHR5ZWFyLFxyXG5cdFx0XHRcdHN0YXJ0WWVhcixcclxuXHRcdFx0XHRlbmRZZWFyLFxyXG5cdFx0XHRcdHRoaXMuby5iZWZvcmVTaG93WWVhclxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Ly8gR2VuZXJhdGluZyBjZW50dXJ5L2RlY2FkZXMgcGlja2VyXHJcblx0XHRcdHRoaXMuX2ZpbGxfeWVhcnNWaWV3KFxyXG5cdFx0XHRcdCcuZGF0ZXBpY2tlci1kZWNhZGVzJyxcclxuXHRcdFx0XHQnZGVjYWRlJyxcclxuXHRcdFx0XHQxMDAsXHJcblx0XHRcdFx0eWVhcixcclxuXHRcdFx0XHRzdGFydFllYXIsXHJcblx0XHRcdFx0ZW5kWWVhcixcclxuXHRcdFx0XHR0aGlzLm8uYmVmb3JlU2hvd0RlY2FkZVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Ly8gR2VuZXJhdGluZyBtaWxsZW5uaXVtL2NlbnR1cmllcyBwaWNrZXJcclxuXHRcdFx0dGhpcy5fZmlsbF95ZWFyc1ZpZXcoXHJcblx0XHRcdFx0Jy5kYXRlcGlja2VyLWNlbnR1cmllcycsXHJcblx0XHRcdFx0J2NlbnR1cnknLFxyXG5cdFx0XHRcdDEwMDAsXHJcblx0XHRcdFx0eWVhcixcclxuXHRcdFx0XHRzdGFydFllYXIsXHJcblx0XHRcdFx0ZW5kWWVhcixcclxuXHRcdFx0XHR0aGlzLm8uYmVmb3JlU2hvd0NlbnR1cnlcclxuXHRcdFx0KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlTmF2QXJyb3dzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSlcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR2YXIgZCA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpLFxyXG5cdFx0XHRcdHllYXIgPSBkLmdldFVUQ0Z1bGxZZWFyKCksXHJcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCksXHJcblx0XHRcdFx0c3RhcnRZZWFyID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENGdWxsWWVhcigpIDogLUluZmluaXR5LFxyXG5cdFx0XHRcdHN0YXJ0TW9udGggPSB0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgPyB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ01vbnRoKCkgOiAtSW5maW5pdHksXHJcblx0XHRcdFx0ZW5kWWVhciA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgOiBJbmZpbml0eSxcclxuXHRcdFx0XHRlbmRNb250aCA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ01vbnRoKCkgOiBJbmZpbml0eSxcclxuXHRcdFx0XHRwcmV2SXNEaXNhYmxlZCxcclxuXHRcdFx0XHRuZXh0SXNEaXNhYmxlZCxcclxuXHRcdFx0XHRmYWN0b3IgPSAxO1xyXG5cdFx0XHRzd2l0Y2ggKHRoaXMudmlld01vZGUpe1xyXG5cdFx0XHRcdGNhc2UgMDpcclxuXHRcdFx0XHRcdHByZXZJc0Rpc2FibGVkID0geWVhciA8PSBzdGFydFllYXIgJiYgbW9udGggPD0gc3RhcnRNb250aDtcclxuXHRcdFx0XHRcdG5leHRJc0Rpc2FibGVkID0geWVhciA+PSBlbmRZZWFyICYmIG1vbnRoID49IGVuZE1vbnRoO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA0OlxyXG5cdFx0XHRcdFx0ZmFjdG9yICo9IDEwO1xyXG5cdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cdFx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHRcdGZhY3RvciAqPSAxMDtcclxuXHRcdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cclxuXHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRmYWN0b3IgKj0gMTA7XHJcblx0XHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXHJcblx0XHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdFx0cHJldklzRGlzYWJsZWQgPSBNYXRoLmZsb29yKHllYXIgLyBmYWN0b3IpICogZmFjdG9yIDw9IHN0YXJ0WWVhcjtcclxuXHRcdFx0XHRcdG5leHRJc0Rpc2FibGVkID0gTWF0aC5mbG9vcih5ZWFyIC8gZmFjdG9yKSAqIGZhY3RvciArIGZhY3RvciA+PSBlbmRZZWFyO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgcHJldklzRGlzYWJsZWQpO1xyXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsIG5leHRJc0Rpc2FibGVkKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xpY2s6IGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0XHR2YXIgdGFyZ2V0LCBkaXIsIGRheSwgeWVhciwgbW9udGg7XHJcblx0XHRcdHRhcmdldCA9ICQoZS50YXJnZXQpO1xyXG5cclxuXHRcdFx0Ly8gQ2xpY2tlZCBvbiB0aGUgc3dpdGNoXHJcblx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2RhdGVwaWNrZXItc3dpdGNoJykgJiYgdGhpcy52aWV3TW9kZSAhPT0gdGhpcy5vLm1heFZpZXdNb2RlKXtcclxuXHRcdFx0XHR0aGlzLnNldFZpZXdNb2RlKHRoaXMudmlld01vZGUgKyAxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ2xpY2tlZCBvbiB0b2RheSBidXR0b25cclxuXHRcdFx0aWYgKHRhcmdldC5oYXNDbGFzcygndG9kYXknKSAmJiAhdGFyZ2V0Lmhhc0NsYXNzKCdkYXknKSl7XHJcblx0XHRcdFx0dGhpcy5zZXRWaWV3TW9kZSgwKTtcclxuXHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ1RvZGF5KCksIHRoaXMuby50b2RheUJ0biA9PT0gJ2xpbmtlZCcgPyBudWxsIDogJ3ZpZXcnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ2xpY2tlZCBvbiBjbGVhciBidXR0b25cclxuXHRcdFx0aWYgKHRhcmdldC5oYXNDbGFzcygnY2xlYXInKSl7XHJcblx0XHRcdFx0dGhpcy5jbGVhckRhdGVzKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghdGFyZ2V0Lmhhc0NsYXNzKCdkaXNhYmxlZCcpKXtcclxuXHRcdFx0XHQvLyBDbGlja2VkIG9uIGEgbW9udGgsIHllYXIsIGRlY2FkZSwgY2VudHVyeVxyXG5cdFx0XHRcdGlmICh0YXJnZXQuaGFzQ2xhc3MoJ21vbnRoJylcclxuXHRcdFx0XHRcdFx0fHwgdGFyZ2V0Lmhhc0NsYXNzKCd5ZWFyJylcclxuXHRcdFx0XHRcdFx0fHwgdGFyZ2V0Lmhhc0NsYXNzKCdkZWNhZGUnKVxyXG5cdFx0XHRcdFx0XHR8fCB0YXJnZXQuaGFzQ2xhc3MoJ2NlbnR1cnknKSkge1xyXG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENEYXRlKDEpO1xyXG5cclxuXHRcdFx0XHRcdGRheSA9IDE7XHJcblx0XHRcdFx0XHRpZiAodGhpcy52aWV3TW9kZSA9PT0gMSl7XHJcblx0XHRcdFx0XHRcdG1vbnRoID0gdGFyZ2V0LnBhcmVudCgpLmZpbmQoJ3NwYW4nKS5pbmRleCh0YXJnZXQpO1xyXG5cdFx0XHRcdFx0XHR5ZWFyID0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ01vbnRoKG1vbnRoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdG1vbnRoID0gMDtcclxuXHRcdFx0XHRcdFx0eWVhciA9IE51bWJlcih0YXJnZXQudGV4dCgpKTtcclxuXHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKERQR2xvYmFsLnZpZXdNb2Rlc1t0aGlzLnZpZXdNb2RlIC0gMV0uZSwgdGhpcy52aWV3RGF0ZSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMudmlld01vZGUgPT09IHRoaXMuby5taW5WaWV3TW9kZSl7XHJcblx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNldFZpZXdNb2RlKHRoaXMudmlld01vZGUgLSAxKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5maWxsKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykgJiYgdGhpcy5fZm9jdXNlZF9mcm9tKXtcclxuXHRcdFx0XHR0aGlzLl9mb2N1c2VkX2Zyb20uZm9jdXMoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkZWxldGUgdGhpcy5fZm9jdXNlZF9mcm9tO1xyXG5cdFx0fSxcclxuXHJcblx0XHRkYXlDZWxsQ2xpY2s6IGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHR2YXIgJHRhcmdldCA9ICQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0dmFyIHRpbWVzdGFtcCA9ICR0YXJnZXQuZGF0YSgnZGF0ZScpO1xyXG5cdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWVzdGFtcCk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vLnVwZGF0ZVZpZXdEYXRlKSB7XHJcblx0XHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAhPT0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpKSB7XHJcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VZZWFyJywgdGhpcy52aWV3RGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZGF0ZS5nZXRVVENNb250aCgpICE9PSB0aGlzLnZpZXdEYXRlLmdldFVUQ01vbnRoKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZU1vbnRoJywgdGhpcy52aWV3RGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3NldERhdGUoZGF0ZSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIENsaWNrZWQgb24gcHJldiBvciBuZXh0XHJcblx0XHRuYXZBcnJvd3NDbGljazogZnVuY3Rpb24oZSl7XHJcblx0XHRcdHZhciAkdGFyZ2V0ID0gJChlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHR2YXIgZGlyID0gJHRhcmdldC5oYXNDbGFzcygncHJldicpID8gLTEgOiAxO1xyXG5cdFx0XHRpZiAodGhpcy52aWV3TW9kZSAhPT0gMCl7XHJcblx0XHRcdFx0ZGlyICo9IERQR2xvYmFsLnZpZXdNb2Rlc1t0aGlzLnZpZXdNb2RlXS5uYXZTdGVwICogMTI7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XHJcblx0XHRcdHRoaXMuX3RyaWdnZXIoRFBHbG9iYWwudmlld01vZGVzW3RoaXMudmlld01vZGVdLmUsIHRoaXMudmlld0RhdGUpO1xyXG5cdFx0XHR0aGlzLmZpbGwoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0X3RvZ2dsZV9tdWx0aWRhdGU6IGZ1bmN0aW9uKGRhdGUpe1xyXG5cdFx0XHR2YXIgaXggPSB0aGlzLmRhdGVzLmNvbnRhaW5zKGRhdGUpO1xyXG5cdFx0XHRpZiAoIWRhdGUpe1xyXG5cdFx0XHRcdHRoaXMuZGF0ZXMuY2xlYXIoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGl4ICE9PSAtMSl7XHJcblx0XHRcdFx0aWYgKHRoaXMuby5tdWx0aWRhdGUgPT09IHRydWUgfHwgdGhpcy5vLm11bHRpZGF0ZSA+IDEgfHwgdGhpcy5vLnRvZ2dsZUFjdGl2ZSl7XHJcblx0XHRcdFx0XHR0aGlzLmRhdGVzLnJlbW92ZShpeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuby5tdWx0aWRhdGUgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0dGhpcy5kYXRlcy5jbGVhcigpO1xyXG5cdFx0XHRcdHRoaXMuZGF0ZXMucHVzaChkYXRlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmRhdGVzLnB1c2goZGF0ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0eXBlb2YgdGhpcy5vLm11bHRpZGF0ZSA9PT0gJ251bWJlcicpXHJcblx0XHRcdFx0d2hpbGUgKHRoaXMuZGF0ZXMubGVuZ3RoID4gdGhpcy5vLm11bHRpZGF0ZSlcclxuXHRcdFx0XHRcdHRoaXMuZGF0ZXMucmVtb3ZlKDApO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfc2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgd2hpY2gpe1xyXG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoID09PSAnZGF0ZScpXHJcblx0XHRcdFx0dGhpcy5fdG9nZ2xlX211bHRpZGF0ZShkYXRlICYmIG5ldyBEYXRlKGRhdGUpKTtcclxuXHRcdFx0aWYgKCghd2hpY2ggJiYgdGhpcy5vLnVwZGF0ZVZpZXdEYXRlKSB8fCB3aGljaCA9PT0gJ3ZpZXcnKVxyXG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBkYXRlICYmIG5ldyBEYXRlKGRhdGUpO1xyXG5cclxuXHRcdFx0dGhpcy5maWxsKCk7XHJcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcclxuXHRcdFx0aWYgKCF3aGljaCB8fCB3aGljaCAhPT0gJ3ZpZXcnKSB7XHJcblx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuaW5wdXRGaWVsZC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuXHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UgJiYgKCF3aGljaCB8fCB3aGljaCA9PT0gJ2RhdGUnKSl7XHJcblx0XHRcdFx0dGhpcy5oaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0bW92ZURheTogZnVuY3Rpb24oZGF0ZSwgZGlyKXtcclxuXHRcdFx0dmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuXHRcdFx0bmV3RGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcclxuXHJcblx0XHRcdHJldHVybiBuZXdEYXRlO1xyXG5cdFx0fSxcclxuXHJcblx0XHRtb3ZlV2VlazogZnVuY3Rpb24oZGF0ZSwgZGlyKXtcclxuXHRcdFx0cmV0dXJuIHRoaXMubW92ZURheShkYXRlLCBkaXIgKiA3KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0bW92ZU1vbnRoOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xyXG5cdFx0XHRpZiAoIWlzVmFsaWREYXRlKGRhdGUpKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLm8uZGVmYXVsdFZpZXdEYXRlO1xyXG5cdFx0XHRpZiAoIWRpcilcclxuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcclxuXHRcdFx0dmFyIG5ld19kYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpLFxyXG5cdFx0XHRcdGRheSA9IG5ld19kYXRlLmdldFVUQ0RhdGUoKSxcclxuXHRcdFx0XHRtb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCksXHJcblx0XHRcdFx0bWFnID0gTWF0aC5hYnMoZGlyKSxcclxuXHRcdFx0XHRuZXdfbW9udGgsIHRlc3Q7XHJcblx0XHRcdGRpciA9IGRpciA+IDAgPyAxIDogLTE7XHJcblx0XHRcdGlmIChtYWcgPT09IDEpe1xyXG5cdFx0XHRcdHRlc3QgPSBkaXIgPT09IC0xXHJcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBiYWNrIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIG5vdCBjdXJyZW50IG1vbnRoXHJcblx0XHRcdFx0XHQvLyAoZWcsIE1hciAzMSAtPiBGZWIgMzEgPT0gRmViIDI4LCBub3QgTWFyIDAyKVxyXG5cdFx0XHRcdFx0PyBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSA9PT0gbW9udGg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBmb3J3YXJkIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIGFzIGV4cGVjdGVkXHJcblx0XHRcdFx0XHQvLyAoZWcsIEphbiAzMSAtPiBGZWIgMzEgPT0gRmViIDI4LCBub3QgTWFyIDAyKVxyXG5cdFx0XHRcdFx0OiBmdW5jdGlvbigpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSAhPT0gbmV3X21vbnRoO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRuZXdfbW9udGggPSBtb250aCArIGRpcjtcclxuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xyXG5cdFx0XHRcdC8vIERlYyAtPiBKYW4gKDEyKSBvciBKYW4gLT4gRGVjICgtMSkgLS0gbGltaXQgZXhwZWN0ZWQgZGF0ZSB0byAwLTExXHJcblx0XHRcdFx0bmV3X21vbnRoID0gKG5ld19tb250aCArIDEyKSAlIDEyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdC8vIEZvciBtYWduaXR1ZGVzID4xLCBtb3ZlIG9uZSBtb250aCBhdCBhIHRpbWUuLi5cclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGkgPCBtYWc7IGkrKylcclxuXHRcdFx0XHRcdC8vIC4uLndoaWNoIG1pZ2h0IGRlY3JlYXNlIHRoZSBkYXkgKGVnLCBKYW4gMzEgdG8gRmViIDI4LCBldGMpLi4uXHJcblx0XHRcdFx0XHRuZXdfZGF0ZSA9IHRoaXMubW92ZU1vbnRoKG5ld19kYXRlLCBkaXIpO1xyXG5cdFx0XHRcdC8vIC4uLnRoZW4gcmVzZXQgdGhlIGRheSwga2VlcGluZyBpdCBpbiB0aGUgbmV3IG1vbnRoXHJcblx0XHRcdFx0bmV3X21vbnRoID0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTtcclxuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENEYXRlKGRheSk7XHJcblx0XHRcdFx0dGVzdCA9IGZ1bmN0aW9uKCl7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3X21vbnRoICE9PSBuZXdfZGF0ZS5nZXRVVENNb250aCgpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQ29tbW9uIGRhdGUtcmVzZXR0aW5nIGxvb3AgLS0gaWYgZGF0ZSBpcyBiZXlvbmQgZW5kIG9mIG1vbnRoLCBtYWtlIGl0XHJcblx0XHRcdC8vIGVuZCBvZiBtb250aFxyXG5cdFx0XHR3aGlsZSAodGVzdCgpKXtcclxuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENEYXRlKC0tZGF5KTtcclxuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXdfZGF0ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0bW92ZVllYXI6IGZ1bmN0aW9uKGRhdGUsIGRpcil7XHJcblx0XHRcdHJldHVybiB0aGlzLm1vdmVNb250aChkYXRlLCBkaXIqMTIpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRtb3ZlQXZhaWxhYmxlRGF0ZTogZnVuY3Rpb24oZGF0ZSwgZGlyLCBmbil7XHJcblx0XHRcdGRvIHtcclxuXHRcdFx0XHRkYXRlID0gdGhpc1tmbl0oZGF0ZSwgZGlyKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aGlzLmRhdGVXaXRoaW5SYW5nZShkYXRlKSlcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdFx0Zm4gPSAnbW92ZURheSc7XHJcblx0XHRcdH1cclxuXHRcdFx0d2hpbGUgKHRoaXMuZGF0ZUlzRGlzYWJsZWQoZGF0ZSkpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHR9LFxyXG5cclxuXHRcdHdlZWtPZkRhdGVJc0Rpc2FibGVkOiBmdW5jdGlvbihkYXRlKXtcclxuXHRcdFx0cmV0dXJuICQuaW5BcnJheShkYXRlLmdldFVUQ0RheSgpLCB0aGlzLm8uZGF5c09mV2Vla0Rpc2FibGVkKSAhPT0gLTE7XHJcblx0XHR9LFxyXG5cclxuXHRcdGRhdGVJc0Rpc2FibGVkOiBmdW5jdGlvbihkYXRlKXtcclxuXHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHR0aGlzLndlZWtPZkRhdGVJc0Rpc2FibGVkKGRhdGUpIHx8XHJcblx0XHRcdFx0JC5ncmVwKHRoaXMuby5kYXRlc0Rpc2FibGVkLCBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHRcdHJldHVybiBpc1VUQ0VxdWFscyhkYXRlLCBkKTtcclxuXHRcdFx0XHR9KS5sZW5ndGggPiAwXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGRhdGVXaXRoaW5SYW5nZTogZnVuY3Rpb24oZGF0ZSl7XHJcblx0XHRcdHJldHVybiBkYXRlID49IHRoaXMuby5zdGFydERhdGUgJiYgZGF0ZSA8PSB0aGlzLm8uZW5kRGF0ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oZSl7XHJcblx0XHRcdGlmICghdGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykpe1xyXG5cdFx0XHRcdGlmIChlLmtleUNvZGUgPT09IDQwIHx8IGUua2V5Q29kZSA9PT0gMjcpIHsgLy8gYWxsb3cgZG93biB0byByZS1zaG93IHBpY2tlclxyXG5cdFx0XHRcdFx0dGhpcy5zaG93KCk7XHJcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGRhdGVDaGFuZ2VkID0gZmFsc2UsXHJcblx0XHRcdFx0ZGlyLCBuZXdWaWV3RGF0ZSxcclxuXHRcdFx0XHRmb2N1c0RhdGUgPSB0aGlzLmZvY3VzRGF0ZSB8fCB0aGlzLnZpZXdEYXRlO1xyXG5cdFx0XHRzd2l0Y2ggKGUua2V5Q29kZSl7XHJcblx0XHRcdFx0Y2FzZSAyNzogLy8gZXNjYXBlXHJcblx0XHRcdFx0XHRpZiAodGhpcy5mb2N1c0RhdGUpe1xyXG5cdFx0XHRcdFx0XHR0aGlzLmZvY3VzRGF0ZSA9IG51bGw7XHJcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLmRhdGVzLmdldCgtMSkgfHwgdGhpcy52aWV3RGF0ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5maWxsKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgMzc6IC8vIGxlZnRcclxuXHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxyXG5cdFx0XHRcdGNhc2UgMzk6IC8vIHJpZ2h0XHJcblx0XHRcdFx0Y2FzZSA0MDogLy8gZG93blxyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLm8ua2V5Ym9hcmROYXZpZ2F0aW9uIHx8IHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQubGVuZ3RoID09PSA3KVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGRpciA9IGUua2V5Q29kZSA9PT0gMzcgfHwgZS5rZXlDb2RlID09PSAzOCA/IC0xIDogMTtcclxuICAgICAgICAgIGlmICh0aGlzLnZpZXdNb2RlID09PSAwKSB7XHJcbiAgXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xyXG4gIFx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlQXZhaWxhYmxlRGF0ZShmb2N1c0RhdGUsIGRpciwgJ21vdmVZZWFyJyk7XHJcblxyXG4gIFx0XHRcdFx0XHRcdGlmIChuZXdWaWV3RGF0ZSlcclxuICBcdFx0XHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVllYXInLCB0aGlzLnZpZXdEYXRlKTtcclxuICBcdFx0XHRcdFx0fSBlbHNlIGlmIChlLnNoaWZ0S2V5KXtcclxuICBcdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZUF2YWlsYWJsZURhdGUoZm9jdXNEYXRlLCBkaXIsICdtb3ZlTW9udGgnKTtcclxuXHJcbiAgXHRcdFx0XHRcdFx0aWYgKG5ld1ZpZXdEYXRlKVxyXG4gIFx0XHRcdFx0XHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlTW9udGgnLCB0aGlzLnZpZXdEYXRlKTtcclxuICBcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDM3IHx8IGUua2V5Q29kZSA9PT0gMzkpe1xyXG4gIFx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlQXZhaWxhYmxlRGF0ZShmb2N1c0RhdGUsIGRpciwgJ21vdmVEYXknKTtcclxuICBcdFx0XHRcdFx0fSBlbHNlIGlmICghdGhpcy53ZWVrT2ZEYXRlSXNEaXNhYmxlZChmb2N1c0RhdGUpKXtcclxuICBcdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZUF2YWlsYWJsZURhdGUoZm9jdXNEYXRlLCBkaXIsICdtb3ZlV2VlaycpO1xyXG4gIFx0XHRcdFx0XHR9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlld01vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzggfHwgZS5rZXlDb2RlID09PSA0MCkge1xyXG4gICAgICAgICAgICAgIGRpciA9IGRpciAqIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZU1vbnRoJyk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlld01vZGUgPT09IDIpIHtcclxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzggfHwgZS5rZXlDb2RlID09PSA0MCkge1xyXG4gICAgICAgICAgICAgIGRpciA9IGRpciAqIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVBdmFpbGFibGVEYXRlKGZvY3VzRGF0ZSwgZGlyLCAnbW92ZVllYXInKTtcclxuICAgICAgICAgIH1cclxuXHRcdFx0XHRcdGlmIChuZXdWaWV3RGF0ZSl7XHJcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXNEYXRlID0gdGhpcy52aWV3RGF0ZSA9IG5ld1ZpZXdEYXRlO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDEzOiAvLyBlbnRlclxyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLm8uZm9yY2VQYXJzZSlcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRmb2N1c0RhdGUgPSB0aGlzLmZvY3VzRGF0ZSB8fCB0aGlzLmRhdGVzLmdldCgtMSkgfHwgdGhpcy52aWV3RGF0ZTtcclxuXHRcdFx0XHRcdGlmICh0aGlzLm8ua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX3RvZ2dsZV9tdWx0aWRhdGUoZm9jdXNEYXRlKTtcclxuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5mb2N1c0RhdGUgPSBudWxsO1xyXG5cdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMuZGF0ZXMuZ2V0KC0xKSB8fCB0aGlzLnZpZXdEYXRlO1xyXG5cdFx0XHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5maWxsKCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5waWNrZXIuaXMoJzp2aXNpYmxlJykpe1xyXG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLm8uYXV0b2Nsb3NlKVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSA5OiAvLyB0YWJcclxuXHRcdFx0XHRcdHRoaXMuZm9jdXNEYXRlID0gbnVsbDtcclxuXHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLmRhdGVzLmdldCgtMSkgfHwgdGhpcy52aWV3RGF0ZTtcclxuXHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoZGF0ZUNoYW5nZWQpe1xyXG5cdFx0XHRcdGlmICh0aGlzLmRhdGVzLmxlbmd0aClcclxuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZURhdGUnKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjbGVhckRhdGUnKTtcclxuXHRcdFx0XHR0aGlzLmlucHV0RmllbGQudHJpZ2dlcignY2hhbmdlJyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Vmlld01vZGU6IGZ1bmN0aW9uKHZpZXdNb2RlKXtcclxuXHRcdFx0dGhpcy52aWV3TW9kZSA9IHZpZXdNb2RlO1xyXG5cdFx0XHR0aGlzLnBpY2tlclxyXG5cdFx0XHRcdC5jaGlsZHJlbignZGl2JylcclxuXHRcdFx0XHQuaGlkZSgpXHJcblx0XHRcdFx0LmZpbHRlcignLmRhdGVwaWNrZXItJyArIERQR2xvYmFsLnZpZXdNb2Rlc1t0aGlzLnZpZXdNb2RlXS5jbHNOYW1lKVxyXG5cdFx0XHRcdFx0LnNob3coKTtcclxuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcclxuICAgICAgdGhpcy5fdHJpZ2dlcignY2hhbmdlVmlld01vZGUnLCBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0dmFyIERhdGVSYW5nZVBpY2tlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpe1xyXG5cdFx0JC5kYXRhKGVsZW1lbnQsICdkYXRlcGlja2VyJywgdGhpcyk7XHJcblx0XHR0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xyXG5cdFx0dGhpcy5pbnB1dHMgPSAkLm1hcChvcHRpb25zLmlucHV0cywgZnVuY3Rpb24oaSl7XHJcblx0XHRcdHJldHVybiBpLmpxdWVyeSA/IGlbMF0gOiBpO1xyXG5cdFx0fSk7XHJcblx0XHRkZWxldGUgb3B0aW9ucy5pbnB1dHM7XHJcblxyXG5cdFx0dGhpcy5rZWVwRW1wdHlWYWx1ZXMgPSBvcHRpb25zLmtlZXBFbXB0eVZhbHVlcztcclxuXHRcdGRlbGV0ZSBvcHRpb25zLmtlZXBFbXB0eVZhbHVlcztcclxuXHJcblx0XHRkYXRlcGlja2VyUGx1Z2luLmNhbGwoJCh0aGlzLmlucHV0cyksIG9wdGlvbnMpXHJcblx0XHRcdC5vbignY2hhbmdlRGF0ZScsICQucHJveHkodGhpcy5kYXRlVXBkYXRlZCwgdGhpcykpO1xyXG5cclxuXHRcdHRoaXMucGlja2VycyA9ICQubWFwKHRoaXMuaW5wdXRzLCBmdW5jdGlvbihpKXtcclxuXHRcdFx0cmV0dXJuICQuZGF0YShpLCAnZGF0ZXBpY2tlcicpO1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnVwZGF0ZURhdGVzKCk7XHJcblx0fTtcclxuXHREYXRlUmFuZ2VQaWNrZXIucHJvdG90eXBlID0ge1xyXG5cdFx0dXBkYXRlRGF0ZXM6IGZ1bmN0aW9uKCl7XHJcblx0XHRcdHRoaXMuZGF0ZXMgPSAkLm1hcCh0aGlzLnBpY2tlcnMsIGZ1bmN0aW9uKGkpe1xyXG5cdFx0XHRcdHJldHVybiBpLmdldFVUQ0RhdGUoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMudXBkYXRlUmFuZ2VzKCk7XHJcblx0XHR9LFxyXG5cdFx0dXBkYXRlUmFuZ2VzOiBmdW5jdGlvbigpe1xyXG5cdFx0XHR2YXIgcmFuZ2UgPSAkLm1hcCh0aGlzLmRhdGVzLCBmdW5jdGlvbihkKXtcclxuXHRcdFx0XHRyZXR1cm4gZC52YWx1ZU9mKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQkLmVhY2godGhpcy5waWNrZXJzLCBmdW5jdGlvbihpLCBwKXtcclxuXHRcdFx0XHRwLnNldFJhbmdlKHJhbmdlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cdFx0ZGF0ZVVwZGF0ZWQ6IGZ1bmN0aW9uKGUpe1xyXG5cdFx0XHQvLyBgdGhpcy51cGRhdGluZ2AgaXMgYSB3b3JrYXJvdW5kIGZvciBwcmV2ZW50aW5nIGluZmluaXRlIHJlY3Vyc2lvblxyXG5cdFx0XHQvLyBiZXR3ZWVuIGBjaGFuZ2VEYXRlYCB0cmlnZ2VyaW5nIGFuZCBgc2V0VVRDRGF0ZWAgY2FsbGluZy4gIFVudGlsXHJcblx0XHRcdC8vIHRoZXJlIGlzIGEgYmV0dGVyIG1lY2hhbmlzbS5cclxuXHRcdFx0aWYgKHRoaXMudXBkYXRpbmcpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdHZhciBkcCA9ICQuZGF0YShlLnRhcmdldCwgJ2RhdGVwaWNrZXInKTtcclxuXHJcblx0XHRcdGlmIChkcCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbmV3X2RhdGUgPSBkcC5nZXRVVENEYXRlKCksXHJcblx0XHRcdFx0a2VlcF9lbXB0eV92YWx1ZXMgPSB0aGlzLmtlZXBFbXB0eVZhbHVlcyxcclxuXHRcdFx0XHRpID0gJC5pbkFycmF5KGUudGFyZ2V0LCB0aGlzLmlucHV0cyksXHJcblx0XHRcdFx0aiA9IGkgLSAxLFxyXG5cdFx0XHRcdGsgPSBpICsgMSxcclxuXHRcdFx0XHRsID0gdGhpcy5pbnB1dHMubGVuZ3RoO1xyXG5cdFx0XHRpZiAoaSA9PT0gLTEpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0JC5lYWNoKHRoaXMucGlja2VycywgZnVuY3Rpb24oaSwgcCl7XHJcblx0XHRcdFx0aWYgKCFwLmdldFVUQ0RhdGUoKSAmJiAocCA9PT0gZHAgfHwgIWtlZXBfZW1wdHlfdmFsdWVzKSlcclxuXHRcdFx0XHRcdHAuc2V0VVRDRGF0ZShuZXdfZGF0ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKG5ld19kYXRlIDwgdGhpcy5kYXRlc1tqXSl7XHJcblx0XHRcdFx0Ly8gRGF0ZSBiZWluZyBtb3ZlZCBlYXJsaWVyL2xlZnRcclxuXHRcdFx0XHR3aGlsZSAoaiA+PSAwICYmIG5ld19kYXRlIDwgdGhpcy5kYXRlc1tqXSl7XHJcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbai0tXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAobmV3X2RhdGUgPiB0aGlzLmRhdGVzW2tdKXtcclxuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGxhdGVyL3JpZ2h0XHJcblx0XHRcdFx0d2hpbGUgKGsgPCBsICYmIG5ld19kYXRlID4gdGhpcy5kYXRlc1trXSl7XHJcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaysrXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy51cGRhdGVEYXRlcygpO1xyXG5cclxuXHRcdFx0ZGVsZXRlIHRoaXMudXBkYXRpbmc7XHJcblx0XHR9LFxyXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKXtcclxuXHRcdFx0JC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihwKXsgcC5kZXN0cm95KCk7IH0pO1xyXG5cdFx0XHQkKHRoaXMuaW5wdXRzKS5vZmYoJ2NoYW5nZURhdGUnLCB0aGlzLmRhdGVVcGRhdGVkKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZXBpY2tlcjtcclxuXHRcdH0sXHJcblx0XHRyZW1vdmU6IGFsaWFzKCdkZXN0cm95JywgJ01ldGhvZCBgcmVtb3ZlYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiAyLjAuIFVzZSBgZGVzdHJveWAgaW5zdGVhZCcpXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gb3B0c19mcm9tX2VsKGVsLCBwcmVmaXgpe1xyXG5cdFx0Ly8gRGVyaXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGRhdGEtYXR0cnNcclxuXHRcdHZhciBkYXRhID0gJChlbCkuZGF0YSgpLFxyXG5cdFx0XHRvdXQgPSB7fSwgaW5rZXksXHJcblx0XHRcdHJlcGxhY2UgPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpICsgJyhbQS1aXSknKTtcclxuXHRcdHByZWZpeCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4LnRvTG93ZXJDYXNlKCkpO1xyXG5cdFx0ZnVuY3Rpb24gcmVfbG93ZXIoXyxhKXtcclxuXHRcdFx0cmV0dXJuIGEudG9Mb3dlckNhc2UoKTtcclxuXHRcdH1cclxuXHRcdGZvciAodmFyIGtleSBpbiBkYXRhKVxyXG5cdFx0XHRpZiAocHJlZml4LnRlc3Qoa2V5KSl7XHJcblx0XHRcdFx0aW5rZXkgPSBrZXkucmVwbGFjZShyZXBsYWNlLCByZV9sb3dlcik7XHJcblx0XHRcdFx0b3V0W2lua2V5XSA9IGRhdGFba2V5XTtcclxuXHRcdFx0fVxyXG5cdFx0cmV0dXJuIG91dDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9wdHNfZnJvbV9sb2NhbGUobGFuZyl7XHJcblx0XHQvLyBEZXJpdmUgb3B0aW9ucyBmcm9tIGxvY2FsZSBwbHVnaW5zXHJcblx0XHR2YXIgb3V0ID0ge307XHJcblx0XHQvLyBDaGVjayBpZiBcImRlLURFXCIgc3R5bGUgZGF0ZSBpcyBhdmFpbGFibGUsIGlmIG5vdCBsYW5ndWFnZSBzaG91bGRcclxuXHRcdC8vIGZhbGxiYWNrIHRvIDIgbGV0dGVyIGNvZGUgZWcgXCJkZVwiXHJcblx0XHRpZiAoIWRhdGVzW2xhbmddKXtcclxuXHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXTtcclxuXHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgZCA9IGRhdGVzW2xhbmddO1xyXG5cdFx0JC5lYWNoKGxvY2FsZV9vcHRzLCBmdW5jdGlvbihpLGspe1xyXG5cdFx0XHRpZiAoayBpbiBkKVxyXG5cdFx0XHRcdG91dFtrXSA9IGRba107XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBvdXQ7XHJcblx0fVxyXG5cclxuXHR2YXIgb2xkID0gJC5mbi5kYXRlcGlja2VyO1xyXG5cdHZhciBkYXRlcGlja2VyUGx1Z2luID0gZnVuY3Rpb24ob3B0aW9uKXtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuXHRcdGFyZ3Muc2hpZnQoKTtcclxuXHRcdHZhciBpbnRlcm5hbF9yZXR1cm47XHJcblx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKXtcclxuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcclxuXHRcdFx0XHRkYXRhID0gJHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicpLFxyXG5cdFx0XHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0JyAmJiBvcHRpb247XHJcblx0XHRcdGlmICghZGF0YSl7XHJcblx0XHRcdFx0dmFyIGVsb3B0cyA9IG9wdHNfZnJvbV9lbCh0aGlzLCAnZGF0ZScpLFxyXG5cdFx0XHRcdFx0Ly8gUHJlbGltaW5hcnkgb3Rpb25zXHJcblx0XHRcdFx0XHR4b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZWxvcHRzLCBvcHRpb25zKSxcclxuXHRcdFx0XHRcdGxvY29wdHMgPSBvcHRzX2Zyb21fbG9jYWxlKHhvcHRzLmxhbmd1YWdlKSxcclxuXHRcdFx0XHRcdC8vIE9wdGlvbnMgcHJpb3JpdHk6IGpzIGFyZ3MsIGRhdGEtYXR0cnMsIGxvY2FsZXMsIGRlZmF1bHRzXHJcblx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBsb2NvcHRzLCBlbG9wdHMsIG9wdGlvbnMpO1xyXG5cdFx0XHRcdGlmICgkdGhpcy5oYXNDbGFzcygnaW5wdXQtZGF0ZXJhbmdlJykgfHwgb3B0cy5pbnB1dHMpe1xyXG5cdFx0XHRcdFx0JC5leHRlbmQob3B0cywge1xyXG5cdFx0XHRcdFx0XHRpbnB1dHM6IG9wdHMuaW5wdXRzIHx8ICR0aGlzLmZpbmQoJ2lucHV0JykudG9BcnJheSgpXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdGRhdGEgPSBuZXcgRGF0ZVJhbmdlUGlja2VyKHRoaXMsIG9wdHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGRhdGEgPSBuZXcgRGF0ZXBpY2tlcih0aGlzLCBvcHRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09PSAnZnVuY3Rpb24nKXtcclxuXHRcdFx0XHRpbnRlcm5hbF9yZXR1cm4gPSBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChcclxuXHRcdFx0aW50ZXJuYWxfcmV0dXJuID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0aW50ZXJuYWxfcmV0dXJuIGluc3RhbmNlb2YgRGF0ZXBpY2tlciB8fFxyXG5cdFx0XHRpbnRlcm5hbF9yZXR1cm4gaW5zdGFuY2VvZiBEYXRlUmFuZ2VQaWNrZXJcclxuXHRcdClcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0aWYgKHRoaXMubGVuZ3RoID4gMSlcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2luZyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBjb2xsZWN0aW9uIG9mIGEgc2luZ2xlIGVsZW1lbnQgKCcgKyBvcHRpb24gKyAnIGZ1bmN0aW9uKScpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxfcmV0dXJuO1xyXG5cdH07XHJcblx0JC5mbi5kYXRlcGlja2VyID0gZGF0ZXBpY2tlclBsdWdpbjtcclxuXHJcblx0dmFyIGRlZmF1bHRzID0gJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xyXG5cdFx0YXNzdW1lTmVhcmJ5WWVhcjogZmFsc2UsXHJcblx0XHRhdXRvY2xvc2U6IGZhbHNlLFxyXG5cdFx0YmVmb3JlU2hvd0RheTogJC5ub29wLFxyXG5cdFx0YmVmb3JlU2hvd01vbnRoOiAkLm5vb3AsXHJcblx0XHRiZWZvcmVTaG93WWVhcjogJC5ub29wLFxyXG5cdFx0YmVmb3JlU2hvd0RlY2FkZTogJC5ub29wLFxyXG5cdFx0YmVmb3JlU2hvd0NlbnR1cnk6ICQubm9vcCxcclxuXHRcdGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxyXG5cdFx0Y2xlYXJCdG46IGZhbHNlLFxyXG5cdFx0dG9nZ2xlQWN0aXZlOiBmYWxzZSxcclxuXHRcdGRheXNPZldlZWtEaXNhYmxlZDogW10sXHJcblx0XHRkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ6IFtdLFxyXG5cdFx0ZGF0ZXNEaXNhYmxlZDogW10sXHJcblx0XHRlbmREYXRlOiBJbmZpbml0eSxcclxuXHRcdGZvcmNlUGFyc2U6IHRydWUsXHJcblx0XHRmb3JtYXQ6ICdtbS9kZC95eXl5JyxcclxuXHRcdGtlZXBFbXB0eVZhbHVlczogZmFsc2UsXHJcblx0XHRrZXlib2FyZE5hdmlnYXRpb246IHRydWUsXHJcblx0XHRsYW5ndWFnZTogJ2VuJyxcclxuXHRcdG1pblZpZXdNb2RlOiAwLFxyXG5cdFx0bWF4Vmlld01vZGU6IDQsXHJcblx0XHRtdWx0aWRhdGU6IGZhbHNlLFxyXG5cdFx0bXVsdGlkYXRlU2VwYXJhdG9yOiAnLCcsXHJcblx0XHRvcmllbnRhdGlvbjogXCJhdXRvXCIsXHJcblx0XHRydGw6IGZhbHNlLFxyXG5cdFx0c3RhcnREYXRlOiAtSW5maW5pdHksXHJcblx0XHRzdGFydFZpZXc6IDAsXHJcblx0XHR0b2RheUJ0bjogZmFsc2UsXHJcblx0XHR0b2RheUhpZ2hsaWdodDogZmFsc2UsXHJcblx0XHR1cGRhdGVWaWV3RGF0ZTogdHJ1ZSxcclxuXHRcdHdlZWtTdGFydDogMCxcclxuXHRcdGRpc2FibGVUb3VjaEtleWJvYXJkOiBmYWxzZSxcclxuXHRcdGVuYWJsZU9uUmVhZG9ubHk6IHRydWUsXHJcblx0XHRzaG93T25Gb2N1czogdHJ1ZSxcclxuXHRcdHpJbmRleE9mZnNldDogMTAsXHJcblx0XHRjb250YWluZXI6ICdib2R5JyxcclxuXHRcdGltbWVkaWF0ZVVwZGF0ZXM6IGZhbHNlLFxyXG5cdFx0dGl0bGU6ICcnLFxyXG5cdFx0dGVtcGxhdGVzOiB7XHJcblx0XHRcdGxlZnRBcnJvdzogJyYjeDAwQUI7JyxcclxuXHRcdFx0cmlnaHRBcnJvdzogJyYjeDAwQkI7J1xyXG5cdFx0fSxcclxuICAgIHNob3dXZWVrRGF5czogdHJ1ZVxyXG5cdH07XHJcblx0dmFyIGxvY2FsZV9vcHRzID0gJC5mbi5kYXRlcGlja2VyLmxvY2FsZV9vcHRzID0gW1xyXG5cdFx0J2Zvcm1hdCcsXHJcblx0XHQncnRsJyxcclxuXHRcdCd3ZWVrU3RhcnQnXHJcblx0XTtcclxuXHQkLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlcGlja2VyO1xyXG5cdHZhciBkYXRlcyA9ICQuZm4uZGF0ZXBpY2tlci5kYXRlcyA9IHtcclxuXHRcdGVuOiB7XHJcblx0XHRcdGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxyXG5cdFx0XHRkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcclxuXHRcdFx0ZGF5c01pbjogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXHJcblx0XHRcdG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXHJcblx0XHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXHJcblx0XHRcdHRvZGF5OiBcIlRvZGF5XCIsXHJcblx0XHRcdGNsZWFyOiBcIkNsZWFyXCIsXHJcblx0XHRcdHRpdGxlRm9ybWF0OiBcIk1NIHl5eXlcIlxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdHZhciBEUEdsb2JhbCA9IHtcclxuXHRcdHZpZXdNb2RlczogW1xyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZXM6IFsnZGF5cycsICdtb250aCddLFxyXG5cdFx0XHRcdGNsc05hbWU6ICdkYXlzJyxcclxuXHRcdFx0XHRlOiAnY2hhbmdlTW9udGgnXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lczogWydtb250aHMnLCAneWVhciddLFxyXG5cdFx0XHRcdGNsc05hbWU6ICdtb250aHMnLFxyXG5cdFx0XHRcdGU6ICdjaGFuZ2VZZWFyJyxcclxuXHRcdFx0XHRuYXZTdGVwOiAxXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lczogWyd5ZWFycycsICdkZWNhZGUnXSxcclxuXHRcdFx0XHRjbHNOYW1lOiAneWVhcnMnLFxyXG5cdFx0XHRcdGU6ICdjaGFuZ2VEZWNhZGUnLFxyXG5cdFx0XHRcdG5hdlN0ZXA6IDEwXHJcblx0XHRcdH0sXHJcblx0XHRcdHtcclxuXHRcdFx0XHRuYW1lczogWydkZWNhZGVzJywgJ2NlbnR1cnknXSxcclxuXHRcdFx0XHRjbHNOYW1lOiAnZGVjYWRlcycsXHJcblx0XHRcdFx0ZTogJ2NoYW5nZUNlbnR1cnknLFxyXG5cdFx0XHRcdG5hdlN0ZXA6IDEwMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bmFtZXM6IFsnY2VudHVyaWVzJywgJ21pbGxlbm5pdW0nXSxcclxuXHRcdFx0XHRjbHNOYW1lOiAnY2VudHVyaWVzJyxcclxuXHRcdFx0XHRlOiAnY2hhbmdlTWlsbGVubml1bScsXHJcblx0XHRcdFx0bmF2U3RlcDogMTAwMFxyXG5cdFx0XHR9XHJcblx0XHRdLFxyXG5cdFx0dmFsaWRQYXJ0czogL2RkP3xERD98bW0/fE1NP3x5eSg/Onl5KT8vZyxcclxuXHRcdG5vbnB1bmN0dWF0aW9uOiAvW14gLVxcLzotQFxcdTVlNzRcXHU2NzA4XFx1NjVlNVxcWy1gey1+XFx0XFxuXFxyXSsvZyxcclxuXHRcdHBhcnNlRm9ybWF0OiBmdW5jdGlvbihmb3JtYXQpe1xyXG5cdFx0XHRpZiAodHlwZW9mIGZvcm1hdC50b1ZhbHVlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBmb3JtYXQudG9EaXNwbGF5ID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcclxuICAgICAgICAgICAgLy8gSUUgdHJlYXRzIFxcMCBhcyBhIHN0cmluZyBlbmQgaW4gaW5wdXRzICh0cnVuY2F0aW5nIHRoZSB2YWx1ZSksXHJcblx0XHRcdC8vIHNvIGl0J3MgYSBiYWQgZm9ybWF0IGRlbGltaXRlciwgYW55d2F5XHJcblx0XHRcdHZhciBzZXBhcmF0b3JzID0gZm9ybWF0LnJlcGxhY2UodGhpcy52YWxpZFBhcnRzLCAnXFwwJykuc3BsaXQoJ1xcMCcpLFxyXG5cdFx0XHRcdHBhcnRzID0gZm9ybWF0Lm1hdGNoKHRoaXMudmFsaWRQYXJ0cyk7XHJcblx0XHRcdGlmICghc2VwYXJhdG9ycyB8fCAhc2VwYXJhdG9ycy5sZW5ndGggfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIGZvcm1hdC5cIik7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHtzZXBhcmF0b3JzOiBzZXBhcmF0b3JzLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fSxcclxuXHRcdHBhcnNlRGF0ZTogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0LCBsYW5ndWFnZSwgYXNzdW1lTmVhcmJ5KXtcclxuXHRcdFx0aWYgKCFkYXRlKVxyXG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSlcclxuXHRcdFx0XHRyZXR1cm4gZGF0ZTtcclxuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKVxyXG5cdFx0XHRcdGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KGZvcm1hdCk7XHJcblx0XHRcdGlmIChmb3JtYXQudG9WYWx1ZSlcclxuXHRcdFx0XHRyZXR1cm4gZm9ybWF0LnRvVmFsdWUoZGF0ZSwgZm9ybWF0LCBsYW5ndWFnZSk7XHJcblx0XHRcdHZhciBmbl9tYXAgPSB7XHJcblx0XHRcdFx0XHRkOiAnbW92ZURheScsXHJcblx0XHRcdFx0XHRtOiAnbW92ZU1vbnRoJyxcclxuXHRcdFx0XHRcdHc6ICdtb3ZlV2VlaycsXHJcblx0XHRcdFx0XHR5OiAnbW92ZVllYXInXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRkYXRlQWxpYXNlcyA9IHtcclxuXHRcdFx0XHRcdHllc3RlcmRheTogJy0xZCcsXHJcblx0XHRcdFx0XHR0b2RheTogJyswZCcsXHJcblx0XHRcdFx0XHR0b21vcnJvdzogJysxZCdcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHBhcnRzLCBwYXJ0LCBkaXIsIGksIGZuO1xyXG5cdFx0XHRpZiAoZGF0ZSBpbiBkYXRlQWxpYXNlcyl7XHJcblx0XHRcdFx0ZGF0ZSA9IGRhdGVBbGlhc2VzW2RhdGVdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICgvXltcXC0rXVxcZCtbZG13eV0oW1xccyxdK1tcXC0rXVxcZCtbZG13eV0pKiQvaS50ZXN0KGRhdGUpKXtcclxuXHRcdFx0XHRwYXJ0cyA9IGRhdGUubWF0Y2goLyhbXFwtK11cXGQrKShbZG13eV0pL2dpKTtcclxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoKTtcclxuXHRcdFx0XHRmb3IgKGk9MDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHRcdHBhcnQgPSBwYXJ0c1tpXS5tYXRjaCgvKFtcXC0rXVxcZCspKFtkbXd5XSkvaSk7XHJcblx0XHRcdFx0XHRkaXIgPSBOdW1iZXIocGFydFsxXSk7XHJcblx0XHRcdFx0XHRmbiA9IGZuX21hcFtwYXJ0WzJdLnRvTG93ZXJDYXNlKCldO1xyXG5cdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlW2ZuXShkYXRlLCBkaXIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gRGF0ZXBpY2tlci5wcm90b3R5cGUuX3plcm9fdXRjX3RpbWUoZGF0ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcnRzID0gZGF0ZSAmJiBkYXRlLm1hdGNoKHRoaXMubm9ucHVuY3R1YXRpb24pIHx8IFtdO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gYXBwbHlOZWFyYnlZZWFyKHllYXIsIHRocmVzaG9sZCl7XHJcblx0XHRcdFx0aWYgKHRocmVzaG9sZCA9PT0gdHJ1ZSlcclxuXHRcdFx0XHRcdHRocmVzaG9sZCA9IDEwO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB5ZWFyIGlzIDIgZGlnaXRzIG9yIGxlc3MsIHRoYW4gdGhlIHVzZXIgbW9zdCBsaWtlbHkgaXMgdHJ5aW5nIHRvIGdldCBhIHJlY2VudCBjZW50dXJ5XHJcblx0XHRcdFx0aWYgKHllYXIgPCAxMDApe1xyXG5cdFx0XHRcdFx0eWVhciArPSAyMDAwO1xyXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIG5ldyB5ZWFyIGlzIG1vcmUgdGhhbiB0aHJlc2hvbGQgeWVhcnMgaW4gYWR2YW5jZSwgdXNlIGxhc3QgY2VudHVyeVxyXG5cdFx0XHRcdFx0aWYgKHllYXIgPiAoKG5ldyBEYXRlKCkpLmdldEZ1bGxZZWFyKCkrdGhyZXNob2xkKSl7XHJcblx0XHRcdFx0XHRcdHllYXIgLT0gMTAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHllYXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwYXJzZWQgPSB7fSxcclxuXHRcdFx0XHRzZXR0ZXJzX29yZGVyID0gWyd5eXl5JywgJ3l5JywgJ00nLCAnTU0nLCAnbScsICdtbScsICdkJywgJ2RkJ10sXHJcblx0XHRcdFx0c2V0dGVyc19tYXAgPSB7XHJcblx0XHRcdFx0XHR5eXl5OiBmdW5jdGlvbihkLHYpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZC5zZXRVVENGdWxsWWVhcihhc3N1bWVOZWFyYnkgPyBhcHBseU5lYXJieVllYXIodiwgYXNzdW1lTmVhcmJ5KSA6IHYpO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdG06IGZ1bmN0aW9uKGQsdil7XHJcblx0XHRcdFx0XHRcdGlmIChpc05hTihkKSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZDtcclxuXHRcdFx0XHRcdFx0diAtPSAxO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAodiA8IDApIHYgKz0gMTI7XHJcblx0XHRcdFx0XHRcdHYgJT0gMTI7XHJcblx0XHRcdFx0XHRcdGQuc2V0VVRDTW9udGgodik7XHJcblx0XHRcdFx0XHRcdHdoaWxlIChkLmdldFVUQ01vbnRoKCkgIT09IHYpXHJcblx0XHRcdFx0XHRcdFx0ZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpLTEpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZDtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRkOiBmdW5jdGlvbihkLHYpe1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZC5zZXRVVENEYXRlKHYpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dmFsLCBmaWx0ZXJlZDtcclxuXHRcdFx0c2V0dGVyc19tYXBbJ3l5J10gPSBzZXR0ZXJzX21hcFsneXl5eSddO1xyXG5cdFx0XHRzZXR0ZXJzX21hcFsnTSddID0gc2V0dGVyc19tYXBbJ01NJ10gPSBzZXR0ZXJzX21hcFsnbW0nXSA9IHNldHRlcnNfbWFwWydtJ107XHJcblx0XHRcdHNldHRlcnNfbWFwWydkZCddID0gc2V0dGVyc19tYXBbJ2QnXTtcclxuXHRcdFx0ZGF0ZSA9IFVUQ1RvZGF5KCk7XHJcblx0XHRcdHZhciBmcGFydHMgPSBmb3JtYXQucGFydHMuc2xpY2UoKTtcclxuXHRcdFx0Ly8gUmVtb3ZlIG5vb3AgcGFydHNcclxuXHRcdFx0aWYgKHBhcnRzLmxlbmd0aCAhPT0gZnBhcnRzLmxlbmd0aCl7XHJcblx0XHRcdFx0ZnBhcnRzID0gJChmcGFydHMpLmZpbHRlcihmdW5jdGlvbihpLHApe1xyXG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheShwLCBzZXR0ZXJzX29yZGVyKSAhPT0gLTE7XHJcblx0XHRcdFx0fSkudG9BcnJheSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIFByb2Nlc3MgcmVtYWluZGVyXHJcblx0XHRcdGZ1bmN0aW9uIG1hdGNoX3BhcnQoKXtcclxuXHRcdFx0XHR2YXIgbSA9IHRoaXMuc2xpY2UoMCwgcGFydHNbaV0ubGVuZ3RoKSxcclxuXHRcdFx0XHRcdHAgPSBwYXJ0c1tpXS5zbGljZSgwLCBtLmxlbmd0aCk7XHJcblx0XHRcdFx0cmV0dXJuIG0udG9Mb3dlckNhc2UoKSA9PT0gcC50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChwYXJ0cy5sZW5ndGggPT09IGZwYXJ0cy5sZW5ndGgpe1xyXG5cdFx0XHRcdHZhciBjbnQ7XHJcblx0XHRcdFx0Zm9yIChpPTAsIGNudCA9IGZwYXJ0cy5sZW5ndGg7IGkgPCBjbnQ7IGkrKyl7XHJcblx0XHRcdFx0XHR2YWwgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xyXG5cdFx0XHRcdFx0cGFydCA9IGZwYXJ0c1tpXTtcclxuXHRcdFx0XHRcdGlmIChpc05hTih2YWwpKXtcclxuXHRcdFx0XHRcdFx0c3dpdGNoIChwYXJ0KXtcclxuXHRcdFx0XHRcdFx0XHRjYXNlICdNTSc6XHJcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykuZmlsdGVyKG1hdGNoX3BhcnQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gJC5pbkFycmF5KGZpbHRlcmVkWzBdLCBkYXRlc1tsYW5ndWFnZV0ubW9udGhzKSArIDE7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlICdNJzpcclxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcmVkID0gJChkYXRlc1tsYW5ndWFnZV0ubW9udGhzU2hvcnQpLmZpbHRlcihtYXRjaF9wYXJ0KTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KSArIDE7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cGFyc2VkW3BhcnRdID0gdmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgX2RhdGUsIHM7XHJcblx0XHRcdFx0Zm9yIChpPTA7IGkgPCBzZXR0ZXJzX29yZGVyLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHRcdHMgPSBzZXR0ZXJzX29yZGVyW2ldO1xyXG5cdFx0XHRcdFx0aWYgKHMgaW4gcGFyc2VkICYmICFpc05hTihwYXJzZWRbc10pKXtcclxuXHRcdFx0XHRcdFx0X2RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcclxuXHRcdFx0XHRcdFx0c2V0dGVyc19tYXBbc10oX2RhdGUsIHBhcnNlZFtzXSk7XHJcblx0XHRcdFx0XHRcdGlmICghaXNOYU4oX2RhdGUpKVxyXG5cdFx0XHRcdFx0XHRcdGRhdGUgPSBfZGF0ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGRhdGU7XHJcblx0XHR9LFxyXG5cdFx0Zm9ybWF0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgZm9ybWF0LCBsYW5ndWFnZSl7XHJcblx0XHRcdGlmICghZGF0ZSlcclxuXHRcdFx0XHRyZXR1cm4gJyc7XHJcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcclxuXHRcdFx0XHRmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChmb3JtYXQpO1xyXG5cdFx0XHRpZiAoZm9ybWF0LnRvRGlzcGxheSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQudG9EaXNwbGF5KGRhdGUsIGZvcm1hdCwgbGFuZ3VhZ2UpO1xyXG4gICAgICAgICAgICB2YXIgdmFsID0ge1xyXG5cdFx0XHRcdGQ6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxyXG5cdFx0XHRcdEQ6IGRhdGVzW2xhbmd1YWdlXS5kYXlzU2hvcnRbZGF0ZS5nZXRVVENEYXkoKV0sXHJcblx0XHRcdFx0REQ6IGRhdGVzW2xhbmd1YWdlXS5kYXlzW2RhdGUuZ2V0VVRDRGF5KCldLFxyXG5cdFx0XHRcdG06IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXHJcblx0XHRcdFx0TTogZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0W2RhdGUuZ2V0VVRDTW9udGgoKV0sXHJcblx0XHRcdFx0TU06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNbZGF0ZS5nZXRVVENNb250aCgpXSxcclxuXHRcdFx0XHR5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxyXG5cdFx0XHRcdHl5eXk6IGRhdGUuZ2V0VVRDRnVsbFllYXIoKVxyXG5cdFx0XHR9O1xyXG5cdFx0XHR2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xyXG5cdFx0XHR2YWwubW0gPSAodmFsLm0gPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5tO1xyXG5cdFx0XHRkYXRlID0gW107XHJcblx0XHRcdHZhciBzZXBzID0gJC5leHRlbmQoW10sIGZvcm1hdC5zZXBhcmF0b3JzKTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmb3JtYXQucGFydHMubGVuZ3RoOyBpIDw9IGNudDsgaSsrKXtcclxuXHRcdFx0XHRpZiAoc2Vwcy5sZW5ndGgpXHJcblx0XHRcdFx0XHRkYXRlLnB1c2goc2Vwcy5zaGlmdCgpKTtcclxuXHRcdFx0XHRkYXRlLnB1c2godmFsW2Zvcm1hdC5wYXJ0c1tpXV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBkYXRlLmpvaW4oJycpO1xyXG5cdFx0fSxcclxuXHRcdGhlYWRUZW1wbGF0ZTogJzx0aGVhZD4nK1xyXG5cdFx0XHQgICAgICAgICAgICAgICc8dHI+JytcclxuXHRcdFx0ICAgICAgICAgICAgICAgICc8dGggY29sc3Bhbj1cIjdcIiBjbGFzcz1cImRhdGVwaWNrZXItdGl0bGVcIj48L3RoPicrXHJcblx0XHRcdCAgICAgICAgICAgICAgJzwvdHI+JytcclxuXHRcdFx0XHRcdFx0XHQnPHRyPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwicHJldlwiPicrZGVmYXVsdHMudGVtcGxhdGVzLmxlZnRBcnJvdysnPC90aD4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjb2xzcGFuPVwiNVwiIGNsYXNzPVwiZGF0ZXBpY2tlci1zd2l0Y2hcIj48L3RoPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwibmV4dFwiPicrZGVmYXVsdHMudGVtcGxhdGVzLnJpZ2h0QXJyb3crJzwvdGg+JytcclxuXHRcdFx0XHRcdFx0XHQnPC90cj4nK1xyXG5cdFx0XHRcdFx0XHQnPC90aGVhZD4nLFxyXG5cdFx0Y29udFRlbXBsYXRlOiAnPHRib2R5Pjx0cj48dGQgY29sc3Bhbj1cIjdcIj48L3RkPjwvdHI+PC90Ym9keT4nLFxyXG5cdFx0Zm9vdFRlbXBsYXRlOiAnPHRmb290PicrXHJcblx0XHRcdFx0XHRcdFx0Jzx0cj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidG9kYXlcIj48L3RoPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvdHI+JytcclxuXHRcdFx0XHRcdFx0XHQnPHRyPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI3XCIgY2xhc3M9XCJjbGVhclwiPjwvdGg+JytcclxuXHRcdFx0XHRcdFx0XHQnPC90cj4nK1xyXG5cdFx0XHRcdFx0XHQnPC90Zm9vdD4nXHJcblx0fTtcclxuXHREUEdsb2JhbC50ZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGF0ZXBpY2tlclwiPicrXHJcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRheXNcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInRhYmxlLWNvbmRlbnNlZFwiPicrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdFx0Jzx0Ym9keT48L3Rib2R5PicrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXHJcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLW1vbnRoc1wiPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JytcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXHJcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXllYXJzXCI+JytcclxuXHRcdFx0XHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5oZWFkVGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuZm9vdFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0JzwvdGFibGU+JytcclxuXHRcdFx0XHRcdFx0XHQnPC9kaXY+JytcclxuXHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItZGVjYWRlc1wiPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JytcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXHJcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWNlbnR1cmllc1wiPicrXHJcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+JytcclxuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuaGVhZFRlbXBsYXRlK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHREUEdsb2JhbC5jb250VGVtcGxhdGUrXHJcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcclxuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXHJcblx0XHRcdFx0XHRcdFx0JzwvZGl2PicrXHJcblx0XHRcdFx0XHRcdCc8L2Rpdj4nO1xyXG5cclxuXHQkLmZuLmRhdGVwaWNrZXIuRFBHbG9iYWwgPSBEUEdsb2JhbDtcclxuXHJcblxyXG5cdC8qIERBVEVQSUNLRVIgTk8gQ09ORkxJQ1RcclxuXHQqID09PT09PT09PT09PT09PT09PT0gKi9cclxuXHJcblx0JC5mbi5kYXRlcGlja2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpe1xyXG5cdFx0JC5mbi5kYXRlcGlja2VyID0gb2xkO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0LyogREFURVBJQ0tFUiBWRVJTSU9OXHJcblx0ICogPT09PT09PT09PT09PT09PT09PSAqL1xyXG5cdCQuZm4uZGF0ZXBpY2tlci52ZXJzaW9uID0gJzEuNy4xJztcclxuXHJcblx0JC5mbi5kYXRlcGlja2VyLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihtc2cpe1xyXG5cdFx0dmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuXHRcdGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0RFUFJFQ0FURUQ6ICcgKyBtc2cpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHQvKiBEQVRFUElDS0VSIERBVEEtQVBJXHJcblx0KiA9PT09PT09PT09PT09PT09PT0gKi9cclxuXHJcblx0JChkb2N1bWVudCkub24oXHJcblx0XHQnZm9jdXMuZGF0ZXBpY2tlci5kYXRhLWFwaSBjbGljay5kYXRlcGlja2VyLmRhdGEtYXBpJyxcclxuXHRcdCdbZGF0YS1wcm92aWRlPVwiZGF0ZXBpY2tlclwiXScsXHJcblx0XHRmdW5jdGlvbihlKXtcclxuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcclxuXHRcdFx0aWYgKCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSlcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0Ly8gY29tcG9uZW50IGNsaWNrIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2hvdyBpdFxyXG5cdFx0XHRkYXRlcGlja2VyUGx1Z2luLmNhbGwoJHRoaXMsICdzaG93Jyk7XHJcblx0XHR9XHJcblx0KTtcclxuXHQkKGZ1bmN0aW9uKCl7XHJcblx0XHRkYXRlcGlja2VyUGx1Z2luLmNhbGwoJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykpO1xyXG5cdH0pO1xyXG5cclxufSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ib290c3RyYXAtZGF0ZXBpY2tlci9kaXN0L2pzL2Jvb3RzdHJhcC1kYXRlcGlja2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9ib290c3RyYXAtZGF0ZXBpY2tlci9kaXN0L2pzL2Jvb3RzdHJhcC1kYXRlcGlja2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDMiLCIvKipcclxuKiBAdmVyc2lvbjogMi4xLjI1XHJcbiogQGF1dGhvcjogRGFuIEdyb3NzbWFuIGh0dHA6Ly93d3cuZGFuZ3Jvc3NtYW4uaW5mby9cclxuKiBAY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBEYW4gR3Jvc3NtYW4uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiogQGxpY2Vuc2U6IExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcbiogQHdlYnNpdGU6IGh0dHA6Ly93d3cuZGF0ZXJhbmdlcGlja2VyLmNvbS9cclxuKi9cclxuLy8gRm9sbG93IHRoZSBVTUQgdGVtcGxhdGUgaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci90ZW1wbGF0ZXMvcmV0dXJuRXhwb3J0c0dsb2JhbC5qc1xyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICAvLyBBTUQuIE1ha2UgZ2xvYmFseSBhdmFpbGFibGUgYXMgd2VsbFxyXG4gICAgICAgIGRlZmluZShbJ21vbWVudCcsICdqcXVlcnknXSwgZnVuY3Rpb24gKG1vbWVudCwganF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAocm9vdC5kYXRlcmFuZ2VwaWNrZXIgPSBmYWN0b3J5KG1vbWVudCwganF1ZXJ5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgLy8gTm9kZSAvIEJyb3dzZXJpZnlcclxuICAgICAgICAvL2lzb21vcnBoaWMgaXNzdWVcclxuICAgICAgICB2YXIgalF1ZXJ5ID0gKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpID8gd2luZG93LmpRdWVyeSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoIWpRdWVyeSkge1xyXG4gICAgICAgICAgICBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcclxuICAgICAgICAgICAgaWYgKCFqUXVlcnkuZm4pIGpRdWVyeS5mbiA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9tZW50ID0gKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5tb21lbnQgIT0gJ3VuZGVmaW5lZCcpID8gd2luZG93Lm1vbWVudCA6IHJlcXVpcmUoJ21vbWVudCcpO1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShtb21lbnQsIGpRdWVyeSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xyXG4gICAgICAgIHJvb3QuZGF0ZXJhbmdlcGlja2VyID0gZmFjdG9yeShyb290Lm1vbWVudCwgcm9vdC5qUXVlcnkpO1xyXG4gICAgfVxyXG59KHRoaXMsIGZ1bmN0aW9uKG1vbWVudCwgJCkge1xyXG4gICAgdmFyIERhdGVSYW5nZVBpY2tlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNiKSB7XHJcblxyXG4gICAgICAgIC8vZGVmYXVsdCBzZXR0aW5ncyBmb3Igb3B0aW9uc1xyXG4gICAgICAgIHRoaXMucGFyZW50RWwgPSAnYm9keSc7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcclxuICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IG1vbWVudCgpLnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgIHRoaXMuZW5kRGF0ZSA9IG1vbWVudCgpLmVuZE9mKCdkYXknKTtcclxuICAgICAgICB0aGlzLm1pbkRhdGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1heERhdGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRhdGVMaW1pdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b0FwcGx5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaW5nbGVEYXRlUGlja2VyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaG93RHJvcGRvd25zID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaG93V2Vla051bWJlcnMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNob3dJU09XZWVrTnVtYmVycyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2hvd0N1c3RvbVJhbmdlTGFiZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudGltZVBpY2tlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGltZVBpY2tlcjI0SG91ciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGltZVBpY2tlckluY3JlbWVudCA9IDE7XHJcbiAgICAgICAgdGhpcy50aW1lUGlja2VyU2Vjb25kcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGlua2VkQ2FsZW5kYXJzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmF1dG9VcGRhdGVJbnB1dCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hbHdheXNTaG93Q2FsZW5kYXJzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yYW5nZXMgPSB7fTtcclxuXHJcbiAgICAgICAgdGhpcy5vcGVucyA9ICdyaWdodCc7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNDbGFzcygncHVsbC1yaWdodCcpKVxyXG4gICAgICAgICAgICB0aGlzLm9wZW5zID0gJ2xlZnQnO1xyXG5cclxuICAgICAgICB0aGlzLmRyb3BzID0gJ2Rvd24nO1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQ2xhc3MoJ2Ryb3B1cCcpKVxyXG4gICAgICAgICAgICB0aGlzLmRyb3BzID0gJ3VwJztcclxuXHJcbiAgICAgICAgdGhpcy5idXR0b25DbGFzc2VzID0gJ2J0biBidG4tc20nO1xyXG4gICAgICAgIHRoaXMuYXBwbHlDbGFzcyA9ICdidG4tc3VjY2Vzcyc7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxDbGFzcyA9ICdidG4tZGVmYXVsdCc7XHJcblxyXG4gICAgICAgIHRoaXMubG9jYWxlID0ge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdsdHInLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IG1vbWVudC5sb2NhbGVEYXRhKCkubG9uZ0RhdGVGb3JtYXQoJ0wnKSxcclxuICAgICAgICAgICAgc2VwYXJhdG9yOiAnIC0gJyxcclxuICAgICAgICAgICAgYXBwbHlMYWJlbDogJ0FwcGx5JyxcclxuICAgICAgICAgICAgY2FuY2VsTGFiZWw6ICdDYW5jZWwnLFxyXG4gICAgICAgICAgICB3ZWVrTGFiZWw6ICdXJyxcclxuICAgICAgICAgICAgY3VzdG9tUmFuZ2VMYWJlbDogJ0N1c3RvbSBSYW5nZScsXHJcbiAgICAgICAgICAgIGRheXNPZldlZWs6IG1vbWVudC53ZWVrZGF5c01pbigpLFxyXG4gICAgICAgICAgICBtb250aE5hbWVzOiBtb21lbnQubW9udGhzU2hvcnQoKSxcclxuICAgICAgICAgICAgZmlyc3REYXk6IG1vbWVudC5sb2NhbGVEYXRhKCkuZmlyc3REYXlPZldlZWsoKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbigpIHsgfTtcclxuXHJcbiAgICAgICAgLy9zb21lIHN0YXRlIGluZm9ybWF0aW9uXHJcbiAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxlZnRDYWxlbmRhciA9IHt9O1xyXG4gICAgICAgIHRoaXMucmlnaHRDYWxlbmRhciA9IHt9O1xyXG5cclxuICAgICAgICAvL2N1c3RvbSBvcHRpb25zIGZyb20gdXNlclxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbClcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAvL2FsbG93IHNldHRpbmcgb3B0aW9ucyB3aXRoIGRhdGEgYXR0cmlidXRlc1xyXG4gICAgICAgIC8vZGF0YS1hcGkgb3B0aW9ucyB3aWxsIGJlIG92ZXJ3cml0dGVuIHdpdGggY3VzdG9tIGphdmFzY3JpcHQgb3B0aW9uc1xyXG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0aGlzLmVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy9odG1sIHRlbXBsYXRlIGZvciB0aGUgcGlja2VyIFVJXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlICE9PSAnc3RyaW5nJyAmJiAhKG9wdGlvbnMudGVtcGxhdGUgaW5zdGFuY2VvZiAkKSlcclxuICAgICAgICAgICAgb3B0aW9ucy50ZW1wbGF0ZSA9ICc8ZGl2IGNsYXNzPVwiZGF0ZXJhbmdlcGlja2VyIGRyb3Bkb3duLW1lbnVcIj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXIgbGVmdFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXJhbmdlcGlja2VyX2lucHV0XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwiaW5wdXQtbWluaSBmb3JtLWNvbnRyb2xcIiB0eXBlPVwidGV4dFwiIG5hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfc3RhcnRcIiB2YWx1ZT1cIlwiIC8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPGkgY2xhc3M9XCJmYSBmYS1jYWxlbmRhciBnbHlwaGljb24gZ2x5cGhpY29uLWNhbGVuZGFyXCI+PC9pPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjYWxlbmRhci10aW1lXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2PjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGkgY2xhc3M9XCJmYSBmYS1jbG9jay1vIGdseXBoaWNvbiBnbHlwaGljb24tdGltZVwiPjwvaT4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjYWxlbmRhci10YWJsZVwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjYWxlbmRhciByaWdodFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZGF0ZXJhbmdlcGlja2VyX2lucHV0XCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPGlucHV0IGNsYXNzPVwiaW5wdXQtbWluaSBmb3JtLWNvbnRyb2xcIiB0eXBlPVwidGV4dFwiIG5hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfZW5kXCIgdmFsdWU9XCJcIiAvPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtY2FsZW5kYXIgZ2x5cGhpY29uIGdseXBoaWNvbi1jYWxlbmRhclwiPjwvaT4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXItdGltZVwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtY2xvY2stbyBnbHlwaGljb24gZ2x5cGhpY29uLXRpbWVcIj48L2k+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2FsZW5kYXItdGFibGVcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmFuZ2VzXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJyYW5nZV9pbnB1dHNcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzxidXR0b24gY2xhc3M9XCJhcHBseUJ0blwiIGRpc2FibGVkPVwiZGlzYWJsZWRcIiB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cImNhbmNlbEJ0blwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG5cclxuICAgICAgICB0aGlzLnBhcmVudEVsID0gKG9wdGlvbnMucGFyZW50RWwgJiYgJChvcHRpb25zLnBhcmVudEVsKS5sZW5ndGgpID8gJChvcHRpb25zLnBhcmVudEVsKSA6ICQodGhpcy5wYXJlbnRFbCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSAkKG9wdGlvbnMudGVtcGxhdGUpLmFwcGVuZFRvKHRoaXMucGFyZW50RWwpO1xyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGhhbmRsZSBhbGwgdGhlIHBvc3NpYmxlIG9wdGlvbnMgb3ZlcnJpZGluZyBkZWZhdWx0c1xyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLmRpcmVjdGlvbiA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZS5kaXJlY3Rpb24gPSBvcHRpb25zLmxvY2FsZS5kaXJlY3Rpb247XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLmZvcm1hdCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZS5mb3JtYXQgPSBvcHRpb25zLmxvY2FsZS5mb3JtYXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLnNlcGFyYXRvciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZS5zZXBhcmF0b3IgPSBvcHRpb25zLmxvY2FsZS5zZXBhcmF0b3I7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLmRheXNPZldlZWsgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuZGF5c09mV2VlayA9IG9wdGlvbnMubG9jYWxlLmRheXNPZldlZWsuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUubW9udGhOYW1lcyA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUubW9udGhOYW1lcyA9IG9wdGlvbnMubG9jYWxlLm1vbnRoTmFtZXMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUuZmlyc3REYXkgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgIHRoaXMubG9jYWxlLmZpcnN0RGF5ID0gb3B0aW9ucy5sb2NhbGUuZmlyc3REYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLmFwcGx5TGFiZWwgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgIHRoaXMubG9jYWxlLmFwcGx5TGFiZWwgPSBvcHRpb25zLmxvY2FsZS5hcHBseUxhYmVsO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZS5jYW5jZWxMYWJlbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuY2FuY2VsTGFiZWwgPSBvcHRpb25zLmxvY2FsZS5jYW5jZWxMYWJlbDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUud2Vla0xhYmVsID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICB0aGlzLmxvY2FsZS53ZWVrTGFiZWwgPSBvcHRpb25zLmxvY2FsZS53ZWVrTGFiZWw7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWwgPT09ICdzdHJpbmcnKXtcclxuICAgICAgICAgICAgICAgIC8vU3VwcG9ydCB1bmljb2RlIGNoYXJzIGluIHRoZSBjdXN0b20gcmFuZ2UgbmFtZS5cclxuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcclxuICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gb3B0aW9ucy5sb2NhbGUuY3VzdG9tUmFuZ2VMYWJlbDtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZUh0bWwgPSBlbGVtLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGUuY3VzdG9tUmFuZ2VMYWJlbCA9IHJhbmdlSHRtbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLmxvY2FsZS5kaXJlY3Rpb24pO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3RhcnREYXRlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSBtb21lbnQob3B0aW9ucy5zdGFydERhdGUsIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lbmREYXRlID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gbW9tZW50KG9wdGlvbnMuZW5kRGF0ZSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1pbkRhdGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aGlzLm1pbkRhdGUgPSBtb21lbnQob3B0aW9ucy5taW5EYXRlLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4RGF0ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IG1vbWVudChvcHRpb25zLm1heERhdGUsIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdGFydERhdGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IG1vbWVudChvcHRpb25zLnN0YXJ0RGF0ZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lbmREYXRlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gbW9tZW50KG9wdGlvbnMuZW5kRGF0ZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5taW5EYXRlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhpcy5taW5EYXRlID0gbW9tZW50KG9wdGlvbnMubWluRGF0ZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tYXhEYXRlID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhpcy5tYXhEYXRlID0gbW9tZW50KG9wdGlvbnMubWF4RGF0ZSk7XHJcblxyXG4gICAgICAgIC8vIHNhbml0eSBjaGVjayBmb3IgYmFkIG9wdGlvbnNcclxuICAgICAgICBpZiAodGhpcy5taW5EYXRlICYmIHRoaXMuc3RhcnREYXRlLmlzQmVmb3JlKHRoaXMubWluRGF0ZSkpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gdGhpcy5taW5EYXRlLmNsb25lKCk7XHJcblxyXG4gICAgICAgIC8vIHNhbml0eSBjaGVjayBmb3IgYmFkIG9wdGlvbnNcclxuICAgICAgICBpZiAodGhpcy5tYXhEYXRlICYmIHRoaXMuZW5kRGF0ZS5pc0FmdGVyKHRoaXMubWF4RGF0ZSkpXHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMubWF4RGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYXBwbHlDbGFzcyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlDbGFzcyA9IG9wdGlvbnMuYXBwbHlDbGFzcztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbmNlbENsYXNzID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxDbGFzcyA9IG9wdGlvbnMuY2FuY2VsQ2xhc3M7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYXRlTGltaXQgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB0aGlzLmRhdGVMaW1pdCA9IG9wdGlvbnMuZGF0ZUxpbWl0O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMub3BlbnMgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aGlzLm9wZW5zID0gb3B0aW9ucy5vcGVucztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRyb3BzID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhpcy5kcm9wcyA9IG9wdGlvbnMuZHJvcHM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaG93V2Vla051bWJlcnMgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy5zaG93V2Vla051bWJlcnMgPSBvcHRpb25zLnNob3dXZWVrTnVtYmVycztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNob3dJU09XZWVrTnVtYmVycyA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLnNob3dJU09XZWVrTnVtYmVycyA9IG9wdGlvbnMuc2hvd0lTT1dlZWtOdW1iZXJzO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYnV0dG9uQ2xhc3NlcyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3NlcyA9IG9wdGlvbnMuYnV0dG9uQ2xhc3NlcztcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJ1dHRvbkNsYXNzZXMgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzZXMgPSBvcHRpb25zLmJ1dHRvbkNsYXNzZXMuam9pbignICcpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2hvd0Ryb3Bkb3ducyA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLnNob3dEcm9wZG93bnMgPSBvcHRpb25zLnNob3dEcm9wZG93bnM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaG93Q3VzdG9tUmFuZ2VMYWJlbCA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLnNob3dDdXN0b21SYW5nZUxhYmVsID0gb3B0aW9ucy5zaG93Q3VzdG9tUmFuZ2VMYWJlbDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZURhdGVQaWNrZXIgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICB0aGlzLnNpbmdsZURhdGVQaWNrZXIgPSBvcHRpb25zLnNpbmdsZURhdGVQaWNrZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZURhdGVQaWNrZXIpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVQaWNrZXIgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy50aW1lUGlja2VyID0gb3B0aW9ucy50aW1lUGlja2VyO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGltZVBpY2tlclNlY29uZHMgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy50aW1lUGlja2VyU2Vjb25kcyA9IG9wdGlvbnMudGltZVBpY2tlclNlY29uZHM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50aW1lUGlja2VySW5jcmVtZW50ID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgdGhpcy50aW1lUGlja2VySW5jcmVtZW50ID0gb3B0aW9ucy50aW1lUGlja2VySW5jcmVtZW50O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudGltZVBpY2tlcjI0SG91ciA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLnRpbWVQaWNrZXIyNEhvdXIgPSBvcHRpb25zLnRpbWVQaWNrZXIyNEhvdXI7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hdXRvQXBwbHkgPT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgdGhpcy5hdXRvQXBwbHkgPSBvcHRpb25zLmF1dG9BcHBseTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmF1dG9VcGRhdGVJbnB1dCA9PT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICB0aGlzLmF1dG9VcGRhdGVJbnB1dCA9IG9wdGlvbnMuYXV0b1VwZGF0ZUlucHV0O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGlua2VkQ2FsZW5kYXJzID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIHRoaXMubGlua2VkQ2FsZW5kYXJzID0gb3B0aW9ucy5saW5rZWRDYWxlbmRhcnM7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pc0ludmFsaWREYXRlID09PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICB0aGlzLmlzSW52YWxpZERhdGUgPSBvcHRpb25zLmlzSW52YWxpZERhdGU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pc0N1c3RvbURhdGUgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICAgIHRoaXMuaXNDdXN0b21EYXRlID0gb3B0aW9ucy5pc0N1c3RvbURhdGU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbHdheXNTaG93Q2FsZW5kYXJzID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIHRoaXMuYWx3YXlzU2hvd0NhbGVuZGFycyA9IG9wdGlvbnMuYWx3YXlzU2hvd0NhbGVuZGFycztcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGRheSBuYW1lcyBvcmRlciB0byBmaXJzdERheVxyXG4gICAgICAgIGlmICh0aGlzLmxvY2FsZS5maXJzdERheSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMubG9jYWxlLmZpcnN0RGF5O1xyXG4gICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZS5kYXlzT2ZXZWVrLnB1c2godGhpcy5sb2NhbGUuZGF5c09mV2Vlay5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBzdGFydCwgZW5kLCByYW5nZTtcclxuXHJcbiAgICAgICAgLy9pZiBubyBzdGFydC9lbmQgZGF0ZXMgc2V0LCBjaGVjayBpZiBhbiBpbnB1dCBlbGVtZW50IGNvbnRhaW5zIGluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0YXJ0RGF0ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdGlvbnMuZW5kRGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKCQodGhpcy5lbGVtZW50KS5pcygnaW5wdXRbdHlwZT10ZXh0XScpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gJCh0aGlzLmVsZW1lbnQpLnZhbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gdmFsLnNwbGl0KHRoaXMubG9jYWxlLnNlcGFyYXRvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KHNwbGl0WzBdLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IG1vbWVudChzcGxpdFsxXSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaW5nbGVEYXRlUGlja2VyICYmIHZhbCAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbW9tZW50KHZhbCwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtb21lbnQodmFsLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGVuZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnREYXRlKHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEVuZERhdGUoZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJhbmdlcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZm9yIChyYW5nZSBpbiBvcHRpb25zLnJhbmdlcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yYW5nZXNbcmFuZ2VdWzBdID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1vbWVudChvcHRpb25zLnJhbmdlc1tyYW5nZV1bMF0sIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBtb21lbnQob3B0aW9ucy5yYW5nZXNbcmFuZ2VdWzBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmFuZ2VzW3JhbmdlXVsxXSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbW9tZW50KG9wdGlvbnMucmFuZ2VzW3JhbmdlXVsxXSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtb21lbnQob3B0aW9ucy5yYW5nZXNbcmFuZ2VdWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3RhcnQgb3IgZW5kIGRhdGUgZXhjZWVkIHRob3NlIGFsbG93ZWQgYnkgdGhlIG1pbkRhdGUgb3IgZGF0ZUxpbWl0XHJcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zLCBzaG9ydGVuIHRoZSByYW5nZSB0byB0aGUgYWxsb3dhYmxlIHBlcmlvZC5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbkRhdGUgJiYgc3RhcnQuaXNCZWZvcmUodGhpcy5taW5EYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMubWluRGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYXhEYXRlID0gdGhpcy5tYXhEYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZUxpbWl0ICYmIG1heERhdGUgJiYgc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kYXRlTGltaXQpLmlzQWZ0ZXIobWF4RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RGF0ZSA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGF0ZUxpbWl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIGVuZC5pc0FmdGVyKG1heERhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IG1heERhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW5kIG9mIHRoZSByYW5nZSBpcyBiZWZvcmUgdGhlIG1pbmltdW0gb3IgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIG1heGltdW0sIGRvbid0IGRpc3BsYXkgdGhpcyByYW5nZSBvcHRpb24gYXQgYWxsLlxyXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLm1pbkRhdGUgJiYgZW5kLmlzQmVmb3JlKHRoaXMubWluRGF0ZSwgdGhpcy50aW1lcGlja2VyID8gJ21pbnV0ZScgOiAnZGF5JykpIFxyXG4gICAgICAgICAgICAgICAgICB8fCAobWF4RGF0ZSAmJiBzdGFydC5pc0FmdGVyKG1heERhdGUsIHRoaXMudGltZXBpY2tlciA/ICdtaW51dGUnIDogJ2RheScpKSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1N1cHBvcnQgdW5pY29kZSBjaGFycyBpbiB0aGUgcmFuZ2UgbmFtZXMuXHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XHJcbiAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHJhbmdlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlSHRtbCA9IGVsZW0udmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZXNbcmFuZ2VIdG1sXSA9IFtzdGFydCwgZW5kXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGxpc3QgPSAnPHVsPic7XHJcbiAgICAgICAgICAgIGZvciAocmFuZ2UgaW4gdGhpcy5yYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGxpc3QgKz0gJzxsaSBkYXRhLXJhbmdlLWtleT1cIicgKyByYW5nZSArICdcIj4nICsgcmFuZ2UgKyAnPC9saT4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dDdXN0b21SYW5nZUxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ICs9ICc8bGkgZGF0YS1yYW5nZS1rZXk9XCInICsgdGhpcy5sb2NhbGUuY3VzdG9tUmFuZ2VMYWJlbCArICdcIj4nICsgdGhpcy5sb2NhbGUuY3VzdG9tUmFuZ2VMYWJlbCArICc8L2xpPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGlzdCArPSAnPC91bD4nO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcucmFuZ2VzJykucHJlcGVuZChsaXN0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVQaWNrZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5zdGFydE9mKCdkYXknKTtcclxuICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdGhpcy5lbmREYXRlLmVuZE9mKCdkYXknKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyLXRpbWUnKS5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2Nhbid0IGJlIHVzZWQgdG9nZXRoZXIgZm9yIG5vd1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIgJiYgdGhpcy5hdXRvQXBwbHkpXHJcbiAgICAgICAgICAgIHRoaXMuYXV0b0FwcGx5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1dG9BcHBseSAmJiB0eXBlb2Ygb3B0aW9ucy5yYW5nZXMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yYW5nZXMnKS5oaWRlKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmF1dG9BcHBseSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuYXBwbHlCdG4sIC5jYW5jZWxCdG4nKS5hZGRDbGFzcygnaGlkZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlRGF0ZVBpY2tlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcygnc2luZ2xlJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci5sZWZ0JykuYWRkQ2xhc3MoJ3NpbmdsZScpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuY2FsZW5kYXIubGVmdCcpLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyLnJpZ2h0JykuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuZGF0ZXJhbmdlcGlja2VyX2lucHV0IGlucHV0LCAuZGF0ZXJhbmdlcGlja2VyX2lucHV0ID4gaScpLmhpZGUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcyB1bCcpLmhpZGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yYW5nZXMnKS5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgodHlwZW9mIG9wdGlvbnMucmFuZ2VzID09PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zaW5nbGVEYXRlUGlja2VyKSB8fCB0aGlzLmFsd2F5c1Nob3dDYWxlbmRhcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ3Nob3ctY2FsZW5kYXInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKCdvcGVucycgKyB0aGlzLm9wZW5zKTtcclxuXHJcbiAgICAgICAgLy9zd2FwIHRoZSBwb3NpdGlvbiBvZiB0aGUgcHJlZGVmaW5lZCByYW5nZXMgaWYgb3BlbnMgcmlnaHRcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmFuZ2VzICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wZW5zID09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcycpLnByZXBlbmRUbyggdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyLmxlZnQnKS5wYXJlbnQoKSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hcHBseSBDU1MgY2xhc3NlcyBhbmQgbGFiZWxzIHRvIGJ1dHRvbnNcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuYXBwbHlCdG4sIC5jYW5jZWxCdG4nKS5hZGRDbGFzcyh0aGlzLmJ1dHRvbkNsYXNzZXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmFwcGx5Q2xhc3MubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcuYXBwbHlCdG4nKS5hZGRDbGFzcyh0aGlzLmFwcGx5Q2xhc3MpO1xyXG4gICAgICAgIGlmICh0aGlzLmNhbmNlbENsYXNzLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmNhbmNlbEJ0bicpLmFkZENsYXNzKHRoaXMuY2FuY2VsQ2xhc3MpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5hcHBseUJ0bicpLmh0bWwodGhpcy5sb2NhbGUuYXBwbHlMYWJlbCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmNhbmNlbEJ0bicpLmh0bWwodGhpcy5sb2NhbGUuY2FuY2VsTGFiZWwpO1xyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhcicpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJy5wcmV2JywgJC5wcm94eSh0aGlzLmNsaWNrUHJldiwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJy5uZXh0JywgJC5wcm94eSh0aGlzLmNsaWNrTmV4dCwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duLmRhdGVyYW5nZXBpY2tlcicsICd0ZC5hdmFpbGFibGUnLCAkLnByb3h5KHRoaXMuY2xpY2tEYXRlLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZWVudGVyLmRhdGVyYW5nZXBpY2tlcicsICd0ZC5hdmFpbGFibGUnLCAkLnByb3h5KHRoaXMuaG92ZXJEYXRlLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlLmRhdGVyYW5nZXBpY2tlcicsICd0ZC5hdmFpbGFibGUnLCAkLnByb3h5KHRoaXMudXBkYXRlRm9ybUlucHV0cywgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignY2hhbmdlLmRhdGVyYW5nZXBpY2tlcicsICdzZWxlY3QueWVhcnNlbGVjdCcsICQucHJveHkodGhpcy5tb250aE9yWWVhckNoYW5nZWQsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2NoYW5nZS5kYXRlcmFuZ2VwaWNrZXInLCAnc2VsZWN0Lm1vbnRoc2VsZWN0JywgJC5wcm94eSh0aGlzLm1vbnRoT3JZZWFyQ2hhbmdlZCwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignY2hhbmdlLmRhdGVyYW5nZXBpY2tlcicsICdzZWxlY3QuaG91cnNlbGVjdCxzZWxlY3QubWludXRlc2VsZWN0LHNlbGVjdC5zZWNvbmRzZWxlY3Qsc2VsZWN0LmFtcG1zZWxlY3QnLCAkLnByb3h5KHRoaXMudGltZUNoYW5nZWQsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrLmRhdGVyYW5nZXBpY2tlcicsICcuZGF0ZXJhbmdlcGlja2VyX2lucHV0IGlucHV0JywgJC5wcm94eSh0aGlzLnNob3dDYWxlbmRhcnMsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ2ZvY3VzLmRhdGVyYW5nZXBpY2tlcicsICcuZGF0ZXJhbmdlcGlja2VyX2lucHV0IGlucHV0JywgJC5wcm94eSh0aGlzLmZvcm1JbnB1dHNGb2N1c2VkLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdibHVyLmRhdGVyYW5nZXBpY2tlcicsICcuZGF0ZXJhbmdlcGlja2VyX2lucHV0IGlucHV0JywgJC5wcm94eSh0aGlzLmZvcm1JbnB1dHNCbHVycmVkLCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdjaGFuZ2UuZGF0ZXJhbmdlcGlja2VyJywgJy5kYXRlcmFuZ2VwaWNrZXJfaW5wdXQgaW5wdXQnLCAkLnByb3h5KHRoaXMuZm9ybUlucHV0c0NoYW5nZWQsIHRoaXMpKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcycpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJ2J1dHRvbi5hcHBseUJ0bicsICQucHJveHkodGhpcy5jbGlja0FwcGx5LCB0aGlzKSlcclxuICAgICAgICAgICAgLm9uKCdjbGljay5kYXRlcmFuZ2VwaWNrZXInLCAnYnV0dG9uLmNhbmNlbEJ0bicsICQucHJveHkodGhpcy5jbGlja0NhbmNlbCwgdGhpcykpXHJcbiAgICAgICAgICAgIC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJ2xpJywgJC5wcm94eSh0aGlzLmNsaWNrUmFuZ2UsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlZW50ZXIuZGF0ZXJhbmdlcGlja2VyJywgJ2xpJywgJC5wcm94eSh0aGlzLmhvdmVyUmFuZ2UsIHRoaXMpKVxyXG4gICAgICAgICAgICAub24oJ21vdXNlbGVhdmUuZGF0ZXJhbmdlcGlja2VyJywgJ2xpJywgJC5wcm94eSh0aGlzLnVwZGF0ZUZvcm1JbnB1dHMsIHRoaXMpKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5pcygnaW5wdXQnKSB8fCB0aGlzLmVsZW1lbnQuaXMoJ2J1dHRvbicpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vbih7XHJcbiAgICAgICAgICAgICAgICAnY2xpY2suZGF0ZXJhbmdlcGlja2VyJzogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgJ2ZvY3VzLmRhdGVyYW5nZXBpY2tlcic6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICdrZXl1cC5kYXRlcmFuZ2VwaWNrZXInOiAkLnByb3h5KHRoaXMuZWxlbWVudENoYW5nZWQsIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgJ2tleWRvd24uZGF0ZXJhbmdlcGlja2VyJzogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJC5wcm94eSh0aGlzLnRvZ2dsZSwgdGhpcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBpZiBhdHRhY2hlZCB0byBhIHRleHQgaW5wdXQsIHNldCB0aGUgaW5pdGlhbCB2YWx1ZVxyXG4gICAgICAgIC8vXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2lucHV0JykgJiYgIXRoaXMuc2luZ2xlRGF0ZVBpY2tlciAmJiB0aGlzLmF1dG9VcGRhdGVJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudmFsKHRoaXMuc3RhcnREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpICsgdGhpcy5sb2NhbGUuc2VwYXJhdG9yICsgdGhpcy5lbmREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpICYmIHRoaXMuYXV0b1VwZGF0ZUlucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC52YWwodGhpcy5zdGFydERhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgRGF0ZVJhbmdlUGlja2VyLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3I6IERhdGVSYW5nZVBpY2tlcixcclxuXHJcbiAgICAgICAgc2V0U3RhcnREYXRlOiBmdW5jdGlvbihzdGFydERhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydERhdGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSBtb21lbnQoc3RhcnREYXRlLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydERhdGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSBtb21lbnQoc3RhcnREYXRlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSB0aGlzLnN0YXJ0RGF0ZS5zdGFydE9mKCdkYXknKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIgJiYgdGhpcy50aW1lUGlja2VySW5jcmVtZW50KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUubWludXRlKE1hdGgucm91bmQodGhpcy5zdGFydERhdGUubWludXRlKCkgLyB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpICogdGhpcy50aW1lUGlja2VySW5jcmVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1pbkRhdGUgJiYgdGhpcy5zdGFydERhdGUuaXNCZWZvcmUodGhpcy5taW5EYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSB0aGlzLm1pbkRhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIgJiYgdGhpcy50aW1lUGlja2VySW5jcmVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlLm1pbnV0ZShNYXRoLnJvdW5kKHRoaXMuc3RhcnREYXRlLm1pbnV0ZSgpIC8gdGhpcy50aW1lUGlja2VySW5jcmVtZW50KSAqIHRoaXMudGltZVBpY2tlckluY3JlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERhdGUgJiYgdGhpcy5zdGFydERhdGUuaXNBZnRlcih0aGlzLm1heERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHRoaXMubWF4RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZVBpY2tlciAmJiB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUubWludXRlKE1hdGguZmxvb3IodGhpcy5zdGFydERhdGUubWludXRlKCkgLyB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpICogdGhpcy50aW1lUGlja2VySW5jcmVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2hvd2luZylcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb250aHNJblZpZXcoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRFbmREYXRlOiBmdW5jdGlvbihlbmREYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kRGF0ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSBtb21lbnQoZW5kRGF0ZSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kRGF0ZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSBtb21lbnQoZW5kRGF0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcilcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMuZW5kRGF0ZS5lbmRPZignZGF5Jyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyICYmIHRoaXMudGltZVBpY2tlckluY3JlbWVudClcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZS5taW51dGUoTWF0aC5yb3VuZCh0aGlzLmVuZERhdGUubWludXRlKCkgLyB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpICogdGhpcy50aW1lUGlja2VySW5jcmVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUuaXNCZWZvcmUodGhpcy5zdGFydERhdGUpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1heERhdGUgJiYgdGhpcy5lbmREYXRlLmlzQWZ0ZXIodGhpcy5tYXhEYXRlKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMubWF4RGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZUxpbWl0ICYmIHRoaXMuc3RhcnREYXRlLmNsb25lKCkuYWRkKHRoaXMuZGF0ZUxpbWl0KS5pc0JlZm9yZSh0aGlzLmVuZERhdGUpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKS5hZGQodGhpcy5kYXRlTGltaXQpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1JpZ2h0VGltZSA9IHRoaXMuZW5kRGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2hvd2luZylcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb250aHNJblZpZXcoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0ludmFsaWREYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzQ3VzdG9tRGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaW1lUGlja2VyKCdsZWZ0Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVQaWNrZXIoJ3JpZ2h0Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5yaWdodCAuY2FsZW5kYXItdGltZSBzZWxlY3QnKS5hdHRyKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLmNhbGVuZGFyLXRpbWUgc2VsZWN0JykucmVtb3ZlQXR0cignZGlzYWJsZWQnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX2VuZFwiXScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfc3RhcnRcIl0nKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX2VuZFwiXScpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfc3RhcnRcIl0nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb250aHNJblZpZXcoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxlbmRhcnMoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtSW5wdXRzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlTW9udGhzSW5WaWV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgYm90aCBkYXRlcyBhcmUgdmlzaWJsZSBhbHJlYWR5LCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2luZ2xlRGF0ZVBpY2tlciAmJiB0aGlzLmxlZnRDYWxlbmRhci5tb250aCAmJiB0aGlzLnJpZ2h0Q2FsZW5kYXIubW9udGggJiZcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5zdGFydERhdGUuZm9ybWF0KCdZWVlZLU1NJykgPT0gdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGguZm9ybWF0KCdZWVlZLU1NJykgfHwgdGhpcy5zdGFydERhdGUuZm9ybWF0KCdZWVlZLU1NJykgPT0gdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLmZvcm1hdCgnWVlZWS1NTScpKVxyXG4gICAgICAgICAgICAgICAgICAgICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZW5kRGF0ZS5mb3JtYXQoJ1lZWVktTU0nKSA9PSB0aGlzLmxlZnRDYWxlbmRhci5tb250aC5mb3JtYXQoJ1lZWVktTU0nKSB8fCB0aGlzLmVuZERhdGUuZm9ybWF0KCdZWVlZLU1NJykgPT0gdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLmZvcm1hdCgnWVlZWS1NTScpKVxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aCA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCkuZGF0ZSgyKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saW5rZWRDYWxlbmRhcnMgJiYgKHRoaXMuZW5kRGF0ZS5tb250aCgpICE9IHRoaXMuc3RhcnREYXRlLm1vbnRoKCkgfHwgdGhpcy5lbmREYXRlLnllYXIoKSAhPSB0aGlzLnN0YXJ0RGF0ZS55ZWFyKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoID0gdGhpcy5lbmREYXRlLmNsb25lKCkuZGF0ZSgyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKS5kYXRlKDIpLmFkZCgxLCAnbW9udGgnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2FsZW5kYXIubW9udGguZm9ybWF0KCdZWVlZLU1NJykgIT0gdGhpcy5zdGFydERhdGUuZm9ybWF0KCdZWVlZLU1NJykgJiYgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLmZvcm1hdCgnWVlZWS1NTScpICE9IHRoaXMuc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGggPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpLmRhdGUoMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKS5kYXRlKDIpLmFkZCgxLCAnbW9udGgnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEYXRlICYmIHRoaXMubGlua2VkQ2FsZW5kYXJzICYmICF0aGlzLnNpbmdsZURhdGVQaWNrZXIgJiYgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoID4gdGhpcy5tYXhEYXRlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoID0gdGhpcy5tYXhEYXRlLmNsb25lKCkuZGF0ZSgyKTtcclxuICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aCA9IHRoaXMubWF4RGF0ZS5jbG9uZSgpLmRhdGUoMikuc3VidHJhY3QoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cGRhdGVDYWxlbmRhcnM6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvdXIsIG1pbnV0ZSwgc2Vjb25kO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcubGVmdCAuaG91cnNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWludXRlID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLmxlZnQgLm1pbnV0ZXNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy50aW1lUGlja2VyU2Vjb25kcyA/IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5sZWZ0IC5zZWNvbmRzZWxlY3QnKS52YWwoKSwgMTApIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGltZVBpY2tlcjI0SG91cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW1wbSA9IHRoaXMuY29udGFpbmVyLmZpbmQoJy5sZWZ0IC5hbXBtc2VsZWN0JykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnUE0nICYmIGhvdXIgPCAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbXBtID09PSAnQU0nICYmIGhvdXIgPT09IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBob3VyID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLnJpZ2h0IC5ob3Vyc2VsZWN0JykudmFsKCksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPSBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLm1pbnV0ZXNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy50aW1lUGlja2VyU2Vjb25kcyA/IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5yaWdodCAuc2Vjb25kc2VsZWN0JykudmFsKCksIDEwKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVQaWNrZXIyNEhvdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtcG0gPSB0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLmFtcG1zZWxlY3QnKS52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdQTScgJiYgaG91ciA8IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArPSAxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdBTScgJiYgaG91ciA9PT0gMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aC5ob3VyKGhvdXIpLm1pbnV0ZShtaW51dGUpLnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLmhvdXIoaG91cikubWludXRlKG1pbnV0ZSkuc2Vjb25kKHNlY29uZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FsZW5kYXIoJ2xlZnQnKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDYWxlbmRhcigncmlnaHQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vaGlnaGxpZ2h0IGFueSBwcmVkZWZpbmVkIHJhbmdlIG1hdGNoaW5nIHRoZSBjdXJyZW50IHN0YXJ0IGFuZCBlbmQgZGF0ZXNcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLnJhbmdlcyBsaScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSA9PSBudWxsKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUNob3NlbkxhYmVsKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVuZGVyQ2FsZW5kYXI6IGZ1bmN0aW9uKHNpZGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBtYXRyaXggb2YgZGF0ZXMgdGhhdCB3aWxsIHBvcHVsYXRlIHRoZSBjYWxlbmRhclxyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbGVuZGFyID0gc2lkZSA9PSAnbGVmdCcgPyB0aGlzLmxlZnRDYWxlbmRhciA6IHRoaXMucmlnaHRDYWxlbmRhcjtcclxuICAgICAgICAgICAgdmFyIG1vbnRoID0gY2FsZW5kYXIubW9udGgubW9udGgoKTtcclxuICAgICAgICAgICAgdmFyIHllYXIgPSBjYWxlbmRhci5tb250aC55ZWFyKCk7XHJcbiAgICAgICAgICAgIHZhciBob3VyID0gY2FsZW5kYXIubW9udGguaG91cigpO1xyXG4gICAgICAgICAgICB2YXIgbWludXRlID0gY2FsZW5kYXIubW9udGgubWludXRlKCk7XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSBjYWxlbmRhci5tb250aC5zZWNvbmQoKTtcclxuICAgICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gbW9tZW50KFt5ZWFyLCBtb250aF0pLmRheXNJbk1vbnRoKCk7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdERheSA9IG1vbWVudChbeWVhciwgbW9udGgsIDFdKTtcclxuICAgICAgICAgICAgdmFyIGxhc3REYXkgPSBtb21lbnQoW3llYXIsIG1vbnRoLCBkYXlzSW5Nb250aF0pO1xyXG4gICAgICAgICAgICB2YXIgbGFzdE1vbnRoID0gbW9tZW50KGZpcnN0RGF5KS5zdWJ0cmFjdCgxLCAnbW9udGgnKS5tb250aCgpO1xyXG4gICAgICAgICAgICB2YXIgbGFzdFllYXIgPSBtb21lbnQoZmlyc3REYXkpLnN1YnRyYWN0KDEsICdtb250aCcpLnllYXIoKTtcclxuICAgICAgICAgICAgdmFyIGRheXNJbkxhc3RNb250aCA9IG1vbWVudChbbGFzdFllYXIsIGxhc3RNb250aF0pLmRheXNJbk1vbnRoKCk7XHJcbiAgICAgICAgICAgIHZhciBkYXlPZldlZWsgPSBmaXJzdERheS5kYXkoKTtcclxuXHJcbiAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSBhIDYgcm93cyB4IDcgY29sdW1ucyBhcnJheSBmb3IgdGhlIGNhbGVuZGFyXHJcbiAgICAgICAgICAgIHZhciBjYWxlbmRhciA9IFtdO1xyXG4gICAgICAgICAgICBjYWxlbmRhci5maXJzdERheSA9IGZpcnN0RGF5O1xyXG4gICAgICAgICAgICBjYWxlbmRhci5sYXN0RGF5ID0gbGFzdERheTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxlbmRhcltpXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3BvcHVsYXRlIHRoZSBjYWxlbmRhciB3aXRoIGRhdGUgb2JqZWN0c1xyXG4gICAgICAgICAgICB2YXIgc3RhcnREYXkgPSBkYXlzSW5MYXN0TW9udGggLSBkYXlPZldlZWsgKyB0aGlzLmxvY2FsZS5maXJzdERheSArIDE7XHJcbiAgICAgICAgICAgIGlmIChzdGFydERheSA+IGRheXNJbkxhc3RNb250aClcclxuICAgICAgICAgICAgICAgIHN0YXJ0RGF5IC09IDc7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF5T2ZXZWVrID09IHRoaXMubG9jYWxlLmZpcnN0RGF5KVxyXG4gICAgICAgICAgICAgICAgc3RhcnREYXkgPSBkYXlzSW5MYXN0TW9udGggLSA2O1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1ckRhdGUgPSBtb21lbnQoW2xhc3RZZWFyLCBsYXN0TW9udGgsIHN0YXJ0RGF5LCAxMiwgbWludXRlLCBzZWNvbmRdKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb2wsIHJvdztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNvbCA9IDAsIHJvdyA9IDA7IGkgPCA0MjsgaSsrLCBjb2wrKywgY3VyRGF0ZSA9IG1vbWVudChjdXJEYXRlKS5hZGQoMjQsICdob3VyJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMCAmJiBjb2wgJSA3ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sID0gMDtcclxuICAgICAgICAgICAgICAgICAgICByb3crKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyW3Jvd11bY29sXSA9IGN1ckRhdGUuY2xvbmUoKS5ob3VyKGhvdXIpLm1pbnV0ZShtaW51dGUpLnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgY3VyRGF0ZS5ob3VyKDEyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taW5EYXRlICYmIGNhbGVuZGFyW3Jvd11bY29sXS5mb3JtYXQoJ1lZWVktTU0tREQnKSA9PSB0aGlzLm1pbkRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgJiYgY2FsZW5kYXJbcm93XVtjb2xdLmlzQmVmb3JlKHRoaXMubWluRGF0ZSkgJiYgc2lkZSA9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhcltyb3ddW2NvbF0gPSB0aGlzLm1pbkRhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhEYXRlICYmIGNhbGVuZGFyW3Jvd11bY29sXS5mb3JtYXQoJ1lZWVktTU0tREQnKSA9PSB0aGlzLm1heERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgJiYgY2FsZW5kYXJbcm93XVtjb2xdLmlzQWZ0ZXIodGhpcy5tYXhEYXRlKSAmJiBzaWRlID09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhcltyb3ddW2NvbF0gPSB0aGlzLm1heERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vbWFrZSB0aGUgY2FsZW5kYXIgb2JqZWN0IGF2YWlsYWJsZSB0byBob3ZlckRhdGUvY2xpY2tEYXRlXHJcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBjYWxlbmRhclxyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBzaWRlID09ICdsZWZ0JyA/IHRoaXMubWluRGF0ZSA6IHRoaXMuc3RhcnREYXRlO1xyXG4gICAgICAgICAgICB2YXIgbWF4RGF0ZSA9IHRoaXMubWF4RGF0ZTtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2lkZSA9PSAnbGVmdCcgPyB0aGlzLnN0YXJ0RGF0ZSA6IHRoaXMuZW5kRGF0ZTtcclxuICAgICAgICAgICAgdmFyIGFycm93ID0gdGhpcy5sb2NhbGUuZGlyZWN0aW9uID09ICdsdHInID8ge2xlZnQ6ICdjaGV2cm9uLWxlZnQnLCByaWdodDogJ2NoZXZyb24tcmlnaHQnfSA6IHtsZWZ0OiAnY2hldnJvbi1yaWdodCcsIHJpZ2h0OiAnY2hldnJvbi1sZWZ0J307XHJcblxyXG4gICAgICAgICAgICB2YXIgaHRtbCA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZS1jb25kZW5zZWRcIj4nO1xyXG4gICAgICAgICAgICBodG1sICs9ICc8dGhlYWQ+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPHRyPic7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgZW1wdHkgY2VsbCBmb3Igd2VlayBudW1iZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd1dlZWtOdW1iZXJzIHx8IHRoaXMuc2hvd0lTT1dlZWtOdW1iZXJzKVxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRoPjwvdGg+JztcclxuXHJcbiAgICAgICAgICAgIGlmICgoIW1pbkRhdGUgfHwgbWluRGF0ZS5pc0JlZm9yZShjYWxlbmRhci5maXJzdERheSkpICYmICghdGhpcy5saW5rZWRDYWxlbmRhcnMgfHwgc2lkZSA9PSAnbGVmdCcpKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dGggY2xhc3M9XCJwcmV2IGF2YWlsYWJsZVwiPjxpIGNsYXNzPVwiZmEgZmEtJyArIGFycm93LmxlZnQgKyAnIGdseXBoaWNvbiBnbHlwaGljb24tJyArIGFycm93LmxlZnQgKyAnXCI+PC9pPjwvdGg+JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzx0aD48L3RoPic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRlSHRtbCA9IHRoaXMubG9jYWxlLm1vbnRoTmFtZXNbY2FsZW5kYXJbMV1bMV0ubW9udGgoKV0gKyBjYWxlbmRhclsxXVsxXS5mb3JtYXQoXCIgWVlZWVwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dEcm9wZG93bnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjYWxlbmRhclsxXVsxXS5tb250aCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRZZWFyID0gY2FsZW5kYXJbMV1bMV0ueWVhcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heFllYXIgPSAobWF4RGF0ZSAmJiBtYXhEYXRlLnllYXIoKSkgfHwgKGN1cnJlbnRZZWFyICsgNSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWWVhciA9IChtaW5EYXRlICYmIG1pbkRhdGUueWVhcigpKSB8fCAoY3VycmVudFllYXIgLSA1MCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5NaW5ZZWFyID0gY3VycmVudFllYXIgPT0gbWluWWVhcjtcclxuICAgICAgICAgICAgICAgIHZhciBpbk1heFllYXIgPSBjdXJyZW50WWVhciA9PSBtYXhZZWFyO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtb250aEh0bWwgPSAnPHNlbGVjdCBjbGFzcz1cIm1vbnRoc2VsZWN0XCI+JztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgMTI7IG0rKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoIWluTWluWWVhciB8fCBtID49IG1pbkRhdGUubW9udGgoKSkgJiYgKCFpbk1heFllYXIgfHwgbSA8PSBtYXhEYXRlLm1vbnRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoSHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgbSArIFwiJ1wiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtID09PSBjdXJyZW50TW9udGggPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIj5cIiArIHRoaXMubG9jYWxlLm1vbnRoTmFtZXNbbV0gKyBcIjwvb3B0aW9uPlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoSHRtbCArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgbSArIFwiJ1wiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtID09PSBjdXJyZW50TW9udGggPyBcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXCIgOiBcIlwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBkaXNhYmxlZD0nZGlzYWJsZWQnPlwiICsgdGhpcy5sb2NhbGUubW9udGhOYW1lc1ttXSArIFwiPC9vcHRpb24+XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW9udGhIdG1sICs9IFwiPC9zZWxlY3Q+XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHllYXJIdG1sID0gJzxzZWxlY3QgY2xhc3M9XCJ5ZWFyc2VsZWN0XCI+JztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSBtaW5ZZWFyOyB5IDw9IG1heFllYXI7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXJIdG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIHkgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHkgPT09IGN1cnJlbnRZZWFyID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInIDogJycpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJz4nICsgeSArICc8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeWVhckh0bWwgKz0gJzwvc2VsZWN0Pic7XHJcblxyXG4gICAgICAgICAgICAgICAgZGF0ZUh0bWwgPSBtb250aEh0bWwgKyB5ZWFySHRtbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJtb250aFwiPicgKyBkYXRlSHRtbCArICc8L3RoPic7XHJcbiAgICAgICAgICAgIGlmICgoIW1heERhdGUgfHwgbWF4RGF0ZS5pc0FmdGVyKGNhbGVuZGFyLmxhc3REYXkpKSAmJiAoIXRoaXMubGlua2VkQ2FsZW5kYXJzIHx8IHNpZGUgPT0gJ3JpZ2h0JyB8fCB0aGlzLnNpbmdsZURhdGVQaWNrZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dGggY2xhc3M9XCJuZXh0IGF2YWlsYWJsZVwiPjxpIGNsYXNzPVwiZmEgZmEtJyArIGFycm93LnJpZ2h0ICsgJyBnbHlwaGljb24gZ2x5cGhpY29uLScgKyBhcnJvdy5yaWdodCArICdcIj48L2k+PC90aD4nO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRoPjwvdGg+JztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPC90cj4nO1xyXG4gICAgICAgICAgICBodG1sICs9ICc8dHI+JztcclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCB3ZWVrIG51bWJlciBsYWJlbFxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93V2Vla051bWJlcnMgfHwgdGhpcy5zaG93SVNPV2Vla051bWJlcnMpXHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dGggY2xhc3M9XCJ3ZWVrXCI+JyArIHRoaXMubG9jYWxlLndlZWtMYWJlbCArICc8L3RoPic7XHJcblxyXG4gICAgICAgICAgICAkLmVhY2godGhpcy5sb2NhbGUuZGF5c09mV2VlaywgZnVuY3Rpb24oaW5kZXgsIGRheU9mV2Vlaykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRoPicgKyBkYXlPZldlZWsgKyAnPC90aD4nO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcclxuICAgICAgICAgICAgaHRtbCArPSAnPC90aGVhZD4nO1xyXG4gICAgICAgICAgICBodG1sICs9ICc8dGJvZHk+JztcclxuXHJcbiAgICAgICAgICAgIC8vYWRqdXN0IG1heERhdGUgdG8gcmVmbGVjdCB0aGUgZGF0ZUxpbWl0IHNldHRpbmcgaW4gb3JkZXIgdG9cclxuICAgICAgICAgICAgLy9ncmV5IG91dCBlbmQgZGF0ZXMgYmV5b25kIHRoZSBkYXRlTGltaXRcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSA9PSBudWxsICYmIHRoaXMuZGF0ZUxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4TGltaXQgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpLmFkZCh0aGlzLmRhdGVMaW1pdCkuZW5kT2YoJ2RheScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFtYXhEYXRlIHx8IG1heExpbWl0LmlzQmVmb3JlKG1heERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RGF0ZSA9IG1heExpbWl0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA2OyByb3crKykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPHRyPic7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHdlZWsgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93V2Vla051bWJlcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwid2Vla1wiPicgKyBjYWxlbmRhcltyb3ddWzBdLndlZWsoKSArICc8L3RkPic7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNob3dJU09XZWVrTnVtYmVycylcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCJ3ZWVrXCI+JyArIGNhbGVuZGFyW3Jvd11bMF0uaXNvV2VlaygpICsgJzwvdGQ+JztcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCA3OyBjb2wrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCB0b2RheSdzIGRhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJbcm93XVtjb2xdLmlzU2FtZShuZXcgRGF0ZSgpLCBcImRheVwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd0b2RheScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCB3ZWVrZW5kc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhcltyb3ddW2NvbF0uaXNvV2Vla2RheSgpID4gNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCd3ZWVrZW5kJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ3JleSBvdXQgdGhlIGRhdGVzIGluIG90aGVyIG1vbnRocyBkaXNwbGF5ZWQgYXQgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhpcyBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhcltyb3ddW2NvbF0ubW9udGgoKSAhPSBjYWxlbmRhclsxXVsxXS5tb250aCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ29mZicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Rvbid0IGFsbG93IHNlbGVjdGlvbiBvZiBkYXRlcyBiZWZvcmUgdGhlIG1pbmltdW0gZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pbkRhdGUgJiYgY2FsZW5kYXJbcm93XVtjb2xdLmlzQmVmb3JlKHRoaXMubWluRGF0ZSwgJ2RheScpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ29mZicsICdkaXNhYmxlZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Rvbid0IGFsbG93IHNlbGVjdGlvbiBvZiBkYXRlcyBhZnRlciB0aGUgbWF4aW11bSBkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heERhdGUgJiYgY2FsZW5kYXJbcm93XVtjb2xdLmlzQWZ0ZXIobWF4RGF0ZSwgJ2RheScpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ29mZicsICdkaXNhYmxlZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Rvbid0IGFsbG93IHNlbGVjdGlvbiBvZiBkYXRlIGlmIGEgY3VzdG9tIGZ1bmN0aW9uIGRlY2lkZXMgaXQncyBpbnZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnZhbGlkRGF0ZShjYWxlbmRhcltyb3ddW2NvbF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ29mZicsICdkaXNhYmxlZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2hpZ2hsaWdodCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHN0YXJ0IGRhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXJbcm93XVtjb2xdLmZvcm1hdCgnWVlZWS1NTS1ERCcpID09IHRoaXMuc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2FjdGl2ZScsICdzdGFydC1kYXRlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaGlnaGxpZ2h0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZW5kIGRhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlICE9IG51bGwgJiYgY2FsZW5kYXJbcm93XVtjb2xdLmZvcm1hdCgnWVlZWS1NTS1ERCcpID09IHRoaXMuZW5kRGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhY3RpdmUnLCAnZW5kLWRhdGUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9oaWdobGlnaHQgZGF0ZXMgaW4tYmV0d2VlbiB0aGUgc2VsZWN0ZWQgZGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlICE9IG51bGwgJiYgY2FsZW5kYXJbcm93XVtjb2xdID4gdGhpcy5zdGFydERhdGUgJiYgY2FsZW5kYXJbcm93XVtjb2xdIDwgdGhpcy5lbmREYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2luLXJhbmdlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgY3VzdG9tIGNsYXNzZXMgZm9yIHRoaXMgZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0N1c3RvbSA9IHRoaXMuaXNDdXN0b21EYXRlKGNhbGVuZGFyW3Jvd11bY29sXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzQ3VzdG9tID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChpc0N1c3RvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNsYXNzZXMsIGlzQ3VzdG9tKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbmFtZSA9ICcnLCBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbmFtZSArPSBjbGFzc2VzW2ldICsgJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlc1tpXSA9PSAnZGlzYWJsZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbmFtZSArPSAnYXZhaWxhYmxlJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPHRkIGNsYXNzPVwiJyArIGNuYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSArICdcIiBkYXRhLXRpdGxlPVwiJyArICdyJyArIHJvdyArICdjJyArIGNvbCArICdcIj4nICsgY2FsZW5kYXJbcm93XVtjb2xdLmRhdGUoKSArICc8L3RkPic7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPC90cj4nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBodG1sICs9ICc8L3Rib2R5Pic7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvdGFibGU+JztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci4nICsgc2lkZSArICcgLmNhbGVuZGFyLXRhYmxlJykuaHRtbChodG1sKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVuZGVyVGltZVBpY2tlcjogZnVuY3Rpb24oc2lkZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3QgYm90aGVyIHVwZGF0aW5nIHRoZSB0aW1lIHBpY2tlciBpZiBpdCdzIGN1cnJlbnRseSBkaXNhYmxlZFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGFuIGVuZCBkYXRlIGhhc24ndCBiZWVuIGNsaWNrZWQgeWV0XHJcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdyaWdodCcgJiYgIXRoaXMuZW5kRGF0ZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGh0bWwsIHNlbGVjdGVkLCBtaW5EYXRlLCBtYXhEYXRlID0gdGhpcy5tYXhEYXRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZUxpbWl0ICYmICghdGhpcy5tYXhEYXRlIHx8IHRoaXMuc3RhcnREYXRlLmNsb25lKCkuYWRkKHRoaXMuZGF0ZUxpbWl0KS5pc0FmdGVyKHRoaXMubWF4RGF0ZSkpKVxyXG4gICAgICAgICAgICAgICAgbWF4RGF0ZSA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCkuYWRkKHRoaXMuZGF0ZUxpbWl0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgbWluRGF0ZSA9IHRoaXMubWluRGF0ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaWRlID09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdGhpcy5lbmREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBtaW5EYXRlID0gdGhpcy5zdGFydERhdGU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9QcmVzZXJ2ZSB0aGUgdGltZSBhbHJlYWR5IHNlbGVjdGVkXHJcbiAgICAgICAgICAgICAgICB2YXIgdGltZVNlbGVjdG9yID0gdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyLnJpZ2h0IC5jYWxlbmRhci10aW1lIGRpdicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTZWxlY3Rvci5odG1sKCkgIT0gJycpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuaG91cih0aW1lU2VsZWN0b3IuZmluZCgnLmhvdXJzZWxlY3Qgb3B0aW9uOnNlbGVjdGVkJykudmFsKCkgfHwgc2VsZWN0ZWQuaG91cigpKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5taW51dGUodGltZVNlbGVjdG9yLmZpbmQoJy5taW51dGVzZWxlY3Qgb3B0aW9uOnNlbGVjdGVkJykudmFsKCkgfHwgc2VsZWN0ZWQubWludXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnNlY29uZCh0aW1lU2VsZWN0b3IuZmluZCgnLnNlY29uZHNlbGVjdCBvcHRpb246c2VsZWN0ZWQnKS52YWwoKSB8fCBzZWxlY3RlZC5zZWNvbmQoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbXBtID0gdGltZVNlbGVjdG9yLmZpbmQoJy5hbXBtc2VsZWN0IG9wdGlvbjpzZWxlY3RlZCcpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ1BNJyAmJiBzZWxlY3RlZC5ob3VyKCkgPCAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLmhvdXIoc2VsZWN0ZWQuaG91cigpICsgMTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ0FNJyAmJiBzZWxlY3RlZC5ob3VyKCkgPT09IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQuaG91cigwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5pc0JlZm9yZSh0aGlzLnN0YXJ0RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIHNlbGVjdGVkLmlzQWZ0ZXIobWF4RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBtYXhEYXRlLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBob3Vyc1xyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgaHRtbCA9ICc8c2VsZWN0IGNsYXNzPVwiaG91cnNlbGVjdFwiPic7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnRpbWVQaWNrZXIyNEhvdXIgPyAwIDogMTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMudGltZVBpY2tlcjI0SG91ciA/IDIzIDogMTI7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpX2luXzI0ID0gaTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKVxyXG4gICAgICAgICAgICAgICAgICAgIGlfaW5fMjQgPSBzZWxlY3RlZC5ob3VyKCkgPj0gMTIgPyAoaSA9PSAxMiA/IDEyIDogaSArIDEyKSA6IChpID09IDEyID8gMCA6IGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gc2VsZWN0ZWQuY2xvbmUoKS5ob3VyKGlfaW5fMjQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluRGF0ZSAmJiB0aW1lLm1pbnV0ZSg1OSkuaXNCZWZvcmUobWluRGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heERhdGUgJiYgdGltZS5taW51dGUoMCkuaXNBZnRlcihtYXhEYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlfaW5fMjQgPT0gc2VsZWN0ZWQuaG91cigpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIiBzZWxlY3RlZD1cInNlbGVjdGVkXCI+JyArIGkgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCIgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGNsYXNzPVwiZGlzYWJsZWRcIj4nICsgaSArICc8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCI+JyArIGkgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaHRtbCArPSAnPC9zZWxlY3Q+ICc7XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBtaW51dGVzXHJcbiAgICAgICAgICAgIC8vXHJcblxyXG4gICAgICAgICAgICBodG1sICs9ICc6IDxzZWxlY3QgY2xhc3M9XCJtaW51dGVzZWxlY3RcIj4nO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2MDsgaSArPSB0aGlzLnRpbWVQaWNrZXJJbmNyZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYWRkZWQgPSBpIDwgMTAgPyAnMCcgKyBpIDogaTtcclxuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gc2VsZWN0ZWQuY2xvbmUoKS5taW51dGUoaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluRGF0ZSAmJiB0aW1lLnNlY29uZCg1OSkuaXNCZWZvcmUobWluRGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heERhdGUgJiYgdGltZS5zZWNvbmQoMCkuaXNBZnRlcihtYXhEYXRlKSlcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkLm1pbnV0ZSgpID09IGkgJiYgIWRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiIHNlbGVjdGVkPVwic2VsZWN0ZWRcIj4nICsgcGFkZGVkICsgJzwvb3B0aW9uPic7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiIGRpc2FibGVkPVwiZGlzYWJsZWRcIiBjbGFzcz1cImRpc2FibGVkXCI+JyArIHBhZGRlZCArICc8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCI+JyArIHBhZGRlZCArICc8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBodG1sICs9ICc8L3NlbGVjdD4gJztcclxuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIHNlY29uZHNcclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXJTZWNvbmRzKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc6IDxzZWxlY3QgY2xhc3M9XCJzZWNvbmRzZWxlY3RcIj4nO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkZWQgPSBpIDwgMTAgPyAnMCcgKyBpIDogaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IHNlbGVjdGVkLmNsb25lKCkuc2Vjb25kKGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluRGF0ZSAmJiB0aW1lLmlzQmVmb3JlKG1pbkRhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heERhdGUgJiYgdGltZS5pc0FmdGVyKG1heERhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZC5zZWNvbmQoKSA9PSBpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiPicgKyBwYWRkZWQgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIiBkaXNhYmxlZD1cImRpc2FibGVkXCIgY2xhc3M9XCJkaXNhYmxlZFwiPicgKyBwYWRkZWQgKyAnPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCI+JyArIHBhZGRlZCArICc8L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8L3NlbGVjdD4gJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gQU0vUE1cclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8c2VsZWN0IGNsYXNzPVwiYW1wbXNlbGVjdFwiPic7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFtX2h0bWwgPSAnJztcclxuICAgICAgICAgICAgICAgIHZhciBwbV9odG1sID0gJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbkRhdGUgJiYgc2VsZWN0ZWQuY2xvbmUoKS5ob3VyKDEyKS5taW51dGUoMCkuc2Vjb25kKDApLmlzQmVmb3JlKG1pbkRhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGFtX2h0bWwgPSAnIGRpc2FibGVkPVwiZGlzYWJsZWRcIiBjbGFzcz1cImRpc2FibGVkXCInO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIHNlbGVjdGVkLmNsb25lKCkuaG91cigwKS5taW51dGUoMCkuc2Vjb25kKDApLmlzQWZ0ZXIobWF4RGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcG1faHRtbCA9ICcgZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGNsYXNzPVwiZGlzYWJsZWRcIic7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkLmhvdXIoKSA+PSAxMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCJBTVwiJyArIGFtX2h0bWwgKyAnPkFNPC9vcHRpb24+PG9wdGlvbiB2YWx1ZT1cIlBNXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyArIHBtX2h0bWwgKyAnPlBNPC9vcHRpb24+JztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSAnPG9wdGlvbiB2YWx1ZT1cIkFNXCIgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyArIGFtX2h0bWwgKyAnPkFNPC9vcHRpb24+PG9wdGlvbiB2YWx1ZT1cIlBNXCInICsgcG1faHRtbCArICc+UE08L29wdGlvbj4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gJzwvc2VsZWN0Pic7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJy5jYWxlbmRhci4nICsgc2lkZSArICcgLmNhbGVuZGFyLXRpbWUgZGl2JykuaHRtbChodG1sKTtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlRm9ybUlucHV0czogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAvL2lnbm9yZSBtb3VzZSBtb3ZlbWVudHMgd2hpbGUgYW4gYWJvdmUtY2FsZW5kYXIgdGV4dCBpbnB1dCBoYXMgZm9jdXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XScpLmlzKFwiOmZvY3VzXCIpIHx8IHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX2VuZF0nKS5pcyhcIjpmb2N1c1wiKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XScpLnZhbCh0aGlzLnN0YXJ0RGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZERhdGUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9lbmRdJykudmFsKHRoaXMuZW5kRGF0ZS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW5nbGVEYXRlUGlja2VyIHx8ICh0aGlzLmVuZERhdGUgJiYgKHRoaXMuc3RhcnREYXRlLmlzQmVmb3JlKHRoaXMuZW5kRGF0ZSkgfHwgdGhpcy5zdGFydERhdGUuaXNTYW1lKHRoaXMuZW5kRGF0ZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnYnV0dG9uLmFwcGx5QnRuJykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2J1dHRvbi5hcHBseUJ0bicpLmF0dHIoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9LFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyVG9wO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50UmlnaHRFZGdlID0gJCh3aW5kb3cpLndpZHRoKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnRFbC5pcygnYm9keScpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLnBhcmVudEVsLm9mZnNldCgpLnRvcCAtIHRoaXMucGFyZW50RWwuc2Nyb2xsVG9wKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5wYXJlbnRFbC5vZmZzZXQoKS5sZWZ0IC0gdGhpcy5wYXJlbnRFbC5zY3JvbGxMZWZ0KClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRSaWdodEVkZ2UgPSB0aGlzLnBhcmVudEVsWzBdLmNsaWVudFdpZHRoICsgdGhpcy5wYXJlbnRFbC5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kcm9wcyA9PSAndXAnKVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyVG9wID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpLnRvcCAtIHRoaXMuY29udGFpbmVyLm91dGVySGVpZ2h0KCkgLSBwYXJlbnRPZmZzZXQudG9wO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJUb3AgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCkudG9wICsgdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgLSBwYXJlbnRPZmZzZXQudG9wO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclt0aGlzLmRyb3BzID09ICd1cCcgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oJ2Ryb3B1cCcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3BlbnMgPT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogY29udGFpbmVyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJlbnRSaWdodEVkZ2UgLSB0aGlzLmVsZW1lbnQub2Zmc2V0KCkubGVmdCAtIHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogJ2F1dG8nXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wZW5zID09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogY29udGFpbmVyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuZWxlbWVudC5vZmZzZXQoKS5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgKyB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpIC8gMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB0aGlzLmNvbnRhaW5lci5vdXRlcldpZHRoKCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bydcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm9mZnNldCgpLmxlZnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogOVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IGNvbnRhaW5lclRvcCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmVsZW1lbnQub2Zmc2V0KCkubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bydcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyB0aGlzLmNvbnRhaW5lci5vdXRlcldpZHRoKCkgPiAkKHdpbmRvdykud2lkdGgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaG93aW5nKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjbGljayBwcm94eSB0aGF0IGlzIHByaXZhdGUgdG8gdGhpcyBpbnN0YW5jZSBvZiBkYXRlcGlja2VyLCBmb3IgdW5iaW5kaW5nXHJcbiAgICAgICAgICAgIHRoaXMuX291dHNpZGVDbGlja1Byb3h5ID0gJC5wcm94eShmdW5jdGlvbihlKSB7IHRoaXMub3V0c2lkZUNsaWNrKGUpOyB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJpbmQgZ2xvYmFsIGRhdGVwaWNrZXIgbW91c2Vkb3duIGZvciBoaWRpbmcgYW5kXHJcbiAgICAgICAgICAgICQoZG9jdW1lbnQpXHJcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24uZGF0ZXJhbmdlcGlja2VyJywgdGhpcy5fb3V0c2lkZUNsaWNrUHJveHkpXHJcbiAgICAgICAgICAgICAgLy8gYWxzbyBzdXBwb3J0IG1vYmlsZSBkZXZpY2VzXHJcbiAgICAgICAgICAgICAgLm9uKCd0b3VjaGVuZC5kYXRlcmFuZ2VwaWNrZXInLCB0aGlzLl9vdXRzaWRlQ2xpY2tQcm94eSlcclxuICAgICAgICAgICAgICAvLyBhbHNvIGV4cGxpY2l0bHkgcGxheSBuaWNlIHdpdGggQm9vdHN0cmFwIGRyb3Bkb3ducywgd2hpY2ggc3RvcFByb3BhZ2F0aW9uIHdoZW4gY2xpY2tpbmcgdGhlbVxyXG4gICAgICAgICAgICAgIC5vbignY2xpY2suZGF0ZXJhbmdlcGlja2VyJywgJ1tkYXRhLXRvZ2dsZT1kcm9wZG93bl0nLCB0aGlzLl9vdXRzaWRlQ2xpY2tQcm94eSlcclxuICAgICAgICAgICAgICAvLyBhbmQgYWxzbyBjbG9zZSB3aGVuIGZvY3VzIGNoYW5nZXMgdG8gb3V0c2lkZSB0aGUgcGlja2VyIChlZy4gdGFiYmluZyBiZXR3ZWVuIGNvbnRyb2xzKVxyXG4gICAgICAgICAgICAgIC5vbignZm9jdXNpbi5kYXRlcmFuZ2VwaWNrZXInLCB0aGlzLl9vdXRzaWRlQ2xpY2tQcm94eSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXBvc2l0aW9uIHRoZSBwaWNrZXIgaWYgdGhlIHdpbmRvdyBpcyByZXNpemVkIHdoaWxlIGl0J3Mgb3BlblxyXG4gICAgICAgICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS5kYXRlcmFuZ2VwaWNrZXInLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHsgdGhpcy5tb3ZlKGUpOyB9LCB0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9sZFN0YXJ0RGF0ZSA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMub2xkRW5kRGF0ZSA9IHRoaXMuZW5kRGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzUmlnaHRUaW1lID0gdGhpcy5lbmREYXRlLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc2hvdygpO1xyXG4gICAgICAgICAgICB0aGlzLm1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ3Nob3cuZGF0ZXJhbmdlcGlja2VyJywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoaWRlOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Nob3dpbmcpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vaW5jb21wbGV0ZSBkYXRlIHNlbGVjdGlvbiwgcmV2ZXJ0IHRvIGxhc3QgdmFsdWVzXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGF0ZSA9IHRoaXMub2xkU3RhcnREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSB0aGlzLm9sZEVuZERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9pZiBhIG5ldyBkYXRlIHJhbmdlIHdhcyBzZWxlY3RlZCwgaW52b2tlIHRoZSB1c2VyIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydERhdGUuaXNTYW1lKHRoaXMub2xkU3RhcnREYXRlKSB8fCAhdGhpcy5lbmREYXRlLmlzU2FtZSh0aGlzLm9sZEVuZERhdGUpKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLnN0YXJ0RGF0ZSwgdGhpcy5lbmREYXRlLCB0aGlzLmNob3NlbkxhYmVsKTtcclxuXHJcbiAgICAgICAgICAgIC8vaWYgcGlja2VyIGlzIGF0dGFjaGVkIHRvIGEgdGV4dCBpbnB1dCwgdXBkYXRlIGl0XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xyXG5cclxuICAgICAgICAgICAgJChkb2N1bWVudCkub2ZmKCcuZGF0ZXJhbmdlcGlja2VyJyk7XHJcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoJy5kYXRlcmFuZ2VwaWNrZXInKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignaGlkZS5kYXRlcmFuZ2VwaWNrZXInLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5pc1Nob3dpbmcgPSBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTaG93aW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb3V0c2lkZUNsaWNrOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkKGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIHBhZ2UgaXMgY2xpY2tlZCBhbnl3aGVyZSBleGNlcHQgd2l0aGluIHRoZSBkYXRlcmFuZ2VycGlja2VyL2J1dHRvblxyXG4gICAgICAgICAgICAvLyBpdHNlbGYgdGhlbiBjYWxsIHRoaXMuaGlkZSgpXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIC8vIGllIG1vZGFsIGRpYWxvZyBmaXhcclxuICAgICAgICAgICAgICAgIGUudHlwZSA9PSBcImZvY3VzaW5cIiB8fFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNsb3Nlc3QodGhpcy5lbGVtZW50KS5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgIHRhcmdldC5jbG9zZXN0KHRoaXMuY29udGFpbmVyKS5sZW5ndGggfHxcclxuICAgICAgICAgICAgICAgIHRhcmdldC5jbG9zZXN0KCcuY2FsZW5kYXItdGFibGUnKS5sZW5ndGhcclxuICAgICAgICAgICAgICAgICkgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ291dHNpZGVDbGljay5kYXRlcmFuZ2VwaWNrZXInLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzaG93Q2FsZW5kYXJzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ3Nob3ctY2FsZW5kYXInKTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdzaG93Q2FsZW5kYXIuZGF0ZXJhbmdlcGlja2VyJywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGlkZUNhbGVuZGFyczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzaG93LWNhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdoaWRlQ2FsZW5kYXIuZGF0ZXJhbmdlcGlja2VyJywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaG92ZXJSYW5nZTogZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy9pZ25vcmUgbW91c2UgbW92ZW1lbnRzIHdoaWxlIGFuIGFib3ZlLWNhbGVuZGFyIHRleHQgaW5wdXQgaGFzIGZvY3VzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9zdGFydF0nKS5pcyhcIjpmb2N1c1wiKSB8fCB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9lbmRdJykuaXMoXCI6Zm9jdXNcIikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmFuZ2Uta2V5Jyk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGFiZWwgPT0gdGhpcy5sb2NhbGUuY3VzdG9tUmFuZ2VMYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZXMgPSB0aGlzLnJhbmdlc1tsYWJlbF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9zdGFydF0nKS52YWwoZGF0ZXNbMF0uZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfZW5kXScpLnZhbChkYXRlc1sxXS5mb3JtYXQodGhpcy5sb2NhbGUuZm9ybWF0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xpY2tSYW5nZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmFuZ2Uta2V5Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2hvc2VuTGFiZWwgPSBsYWJlbDtcclxuICAgICAgICAgICAgaWYgKGxhYmVsID09IHRoaXMubG9jYWxlLmN1c3RvbVJhbmdlTGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NhbGVuZGFycygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGVzID0gdGhpcy5yYW5nZXNbbGFiZWxdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUgPSBkYXRlc1swXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IGRhdGVzWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydERhdGUuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlLmVuZE9mKCdkYXknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWx3YXlzU2hvd0NhbGVuZGFycylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVDYWxlbmRhcnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tBcHBseSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xpY2tQcmV2OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWwgPSAkKGUudGFyZ2V0KS5wYXJlbnRzKCcuY2FsZW5kYXInKTtcclxuICAgICAgICAgICAgaWYgKGNhbC5oYXNDbGFzcygnbGVmdCcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRDYWxlbmRhci5tb250aC5zdWJ0cmFjdCgxLCAnbW9udGgnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmtlZENhbGVuZGFycylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Q2FsZW5kYXIubW9udGguc3VidHJhY3QoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Q2FsZW5kYXIubW9udGguc3VidHJhY3QoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxlbmRhcnMoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGlja05leHQ6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdmFyIGNhbCA9ICQoZS50YXJnZXQpLnBhcmVudHMoJy5jYWxlbmRhcicpO1xyXG4gICAgICAgICAgICBpZiAoY2FsLmhhc0NsYXNzKCdsZWZ0JykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdENhbGVuZGFyLm1vbnRoLmFkZCgxLCAnbW9udGgnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aC5hZGQoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5rZWRDYWxlbmRhcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Q2FsZW5kYXIubW9udGguYWRkKDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FsZW5kYXJzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaG92ZXJEYXRlOiBmdW5jdGlvbihlKSB7XHJcblxyXG4gICAgICAgICAgICAvL2lnbm9yZSBtb3VzZSBtb3ZlbWVudHMgd2hpbGUgYW4gYWJvdmUtY2FsZW5kYXIgdGV4dCBpbnB1dCBoYXMgZm9jdXNcclxuICAgICAgICAgICAgLy9pZiAodGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfc3RhcnRdJykuaXMoXCI6Zm9jdXNcIikgfHwgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfZW5kXScpLmlzKFwiOmZvY3VzXCIpKVxyXG4gICAgICAgICAgICAvLyAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvL2lnbm9yZSBkYXRlcyB0aGF0IGNhbid0IGJlIHNlbGVjdGVkXHJcbiAgICAgICAgICAgIGlmICghJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2F2YWlsYWJsZScpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvL2hhdmUgdGhlIHRleHQgaW5wdXRzIGFib3ZlIGNhbGVuZGFycyByZWZsZWN0IHRoZSBkYXRlIGJlaW5nIGhvdmVyZWQgb3ZlclxyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLXRpdGxlJyk7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSB0aXRsZS5zdWJzdHIoMSwgMSk7XHJcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aXRsZS5zdWJzdHIoMywgMSk7XHJcbiAgICAgICAgICAgIHZhciBjYWwgPSAkKGUudGFyZ2V0KS5wYXJlbnRzKCcuY2FsZW5kYXInKTtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBjYWwuaGFzQ2xhc3MoJ2xlZnQnKSA/IHRoaXMubGVmdENhbGVuZGFyLmNhbGVuZGFyW3Jvd11bY29sXSA6IHRoaXMucmlnaHRDYWxlbmRhci5jYWxlbmRhcltyb3ddW2NvbF07XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5lbmREYXRlICYmICF0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPWRhdGVyYW5nZXBpY2tlcl9zdGFydF0nKS5pcyhcIjpmb2N1c1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfc3RhcnRdJykudmFsKGRhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmVuZERhdGUgJiYgIXRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9ZGF0ZXJhbmdlcGlja2VyX2VuZF0nKS5pcyhcIjpmb2N1c1wiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1kYXRlcmFuZ2VwaWNrZXJfZW5kXScpLnZhbChkYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9oaWdobGlnaHQgdGhlIGRhdGVzIGJldHdlZW4gdGhlIHN0YXJ0IGRhdGUgYW5kIHRoZSBkYXRlIGJlaW5nIGhvdmVyZWQgYXMgYSBwb3RlbnRpYWwgZW5kIGRhdGVcclxuICAgICAgICAgICAgdmFyIGxlZnRDYWxlbmRhciA9IHRoaXMubGVmdENhbGVuZGFyO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRDYWxlbmRhciA9IHRoaXMucmlnaHRDYWxlbmRhcjtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IHRoaXMuc3RhcnREYXRlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyIHRib2R5IHRkJykuZWFjaChmdW5jdGlvbihpbmRleCwgZWwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIHdlZWsgbnVtYmVycywgb25seSBsb29rIGF0IGRhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQoZWwpLmhhc0NsYXNzKCd3ZWVrJykpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpdGxlID0gJChlbCkuYXR0cignZGF0YS10aXRsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aXRsZS5zdWJzdHIoMSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHRpdGxlLnN1YnN0cigzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsID0gJChlbCkucGFyZW50cygnLmNhbGVuZGFyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR0ID0gY2FsLmhhc0NsYXNzKCdsZWZ0JykgPyBsZWZ0Q2FsZW5kYXIuY2FsZW5kYXJbcm93XVtjb2xdIDogcmlnaHRDYWxlbmRhci5jYWxlbmRhcltyb3ddW2NvbF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZHQuaXNBZnRlcihzdGFydERhdGUpICYmIGR0LmlzQmVmb3JlKGRhdGUpKSB8fCBkdC5pc1NhbWUoZGF0ZSwgJ2RheScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZWwpLmFkZENsYXNzKCdpbi1yYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZWwpLnJlbW92ZUNsYXNzKCdpbi1yYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGlja0RhdGU6IGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2F2YWlsYWJsZScpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgdGl0bGUgPSAkKGUudGFyZ2V0KS5hdHRyKCdkYXRhLXRpdGxlJyk7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSB0aXRsZS5zdWJzdHIoMSwgMSk7XHJcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aXRsZS5zdWJzdHIoMywgMSk7XHJcbiAgICAgICAgICAgIHZhciBjYWwgPSAkKGUudGFyZ2V0KS5wYXJlbnRzKCcuY2FsZW5kYXInKTtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBjYWwuaGFzQ2xhc3MoJ2xlZnQnKSA/IHRoaXMubGVmdENhbGVuZGFyLmNhbGVuZGFyW3Jvd11bY29sXSA6IHRoaXMucmlnaHRDYWxlbmRhci5jYWxlbmRhcltyb3ddW2NvbF07XHJcblxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGRvIGEgZmV3IHRoaW5nczpcclxuICAgICAgICAgICAgLy8gKiBhbHRlcm5hdGUgYmV0d2VlbiBzZWxlY3RpbmcgYSBzdGFydCBhbmQgZW5kIGRhdGUgZm9yIHRoZSByYW5nZSxcclxuICAgICAgICAgICAgLy8gKiBpZiB0aGUgdGltZSBwaWNrZXIgaXMgZW5hYmxlZCwgYXBwbHkgdGhlIGhvdXIvbWludXRlL3NlY29uZCBmcm9tIHRoZSBzZWxlY3QgYm94ZXMgdG8gdGhlIGNsaWNrZWQgZGF0ZVxyXG4gICAgICAgICAgICAvLyAqIGlmIGF1dG9hcHBseSBpcyBlbmFibGVkLCBhbmQgYW4gZW5kIGRhdGUgd2FzIGNob3NlbiwgYXBwbHkgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgICAgICAvLyAqIGlmIHNpbmdsZSBkYXRlIHBpY2tlciBtb2RlLCBhbmQgdGltZSBwaWNrZXIgaXNuJ3QgZW5hYmxlZCwgYXBwbHkgdGhlIHNlbGVjdGlvbiBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICAvLyAqIGlmIG9uZSBvZiB0aGUgaW5wdXRzIGFib3ZlIHRoZSBjYWxlbmRhcnMgd2FzIGZvY3VzZWQsIGNhbmNlbCB0aGF0IG1hbnVhbCBpbnB1dFxyXG4gICAgICAgICAgICAvL1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW5kRGF0ZSB8fCBkYXRlLmlzQmVmb3JlKHRoaXMuc3RhcnREYXRlLCAnZGF5JykpIHsgLy9waWNraW5nIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lUGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvdXIgPSBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcubGVmdCAuaG91cnNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVQaWNrZXIyNEhvdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtcG0gPSB0aGlzLmNvbnRhaW5lci5maW5kKCcubGVmdCAuYW1wbXNlbGVjdCcpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ1BNJyAmJiBob3VyIDwgMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ0FNJyAmJiBob3VyID09PSAxMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWludXRlID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuZmluZCgnLmxlZnQgLm1pbnV0ZXNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZCA9IHRoaXMudGltZVBpY2tlclNlY29uZHMgPyBwYXJzZUludCh0aGlzLmNvbnRhaW5lci5maW5kKCcubGVmdCAuc2Vjb25kc2VsZWN0JykudmFsKCksIDEwKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGRhdGUuY2xvbmUoKS5ob3VyKGhvdXIpLm1pbnV0ZShtaW51dGUpLnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmREYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnREYXRlKGRhdGUuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZW5kRGF0ZSAmJiBkYXRlLmlzQmVmb3JlKHRoaXMuc3RhcnREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgLy9zcGVjaWFsIGNhc2U6IGNsaWNraW5nIHRoZSBzYW1lIGRhdGUgZm9yIHN0YXJ0L2VuZCxcclxuICAgICAgICAgICAgICAgIC8vYnV0IHRoZSB0aW1lIG9mIHRoZSBlbmQgZGF0ZSBpcyBiZWZvcmUgdGhlIHN0YXJ0IGRhdGVcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZSh0aGlzLnN0YXJ0RGF0ZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcGlja2luZyBlbmRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG91ciA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5yaWdodCAuaG91cnNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVQaWNrZXIyNEhvdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFtcG0gPSB0aGlzLmNvbnRhaW5lci5maW5kKCcucmlnaHQgLmFtcG1zZWxlY3QnKS52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdQTScgJiYgaG91ciA8IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91ciArPSAxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdBTScgJiYgaG91ciA9PT0gMTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbnV0ZSA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5yaWdodCAubWludXRlc2VsZWN0JykudmFsKCksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kID0gdGhpcy50aW1lUGlja2VyU2Vjb25kcyA/IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLmZpbmQoJy5yaWdodCAuc2Vjb25kc2VsZWN0JykudmFsKCksIDEwKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGRhdGUuY2xvbmUoKS5ob3VyKGhvdXIpLm1pbnV0ZShtaW51dGUpLnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmREYXRlKGRhdGUuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvQXBwbHkpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVDaG9zZW5MYWJlbCgpO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQXBwbHkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2luZ2xlRGF0ZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmREYXRlKHRoaXMuc3RhcnREYXRlKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tBcHBseSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhpcyBpcyB0byBjYW5jZWwgdGhlIGJsdXIgZXZlbnQgaGFuZGxlciBpZiB0aGUgbW91c2Ugd2FzIGluIG9uZSBvZiB0aGUgaW5wdXRzXHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNhbGN1bGF0ZUNob3NlbkxhYmVsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXN0b21SYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgcmFuZ2UgaW4gdGhpcy5yYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVQaWNrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydERhdGUuaXNTYW1lKHRoaXMucmFuZ2VzW3JhbmdlXVswXSkgJiYgdGhpcy5lbmREYXRlLmlzU2FtZSh0aGlzLnJhbmdlc1tyYW5nZV1bMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hvc2VuTGFiZWwgPSB0aGlzLmNvbnRhaW5lci5maW5kKCcucmFuZ2VzIGxpOmVxKCcgKyBpICsgJyknKS5hZGRDbGFzcygnYWN0aXZlJykuaHRtbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWdub3JlIHRpbWVzIHdoZW4gY29tcGFyaW5nIGRhdGVzIGlmIHRpbWUgcGlja2VyIGlzIG5vdCBlbmFibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpID09IHRoaXMucmFuZ2VzW3JhbmdlXVswXS5mb3JtYXQoJ1lZWVktTU0tREQnKSAmJiB0aGlzLmVuZERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgPT0gdGhpcy5yYW5nZXNbcmFuZ2VdWzFdLmZvcm1hdCgnWVlZWS1NTS1ERCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hvc2VuTGFiZWwgPSB0aGlzLmNvbnRhaW5lci5maW5kKCcucmFuZ2VzIGxpOmVxKCcgKyBpICsgJyknKS5hZGRDbGFzcygnYWN0aXZlJykuaHRtbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1c3RvbVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG93Q3VzdG9tUmFuZ2VMYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hvc2VuTGFiZWwgPSB0aGlzLmNvbnRhaW5lci5maW5kKCcucmFuZ2VzIGxpOmxhc3QnKS5hZGRDbGFzcygnYWN0aXZlJykuaHRtbCgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNob3NlbkxhYmVsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NhbGVuZGFycygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xpY2tBcHBseTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ2FwcGx5LmRhdGVyYW5nZXBpY2tlcicsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsaWNrQ2FuY2VsOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREYXRlID0gdGhpcy5vbGRTdGFydERhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMub2xkRW5kRGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdjYW5jZWwuZGF0ZXJhbmdlcGlja2VyJywgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbW9udGhPclllYXJDaGFuZ2VkOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0xlZnQgPSAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuY2FsZW5kYXInKS5oYXNDbGFzcygnbGVmdCcpLFxyXG4gICAgICAgICAgICAgICAgbGVmdE9yUmlnaHQgPSBpc0xlZnQgPyAnbGVmdCcgOiAncmlnaHQnLFxyXG4gICAgICAgICAgICAgICAgY2FsID0gdGhpcy5jb250YWluZXIuZmluZCgnLmNhbGVuZGFyLicrbGVmdE9yUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gTW9udGggbXVzdCBiZSBOdW1iZXIgZm9yIG5ldyBtb21lbnQgdmVyc2lvbnNcclxuICAgICAgICAgICAgdmFyIG1vbnRoID0gcGFyc2VJbnQoY2FsLmZpbmQoJy5tb250aHNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciB5ZWFyID0gY2FsLmZpbmQoJy55ZWFyc2VsZWN0JykudmFsKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHllYXIgPCB0aGlzLnN0YXJ0RGF0ZS55ZWFyKCkgfHwgKHllYXIgPT0gdGhpcy5zdGFydERhdGUueWVhcigpICYmIG1vbnRoIDwgdGhpcy5zdGFydERhdGUubW9udGgoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb250aCA9IHRoaXMuc3RhcnREYXRlLm1vbnRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeWVhciA9IHRoaXMuc3RhcnREYXRlLnllYXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubWluRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHllYXIgPCB0aGlzLm1pbkRhdGUueWVhcigpIHx8ICh5ZWFyID09IHRoaXMubWluRGF0ZS55ZWFyKCkgJiYgbW9udGggPCB0aGlzLm1pbkRhdGUubW9udGgoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb250aCA9IHRoaXMubWluRGF0ZS5tb250aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHllYXIgPSB0aGlzLm1pbkRhdGUueWVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXhEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeWVhciA+IHRoaXMubWF4RGF0ZS55ZWFyKCkgfHwgKHllYXIgPT0gdGhpcy5tYXhEYXRlLnllYXIoKSAmJiBtb250aCA+IHRoaXMubWF4RGF0ZS5tb250aCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gdGhpcy5tYXhEYXRlLm1vbnRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeWVhciA9IHRoaXMubWF4RGF0ZS55ZWFyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc0xlZnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdENhbGVuZGFyLm1vbnRoLm1vbnRoKG1vbnRoKS55ZWFyKHllYXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua2VkQ2FsZW5kYXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYWxlbmRhci5tb250aCA9IHRoaXMubGVmdENhbGVuZGFyLm1vbnRoLmNsb25lKCkuYWRkKDEsICdtb250aCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLm1vbnRoKG1vbnRoKS55ZWFyKHllYXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlua2VkQ2FsZW5kYXJzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdENhbGVuZGFyLm1vbnRoID0gdGhpcy5yaWdodENhbGVuZGFyLm1vbnRoLmNsb25lKCkuc3VidHJhY3QoMSwgJ21vbnRoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxlbmRhcnMoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0aW1lQ2hhbmdlZDogZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJy5jYWxlbmRhcicpLFxyXG4gICAgICAgICAgICAgICAgaXNMZWZ0ID0gY2FsLmhhc0NsYXNzKCdsZWZ0Jyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaG91ciA9IHBhcnNlSW50KGNhbC5maW5kKCcuaG91cnNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciBtaW51dGUgPSBwYXJzZUludChjYWwuZmluZCgnLm1pbnV0ZXNlbGVjdCcpLnZhbCgpLCAxMCk7XHJcbiAgICAgICAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnRpbWVQaWNrZXJTZWNvbmRzID8gcGFyc2VJbnQoY2FsLmZpbmQoJy5zZWNvbmRzZWxlY3QnKS52YWwoKSwgMTApIDogMDtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lUGlja2VyMjRIb3VyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW1wbSA9IGNhbC5maW5kKCcuYW1wbXNlbGVjdCcpLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdQTScgJiYgaG91ciA8IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ0FNJyAmJiBob3VyID09PSAxMilcclxuICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LmhvdXIoaG91cik7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5taW51dGUobWludXRlKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGFydERhdGUoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2luZ2xlRGF0ZVBpY2tlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kRGF0ZSA9IHRoaXMuc3RhcnREYXRlLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZW5kRGF0ZSAmJiB0aGlzLmVuZERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJykgPT0gc3RhcnQuZm9ybWF0KCdZWVlZLU1NLUREJykgJiYgdGhpcy5lbmREYXRlLmlzQmVmb3JlKHN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZShzdGFydC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVuZERhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZERhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGVuZC5ob3VyKGhvdXIpO1xyXG4gICAgICAgICAgICAgICAgZW5kLm1pbnV0ZShtaW51dGUpO1xyXG4gICAgICAgICAgICAgICAgZW5kLnNlY29uZChzZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmREYXRlKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBjYWxlbmRhcnMgc28gYWxsIGNsaWNrYWJsZSBkYXRlcyByZWZsZWN0IHRoZSBuZXcgdGltZSBjb21wb25lbnRcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxlbmRhcnMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBmb3JtIGlucHV0cyBhYm92ZSB0aGUgY2FsZW5kYXJzIHdpdGggdGhlIG5ldyB0aW1lXHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUlucHV0cygpO1xyXG5cclxuICAgICAgICAgICAgLy9yZS1yZW5kZXIgdGhlIHRpbWUgcGlja2VycyBiZWNhdXNlIGNoYW5naW5nIG9uZSBzZWxlY3Rpb24gY2FuIGFmZmVjdCB3aGF0J3MgZW5hYmxlZCBpbiBhbm90aGVyXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGltZVBpY2tlcignbGVmdCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVQaWNrZXIoJ3JpZ2h0Jyk7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZvcm1JbnB1dHNDaGFuZ2VkOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1JpZ2h0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLmNhbGVuZGFyJykuaGFzQ2xhc3MoJ3JpZ2h0Jyk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG1vbWVudCh0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XCJdJykudmFsKCksIHRoaXMubG9jYWxlLmZvcm1hdCk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBtb21lbnQodGhpcy5jb250YWluZXIuZmluZCgnaW5wdXRbbmFtZT1cImRhdGVyYW5nZXBpY2tlcl9lbmRcIl0nKS52YWwoKSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGFydC5pc1ZhbGlkKCkgJiYgZW5kLmlzVmFsaWQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0ICYmIGVuZC5pc0JlZm9yZShzdGFydCkpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXJ0RGF0ZShzdGFydCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVuZERhdGUoZW5kKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfc3RhcnRcIl0nKS52YWwodGhpcy5zdGFydERhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX2VuZFwiXScpLnZhbCh0aGlzLmVuZERhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZm9ybUlucHV0c0ZvY3VzZWQ6IGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0aGUgZm9jdXNlZCBpbnB1dFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX3N0YXJ0XCJdLCBpbnB1dFtuYW1lPVwiZGF0ZXJhbmdlcGlja2VyX2VuZFwiXScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgJChlLnRhcmdldCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBzdGF0ZSBzdWNoIHRoYXQgaWYgdGhlIHVzZXIgZ29lcyBiYWNrIHRvIHVzaW5nIGEgbW91c2UsIFxyXG4gICAgICAgICAgICAvLyB0aGUgY2FsZW5kYXJzIGFyZSBhd2FyZSB3ZSdyZSBzZWxlY3RpbmcgdGhlIGVuZCBvZiB0aGUgcmFuZ2UsIG5vdFxyXG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQuIFRoaXMgYWxsb3dzIHNvbWVvbmUgdG8gZWRpdCB0aGUgZW5kIG9mIGEgZGF0ZSByYW5nZSB3aXRob3V0XHJcbiAgICAgICAgICAgIC8vIHJlLXNlbGVjdGluZyB0aGUgYmVnaW5uaW5nLCBieSBjbGlja2luZyBvbiB0aGUgZW5kIGRhdGUgaW5wdXQgdGhlblxyXG4gICAgICAgICAgICAvLyB1c2luZyB0aGUgY2FsZW5kYXIuXHJcbiAgICAgICAgICAgIHZhciBpc1JpZ2h0ID0gJChlLnRhcmdldCkuY2xvc2VzdCgnLmNhbGVuZGFyJykuaGFzQ2xhc3MoJ3JpZ2h0Jyk7XHJcbiAgICAgICAgICAgIGlmIChpc1JpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGFydERhdGUodGhpcy5zdGFydERhdGUuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmb3JtSW5wdXRzQmx1cnJlZDogZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBoYXMgb25lIHB1cnBvc2UgcmlnaHQgbm93OiBpZiB5b3UgdGFiIGZyb20gdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIC8vIHRleHQgaW5wdXQgdG8gdGhlIHNlY29uZCBpbiB0aGUgVUksIHRoZSBlbmREYXRlIGlzIG51bGxlZCBzbyB0aGF0XHJcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gY2xpY2sgYW5vdGhlciwgYnV0IGlmIHlvdSB0YWIgb3V0IHdpdGhvdXQgY2xpY2tpbmcgYW55dGhpbmdcclxuICAgICAgICAgICAgLy8gb3IgY2hhbmdpbmcgdGhlIGlucHV0IHZhbHVlLCB0aGUgb2xkIGVuZERhdGUgc2hvdWxkIGJlIHJldGFpbmVkXHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJkYXRlcmFuZ2VwaWNrZXJfZW5kXCJdJykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbW9tZW50KHZhbCwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGlmIChlbmQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRFbmREYXRlKGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZWxlbWVudENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5pcygnaW5wdXQnKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC52YWwoKS5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC52YWwoKS5sZW5ndGggPCB0aGlzLmxvY2FsZS5mb3JtYXQubGVuZ3RoKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0ZVN0cmluZyA9IHRoaXMuZWxlbWVudC52YWwoKS5zcGxpdCh0aGlzLmxvY2FsZS5zZXBhcmF0b3IpLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsLFxyXG4gICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtb21lbnQoZGF0ZVN0cmluZ1swXSwgdGhpcy5sb2NhbGUuZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IG1vbWVudChkYXRlU3RyaW5nWzFdLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaW5nbGVEYXRlUGlja2VyIHx8IHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtb21lbnQodGhpcy5lbGVtZW50LnZhbCgpLCB0aGlzLmxvY2FsZS5mb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc3RhcnQuaXNWYWxpZCgpIHx8ICFlbmQuaXNWYWxpZCgpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXJ0RGF0ZShzdGFydCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RW5kRGF0ZShlbmQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBrZXlkb3duOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vaGlkZSBvbiB0YWIgb3IgZW50ZXJcclxuICAgICAgICAgICAgaWYgKChlLmtleUNvZGUgPT09IDkpIHx8IChlLmtleUNvZGUgPT09IDEzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cGRhdGVFbGVtZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5pcygnaW5wdXQnKSAmJiAhdGhpcy5zaW5nbGVEYXRlUGlja2VyICYmIHRoaXMuYXV0b1VwZGF0ZUlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudmFsKHRoaXMuc3RhcnREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpICsgdGhpcy5sb2NhbGUuc2VwYXJhdG9yICsgdGhpcy5lbmREYXRlLmZvcm1hdCh0aGlzLmxvY2FsZS5mb3JtYXQpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2lucHV0JykgJiYgdGhpcy5hdXRvVXBkYXRlSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC52YWwodGhpcy5zdGFydERhdGUuZm9ybWF0KHRoaXMubG9jYWxlLmZvcm1hdCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vZmYoJy5kYXRlcmFuZ2VwaWNrZXInKTtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZURhdGEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmRhdGVyYW5nZXBpY2tlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAoZWwuZGF0YSgnZGF0ZXJhbmdlcGlja2VyJykpXHJcbiAgICAgICAgICAgICAgICBlbC5kYXRhKCdkYXRlcmFuZ2VwaWNrZXInKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgZWwuZGF0YSgnZGF0ZXJhbmdlcGlja2VyJywgbmV3IERhdGVSYW5nZVBpY2tlcihlbCwgb3B0aW9ucywgY2FsbGJhY2spKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIERhdGVSYW5nZVBpY2tlcjtcclxuXHJcbn0pKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZXJhbmdlcGlja2VyL2RhdGVyYW5nZXBpY2tlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZGF0ZXJhbmdlcGlja2VyL2RhdGVyYW5nZXBpY2tlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwianF1ZXJ5XCIpLCByZXF1aXJlKFwibW9tZW50XCIpKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShbXCJqcXVlcnlcIiwgXCJtb21lbnRcIl0sIGZhY3RvcnkpO1xyXG5cdGVsc2Uge1xyXG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIiksIHJlcXVpcmUoXCJtb21lbnRcIikpIDogZmFjdG9yeShyb290W1wialF1ZXJ5XCJdLCByb290W1wibW9tZW50XCJdKTtcclxuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcclxuXHR9XHJcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxyXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xyXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxyXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcclxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cclxuLyoqKioqKi8gXHRcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxyXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcclxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcclxuLyoqKioqKi8gXHR9XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcclxuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcclxuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcclxuLyoqKioqKi8gXHRcdFx0fSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3Mik7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHJcbi8qXHJcbmRlcml2ZWQgZnJvbTpcclxuaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC90c2xpYi9ibG9iL3YxLjYuMC90c2xpYi5qc1xyXG5cclxub25seSBpbmNsdWRlIHRoZSBoZWxwZXJzIHdlIG5lZWQsIHRvIGtlZXAgZG93biBmaWxlc2l6ZVxyXG4qL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPVxyXG5cdC8qIE5PVEU6IHRzbGliJ3MgYXMtaXMgbWV0aG9kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggaG93IENvZmZlZVNjcmlwdCBkb2VzIHN1YmNsYXNzZXMuXHJcblx0ICogV2hlbiBDb2ZmZWVTY3JpcHQgaXMgc3RyaXBwZWQgb3V0LCBjYW4gcmV2ZXJ0LlxyXG5cdCAqXHJcblx0ICogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcblx0ICogKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0cy5fX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG5cdGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcblx0ZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcblx0ZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBHaXZlbiB0aGUgc2Nyb2xsYmFyIHdpZHRocyBvZiBzb21lIG90aGVyIGNvbnRhaW5lciwgY3JlYXRlIGJvcmRlcnMvbWFyZ2lucyBvbiByb3dFbHMgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIGxlZnRcclxuLy8gYW5kIHJpZ2h0IHNwYWNlIHRoYXQgd2FzIG9mZnNldCBieSB0aGUgc2Nyb2xsYmFycy4gQSAxLXBpeGVsIGJvcmRlciBmaXJzdCwgdGhlbiBtYXJnaW4gYmV5b25kIHRoYXQuXHJcbmZ1bmN0aW9uIGNvbXBlbnNhdGVTY3JvbGwocm93RWxzLCBzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgIGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCkge1xyXG4gICAgICAgIHJvd0Vscy5jc3Moe1xyXG4gICAgICAgICAgICAnYm9yZGVyLWxlZnQtd2lkdGgnOiAxLFxyXG4gICAgICAgICAgICAnbWFyZ2luLWxlZnQnOiBzY3JvbGxiYXJXaWR0aHMubGVmdCAtIDFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHtcclxuICAgICAgICByb3dFbHMuY3NzKHtcclxuICAgICAgICAgICAgJ2JvcmRlci1yaWdodC13aWR0aCc6IDEsXHJcbiAgICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiBzY3JvbGxiYXJXaWR0aHMucmlnaHQgLSAxXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb21wZW5zYXRlU2Nyb2xsID0gY29tcGVuc2F0ZVNjcm9sbDtcclxuLy8gVW5kb2VzIGNvbXBlbnNhdGVTY3JvbGwgYW5kIHJlc3RvcmVzIGFsbCBib3JkZXJzL21hcmdpbnNcclxuZnVuY3Rpb24gdW5jb21wZW5zYXRlU2Nyb2xsKHJvd0Vscykge1xyXG4gICAgcm93RWxzLmNzcyh7XHJcbiAgICAgICAgJ21hcmdpbi1sZWZ0JzogJycsXHJcbiAgICAgICAgJ21hcmdpbi1yaWdodCc6ICcnLFxyXG4gICAgICAgICdib3JkZXItbGVmdC13aWR0aCc6ICcnLFxyXG4gICAgICAgICdib3JkZXItcmlnaHQtd2lkdGgnOiAnJ1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy51bmNvbXBlbnNhdGVTY3JvbGwgPSB1bmNvbXBlbnNhdGVTY3JvbGw7XHJcbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxyXG5mdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xyXG4gICAgJCgnYm9keScpLmFkZENsYXNzKCdmYy1ub3QtYWxsb3dlZCcpO1xyXG59XHJcbmV4cG9ydHMuZGlzYWJsZUN1cnNvciA9IGRpc2FibGVDdXJzb3I7XHJcbi8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xyXG5mdW5jdGlvbiBlbmFibGVDdXJzb3IoKSB7XHJcbiAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2ZjLW5vdC1hbGxvd2VkJyk7XHJcbn1cclxuZXhwb3J0cy5lbmFibGVDdXJzb3IgPSBlbmFibGVDdXJzb3I7XHJcbi8vIEdpdmVuIGEgdG90YWwgYXZhaWxhYmxlIGhlaWdodCB0byBmaWxsLCBoYXZlIGBlbHNgIChlc3NlbnRpYWxseSBjaGlsZCByb3dzKSBleHBhbmQgdG8gYWNjb21vZGF0ZS5cclxuLy8gQnkgZGVmYXVsdCwgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHNob3J0ZXIgdGhhbiB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IGFyZSBleHBhbmRlZCB1bmlmb3JtbHksIG5vdCBjb25zaWRlcmluZ1xyXG4vLyBhbnkgb3RoZXIgZWxzIHRoYXQgYXJlIGFscmVhZHkgdG9vIHRhbGwuIGlmIGBzaG91bGRSZWRpc3RyaWJ1dGVgIGlzIG9uLCBpdCBjb25zaWRlcnMgdGhlc2UgdGFsbCByb3dzIGFuZFxyXG4vLyByZWR1Y2VzIHRoZSBhdmFpbGFibGUgaGVpZ2h0LlxyXG5mdW5jdGlvbiBkaXN0cmlidXRlSGVpZ2h0KGVscywgYXZhaWxhYmxlSGVpZ2h0LCBzaG91bGRSZWRpc3RyaWJ1dGUpIHtcclxuICAgIC8vICpGTE9PUklORyBOT1RFKjogd2UgZmxvb3IgaW4gY2VydGFpbiBwbGFjZXMgYmVjYXVzZSB6b29tIGNhbiBnaXZlIGluYWNjdXJhdGUgZmxvYXRpbmctcG9pbnQgZGltZW5zaW9ucyxcclxuICAgIC8vIGFuZCBpdCBpcyBiZXR0ZXIgdG8gYmUgc2hvcnRlciB0aGFuIHRhbGxlciwgdG8gYXZvaWQgY3JlYXRpbmcgdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycy5cclxuICAgIHZhciBtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBlbHMubGVuZ3RoKTsgLy8gZm9yIG5vbi1sYXN0IGVsZW1lbnRcclxuICAgIHZhciBtaW5PZmZzZXQyID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLSBtaW5PZmZzZXQxICogKGVscy5sZW5ndGggLSAxKSk7IC8vIGZvciBsYXN0IGVsZW1lbnQgKkZMT09SSU5HIE5PVEUqXHJcbiAgICB2YXIgZmxleEVscyA9IFtdOyAvLyBlbGVtZW50cyB0aGF0IGFyZSBhbGxvd2VkIHRvIGV4cGFuZC4gYXJyYXkgb2YgRE9NIG5vZGVzXHJcbiAgICB2YXIgZmxleE9mZnNldHMgPSBbXTsgLy8gYW1vdW50IG9mIHZlcnRpY2FsIHNwYWNlIGl0IHRha2VzIHVwXHJcbiAgICB2YXIgZmxleEhlaWdodHMgPSBbXTsgLy8gYWN0dWFsIGNzcyBoZWlnaHRcclxuICAgIHZhciB1c2VkSGVpZ2h0ID0gMDtcclxuICAgIHVuZGlzdHJpYnV0ZUhlaWdodChlbHMpOyAvLyBnaXZlIGFsbCBlbGVtZW50cyB0aGVpciBuYXR1cmFsIGhlaWdodFxyXG4gICAgLy8gZmluZCBlbGVtZW50cyB0aGF0IGFyZSBiZWxvdyB0aGUgcmVjb21tZW5kZWQgaGVpZ2h0IChleHBhbmRhYmxlKS5cclxuICAgIC8vIGltcG9ydGFudCB0byBxdWVyeSBmb3IgaGVpZ2h0cyBpbiBhIHNpbmdsZSBmaXJzdCBwYXNzICh0byBhdm9pZCByZWZsb3cgb3NjaWxsYXRpb24pLlxyXG4gICAgZWxzLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XHJcbiAgICAgICAgdmFyIG1pbk9mZnNldCA9IGkgPT09IGVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XHJcbiAgICAgICAgdmFyIG5hdHVyYWxPZmZzZXQgPSAkKGVsKS5vdXRlckhlaWdodCh0cnVlKTtcclxuICAgICAgICBpZiAobmF0dXJhbE9mZnNldCA8IG1pbk9mZnNldCkge1xyXG4gICAgICAgICAgICBmbGV4RWxzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICBmbGV4T2Zmc2V0cy5wdXNoKG5hdHVyYWxPZmZzZXQpO1xyXG4gICAgICAgICAgICBmbGV4SGVpZ2h0cy5wdXNoKCQoZWwpLmhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBzdHJldGNoZXMgcGFzdCByZWNvbW1lbmRlZCBoZWlnaHQgKG5vbi1leHBhbmRhYmxlKS4gbWFyayB0aGUgc3BhY2UgYXMgb2NjdXBpZWQuXHJcbiAgICAgICAgICAgIHVzZWRIZWlnaHQgKz0gbmF0dXJhbE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIHJlYWRqdXN0IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgdG8gb25seSBjb25zaWRlciB0aGUgaGVpZ2h0IGF2YWlsYWJsZSB0byBub24tbWF4ZWQtb3V0IHJvd3MuXHJcbiAgICBpZiAoc2hvdWxkUmVkaXN0cmlidXRlKSB7XHJcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0IC09IHVzZWRIZWlnaHQ7XHJcbiAgICAgICAgbWluT2Zmc2V0MSA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC8gZmxleEVscy5sZW5ndGgpO1xyXG4gICAgICAgIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZmxleEVscy5sZW5ndGggLSAxKSk7IC8vICpGTE9PUklORyBOT1RFKlxyXG4gICAgfVxyXG4gICAgLy8gYXNzaWduIGhlaWdodHMgdG8gYWxsIGV4cGFuZGFibGUgZWxlbWVudHNcclxuICAgICQoZmxleEVscykuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcclxuICAgICAgICB2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZmxleEVscy5sZW5ndGggLSAxID8gbWluT2Zmc2V0MiA6IG1pbk9mZnNldDE7XHJcbiAgICAgICAgdmFyIG5hdHVyYWxPZmZzZXQgPSBmbGV4T2Zmc2V0c1tpXTtcclxuICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGZsZXhIZWlnaHRzW2ldO1xyXG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBtaW5PZmZzZXQgLSAobmF0dXJhbE9mZnNldCAtIG5hdHVyYWxIZWlnaHQpOyAvLyBzdWJ0cmFjdCB0aGUgbWFyZ2luL3BhZGRpbmdcclxuICAgICAgICBpZiAobmF0dXJhbE9mZnNldCA8IG1pbk9mZnNldCkge1xyXG4gICAgICAgICAgICAkKGVsKS5oZWlnaHQobmV3SGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpc3RyaWJ1dGVIZWlnaHQgPSBkaXN0cmlidXRlSGVpZ2h0O1xyXG4vLyBVbmRvZXMgZGlzdHJ1YnV0ZUhlaWdodCwgcmVzdG9yaW5nIGFsbCBlbHMgdG8gdGhlaXIgbmF0dXJhbCBoZWlnaHRcclxuZnVuY3Rpb24gdW5kaXN0cmlidXRlSGVpZ2h0KGVscykge1xyXG4gICAgZWxzLmhlaWdodCgnJyk7XHJcbn1cclxuZXhwb3J0cy51bmRpc3RyaWJ1dGVIZWlnaHQgPSB1bmRpc3RyaWJ1dGVIZWlnaHQ7XHJcbi8vIEdpdmVuIGBlbHNgLCBhIGpRdWVyeSBzZXQgb2YgPHRkPiBjZWxscywgZmluZCB0aGUgY2VsbCB3aXRoIHRoZSBsYXJnZXN0IG5hdHVyYWwgd2lkdGggYW5kIHNldCB0aGUgd2lkdGhzIG9mIGFsbCB0aGVcclxuLy8gY2VsbHMgdG8gYmUgdGhhdCB3aWR0aC5cclxuLy8gUFJFUkVRVUlTSVRFOiBpZiB5b3Ugd2FudCBhIGNlbGwgdG8gdGFrZSB1cCB3aWR0aCwgaXQgbmVlZHMgdG8gaGF2ZSBhIHNpbmdsZSBpbm5lciBlbGVtZW50IHcvIGRpc3BsYXk6aW5saW5lXHJcbmZ1bmN0aW9uIG1hdGNoQ2VsbFdpZHRocyhlbHMpIHtcclxuICAgIHZhciBtYXhJbm5lcldpZHRoID0gMDtcclxuICAgIGVscy5maW5kKCc+IConKS5lYWNoKGZ1bmN0aW9uIChpLCBpbm5lckVsKSB7XHJcbiAgICAgICAgdmFyIGlubmVyV2lkdGggPSAkKGlubmVyRWwpLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBpZiAoaW5uZXJXaWR0aCA+IG1heElubmVyV2lkdGgpIHtcclxuICAgICAgICAgICAgbWF4SW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBtYXhJbm5lcldpZHRoKys7IC8vIHNvbWV0aW1lcyBub3QgYWNjdXJhdGUgb2Ygd2lkdGggdGhlIHRleHQgbmVlZHMgdG8gc3RheSBvbiBvbmUgbGluZS4gaW5zdXJhbmNlXHJcbiAgICBlbHMud2lkdGgobWF4SW5uZXJXaWR0aCk7XHJcbiAgICByZXR1cm4gbWF4SW5uZXJXaWR0aDtcclxufVxyXG5leHBvcnRzLm1hdGNoQ2VsbFdpZHRocyA9IG1hdGNoQ2VsbFdpZHRocztcclxuLy8gR2l2ZW4gb25lIGVsZW1lbnQgdGhhdCByZXNpZGVzIGluc2lkZSBhbm90aGVyLFxyXG4vLyBTdWJ0cmFjdHMgdGhlIGhlaWdodCBvZiB0aGUgaW5uZXIgZWxlbWVudCBmcm9tIHRoZSBvdXRlciBlbGVtZW50LlxyXG5mdW5jdGlvbiBzdWJ0cmFjdElubmVyRWxIZWlnaHQob3V0ZXJFbCwgaW5uZXJFbCkge1xyXG4gICAgdmFyIGJvdGggPSBvdXRlckVsLmFkZChpbm5lckVsKTtcclxuICAgIHZhciBkaWZmO1xyXG4gICAgLy8gZWZmaW4nIElFOC85LzEwLzExIHNvbWV0aW1lcyByZXR1cm5zIDAgZm9yIGRpbWVuc2lvbnMuIHRoaXMgd2VpcmQgaGFjayB3YXMgdGhlIG9ubHkgdGhpbmcgdGhhdCB3b3JrZWRcclxuICAgIGJvdGguY3NzKHtcclxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuICAgICAgICBsZWZ0OiAtMSAvLyBlbnN1cmUgcmVmbG93IGluIGNhc2UgdGhlIGVsIHdhcyBhbHJlYWR5IHJlbGF0aXZlLiBuZWdhdGl2ZSBpcyBsZXNzIGxpa2VseSB0byBjYXVzZSBuZXcgc2Nyb2xsXHJcbiAgICB9KTtcclxuICAgIGRpZmYgPSBvdXRlckVsLm91dGVySGVpZ2h0KCkgLSBpbm5lckVsLm91dGVySGVpZ2h0KCk7IC8vIGdyYWIgdGhlIGRpbWVuc2lvbnNcclxuICAgIGJvdGguY3NzKHsgcG9zaXRpb246ICcnLCBsZWZ0OiAnJyB9KTsgLy8gdW5kbyBoYWNrXHJcbiAgICByZXR1cm4gZGlmZjtcclxufVxyXG5leHBvcnRzLnN1YnRyYWN0SW5uZXJFbEhlaWdodCA9IHN1YnRyYWN0SW5uZXJFbEhlaWdodDtcclxuLyogRWxlbWVudCBHZW9tIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gYm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iLzEuMTEuMC91aS9jb3JlLmpzI0w1MVxyXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWwpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IGVsLmNzcygncG9zaXRpb24nKSwgc2Nyb2xsUGFyZW50ID0gZWwucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9ICQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuICgvKGF1dG98c2Nyb2xsKS8pLnRlc3QocGFyZW50LmNzcygnb3ZlcmZsb3cnKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXknKSArIHBhcmVudC5jc3MoJ292ZXJmbG93LXgnKSk7XHJcbiAgICB9KS5lcSgwKTtcclxuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/ICQoZWxbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XHJcbn1cclxuZXhwb3J0cy5nZXRTY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQ7XHJcbi8vIFF1ZXJpZXMgdGhlIG91dGVyIGJvdW5kaW5nIGFyZWEgb2YgYSBqUXVlcnkgZWxlbWVudC5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuZnVuY3Rpb24gZ2V0T3V0ZXJSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcclxuICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsLm91dGVyV2lkdGgoKSxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsLm91dGVySGVpZ2h0KClcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRPdXRlclJlY3QgPSBnZXRPdXRlclJlY3Q7XHJcbi8vIFF1ZXJpZXMgdGhlIGFyZWEgd2l0aGluIHRoZSBtYXJnaW4vYm9yZGVyL3Njcm9sbGJhcnMgb2YgYSBqUXVlcnkgZWxlbWVudC4gRG9lcyBub3QgZ28gd2l0aGluIHRoZSBwYWRkaW5nLlxyXG4vLyBSZXR1cm5zIGEgcmVjdGFuZ2xlIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXM6IGxlZnQsIHJpZ2h0IChleGNsdXNpdmUpLCB0b3AsIGJvdHRvbSAoZXhjbHVzaXZlKS5cclxuLy8gT3JpZ2luIGlzIG9wdGlvbmFsLlxyXG4vLyBXQVJOSU5HOiBnaXZlbiBlbGVtZW50IGNhbid0IGhhdmUgYm9yZGVyc1xyXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXHJcbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpO1xyXG4gICAgdmFyIHNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocyhlbCk7XHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLmxlZnQgLSAob3JpZ2luID8gb3JpZ2luLmxlZnQgOiAwKTtcclxuICAgIHZhciB0b3AgPSBvZmZzZXQudG9wICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItdG9wLXdpZHRoJykgKyBzY3JvbGxiYXJXaWR0aHMudG9wIC0gKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsWzBdLmNsaWVudFdpZHRoLFxyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGJvdHRvbTogdG9wICsgZWxbMF0uY2xpZW50SGVpZ2h0IC8vIGNsaWVudEhlaWdodCBpbmNsdWRlcyBwYWRkaW5nIGJ1dCBOT1Qgc2Nyb2xsYmFyc1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldENsaWVudFJlY3QgPSBnZXRDbGllbnRSZWN0O1xyXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9wYWRkaW5nIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIEFzc3VtZWQgbm90IHRvIGhhdmUgc2Nyb2xsYmFycy5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QoZWwsIG9yaWdpbikge1xyXG4gICAgdmFyIG9mZnNldCA9IGVsLm9mZnNldCgpOyAvLyBqdXN0IG91dHNpZGUgb2YgYm9yZGVyLCBtYXJnaW4gbm90IGluY2x1ZGVkXHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgZ2V0Q3NzRmxvYXQoZWwsICdib3JkZXItbGVmdC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLWxlZnQnKSAtXHJcbiAgICAgICAgKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgZ2V0Q3NzRmxvYXQoZWwsICdwYWRkaW5nLXRvcCcpIC1cclxuICAgICAgICAob3JpZ2luID8gb3JpZ2luLnRvcCA6IDApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBsZWZ0LFxyXG4gICAgICAgIHJpZ2h0OiBsZWZ0ICsgZWwud2lkdGgoKSxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsLmhlaWdodCgpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSBnZXRDb250ZW50UmVjdDtcclxuLy8gUmV0dXJucyB0aGUgY29tcHV0ZWQgbGVmdC9yaWdodC90b3AvYm90dG9tIHNjcm9sbGJhciB3aWR0aHMgZm9yIHRoZSBnaXZlbiBqUXVlcnkgZWxlbWVudC5cclxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnMgKHdoaWNoIHdpbGwgY2F1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHRvIGJlIGxhcmdlcikuXHJcbi8vIE5PVEU6IHNob3VsZCB1c2UgY2xpZW50TGVmdC9jbGllbnRUb3AsIGJ1dCB2ZXJ5IHVucmVsaWFibGUgY3Jvc3MtYnJvd3Nlci5cclxuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKGVsKSB7XHJcbiAgICB2YXIgbGVmdFJpZ2h0V2lkdGggPSBlbFswXS5vZmZzZXRXaWR0aCAtIGVsWzBdLmNsaWVudFdpZHRoO1xyXG4gICAgdmFyIGJvdHRvbVdpZHRoID0gZWxbMF0ub2Zmc2V0SGVpZ2h0IC0gZWxbMF0uY2xpZW50SGVpZ2h0O1xyXG4gICAgdmFyIHdpZHRocztcclxuICAgIGxlZnRSaWdodFdpZHRoID0gc2FuaXRpemVTY3JvbGxiYXJXaWR0aChsZWZ0UmlnaHRXaWR0aCk7XHJcbiAgICBib3R0b21XaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgoYm90dG9tV2lkdGgpO1xyXG4gICAgd2lkdGhzID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IGJvdHRvbVdpZHRoIH07XHJcbiAgICBpZiAoZ2V0SXNMZWZ0UnRsU2Nyb2xsYmFycygpICYmIGVsLmNzcygnZGlyZWN0aW9uJykgPT0gJ3J0bCcpIHtcclxuICAgICAgICB3aWR0aHMubGVmdCA9IGxlZnRSaWdodFdpZHRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2lkdGhzLnJpZ2h0ID0gbGVmdFJpZ2h0V2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2lkdGhzO1xyXG59XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gZ2V0U2Nyb2xsYmFyV2lkdGhzO1xyXG4vLyBUaGUgc2Nyb2xsYmFyIHdpZHRoIGNvbXB1dGF0aW9ucyBpbiBnZXRTY3JvbGxiYXJXaWR0aHMgYXJlIHNvbWV0aW1lcyBmbGF3ZWQgd2hlbiBpdCBjb21lcyB0b1xyXG4vLyByZXRpbmEgZGlzcGxheXMsIHJvdW5kaW5nLCBhbmQgSUUxMS4gTWFzc2FnZSB0aGVtIGludG8gYSB1c2FibGUgdmFsdWUuXHJcbmZ1bmN0aW9uIHNhbml0aXplU2Nyb2xsYmFyV2lkdGgod2lkdGgpIHtcclxuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGgpOyAvLyBubyBuZWdhdGl2ZXNcclxuICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XHJcbiAgICByZXR1cm4gd2lkdGg7XHJcbn1cclxuLy8gTG9naWMgZm9yIGRldGVybWluaW5nIGlmLCB3aGVuIHRoZSBlbGVtZW50IGlzIHJpZ2h0LXRvLWxlZnQsIHRoZSBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCBzaWRlXHJcbnZhciBfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSB7XHJcbiAgICBpZiAoX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPT09IG51bGwpIHtcclxuICAgICAgICBfaXNMZWZ0UnRsU2Nyb2xsYmFycyA9IGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2lzTGVmdFJ0bFNjcm9sbGJhcnM7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZUlzTGVmdFJ0bFNjcm9sbGJhcnMoKSB7XHJcbiAgICB2YXIgZWwgPSAkKCc8ZGl2PjxkaXYvPjwvZGl2PicpXHJcbiAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAtMTAwMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvcmRlcjogMCxcclxuICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcclxuICAgICAgICBkaXJlY3Rpb246ICdydGwnXHJcbiAgICB9KVxyXG4gICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xyXG4gICAgdmFyIGlubmVyRWwgPSBlbC5jaGlsZHJlbigpO1xyXG4gICAgdmFyIHJlcyA9IGlubmVyRWwub2Zmc2V0KCkubGVmdCA+IGVsLm9mZnNldCgpLmxlZnQ7IC8vIGlzIHRoZSBpbm5lciBkaXYgc2hpZnRlZCB0byBhY2NvbW1vZGF0ZSBhIGxlZnQgc2Nyb2xsYmFyP1xyXG4gICAgZWwucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIFJldHJpZXZlcyBhIGpRdWVyeSBlbGVtZW50J3MgY29tcHV0ZWQgQ1NTIHZhbHVlIGFzIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxyXG4vLyBJZiB0aGUgcXVlcmllZCB2YWx1ZSBpcyBub24tbnVtZXJpYyAoZXg6IElFIGNhbiByZXR1cm4gXCJtZWRpdW1cIiBmb3IgYm9yZGVyIHdpZHRoKSwgd2lsbCBqdXN0IHJldHVybiB6ZXJvLlxyXG5mdW5jdGlvbiBnZXRDc3NGbG9hdChlbCwgcHJvcCkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZWwuY3NzKHByb3ApKSB8fCAwO1xyXG59XHJcbi8qIE1vdXNlIC8gVG91Y2ggVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcclxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcclxuICAgIHJldHVybiBldi53aGljaCA9PSAxICYmICFldi5jdHJsS2V5O1xyXG59XHJcbmV4cG9ydHMuaXNQcmltYXJ5TW91c2VCdXR0b24gPSBpc1ByaW1hcnlNb3VzZUJ1dHRvbjtcclxuZnVuY3Rpb24gZ2V0RXZYKGV2KSB7XHJcbiAgICB2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcclxuICAgIC8vIG9uIG1vYmlsZSBGRiwgcGFnZVggZm9yIHRvdWNoIGV2ZW50cyBpcyBwcmVzZW50LCBidXQgaW5jb3JyZWN0LFxyXG4gICAgLy8gc28sIGxvb2sgYXQgdG91Y2ggY29vcmRpbmF0ZXMgZmlyc3QuXHJcbiAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0b3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2LnBhZ2VYO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZYID0gZ2V0RXZYO1xyXG5mdW5jdGlvbiBnZXRFdlkoZXYpIHtcclxuICAgIHZhciB0b3VjaGVzID0gZXYub3JpZ2luYWxFdmVudC50b3VjaGVzO1xyXG4gICAgLy8gb24gbW9iaWxlIEZGLCBwYWdlWCBmb3IgdG91Y2ggZXZlbnRzIGlzIHByZXNlbnQsIGJ1dCBpbmNvcnJlY3QsXHJcbiAgICAvLyBzbywgbG9vayBhdCB0b3VjaCBjb29yZGluYXRlcyBmaXJzdC5cclxuICAgIGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdWNoZXNbMF0ucGFnZVk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXYucGFnZVk7XHJcbn1cclxuZXhwb3J0cy5nZXRFdlkgPSBnZXRFdlk7XHJcbmZ1bmN0aW9uIGdldEV2SXNUb3VjaChldikge1xyXG4gICAgcmV0dXJuIC9edG91Y2gvLnRlc3QoZXYudHlwZSk7XHJcbn1cclxuZXhwb3J0cy5nZXRFdklzVG91Y2ggPSBnZXRFdklzVG91Y2g7XHJcbmZ1bmN0aW9uIHByZXZlbnRTZWxlY3Rpb24oZWwpIHtcclxuICAgIGVsLmFkZENsYXNzKCdmYy11bnNlbGVjdGFibGUnKVxyXG4gICAgICAgIC5vbignc2VsZWN0c3RhcnQnLCBwcmV2ZW50RGVmYXVsdCk7XHJcbn1cclxuZXhwb3J0cy5wcmV2ZW50U2VsZWN0aW9uID0gcHJldmVudFNlbGVjdGlvbjtcclxuZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWwpIHtcclxuICAgIGVsLnJlbW92ZUNsYXNzKCdmYy11bnNlbGVjdGFibGUnKVxyXG4gICAgICAgIC5vZmYoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG59XHJcbmV4cG9ydHMuYWxsb3dTZWxlY3Rpb24gPSBhbGxvd1NlbGVjdGlvbjtcclxuLy8gU3RvcHMgYSBtb3VzZS90b3VjaCBldmVudCBmcm9tIGRvaW5nIGl0J3MgbmF0aXZlIGJyb3dzZXIgYWN0aW9uXHJcbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XHJcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG59XHJcbmV4cG9ydHMucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcclxuLyogR2VuZXJhbCBHZW9tZXRyeSBVdGlsc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmVjdGFuZ2xlcy4gSWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgZmFsc2VcclxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XHJcbiAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgIGxlZnQ6IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLFxyXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxyXG4gICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxyXG4gICAgICAgIGJvdHRvbTogTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pXHJcbiAgICB9O1xyXG4gICAgaWYgKHJlcy5sZWZ0IDwgcmVzLnJpZ2h0ICYmIHJlcy50b3AgPCByZXMuYm90dG9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmludGVyc2VjdFJlY3RzID0gaW50ZXJzZWN0UmVjdHM7XHJcbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcclxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXHJcbiAgICAgICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY29uc3RyYWluUG9pbnQgPSBjb25zdHJhaW5Qb2ludDtcclxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXHJcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxyXG4gICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldFJlY3RDZW50ZXIgPSBnZXRSZWN0Q2VudGVyO1xyXG4vLyBTdWJ0cmFjdHMgcG9pbnQyJ3MgY29vcmRpbmF0ZXMgZnJvbSBwb2ludDEncyBjb29yZGluYXRlcywgcmV0dXJuaW5nIGEgZGVsdGFcclxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBwb2ludDEubGVmdCAtIHBvaW50Mi5sZWZ0LFxyXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3BcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5kaWZmUG9pbnRzID0gZGlmZlBvaW50cztcclxuLyogT2JqZWN0IE9yZGVyaW5nIGJ5IEZpZWxkXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5mdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3MoaW5wdXQpIHtcclxuICAgIHZhciBzcGVjcyA9IFtdO1xyXG4gICAgdmFyIHRva2VucyA9IFtdO1xyXG4gICAgdmFyIGksIHRva2VuO1xyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIHRva2VucyA9IGlucHV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09ICctJyA/XHJcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcclxuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3BlY3M7XHJcbn1cclxuZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSBwYXJzZUZpZWxkU3BlY3M7XHJcbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMSwgb2JqMiwgZmllbGRTcGVjcykge1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY21wO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkU3BlY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMSwgb2JqMiwgZmllbGRTcGVjc1tpXSk7XHJcbiAgICAgICAgaWYgKGNtcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IGNvbXBhcmVCeUZpZWxkU3BlY3M7XHJcbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWMpIHtcclxuICAgIGlmIChmaWVsZFNwZWMuZnVuYykge1xyXG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmoxLCBvYmoyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMVtmaWVsZFNwZWMuZmllbGRdLCBvYmoyW2ZpZWxkU3BlYy5maWVsZF0pICpcclxuICAgICAgICAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5mdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xyXG4gICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGEgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKCQudHlwZShhKSA9PT0gJ3N0cmluZycgfHwgJC50eXBlKGIpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcbmV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xyXG4vKiBEYXRlIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0cy5kYXlJRHMgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddO1xyXG5leHBvcnRzLnVuaXRzRGVzYyA9IFsneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTsgLy8gZGVzY2VuZGluZ1xyXG4vLyBEaWZmcyB0aGUgdHdvIG1vbWVudHMgaW50byBhIER1cmF0aW9uIHdoZXJlIGZ1bGwtZGF5cyBhcmUgcmVjb3JkZWQgZmlyc3QsIHRoZW4gdGhlIHJlbWFpbmluZyB0aW1lLlxyXG4vLyBNb21lbnRzIHdpbGwgaGF2ZSB0aGVpciB0aW1lem9uZXMgbm9ybWFsaXplZC5cclxuZnVuY3Rpb24gZGlmZkRheVRpbWUoYSwgYikge1xyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpLFxyXG4gICAgICAgIG1zOiBhLnRpbWUoKSAtIGIudGltZSgpIC8vIHRpbWUtb2YtZGF5IGZyb20gZGF5IHN0YXJ0LiBkaXNyZWdhcmRzIHRpbWV6b25lXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpZmZEYXlUaW1lID0gZGlmZkRheVRpbWU7XHJcbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyB2aWEgdGhlaXIgc3RhcnQtb2YtZGF5IChyZWdhcmRsZXNzIG9mIHRpbWV6b25lKS4gUHJvZHVjZXMgd2hvbGUtZGF5IGR1cmF0aW9ucy5cclxuZnVuY3Rpb24gZGlmZkRheShhLCBiKSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcclxuICAgICAgICBkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJylcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZGlmZkRheSA9IGRpZmZEYXk7XHJcbi8vIERpZmZzIHR3byBtb21lbnRzLCBwcm9kdWNpbmcgYSBkdXJhdGlvbiwgbWFkZSBvZiBhIHdob2xlLXVuaXQtaW5jcmVtZW50IG9mIHRoZSBnaXZlbiB1bml0LiBVc2VzIHJvdW5kaW5nLlxyXG5mdW5jdGlvbiBkaWZmQnlVbml0KGEsIGIsIHVuaXQpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oTWF0aC5yb3VuZChhLmRpZmYoYiwgdW5pdCwgdHJ1ZSkpLCAvLyByZXR1cm5GbG9hdD10cnVlXHJcbiAgICB1bml0KTtcclxufVxyXG5leHBvcnRzLmRpZmZCeVVuaXQgPSBkaWZmQnlVbml0O1xyXG4vLyBDb21wdXRlcyB0aGUgdW5pdCBuYW1lIG9mIHRoZSBsYXJnZXN0IHdob2xlLXVuaXQgcGVyaW9kIG9mIHRpbWUuXHJcbi8vIEZvciBleGFtcGxlLCA0OCBob3VycyB3aWxsIGJlIFwiZGF5c1wiIHdoZXJlYXMgNDkgaG91cnMgd2lsbCBiZSBcImhvdXJzXCIuXHJcbi8vIEFjY2VwdHMgc3RhcnQvZW5kLCBhIHJhbmdlIG9iamVjdCwgb3IgYW4gb3JpZ2luYWwgZHVyYXRpb24gb2JqZWN0LlxyXG5mdW5jdGlvbiBjb21wdXRlR3JlYXRlc3RVbml0KHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBpLCB1bml0O1xyXG4gICAgdmFyIHZhbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLnVuaXRzRGVzYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHVuaXQgPSBleHBvcnRzLnVuaXRzRGVzY1tpXTtcclxuICAgICAgICB2YWwgPSBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKTtcclxuICAgICAgICBpZiAodmFsID49IDEgJiYgaXNJbnQodmFsKSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5pdDsgLy8gd2lsbCBiZSBcIm1pbGxpc2Vjb25kc1wiIGlmIG5vdGhpbmcgZWxzZSBtYXRjaGVzXHJcbn1cclxuZXhwb3J0cy5jb21wdXRlR3JlYXRlc3RVbml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdDtcclxuLy8gbGlrZSBjb21wdXRlR3JlYXRlc3RVbml0LCBidXQgaGFzIHNwZWNpYWwgYWJpbGl0aWVzIHRvIGludGVycHJldCB0aGUgc291cmNlIGlucHV0IGZvciBjbHVlc1xyXG5mdW5jdGlvbiBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpIHtcclxuICAgIHZhciB1bml0ID0gY29tcHV0ZUdyZWF0ZXN0VW5pdChkdXJhdGlvbik7XHJcbiAgICAvLyBwcmV2ZW50IGRheXM6NyBmcm9tIGJlaW5nIGludGVycHJldGVkIGFzIGEgd2Vla1xyXG4gICAgaWYgKHVuaXQgPT09ICd3ZWVrJyAmJiB0eXBlb2YgZHVyYXRpb25JbnB1dCA9PT0gJ29iamVjdCcgJiYgZHVyYXRpb25JbnB1dC5kYXlzKSB7XHJcbiAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXQ7XHJcbn1cclxuZXhwb3J0cy5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQgPSBjb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQ7XHJcbi8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgdW5pdHMgKGxpa2UgXCJob3Vyc1wiKSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXHJcbi8vIFJhbmdlIGNhbiBiZSBhIHtzdGFydCxlbmR9IG9iamVjdCwgc2VwYXJhdGUgc3RhcnQvZW5kIGFyZ3MsIG9yIGEgRHVyYXRpb24uXHJcbi8vIFJlc3VsdHMgYXJlIGJhc2VkIG9uIE1vbWVudCdzIC5hcygpIGFuZCAuZGlmZigpIG1ldGhvZHMsIHNvIHJlc3VsdHMgY2FuIGRlcGVuZCBvbiBpbnRlcm5hbCBoYW5kbGluZ1xyXG4vLyBvZiBtb250aC1kaWZmaW5nIGxvZ2ljICh3aGljaCB0ZW5kcyB0byB2YXJ5IGZyb20gdmVyc2lvbiB0byB2ZXJzaW9uKS5cclxuZnVuY3Rpb24gY29tcHV0ZVJhbmdlQXModW5pdCwgc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKGVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0LCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG1vbWVudC5pc0R1cmF0aW9uKHN0YXJ0KSkge1xyXG4gICAgICAgIHJldHVybiBzdGFydC5hcyh1bml0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzdGFydC5lbmQuZGlmZihzdGFydC5zdGFydCwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIGEgcmFuZ2UgKHNwZWNpZmllZCBieSBhIHN0YXJ0L2VuZCBwYXJhbXMpIGJ5IGEgZHVyYXRpb25cclxuZnVuY3Rpb24gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uKHN0YXJ0LCBlbmQsIGR1cikge1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xyXG4gICAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyO1xyXG4gICAgfVxyXG4gICAgbW9udGhzID0gZHVyLmFzTW9udGhzKCk7XHJcbiAgICBpZiAoTWF0aC5hYnMobW9udGhzKSA+PSAxICYmIGlzSW50KG1vbnRocykpIHtcclxuICAgICAgICByZXR1cm4gZW5kLmRpZmYoc3RhcnQsICdtb250aHMnLCB0cnVlKSAvIG1vbnRocztcclxuICAgIH1cclxuICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgJ2RheXMnLCB0cnVlKSAvIGR1ci5hc0RheXMoKTtcclxufVxyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IGRpdmlkZVJhbmdlQnlEdXJhdGlvbjtcclxuLy8gSW50ZWxsaWdlbnRseSBkaXZpZGVzIG9uZSBkdXJhdGlvbiBieSBhbm90aGVyXHJcbmZ1bmN0aW9uIGRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihkdXIxLCBkdXIyKSB7XHJcbiAgICB2YXIgbW9udGhzMSwgbW9udGhzMjtcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyMSkgfHwgZHVyYXRpb25IYXNUaW1lKGR1cjIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGR1cjEgLyBkdXIyO1xyXG4gICAgfVxyXG4gICAgbW9udGhzMSA9IGR1cjEuYXNNb250aHMoKTtcclxuICAgIG1vbnRoczIgPSBkdXIyLmFzTW9udGhzKCk7XHJcbiAgICBpZiAoTWF0aC5hYnMobW9udGhzMSkgPj0gMSAmJiBpc0ludChtb250aHMxKSAmJlxyXG4gICAgICAgIE1hdGguYWJzKG1vbnRoczIpID49IDEgJiYgaXNJbnQobW9udGhzMikpIHtcclxuICAgICAgICByZXR1cm4gbW9udGhzMSAvIG1vbnRoczI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHVyMS5hc0RheXMoKSAvIGR1cjIuYXNEYXlzKCk7XHJcbn1cclxuZXhwb3J0cy5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24gPSBkaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb247XHJcbi8vIEludGVsbGlnZW50bHkgbXVsdGlwbGllcyBhIGR1cmF0aW9uIGJ5IGEgbnVtYmVyXHJcbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZHVyLCBuKSB7XHJcbiAgICB2YXIgbW9udGhzO1xyXG4gICAgaWYgKGR1cmF0aW9uSGFzVGltZShkdXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbihkdXIgKiBuKTtcclxuICAgIH1cclxuICAgIG1vbnRocyA9IGR1ci5hc01vbnRocygpO1xyXG4gICAgaWYgKE1hdGguYWJzKG1vbnRocykgPj0gMSAmJiBpc0ludChtb250aHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IG1vbnRoczogbW9udGhzICogbiB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiBkdXIuYXNEYXlzKCkgKiBuIH0pO1xyXG59XHJcbmV4cG9ydHMubXVsdGlwbHlEdXJhdGlvbiA9IG11bHRpcGx5RHVyYXRpb247XHJcbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGR1cmF0aW9uIGhhcyBhbnkgdGltZSBwYXJ0cyAoaG91cnMvbWludXRlcy9zZWNvbmRzL21zKVxyXG5mdW5jdGlvbiBkdXJhdGlvbkhhc1RpbWUoZHVyKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihkdXIuaG91cnMoKSB8fCBkdXIubWludXRlcygpIHx8IGR1ci5zZWNvbmRzKCkgfHwgZHVyLm1pbGxpc2Vjb25kcygpKTtcclxufVxyXG5leHBvcnRzLmR1cmF0aW9uSGFzVGltZSA9IGR1cmF0aW9uSGFzVGltZTtcclxuZnVuY3Rpb24gaXNOYXRpdmVEYXRlKGlucHV0KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nIHx8IGlucHV0IGluc3RhbmNlb2YgRGF0ZTtcclxufVxyXG5leHBvcnRzLmlzTmF0aXZlRGF0ZSA9IGlzTmF0aXZlRGF0ZTtcclxuLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgZ2l2ZW4gaW5wdXQgaXMgYSB0aW1lIHN0cmluZywgbGlrZSBcIjA2OjQwOjAwXCIgb3IgXCIwNjowMFwiXHJcbmZ1bmN0aW9uIGlzVGltZVN0cmluZyhzdHIpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIC9eXFxkK1xcOlxcZCsoPzpcXDpcXGQrXFwuPyg/OlxcZHszfSk/KT8kLy50ZXN0KHN0cik7XHJcbn1cclxuZXhwb3J0cy5pc1RpbWVTdHJpbmcgPSBpc1RpbWVTdHJpbmc7XHJcbi8qIExvZ2dpbmcgYW5kIERlYnVnXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5mdW5jdGlvbiBsb2coKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xyXG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcclxuICAgICAgICByZXR1cm4gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5sb2cgPSBsb2c7XHJcbmZ1bmN0aW9uIHdhcm4oKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xyXG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsb2cuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy53YXJuID0gd2FybjtcclxuLyogR2VuZXJhbCBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBoYXNPd25Qcm9wTWV0aG9kID0ge30uaGFzT3duUHJvcGVydHk7XHJcbi8vIE1lcmdlcyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0LlxyXG4vLyBUaGUgc2Vjb25kIGFyZ3VtZW50IGFsbG93cyBmb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgd2hvJ3Mgb2JqZWN0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB0b2dldGhlci5cclxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzKSB7XHJcbiAgICB2YXIgZGVzdCA9IHt9O1xyXG4gICAgdmFyIGksIG5hbWU7XHJcbiAgICB2YXIgY29tcGxleE9ianM7XHJcbiAgICB2YXIgaiwgdmFsO1xyXG4gICAgdmFyIHByb3BzO1xyXG4gICAgaWYgKGNvbXBsZXhQcm9wcykge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV4UHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbmFtZSA9IGNvbXBsZXhQcm9wc1tpXTtcclxuICAgICAgICAgICAgY29tcGxleE9ianMgPSBbXTtcclxuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxyXG4gICAgICAgICAgICBmb3IgKGogPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcHJvcE9ianNbal1bbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdHJhaWxpbmcgdmFsdWVzIHdlcmUgb2JqZWN0cywgdXNlIHRoZSBtZXJnZWQgdmFsdWVcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxyXG4gICAgZm9yIChpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBwcm9wcyA9IHByb3BPYmpzW2ldO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gcHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVzdDtcclxufVxyXG5leHBvcnRzLm1lcmdlUHJvcHMgPSBtZXJnZVByb3BzO1xyXG5mdW5jdGlvbiBjb3B5T3duUHJvcHMoc3JjLCBkZXN0KSB7XHJcbiAgICBmb3IgKHZhciBuYW1lIGluIHNyYykge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHNyYywgbmFtZSkpIHtcclxuICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHNyY1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb3B5T3duUHJvcHMgPSBjb3B5T3duUHJvcHM7XHJcbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gaGFzT3duUHJvcE1ldGhvZC5jYWxsKG9iaiwgbmFtZSk7XHJcbn1cclxuZXhwb3J0cy5oYXNPd25Qcm9wID0gaGFzT3duUHJvcDtcclxuZnVuY3Rpb24gYXBwbHlBbGwoZnVuY3Rpb25zLCB0aGlzT2JqLCBhcmdzKSB7XHJcbiAgICBpZiAoJC5pc0Z1bmN0aW9uKGZ1bmN0aW9ucykpIHtcclxuICAgICAgICBmdW5jdGlvbnMgPSBbZnVuY3Rpb25zXTtcclxuICAgIH1cclxuICAgIGlmIChmdW5jdGlvbnMpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgcmV0O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0ID0gZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXNPYmosIGFyZ3MpIHx8IHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFwcGx5QWxsID0gYXBwbHlBbGw7XHJcbmZ1bmN0aW9uIHJlbW92ZU1hdGNoaW5nKGFycmF5LCB0ZXN0RnVuYykge1xyXG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0ZXN0RnVuYyhhcnJheVtpXSkpIHtcclxuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICByZW1vdmVDbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG59XHJcbmV4cG9ydHMucmVtb3ZlTWF0Y2hpbmcgPSByZW1vdmVNYXRjaGluZztcclxuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XHJcbiAgICB2YXIgcmVtb3ZlQ250ID0gMDtcclxuICAgIHZhciBpID0gMDtcclxuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBleGFjdFZhbCkge1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUNudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdmVDbnQ7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHJlbW92ZUV4YWN0O1xyXG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSkge1xyXG4gICAgdmFyIGxlbiA9IGEwLmxlbmd0aDtcclxuICAgIHZhciBpO1xyXG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiAhPT0gYTEubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGEwW2ldICE9PSBhMVtpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZXhwb3J0cy5pc0FycmF5c0VxdWFsID0gaXNBcnJheXNFcXVhbDtcclxuZnVuY3Rpb24gZmlyc3REZWZpbmVkKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbaV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5maXJzdERlZmluZWQgPSBmaXJzdERlZmluZWQ7XHJcbmZ1bmN0aW9uIGh0bWxFc2NhcGUocykge1xyXG4gICAgcmV0dXJuIChzICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcclxuICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXHJcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcmIzAzOTsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcclxuICAgICAgICAucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKTtcclxufVxyXG5leHBvcnRzLmh0bWxFc2NhcGUgPSBodG1sRXNjYXBlO1xyXG5mdW5jdGlvbiBzdHJpcEh0bWxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8mLio/Oy9nLCAnJyk7XHJcbn1cclxuZXhwb3J0cy5zdHJpcEh0bWxFbnRpdGllcyA9IHN0cmlwSHRtbEVudGl0aWVzO1xyXG4vLyBHaXZlbiBhIGhhc2ggb2YgQ1NTIHByb3BlcnRpZXMsIHJldHVybnMgYSBzdHJpbmcgb2YgQ1NTLlxyXG4vLyBVc2VzIHByb3BlcnR5IG5hbWVzIGFzLWlzIChubyBjYW1lbC1jYXNlIGNvbnZlcnNpb24pLiBXaWxsIG5vdCBtYWtlIHN0YXRlbWVudHMgZm9yIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cclxuZnVuY3Rpb24gY3NzVG9TdHIoY3NzUHJvcHMpIHtcclxuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XHJcbiAgICAkLmVhY2goY3NzUHJvcHMsIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5hbWUgKyAnOicgKyB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN0YXRlbWVudHMuam9pbignOycpO1xyXG59XHJcbmV4cG9ydHMuY3NzVG9TdHIgPSBjc3NUb1N0cjtcclxuLy8gR2l2ZW4gYW4gb2JqZWN0IGhhc2ggb2YgSFRNTCBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLFxyXG4vLyBnZW5lcmF0ZXMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgaW5qZWN0ZWQgYmV0d2VlbiA8ID4gaW4gSFRNTFxyXG5mdW5jdGlvbiBhdHRyc1RvU3RyKGF0dHJzKSB7XHJcbiAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgICQuZWFjaChhdHRycywgZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG5hbWUgKyAnPVwiJyArIGh0bWxFc2NhcGUodmFsKSArICdcIicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJyAnKTtcclxufVxyXG5leHBvcnRzLmF0dHJzVG9TdHIgPSBhdHRyc1RvU3RyO1xyXG5mdW5jdGlvbiBjYXBpdGFsaXNlRmlyc3RMZXR0ZXIoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG59XHJcbmV4cG9ydHMuY2FwaXRhbGlzZUZpcnN0TGV0dGVyID0gY2FwaXRhbGlzZUZpcnN0TGV0dGVyO1xyXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XHJcbiAgICByZXR1cm4gYSAtIGI7XHJcbn1cclxuZXhwb3J0cy5jb21wYXJlTnVtYmVycyA9IGNvbXBhcmVOdW1iZXJzO1xyXG5mdW5jdGlvbiBpc0ludChuKSB7XHJcbiAgICByZXR1cm4gbiAlIDEgPT09IDA7XHJcbn1cclxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xyXG4vLyBSZXR1cm5zIGEgbWV0aG9kIGJvdW5kIHRvIHRoZSBnaXZlbiBvYmplY3QgY29udGV4dC5cclxuLy8gSnVzdCBsaWtlIG9uZSBvZiB0aGUgalF1ZXJ5LnByb3h5IHNpZ25hdHVyZXMsIGJ1dCB3aXRob3V0IHRoZSB1bmRlc2lyZWQgYmVoYXZpb3Igb2YgdHJlYXRpbmcgdGhlIHNhbWUgbWV0aG9kIHdpdGhcclxuLy8gZGlmZmVyZW50IGNvbnRleHRzIGFzIGlkZW50aWNhbCB3aGVuIGJpbmRpbmcvdW5iaW5kaW5nIGV2ZW50cy5cclxuZnVuY3Rpb24gcHJveHkob2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5wcm94eSA9IHByb3h5O1xyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XHJcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcclxuLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXHJcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxyXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcclxuICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSBmYWxzZTsgfVxyXG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xyXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsYXN0ID0gK25ldyBEYXRlKCkgLSB0aW1lc3RhbXA7XHJcbiAgICAgICAgaWYgKGxhc3QgPCB3YWl0KSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHRpbWVzdGFtcCA9ICtuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xyXG4gICAgICAgIGlmICghdGltZW91dCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYWxsTm93KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XHJcblxyXG4vKioqLyB9KSxcclxuLyogNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIFVuem9uZWRSYW5nZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVuem9uZWRSYW5nZShzdGFydElucHV0LCBlbmRJbnB1dCkge1xyXG4gICAgICAgIC8vIFRPRE86IG1vdmUgdGhlc2UgaW50byBmb290cHJpbnQuXHJcbiAgICAgICAgLy8gRXNwZWNpYWxseSwgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBudWxsIHN0YXJ0TXMvZW5kTXMuXHJcbiAgICAgICAgdGhpcy5pc1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KHN0YXJ0SW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0SW5wdXQgPSBzdGFydElucHV0LmNsb25lKCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb21lbnQuaXNNb21lbnQoZW5kSW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGVuZElucHV0ID0gZW5kSW5wdXQuY2xvbmUoKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0SW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydE1zID0gc3RhcnRJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZE1zID0gZW5kSW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IHRoaXMuc3RhcnRNcztcclxuICAgICAgICB2YXIgZW5kTXMgPSB0aGlzLmVuZE1zO1xyXG4gICAgICAgIHZhciBuZXdSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE1zID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TXMgPSBvdGhlclJhbmdlLnN0YXJ0TXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1zID0gTWF0aC5tYXgoc3RhcnRNcywgb3RoZXJSYW5nZS5zdGFydE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3RoZXJSYW5nZS5lbmRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmRNcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNcyA9IG90aGVyUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNcyA9IE1hdGgubWluKGVuZE1zLCBvdGhlclJhbmdlLmVuZE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRNcyA9PSBudWxsIHx8IGVuZE1zID09IG51bGwgfHwgc3RhcnRNcyA8IGVuZE1zKSB7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlID0gbmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBlbmRNcyk7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlLmlzU3RhcnQgPSB0aGlzLmlzU3RhcnQgJiYgc3RhcnRNcyA9PT0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgICAgICBuZXdSYW5nZS5pc0VuZCA9IHRoaXMuaXNFbmQgJiYgZW5kTXMgPT09IHRoaXMuZW5kTXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdSYW5nZTtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdHNXaXRoID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCBvdGhlclJhbmdlLnN0YXJ0TXMgPT0gbnVsbCB8fCB0aGlzLmVuZE1zID4gb3RoZXJSYW5nZS5zdGFydE1zKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5zdGFydE1zID09IG51bGwgfHwgb3RoZXJSYW5nZS5lbmRNcyA9PSBudWxsIHx8IHRoaXMuc3RhcnRNcyA8IG90aGVyUmFuZ2UuZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29udGFpbnNSYW5nZSA9IGZ1bmN0aW9uIChpbm5lclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0TXMgPT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydE1zICE9IG51bGwgJiYgaW5uZXJSYW5nZS5zdGFydE1zID49IHRoaXMuc3RhcnRNcykpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmVuZE1zID09IG51bGwgfHwgKGlubmVyUmFuZ2UuZW5kTXMgIT0gbnVsbCAmJiBpbm5lclJhbmdlLmVuZE1zIDw9IHRoaXMuZW5kTXMpKTtcclxuICAgIH07XHJcbiAgICAvLyBgZGF0ZWAgY2FuIGJlIGEgbW9tZW50LCBhIERhdGUsIG9yIGEgbWlsbGlzZWNvbmQgdGltZS5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29udGFpbnNEYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgbXMgPSBkYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRNcyA9PSBudWxsIHx8IG1zID49IHRoaXMuc3RhcnRNcykgJiZcclxuICAgICAgICAgICAgKHRoaXMuZW5kTXMgPT0gbnVsbCB8fCBtcyA8IHRoaXMuZW5kTXMpO1xyXG4gICAgfTtcclxuICAgIC8vIElmIHRoZSBnaXZlbiBkYXRlIGlzIG5vdCB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLCBtb3ZlIGl0IGluc2lkZS5cclxuICAgIC8vIChJZiBpdCdzIHBhc3QgdGhlIGVuZCwgbWFrZSBpdCBvbmUgbWlsbGlzZWNvbmQgYmVmb3JlIHRoZSBlbmQpLlxyXG4gICAgLy8gYGRhdGVgIGNhbiBiZSBhIG1vbWVudCwgYSBEYXRlLCBvciBhIG1pbGxpc2Vjb25kIHRpbWUuXHJcbiAgICAvLyBSZXR1cm5zIGEgTVMtdGltZS5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuY29uc3RyYWluRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIG1zID0gZGF0ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRNcyAhPSBudWxsICYmIG1zIDwgdGhpcy5zdGFydE1zKSB7XHJcbiAgICAgICAgICAgIG1zID0gdGhpcy5zdGFydE1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lbmRNcyAhPSBudWxsICYmIG1zID49IHRoaXMuZW5kTXMpIHtcclxuICAgICAgICAgICAgbXMgPSB0aGlzLmVuZE1zIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1zO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyUmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE1zID09PSBvdGhlclJhbmdlLnN0YXJ0TXMgJiYgdGhpcy5lbmRNcyA9PT0gb3RoZXJSYW5nZS5lbmRNcztcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2UodGhpcy5zdGFydE1zLCB0aGlzLmVuZE1zKTtcclxuICAgICAgICByYW5nZS5pc1N0YXJ0ID0gdGhpcy5pc1N0YXJ0O1xyXG4gICAgICAgIHJhbmdlLmlzRW5kID0gdGhpcy5pc0VuZDtcclxuICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhbiBhbWJpZy16b25lZCBtb21lbnQgZnJvbSBzdGFydE1zLlxyXG4gICAgLy8gQkVXQVJFOiByZXR1cm5lZCBtb21lbnQgaXMgbm90IGxvY2FsaXplZC5cclxuICAgIC8vIEZvcm1hdHRpbmcgYW5kIHN0YXJ0LW9mLXdlZWsgd2lsbCBiZSBkZWZhdWx0LlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5nZXRTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydE1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyh0aGlzLnN0YXJ0TXMpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGFuIGFtYmlnLXpvbmVkIG1vbWVudCBmcm9tIHN0YXJ0TXMuXHJcbiAgICAvLyBCRVdBUkU6IHJldHVybmVkIG1vbWVudCBpcyBub3QgbG9jYWxpemVkLlxyXG4gICAgLy8gRm9ybWF0dGluZyBhbmQgc3RhcnQtb2Ytd2VlayB3aWxsIGJlIGRlZmF1bHQuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmdldEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbmRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGModGhpcy5lbmRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuYXMgPSBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQudXRjKHRoaXMuZW5kTXMpLmRpZmYobW9tZW50LnV0Yyh0aGlzLnN0YXJ0TXMpLCB1bml0LCB0cnVlKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgU0lERUVGRkVDVDogd2lsbCBtdXRhdGUgZXZlbnRSYW5nZXMuXHJcbiAgICBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXHJcbiAgICBPbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgVW56b25lZFJhbmdlLmludmVydFJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gY29uc3RyYWludFJhbmdlLnN0YXJ0TXM7IC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLiB0aGUgc3RhcnQgb2YgdGhlIG5ldyByYW5nZVxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBkYXRlUmFuZ2U7XHJcbiAgICAgICAgLy8gcmFuZ2VzIG5lZWQgdG8gYmUgaW4gb3JkZXIuIHJlcXVpcmVkIGZvciBvdXIgZGF0ZS13YWxraW5nIGFsZ29yaXRobVxyXG4gICAgICAgIHJhbmdlcy5zb3J0KGNvbXBhcmVVbnpvbmVkUmFuZ2VzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0TXMgPiBzdGFydE1zKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgZGF0ZVJhbmdlLnN0YXJ0TXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLmVuZE1zID4gc3RhcnRNcykge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNcyA9IGRhdGVSYW5nZS5lbmRNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgIGlmIChzdGFydE1zIDwgY29uc3RyYWludFJhbmdlLmVuZE1zKSB7XHJcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZShzdGFydE1zLCBjb25zdHJhaW50UmFuZ2UuZW5kTXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVbnpvbmVkUmFuZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFVuem9uZWRSYW5nZTtcclxuLypcclxuT25seSB3b3JrcyBmb3Igbm9uLW9wZW4tZW5kZWQgcmFuZ2VzLlxyXG4qL1xyXG5mdW5jdGlvbiBjb21wYXJlVW56b25lZFJhbmdlcyhyYW5nZTEsIHJhbmdlMikge1xyXG4gICAgcmV0dXJuIHJhbmdlMS5zdGFydE1zIC0gcmFuZ2UyLnN0YXJ0TXM7IC8vIGVhcmxpZXIgcmFuZ2VzIGdvIGZpcnN0XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgUGFyc2FibGVNb2RlbE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIENsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxudmFyIEV2ZW50RGVmUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxudmFyIEV2ZW50U291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICAvLyBjYW4gd2UgZG8gYXdheSB3aXRoIGNhbGVuZGFyPyBhdCBsZWFzdCBmb3IgdGhlIGFic3RyYWN0P1xyXG4gICAgLy8gdXNlZnVsIGZvciBidWlsZEV2ZW50RGVmXHJcbiAgICBmdW5jdGlvbiBFdmVudFNvdXJjZShjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY2FsZW5kYXIgPSBjYWxlbmRhcjtcclxuICAgICAgICBfdGhpcy5jbGFzc05hbWUgPSBbXTtcclxuICAgICAgICBfdGhpcy51aWQgPSBTdHJpbmcoRXZlbnRTb3VyY2UudXVpZCsrKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50LiBtdXN0IHJldHVybiBhIHByb21pc2UuXHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIC8vIG9wdGlvbmFsIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIEZvciBjb21wYWlyaW5nL21hdGNoaW5nXHJcbiAgICAqL1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChvdGhlclNvdXJjZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucGFyc2VFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmID0gdGhpcy5wYXJzZUV2ZW50RGVmKHJhd0V2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudERlZnM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnBhcnNlRXZlbnREZWYgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXJUcmFuc2Zvcm0gPSB0aGlzLmNhbGVuZGFyLm9wdCgnZXZlbnREYXRhVHJhbnNmb3JtJyk7XHJcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybSA9IHRoaXMuZXZlbnREYXRhVHJhbnNmb3JtO1xyXG4gICAgICAgIGlmIChjYWxlbmRhclRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IGNhbGVuZGFyVHJhbnNmb3JtKHJhd0lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvdXJjZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IHNvdXJjZVRyYW5zZm9ybShyYXdJbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3SW5wdXQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAocmF3UHJvcHMuaWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnRTb3VyY2Uubm9ybWFsaXplSWQocmF3UHJvcHMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50RGVmXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgcmF3SW5wdXQgY2FuIGJlIGFueSBkYXRhIHR5cGUhXHJcbiAgICAqL1xyXG4gICAgRXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyB0aGlzKGNhbGVuZGFyKTtcclxuICAgICAgICBpZiAodHlwZW9mIHJhd0lucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlLmFwcGx5UHJvcHMocmF3SW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5ub3JtYWxpemVJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGlmIChpZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQuZGVmaW5lU3RhbmRhcmRQcm9wcztcclxuICAgIEV2ZW50U291cmNlLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICAvLyBJRHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50RGVmXHJcbiAgICBFdmVudFNvdXJjZS51dWlkID0gMDtcclxuICAgIHJldHVybiBFdmVudFNvdXJjZTtcclxufShDbGFzc18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRTb3VyY2U7XHJcblBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudFNvdXJjZSk7XHJcbi8vIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbkV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgLy8gbWFudWFsbHkgcHJvY2Vzcy4uLlxyXG4gICAgaWQ6IGZhbHNlLFxyXG4gICAgY2xhc3NOYW1lOiBmYWxzZSxcclxuICAgIC8vIGF1dG9tYXRpY2FsbHkgdHJhbnNmZXIuLi5cclxuICAgIGNvbG9yOiB0cnVlLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxyXG4gICAgYm9yZGVyQ29sb3I6IHRydWUsXHJcbiAgICB0ZXh0Q29sb3I6IHRydWUsXHJcbiAgICBlZGl0YWJsZTogdHJ1ZSxcclxuICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXHJcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiB0cnVlLFxyXG4gICAgcmVuZGVyaW5nOiB0cnVlLFxyXG4gICAgb3ZlcmxhcDogdHJ1ZSxcclxuICAgIGNvbnN0cmFpbnQ6IHRydWUsXHJcbiAgICBhbGxEYXlEZWZhdWx0OiB0cnVlLFxyXG4gICAgZXZlbnREYXRhVHJhbnNmb3JtOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8qXHJcblV0aWxpdHkgbWV0aG9kcyBmb3IgZWFzaWx5IGxpc3RlbmluZyB0byBldmVudHMgb24gYW5vdGhlciBvYmplY3QsXHJcbmFuZCBtb3JlIGltcG9ydGFudGx5LCBlYXNpbHkgdW5saXN0ZW5pbmcgZnJvbSB0aGVtLlxyXG5cclxuVVNBR0U6XHJcbiAgICBpbXBvcnQgeyBkZWZhdWx0IGFzIExpc3RlbmVyTWl4aW4sIExpc3RlbmVySW50ZXJmYWNlIH0gZnJvbSAnLi9MaXN0ZW5lck1peGluJ1xyXG5pbiBjbGFzczpcclxuICAgIGxpc3RlblRvOiBMaXN0ZW5lckludGVyZmFjZVsnbGlzdGVuVG8nXVxyXG4gICAgc3RvcExpc3RlbmluZ1RvOiBMaXN0ZW5lckludGVyZmFjZVsnc3RvcExpc3RlbmluZ1RvJ11cclxuYWZ0ZXIgY2xhc3M6XHJcbiAgICBMaXN0ZW5lck1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBndWlkID0gMDtcclxudmFyIExpc3RlbmVyTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0ZW5lck1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdGVuZXJNaXhpbigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5saXN0ZW5lcklkID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgR2l2ZW4gYW4gYG90aGVyYCBvYmplY3QgdGhhdCBoYXMgb24vb2ZmIG1ldGhvZHMsIGJpbmQgdGhlIGdpdmVuIGBjYWxsYmFja2AgdG8gYW4gZXZlbnQgYnkgdGhlIGdpdmVuIG5hbWUuXHJcbiAgICBUaGUgYGNhbGxiYWNrYCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgb2JqZWN0IHRoYXQgLmxpc3RlblRvIGlzIGJlaW5nIGNhbGxlZCBvbi5cclxuICAgIENhbiBiZSBjYWxsZWQ6XHJcbiAgICAgICAgLmxpc3RlblRvKG90aGVyLCBldmVudE5hbWUsIGNhbGxiYWNrKVxyXG4gICAgT1JcclxuICAgICAgICAubGlzdGVuVG8ob3RoZXIsIHtcclxuICAgICAgICAgICAgZXZlbnROYW1lMTogY2FsbGJhY2sxLFxyXG4gICAgICAgICAgICBldmVudE5hbWUyOiBjYWxsYmFjazJcclxuICAgICAgICB9KVxyXG4gICAgKi9cclxuICAgIExpc3RlbmVyTWl4aW4ucHJvdG90eXBlLmxpc3RlblRvID0gZnVuY3Rpb24gKG90aGVyLCBhcmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBhcmcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmcuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8ob3RoZXIsIGV2ZW50TmFtZSwgYXJnW2V2ZW50TmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG90aGVyLm9uKGFyZyArICcuJyArIHRoaXMuZ2V0TGlzdGVuZXJOYW1lc3BhY2UoKSwgLy8gdXNlIGV2ZW50IG5hbWVzcGFjaW5nIHRvIGlkZW50aWZ5IHRoaXMgb2JqZWN0XHJcbiAgICAgICAgICAgICQucHJveHkoY2FsbGJhY2ssIHRoaXMpIC8vIGFsd2F5cyB1c2UgYHRoaXNgIGNvbnRleHRcclxuICAgICAgICAgICAgLy8gdGhlIHVzdWFsbHktdW5kZXNpcmVkIGpRdWVyeSBndWlkIGJlaGF2aW9yIGRvZXNuJ3QgbWF0dGVyLFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFsd2F5cyB1bmJpbmQgdmlhIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgQ2F1c2VzIHRoZSBjdXJyZW50IG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBldmVudHMgb24gdGhlIGBvdGhlcmAgb2JqZWN0LlxyXG4gICAgYGV2ZW50TmFtZWAgaXMgb3B0aW9uYWwuIElmIG9taXR0ZWQsIHdpbGwgc3RvcCBsaXN0ZW5pbmcgdG8gQUxMIGV2ZW50cyBvbiBgb3RoZXJgLlxyXG4gICAgKi9cclxuICAgIExpc3RlbmVyTWl4aW4ucHJvdG90eXBlLnN0b3BMaXN0ZW5pbmdUbyA9IGZ1bmN0aW9uIChvdGhlciwgZXZlbnROYW1lKSB7XHJcbiAgICAgICAgb3RoZXIub2ZmKChldmVudE5hbWUgfHwgJycpICsgJy4nICsgdGhpcy5nZXRMaXN0ZW5lck5hbWVzcGFjZSgpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBhIHN0cmluZywgdW5pcXVlIHRvIHRoaXMgb2JqZWN0LCB0byBiZSB1c2VkIGZvciBldmVudCBuYW1lc3BhY2luZ1xyXG4gICAgKi9cclxuICAgIExpc3RlbmVyTWl4aW4ucHJvdG90eXBlLmdldExpc3RlbmVyTmFtZXNwYWNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVySWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVySWQgPSBndWlkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnX2xpc3RlbmVyJyArIHRoaXMubGlzdGVuZXJJZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdGVuZXJNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdGVuZXJNaXhpbjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIHZlcnNpb246IFwiPCU9IHZlcnNpb24gJT5cIixcclxuICAgIC8vIFdoZW4gaW50cm9kdWNpbmcgaW50ZXJuYWwgQVBJIGluY29tcGF0aWJpbGl0aWVzICh3aGVyZSBmdWxsY2FsZW5kYXIgcGx1Z2lucyB3b3VsZCBicmVhayksXHJcbiAgICAvLyB0aGUgbWlub3IgdmVyc2lvbiBvZiB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIHVwcGVkIChleDogMi43LjIgLT4gMi44LjApXHJcbiAgICAvLyBhbmQgdGhlIGJlbG93IGludGVnZXIgc2hvdWxkIGJlIGluY3JlbWVudGVkLlxyXG4gICAgaW50ZXJuYWxBcGlWZXJzaW9uOiAxMixcclxuICAgIC8vIGZvciBHbG9iYWxFbWl0dGVyXHJcbiAgICB0b3VjaE1vdXNlSWdub3JlV2FpdDogNTAwLFxyXG4gICAgLy8gZm9yIEV4dGVybmFsRHJvcHBpbmdcclxuICAgIC8vIFJlcXVpcmUgYWxsIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVzIHVzZWQgYnkgRnVsbENhbGVuZGFyIHRvIGhhdmUgdGhpcyBwcmVmaXguXHJcbiAgICAvLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxyXG4gICAgZGF0YUF0dHJQcmVmaXg6ICcnLFxyXG4gICAgdmlld3M6IHt9LFxyXG4gICAgbG9jYWxlczoge31cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vKlxyXG5VU0FHRTpcclxuICAgIGltcG9ydCB7IGRlZmF1bHQgYXMgRW1pdHRlck1peGluLCBFbWl0dGVySW50ZXJmYWNlIH0gZnJvbSAnLi9FbWl0dGVyTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gICAgb246IEVtaXR0ZXJJbnRlcmZhY2VbJ29uJ11cclxuICAgIG9uZTogRW1pdHRlckludGVyZmFjZVsnb25lJ11cclxuICAgIG9mZjogRW1pdHRlckludGVyZmFjZVsnb2ZmJ11cclxuICAgIHRyaWdnZXI6IEVtaXR0ZXJJbnRlcmZhY2VbJ3RyaWdnZXInXVxyXG4gICAgdHJpZ2dlcldpdGg6IEVtaXR0ZXJJbnRlcmZhY2VbJ3RyaWdnZXJXaXRoJ11cclxuICAgIGhhc0hhbmRsZXJzOiBFbWl0dGVySW50ZXJmYWNlWydoYXNIYW5kbGVycyddXHJcbmFmdGVyIGNsYXNzOlxyXG4gICAgRW1pdHRlck1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBFbWl0dGVyTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFbWl0dGVyTWl4aW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFbWl0dGVyTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8galF1ZXJ5LWlmaWNhdGlvbiB2aWEgJCh0aGlzKSBhbGxvd3MgYSBub24tRE9NIG9iamVjdCB0byBoYXZlXHJcbiAgICAvLyB0aGUgc2FtZSBldmVudCBoYW5kbGluZyBjYXBhYmlsaXRpZXMgKGluY2x1ZGluZyBuYW1lc3BhY2VzKS5cclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZXMsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKHRoaXMpLm9uKHR5cGVzLCB0aGlzLl9wcmVwYXJlSW50ZXJjZXB0KGhhbmRsZXIpKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS5vbmUgPSBmdW5jdGlvbiAodHlwZXMsIGhhbmRsZXIpIHtcclxuICAgICAgICAkKHRoaXMpLm9uZSh0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUuX3ByZXBhcmVJbnRlcmNlcHQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIC8vIGhhbmRsZXJzIGFyZSBhbHdheXMgY2FsbGVkIHdpdGggYW4gXCJldmVudFwiIG9iamVjdCBhcyB0aGVpciBmaXJzdCBwYXJhbS5cclxuICAgICAgICAvLyBzbmVhayB0aGUgYHRoaXNgIGNvbnRleHQgYW5kIGFyZ3VtZW50cyBpbnRvIHRoZSBleHRyYSBwYXJhbWV0ZXIgb2JqZWN0XHJcbiAgICAgICAgLy8gYW5kIGZvcndhcmQgdGhlbSBvbiB0byB0aGUgb3JpZ2luYWwgaGFuZGxlci5cclxuICAgICAgICB2YXIgaW50ZXJjZXB0ID0gZnVuY3Rpb24gKGV2LCBleHRyYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci5hcHBseShleHRyYS5jb250ZXh0IHx8IHRoaXMsIGV4dHJhLmFyZ3MgfHwgW10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbWltaWNrIGpRdWVyeSdzIGludGVybmFsIFwicHJveHlcIiBzeXN0ZW0gKHJpc2t5LCBJIGtub3cpXHJcbiAgICAgICAgLy8gY2F1c2luZyBhbGwgZnVuY3Rpb25zIHdpdGggdGhlIHNhbWUgLmd1aWQgdG8gYXBwZWFyIHRvIGJlIHRoZSBzYW1lLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvMi4yLjQvc3JjL2NvcmUuanMjTDQ0OFxyXG4gICAgICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciBjYWxsaW5nIC5vZmYgd2l0aCB0aGUgb3JpZ2luYWwgbm9uLWludGVyY2VwdCBoYW5kbGVyLlxyXG4gICAgICAgIGlmICghaGFuZGxlci5ndWlkKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIuZ3VpZCA9ICQuZ3VpZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcmNlcHQuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcclxuICAgICAgICByZXR1cm4gaW50ZXJjZXB0O1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vZmYodHlwZXMsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAodHlwZXMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhc3MgaW4gXCJleHRyYVwiIGluZm8gdG8gdGhlIGludGVyY2VwdFxyXG4gICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIodHlwZXMsIHsgYXJnczogYXJncyB9KTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyV2l0aCA9IGZ1bmN0aW9uICh0eXBlcywgY29udGV4dCwgYXJncykge1xyXG4gICAgICAgIC8vIGB0cmlnZ2VySGFuZGxlcmAgaXMgbGVzcyByZWxpYW50IG9uIHRoZSBET00gY29tcGFyZWQgdG8gYHRyaWdnZXJgLlxyXG4gICAgICAgIC8vIHBhc3MgaW4gXCJleHRyYVwiIGluZm8gdG8gdGhlIGludGVyY2VwdC5cclxuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGNvbnRleHQ6IGNvbnRleHQsIGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUuaGFzSGFuZGxlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBoYXNoID0gJC5fZGF0YSh0aGlzLCAnZXZlbnRzJyk7IC8vIGh0dHA6Ly9ibG9nLmpxdWVyeS5jb20vMjAxMi8wOC8wOS9qcXVlcnktMS04LXJlbGVhc2VkL1xyXG4gICAgICAgIHJldHVybiBoYXNoICYmIGhhc2hbdHlwZV0gJiYgaGFzaFt0eXBlXS5sZW5ndGggPiAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbWl0dGVyTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEVtaXR0ZXJNaXhpbjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG4vKlxyXG5HRU5FUkFMIE5PVEUgb24gbW9tZW50cyB0aHJvdWdob3V0IHRoZSAqZW50aXJlIHJlc3QqIG9mIHRoZSBjb2RlYmFzZTpcclxuQWxsIG1vbWVudHMgYXJlIGFzc3VtZWQgdG8gYmUgYW1iaWd1b3VzbHktem9uZWQgdW5sZXNzIG90aGVyd2lzZSBub3RlZCxcclxud2l0aCB0aGUgTk9UQUJMRSBFWENFT1BUSU9OIG9mIHN0YXJ0L2VuZCBkYXRlcyB0aGF0IGxpdmUgb24gKkV2ZW50IE9iamVjdHMqLlxyXG5BbWJpZ3VvdXNseS1USU1FRCBtb21lbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGFtYmlndW91c2x5LXpvbmVkIGJ5IG5hdHVyZS5cclxuKi9cclxudmFyIGFtYmlnRGF0ZU9mTW9udGhSZWdleCA9IC9eXFxzKlxcZHs0fS1cXGRcXGQkLztcclxudmFyIGFtYmlnVGltZU9yWm9uZVJlZ2V4ID0gL15cXHMqXFxkezR9LSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KT8kLztcclxudmFyIG5ld01vbWVudFByb3RvID0gbW9tZW50LmZuOyAvLyB3aGVyZSB3ZSB3aWxsIGF0dGFjaCBvdXIgbmV3IG1ldGhvZHNcclxuZXhwb3J0cy5uZXdNb21lbnRQcm90byA9IG5ld01vbWVudFByb3RvO1xyXG52YXIgb2xkTW9tZW50UHJvdG8gPSAkLmV4dGVuZCh7fSwgbmV3TW9tZW50UHJvdG8pOyAvLyBjb3B5IG9mIG9yaWdpbmFsIG1vbWVudCBtZXRob2RzXHJcbmV4cG9ydHMub2xkTW9tZW50UHJvdG8gPSBvbGRNb21lbnRQcm90bztcclxuLy8gdGVsbCBtb21lbnRqcyB0byB0cmFuc2ZlciB0aGVzZSBwcm9wZXJ0aWVzIHVwb24gY2xvbmVcclxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBtb21lbnQubW9tZW50UHJvcGVydGllcztcclxubW9tZW50UHJvcGVydGllcy5wdXNoKCdfZnVsbENhbGVuZGFyJyk7XHJcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2FtYmlnVGltZScpO1xyXG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1pvbmUnKTtcclxuLypcclxuQ2FsbCB0aGlzIGlmIHlvdSB3YW50IE1vbWVudCdzIG9yaWdpbmFsIGZvcm1hdCBtZXRob2QgdG8gYmUgdXNlZFxyXG4qL1xyXG5mdW5jdGlvbiBvbGRNb21lbnRGb3JtYXQobW9tLCBmb3JtYXRTdHIpIHtcclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by5mb3JtYXQuY2FsbChtb20sIGZvcm1hdFN0cik7IC8vIG9sZE1vbWVudFByb3RvIGRlZmluZWQgaW4gbW9tZW50LWV4dC5qc1xyXG59XHJcbmV4cG9ydHMub2xkTW9tZW50Rm9ybWF0ID0gb2xkTW9tZW50Rm9ybWF0O1xyXG4vLyBDcmVhdGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIENyZWF0ZXMgYSBuZXcgbW9tZW50LCBzaW1pbGFyIHRvIHRoZSB2YW5pbGxhIG1vbWVudCguLi4pIGNvbnN0cnVjdG9yLCBidXQgd2l0aFxyXG4vLyBleHRyYSBmZWF0dXJlcyAoYW1iaWd1b3VzIHRpbWUsIGVuaGFuY2VkIGZvcm1hdHRpbmcpLiBXaGVuIGdpdmVuIGFuIGV4aXN0aW5nIG1vbWVudCxcclxuLy8gaXQgd2lsbCBmdW5jdGlvbiBhcyBhIGNsb25lIChhbmQgcmV0YWluIHRoZSB6b25lIG9mIHRoZSBtb21lbnQpLiBBbnl0aGluZyBlbHNlIHdpbGxcclxuLy8gcmVzdWx0IGluIGEgbW9tZW50IGluIHRoZSBsb2NhbCB6b25lLlxyXG52YXIgbW9tZW50RXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1ha2VNb21lbnQoYXJndW1lbnRzKTtcclxufTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gbW9tZW50RXh0O1xyXG4vLyBTYW1lcyBhcyBtb21lbnRFeHQsIGJ1dCBmb3JjZXMgdGhlIHJlc3VsdGluZyBtb21lbnQgdG8gYmUgaW4gdGhlIFVUQyB0aW1lem9uZS5cclxubW9tZW50RXh0LnV0YyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtb20gPSBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSk7XHJcbiAgICAvLyBGb3JjZSBpdCBpbnRvIFVUQyBiZWNhdXNlIG1ha2VNb21lbnQgZG9lc24ndCBndWFyYW50ZWUgaXRcclxuICAgIC8vIChpZiBnaXZlbiBhIHByZS1leGlzdGluZyBtb21lbnQgZm9yIGV4YW1wbGUpXHJcbiAgICBpZiAobW9tLmhhc1RpbWUoKSkge1xyXG4gICAgICAgIG1vbS51dGMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb207XHJcbn07XHJcbi8vIFNhbWUgYXMgbW9tZW50RXh0LCBidXQgd2hlbiBnaXZlbiBhbiBJU084NjAxIHN0cmluZywgdGhlIHRpbWV6b25lIG9mZnNldCBpcyBwcmVzZXJ2ZWQuXHJcbi8vIElTTzg2MDEgc3RyaW5ncyB3aXRoIG5vIHRpbWV6b25lIG9mZnNldCB3aWxsIGJlY29tZSBhbWJpZ3VvdXNseSB6b25lZC5cclxubW9tZW50RXh0LnBhcnNlWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSk7XHJcbn07XHJcbi8vIEJ1aWxkcyBhbiBlbmhhbmNlZCBtb21lbnQgZnJvbSBhcmdzLiBXaGVuIGdpdmVuIGFuIGV4aXN0aW5nIG1vbWVudCwgaXQgY2xvbmVzLiBXaGVuIGdpdmVuIGFcclxuLy8gbmF0aXZlIERhdGUsIG9yIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cyAodGhlIGN1cnJlbnQgdGltZSksIHRoZSByZXN1bHRpbmcgbW9tZW50IHdpbGwgYmUgbG9jYWwuXHJcbi8vIEFueXRoaW5nIGVsc2UgbmVlZHMgdG8gYmUgXCJwYXJzZWRcIiAoYSBzdHJpbmcgb3IgYW4gYXJyYXkpLCBhbmQgd2lsbCBiZSBhZmZlY3RlZCBieTpcclxuLy8gICAgcGFyc2VBc1VUQyAtIGlmIHRoZXJlIGlzIG5vIHpvbmUgaW5mb3JtYXRpb24sIHNob3VsZCB3ZSBwYXJzZSB0aGUgaW5wdXQgaW4gVVRDP1xyXG4vLyAgICBwYXJzZVpvbmUgLSBpZiB0aGVyZSBpcyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgZm9yY2UgdGhlIHpvbmUgb2YgdGhlIG1vbWVudD9cclxuZnVuY3Rpb24gbWFrZU1vbWVudChhcmdzLCBwYXJzZUFzVVRDLCBwYXJzZVpvbmUpIHtcclxuICAgIGlmIChwYXJzZUFzVVRDID09PSB2b2lkIDApIHsgcGFyc2VBc1VUQyA9IGZhbHNlOyB9XHJcbiAgICBpZiAocGFyc2Vab25lID09PSB2b2lkIDApIHsgcGFyc2Vab25lID0gZmFsc2U7IH1cclxuICAgIHZhciBpbnB1dCA9IGFyZ3NbMF07XHJcbiAgICB2YXIgaXNTaW5nbGVTdHJpbmcgPSBhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZyc7XHJcbiAgICB2YXIgaXNBbWJpZ1RpbWU7XHJcbiAgICB2YXIgaXNBbWJpZ1pvbmU7XHJcbiAgICB2YXIgYW1iaWdNYXRjaDtcclxuICAgIHZhciBtb207XHJcbiAgICBpZiAobW9tZW50LmlzTW9tZW50KGlucHV0KSB8fCB1dGlsXzEuaXNOYXRpdmVEYXRlKGlucHV0KSB8fCBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbW9tID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaXNBbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgICAgICBpc0FtYmlnWm9uZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpc1NpbmdsZVN0cmluZykge1xyXG4gICAgICAgICAgICBpZiAoYW1iaWdEYXRlT2ZNb250aFJlZ2V4LnRlc3QoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhY2NlcHQgc3RyaW5ncyBsaWtlICcyMDE0LTA1JywgYnV0IGNvbnZlcnQgdG8gdGhlIGZpcnN0IG9mIHRoZSBtb250aFxyXG4gICAgICAgICAgICAgICAgaW5wdXQgKz0gJy0wMSc7XHJcbiAgICAgICAgICAgICAgICBhcmdzID0gW2lucHV0XTsgLy8gZm9yIHdoZW4gd2UgcGFzcyBpdCBvbiB0byBtb21lbnQncyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgaXNBbWJpZ1RpbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaXNBbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChhbWJpZ01hdGNoID0gYW1iaWdUaW1lT3Jab25lUmVnZXguZXhlYyhpbnB1dCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnVGltZSA9ICFhbWJpZ01hdGNoWzVdOyAvLyBubyB0aW1lIHBhcnQ/XHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICAvLyBhcnJheXMgaGF2ZSBubyB0aW1lem9uZSBpbmZvcm1hdGlvbiwgc28gYXNzdW1lIGFtYmlndW91cyB6b25lXHJcbiAgICAgICAgICAgIGlzQW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBwcm9iYWJseSBhIHN0cmluZyB3aXRoIGEgZm9ybWF0XHJcbiAgICAgICAgaWYgKHBhcnNlQXNVVEMgfHwgaXNBbWJpZ1RpbWUpIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50LnV0Yy5hcHBseShtb21lbnQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBbWJpZ1RpbWUpIHtcclxuICAgICAgICAgICAgbW9tLl9hbWJpZ1RpbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICBtb20uX2FtYmlnWm9uZSA9IHRydWU7IC8vIGFtYmlndW91cyB0aW1lIGFsd2F5cyBtZWFucyBhbWJpZ3VvdXMgem9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJzZVpvbmUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQW1iaWdab25lKSB7XHJcbiAgICAgICAgICAgICAgICBtb20uX2FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTaW5nbGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIG1vbS51dGNPZmZzZXQoaW5wdXQpOyAvLyBpZiBub3QgYSB2YWxpZCB6b25lLCB3aWxsIGFzc2lnbiBVVENcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vbS5fZnVsbENhbGVuZGFyID0gdHJ1ZTsgLy8gZmxhZyBmb3IgZXh0ZW5kZWQgZnVuY3Rpb25hbGl0eVxyXG4gICAgcmV0dXJuIG1vbTtcclxufVxyXG4vLyBXZWVrIE51bWJlclxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIFJldHVybnMgdGhlIHdlZWsgbnVtYmVyLCBjb25zaWRlcmluZyB0aGUgbG9jYWxlJ3MgY3VzdG9tIHdlZWsgbnVtYmVyIGNhbGN1YXRpb25cclxuLy8gYHdlZWtzYCBpcyBhbiBhbGlhcyBmb3IgYHdlZWtgXHJcbm5ld01vbWVudFByb3RvLndlZWsgPSBuZXdNb21lbnRQcm90by53ZWVrcyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgdmFyIHdlZWtDYWxjID0gdGhpcy5fbG9jYWxlLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGM7XHJcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCAmJiB0eXBlb2Ygd2Vla0NhbGMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gd2Vla0NhbGModGhpcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh3ZWVrQ2FsYyA9PT0gJ0lTTycpIHtcclxuICAgICAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8uaXNvV2Vlay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBJU08gZ2V0dGVyL3NldHRlclxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9sZE1vbWVudFByb3RvLndlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gbG9jYWwgZ2V0dGVyL3NldHRlclxyXG59O1xyXG4vLyBUaW1lLW9mLWRheVxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIEdFVFRFUlxyXG4vLyBSZXR1cm5zIGEgRHVyYXRpb24gd2l0aCB0aGUgaG91cnMvbWludXRlcy9zZWNvbmRzL21zIHZhbHVlcyBvZiB0aGUgbW9tZW50LlxyXG4vLyBJZiB0aGUgbW9tZW50IGhhcyBhbiBhbWJpZ3VvdXMgdGltZSwgYSBkdXJhdGlvbiBvZiAwMDowMCB3aWxsIGJlIHJldHVybmVkLlxyXG4vL1xyXG4vLyBTRVRURVJcclxuLy8gWW91IGNhbiBzdXBwbHkgYSBEdXJhdGlvbiwgYSBNb21lbnQsIG9yIGEgRHVyYXRpb24tbGlrZSBhcmd1bWVudC5cclxuLy8gV2hlbiBzZXR0aW5nIHRoZSB0aW1lLCBhbmQgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGl0IHRoZW4gYmVjb21lcyB1bmFtYmlndW91cy5cclxubmV3TW9tZW50UHJvdG8udGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAvLyBGYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgbWV0aG9kIChpZiB0aGVyZSBpcyBvbmUpIGlmIHRoaXMgbW9tZW50IHdhc24ndCBjcmVhdGVkIHZpYSBGdWxsQ2FsZW5kYXIuXHJcbiAgICAvLyBgdGltZWAgaXMgYSBnZW5lcmljIGVub3VnaCBtZXRob2QgbmFtZSB3aGVyZSB0aGlzIHByZWNhdXRpb24gaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGNvbGxpc2lvbnMgdy8gb3RoZXIgcGx1Z2lucy5cclxuICAgIGlmICghdGhpcy5fZnVsbENhbGVuZGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIG9sZE1vbWVudFByb3RvLnRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIGlmICh0aW1lID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcclxuICAgICAgICAgICAgaG91cnM6IHRoaXMuaG91cnMoKSxcclxuICAgICAgICAgICAgbWludXRlczogdGhpcy5taW51dGVzKCksXHJcbiAgICAgICAgICAgIHNlY29uZHM6IHRoaXMuc2Vjb25kcygpLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IHRoaXMubWlsbGlzZWNvbmRzKClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlOyAvLyBtYXJrIHRoYXQgdGhlIG1vbWVudCBub3cgaGFzIGEgdGltZVxyXG4gICAgICAgIGlmICghbW9tZW50LmlzRHVyYXRpb24odGltZSkgJiYgIW1vbWVudC5pc01vbWVudCh0aW1lKSkge1xyXG4gICAgICAgICAgICB0aW1lID0gbW9tZW50LmR1cmF0aW9uKHRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgZGF5IHZhbHVlIHNob3VsZCBjYXVzZSBvdmVyZmxvdyAoc28gMjQgaG91cnMgYmVjb21lcyAwMDowMDowMCBvZiBuZXh0IGRheSkuXHJcbiAgICAgICAgLy8gT25seSBmb3IgRHVyYXRpb24gdGltZXMsIG5vdCBNb21lbnQgdGltZXMuXHJcbiAgICAgICAgdmFyIGRheUhvdXJzID0gMDtcclxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24odGltZSkpIHtcclxuICAgICAgICAgICAgZGF5SG91cnMgPSBNYXRoLmZsb29yKHRpbWUuYXNEYXlzKCkpICogMjQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IHRoZSBpbmRpdmlkdWFsIGZpZWxkcy5cclxuICAgICAgICAvLyBDYW4ndCB1c2Ugc3RhcnRPZignZGF5JykgdGhlbiBhZGQgZHVyYXRpb24uIEluIGNhc2Ugb2YgRFNUIGF0IHN0YXJ0IG9mIGRheS5cclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VycyhkYXlIb3VycyArIHRpbWUuaG91cnMoKSlcclxuICAgICAgICAgICAgLm1pbnV0ZXModGltZS5taW51dGVzKCkpXHJcbiAgICAgICAgICAgIC5zZWNvbmRzKHRpbWUuc2Vjb25kcygpKVxyXG4gICAgICAgICAgICAubWlsbGlzZWNvbmRzKHRpbWUubWlsbGlzZWNvbmRzKCkpO1xyXG4gICAgfVxyXG59O1xyXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZS1vZi1kYXkgYW5kIHRpbWV6b25lIG9mZnNldCxcclxuLy8gYnV0IHByZXNlcnZpbmcgaXRzIFlNRC4gQSBtb21lbnQgd2l0aCBhIHN0cmlwcGVkIHRpbWUgd2lsbCBkaXNwbGF5IG5vIHRpbWVcclxuLy8gbm9yIHRpbWV6b25lIG9mZnNldCB3aGVuIC5mb3JtYXQoKSBpcyBjYWxsZWQuXHJcbm5ld01vbWVudFByb3RvLnN0cmlwVGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgdGhpcy51dGModHJ1ZSk7IC8vIGtlZXBMb2NhbFRpbWU9dHJ1ZSAoZm9yIGtlZXBpbmcgKmRhdGUqIHZhbHVlKVxyXG4gICAgICAgIC8vIHNldCB0aW1lIHRvIHplcm9cclxuICAgICAgICB0aGlzLnNldCh7XHJcbiAgICAgICAgICAgIGhvdXJzOiAwLFxyXG4gICAgICAgICAgICBtaW51dGVzOiAwLFxyXG4gICAgICAgICAgICBzZWNvbmRzOiAwLFxyXG4gICAgICAgICAgICBtczogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE1hcmsgdGhlIHRpbWUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxyXG4gICAgICAgIC8vIHdoaWNoIGNsZWFycyBhbGwgYW1iaWcgZmxhZ3MuXHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBpZiBhbWJpZ3VvdXMgdGltZSwgYWxzbyBhbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbn07XHJcbi8vIFJldHVybnMgaWYgdGhlIG1vbWVudCBoYXMgYSBub24tYW1iaWd1b3VzIHRpbWUgKGJvb2xlYW4pXHJcbm5ld01vbWVudFByb3RvLmhhc1RpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuX2FtYmlnVGltZTtcclxufTtcclxuLy8gVGltZXpvbmVcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZXpvbmUgb2Zmc2V0LCBidXQgcHJlc2VydmluZyBpdHNcclxuLy8gWU1EIGFuZCB0aW1lLW9mLWRheS4gQSBtb21lbnQgd2l0aCBhIHN0cmlwcGVkIHRpbWV6b25lIG9mZnNldCB3aWxsIGRpc3BsYXkgbm9cclxuLy8gdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cclxubmV3TW9tZW50UHJvdG8uc3RyaXBab25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHdhc0FtYmlnVGltZTtcclxuICAgIGlmICghdGhpcy5fYW1iaWdab25lKSB7XHJcbiAgICAgICAgd2FzQW1iaWdUaW1lID0gdGhpcy5fYW1iaWdUaW1lO1xyXG4gICAgICAgIHRoaXMudXRjKHRydWUpOyAvLyBrZWVwTG9jYWxUaW1lPXRydWUgKGZvciBrZWVwaW5nIGRhdGUgYW5kIHRpbWUgdmFsdWVzKVxyXG4gICAgICAgIC8vIHRoZSBhYm92ZSBjYWxsIHRvIC51dGMoKS8udXRjT2Zmc2V0KCkgdW5mb3J0dW5hdGVseSBtaWdodCBjbGVhciB0aGUgYW1iaWcgZmxhZ3MsIHNvIHJlc3RvcmVcclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSB3YXNBbWJpZ1RpbWUgfHwgZmFsc2U7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgem9uZSBhcyBhbWJpZ3VvdXMuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSAudXRjKCkgY2FsbCwgd2hpY2ggbWlnaHQgY2FsbCAudXRjT2Zmc2V0KCksXHJcbiAgICAgICAgLy8gd2hpY2ggY2xlYXJzIHRoZSBhbWJpZyBmbGFncy5cclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG59O1xyXG4vLyBSZXR1cm5zIG9mIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lem9uZSBvZmZzZXQgKGJvb2xlYW4pXHJcbm5ld01vbWVudFByb3RvLmhhc1pvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuX2FtYmlnWm9uZTtcclxufTtcclxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmVcclxubmV3TW9tZW50UHJvdG8ubG9jYWwgPSBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgLy8gZm9yIHdoZW4gY29udmVydGluZyBmcm9tIGFtYmlndW91c2x5LXpvbmVkIHRvIGxvY2FsLFxyXG4gICAgLy8ga2VlcCB0aGUgdGltZSB2YWx1ZXMgd2hlbiBjb252ZXJ0aW5nIGZyb20gVVRDIC0+IGxvY2FsXHJcbiAgICBvbGRNb21lbnRQcm90by5sb2NhbC5jYWxsKHRoaXMsIHRoaXMuX2FtYmlnWm9uZSB8fCBrZWVwTG9jYWxUaW1lKTtcclxuICAgIC8vIGVuc3VyZSBub24tYW1iaWd1b3VzXHJcbiAgICAvLyB0aGlzIHByb2JhYmx5IGFscmVhZHkgaGFwcGVuZWQgdmlhIGxvY2FsKCkgLT4gdXRjT2Zmc2V0KCksIGJ1dCBkb24ndCByZWx5IG9uIE1vbWVudCdzIGludGVybmFsc1xyXG4gICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxufTtcclxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmVcclxubmV3TW9tZW50UHJvdG8udXRjID0gZnVuY3Rpb24gKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgIG9sZE1vbWVudFByb3RvLnV0Yy5jYWxsKHRoaXMsIGtlZXBMb2NhbFRpbWUpO1xyXG4gICAgLy8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcclxuICAgIC8vIHRoaXMgcHJvYmFibHkgYWxyZWFkeSBoYXBwZW5lZCB2aWEgdXRjKCkgLT4gdXRjT2Zmc2V0KCksIGJ1dCBkb24ndCByZWx5IG9uIE1vbWVudCdzIGludGVybmFsc1xyXG4gICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZSAod2lsbCBwcm9iYWJseSBnZXQgY2FsbGVkIHVwb24gLnV0YygpIGFuZCAubG9jYWwoKSlcclxubmV3TW9tZW50UHJvdG8udXRjT2Zmc2V0ID0gZnVuY3Rpb24gKHR6bykge1xyXG4gICAgaWYgKHR6byAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gdGhlc2UgYXNzaWdubWVudHMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgb3JpZ2luYWwgem9uZSBtZXRob2QgaXMgY2FsbGVkLlxyXG4gICAgICAgIC8vIEkgZm9yZ2V0IHdoeSwgc29tZXRoaW5nIHRvIGRvIHdpdGggYSBicm93c2VyIGNyYXNoLlxyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2FtYmlnWm9uZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9sZE1vbWVudFByb3RvLnV0Y09mZnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qXHJcbk1lYW50IHRvIGJlIGltbXV0YWJsZVxyXG4qL1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tcG9uZW50Rm9vdHByaW50KHVuem9uZWRSYW5nZSwgaXNBbGxEYXkpIHtcclxuICAgICAgICB0aGlzLmlzQWxsRGF5ID0gZmFsc2U7IC8vIGNvbXBvbmVudCBjYW4gY2hvb3NlIHRvIGlnbm9yZSB0aGlzXHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB1bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5pc0FsbERheSA9IGlzQWxsRGF5O1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIE9ubHkgd29ya3MgZm9yIG5vbi1vcGVuLWVuZGVkIHJhbmdlcy5cclxuICAgICovXHJcbiAgICBDb21wb25lbnRGb290cHJpbnQucHJvdG90eXBlLnRvTGVnYWN5ID0gZnVuY3Rpb24gKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGNhbGVuZGFyLm1zVG9Nb21lbnQodGhpcy51bnpvbmVkUmFuZ2Uuc3RhcnRNcywgdGhpcy5pc0FsbERheSksXHJcbiAgICAgICAgICAgIGVuZDogY2FsZW5kYXIubXNUb01vbWVudCh0aGlzLnVuem9uZWRSYW5nZS5lbmRNcywgdGhpcy5pc0FsbERheSlcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21wb25lbnRGb290cHJpbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvbXBvbmVudEZvb3RwcmludDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbnZhciBFdmVudEluc3RhbmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxudmFyIEV2ZW50RGF0ZVByb2ZpbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgU2luZ2xlRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTaW5nbGVFdmVudERlZiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNpbmdsZUV2ZW50RGVmKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBXaWxsIHJlY2VpdmUgc3RhcnQvZW5kIHBhcmFtcywgYnV0IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICovXHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLmJ1aWxkSW5zdGFuY2UoKV07XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmJ1aWxkSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEluc3RhbmNlXzEuZGVmYXVsdCh0aGlzLCAvLyBkZWZpbml0aW9uXHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSk7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVQcm9maWxlLmlzQWxsRGF5KCk7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWYgPSBfc3VwZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgZGVmLmRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfTtcclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5yZXpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5zb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KGNhbGVuZGFyLm1vbWVudChkYXRlUHJvZmlsZS5zdGFydCksIGRhdGVQcm9maWxlLmVuZCA/IGNhbGVuZGFyLm1vbWVudChkYXRlUHJvZmlsZS5lbmQpIDogbnVsbCwgY2FsZW5kYXIpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBOT1RFOiBpZiBzdXBlci1tZXRob2QgZmFpbHMsIHNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGFwcGx5XHJcbiAgICAqL1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdC5wYXJzZShyYXdQcm9wcywgdGhpcy5zb3VyY2UpOyAvLyByZXR1cm5zIG51bGwgb24gZmFpbHVyZVxyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBgZGF0ZWAgc2hvd3MgdXAgaW4gdGhlIGxlZ2FjeSBldmVudCBvYmplY3RzIGFzLWlzXHJcbiAgICAgICAgICAgIGlmIChyYXdQcm9wcy5kYXRlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWlzY1Byb3BzLmRhdGUgPSByYXdQcm9wcy5kYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTaW5nbGVFdmVudERlZjtcclxufShFdmVudERlZl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU2luZ2xlRXZlbnREZWY7XHJcbi8vIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblNpbmdsZUV2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgc3RhcnQ6IGZhbHNlLFxyXG4gICAgZGF0ZTogZmFsc2UsXHJcbiAgICBlbmQ6IGZhbHNlLFxyXG4gICAgYWxsRGF5OiBmYWxzZVxyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNaXhpbigpIHtcclxuICAgIH1cclxuICAgIE1peGluLm1peEludG8gPSBmdW5jdGlvbiAoZGVzdENsYXNzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBfdGhpcy5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgd2lsbCBvdmVycmlkZSBleGlzdGluZyBtZXRob2RzXHJcbiAgICAqL1xyXG4gICAgTWl4aW4ubWl4T3ZlciA9IGZ1bmN0aW9uIChkZXN0Q2xhc3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBfdGhpcy5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1peGluO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNaXhpbjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSW50ZXJhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbihjb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBjb21wb25lbnQuX2dldFZpZXcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcub3B0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVyYWN0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJbnRlcmFjdGlvbjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBuYW1lc3BhY2VfaG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgZ2xvYmFsRW1pdHRlciA9IG51bGw7XHJcbnZhciBuZWVkZWRDb3VudCA9IDA7XHJcbi8qXHJcbkxpc3RlbnMgdG8gZG9jdW1lbnQgYW5kIHdpbmRvdy1sZXZlbCB1c2VyLWludGVyYWN0aW9uIGV2ZW50cywgbGlrZSB0b3VjaCBldmVudHMgYW5kIG1vdXNlIGV2ZW50cyxcclxuYW5kIGZpcmVzIHRoZXNlIGV2ZW50cyBhcy1pcyB0byB3aG9ldmVyIGlzIG9ic2VydmluZyBhIEdsb2JhbEVtaXR0ZXIuXHJcbkJlc3Qgd2hlbiB1c2VkIGFzIGEgc2luZ2xldG9uIHZpYSBHbG9iYWxFbWl0dGVyLmdldCgpXHJcblxyXG5Ob3JtYWxpemVzIG1vdXNlL3RvdWNoIGV2ZW50cy4gRm9yIGV4YW1wbGVzOlxyXG4tIGlnbm9yZXMgdGhlIHRoZSBzaW11bGF0ZWQgbW91c2UgZXZlbnRzIHRoYXQgaGFwcGVuIGFmdGVyIGEgcXVpY2sgdGFwOiBtb3VzZW1vdmUrbW91c2Vkb3duK21vdXNldXArY2xpY2tcclxuLSBjb21wZW5zYXRlcyBmb3IgdmFyaW91cyBidWdneSBzY2VuYXJpb3Mgd2hlcmUgYSB0b3VjaGVuZCBkb2VzIG5vdCBmaXJlXHJcbiovXHJcbnZhciBHbG9iYWxFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2xvYmFsRW1pdHRlcigpIHtcclxuICAgICAgICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1vdXNlSWdub3JlRGVwdGggPSAwO1xyXG4gICAgfVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcclxuICAgICAgICAgICAgdG91Y2hzdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxyXG4gICAgICAgICAgICB0b3VjaGNhbmNlbDogdGhpcy5oYW5kbGVUb3VjaENhbmNlbCxcclxuICAgICAgICAgICAgdG91Y2hlbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmQsXHJcbiAgICAgICAgICAgIG1vdXNlZG93bjogdGhpcy5oYW5kbGVNb3VzZURvd24sXHJcbiAgICAgICAgICAgIG1vdXNlbW92ZTogdGhpcy5oYW5kbGVNb3VzZU1vdmUsXHJcbiAgICAgICAgICAgIG1vdXNldXA6IHRoaXMuaGFuZGxlTW91c2VVcCxcclxuICAgICAgICAgICAgY2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssXHJcbiAgICAgICAgICAgIHNlbGVjdHN0YXJ0OiB0aGlzLmhhbmRsZVNlbGVjdFN0YXJ0LFxyXG4gICAgICAgICAgICBjb250ZXh0bWVudTogdGhpcy5oYW5kbGVDb250ZXh0TWVudVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBjYWxsIHByZXZlbnREZWZhdWx0XHJcbiAgICAgICAgLy8gYmVjYXVzZSBodHRwczovL3d3dy5jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmVzLzUwOTM1NjYwMDcyMTQwODBcclxuICAgICAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSBwZXJmb3JtYW5jZSBiZWNhdXNlIHRoaXMgaXMgYSBnbG9iYWwgaGFuZGxlclxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZVByb3h5ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVRvdWNoTW92ZSgkLkV2ZW50KGV2KSk7XHJcbiAgICAgICAgfSwgeyBwYXNzaXZlOiBmYWxzZSB9IC8vIGFsbG93cyBwcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxyXG4gICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXHJcbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGxQcm94eSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVTY3JvbGwoJC5FdmVudChldikpO1xyXG4gICAgICAgIH0sIHRydWUgLy8gdXNlQ2FwdHVyZVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmVQcm94eSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsUHJveHksIHRydWUgLy8gdXNlQ2FwdHVyZVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgLy8gVG91Y2ggSGFuZGxlcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gaWYgYSBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiBuZXZlciBlbmRlZCB3aXRoIGEgdG91Y2hlbmQsIHRoZW4gaW1wbGljaXRseSBlbmQgaXQsXHJcbiAgICAgICAgLy8gYnV0IHNpbmNlIGEgbmV3IHRvdWNoIGludGVyYWN0aW9uIGlzIGFib3V0IHRvIGJlZ2luLCBkb24ndCBzdGFydCB0aGUgbW91c2UgaWdub3JlIHBlcmlvZC5cclxuICAgICAgICB0aGlzLnN0b3BUb3VjaChldiwgdHJ1ZSk7IC8vIHNraXBNb3VzZUlnbm9yZT10cnVlXHJcbiAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3RvdWNoc3RhcnQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RvdWNobW92ZScsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hDYW5jZWwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndG91Y2hjYW5jZWwnLCBldik7XHJcbiAgICAgICAgICAgIC8vIEhhdmUgdG91Y2hjYW5jZWwgZmlyZSBhbiBhcnRpZmljaWFsIHRvdWNoZW5kLiBUaGF0IHdheSwgaGFuZGxlcnMgd29uJ3QgbmVlZCB0byBsaXN0ZW4gdG8gYm90aC5cclxuICAgICAgICAgICAgLy8gSWYgdG91Y2hlbmQgZmlyZXMgbGF0ZXIsIGl0IHdvbid0IGhhdmUgYW55IGVmZmVjdCBiL2MgaXNUb3VjaGluZyB3aWxsIGJlIGZhbHNlLlxyXG4gICAgICAgICAgICB0aGlzLnN0b3BUb3VjaChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIE1vdXNlIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZWRvd24nLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZXVwJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIE1pc2MgSGFuZGxlcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVTZWxlY3RTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0c3RhcnQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2Nyb2xsJywgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc3RvcFRvdWNoID0gZnVuY3Rpb24gKGV2LCBza2lwTW91c2VJZ25vcmUpIHtcclxuICAgICAgICBpZiAoc2tpcE1vdXNlSWdub3JlID09PSB2b2lkIDApIHsgc2tpcE1vdXNlSWdub3JlID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAodGhpcy5pc1RvdWNoaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RvdWNoZW5kJywgZXYpO1xyXG4gICAgICAgICAgICBpZiAoIXNraXBNb3VzZUlnbm9yZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRvdWNoTW91c2VJZ25vcmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5zdGFydFRvdWNoTW91c2VJZ25vcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgd2FpdCA9IG5hbWVzcGFjZV9ob29rc18xLmRlZmF1bHQudG91Y2hNb3VzZUlnbm9yZVdhaXQ7XHJcbiAgICAgICAgaWYgKHdhaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZUlnbm9yZURlcHRoKys7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubW91c2VJZ25vcmVEZXB0aC0tO1xyXG4gICAgICAgICAgICB9LCB3YWl0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc2hvdWxkSWdub3JlTW91c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUb3VjaGluZyB8fCBCb29sZWFuKHRoaXMubW91c2VJZ25vcmVEZXB0aCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2luZ2xldG9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZ2V0cyB0aGUgc2luZ2xldG9uXHJcbiAgICBHbG9iYWxFbWl0dGVyLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIWdsb2JhbEVtaXR0ZXIpIHtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlciA9IG5ldyBHbG9iYWxFbWl0dGVyKCk7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2xvYmFsRW1pdHRlcjtcclxuICAgIH07XHJcbiAgICAvLyBjYWxsZWQgd2hlbiBhbiBvYmplY3Qga25vd3MgaXQgd2lsbCBuZWVkIGEgR2xvYmFsRW1pdHRlciBpbiB0aGUgbmVhciBmdXR1cmUuXHJcbiAgICBHbG9iYWxFbWl0dGVyLm5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBHbG9iYWxFbWl0dGVyLmdldCgpOyAvLyBlbnN1cmVzIGdsb2JhbEVtaXR0ZXJcclxuICAgICAgICBuZWVkZWRDb3VudCsrO1xyXG4gICAgfTtcclxuICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgdGhhdCBvcmlnaW5hbGx5IGNhbGxlZCBuZWVkZWQoKSBkb2Vzbid0IG5lZWQgYSBHbG9iYWxFbWl0dGVyIGFueW1vcmUuXHJcbiAgICBHbG9iYWxFbWl0dGVyLnVubmVlZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG5lZWRlZENvdW50LS07XHJcbiAgICAgICAgaWYgKCFuZWVkZWRDb3VudCkge1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyLnVuYmluZCgpO1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEdsb2JhbEVtaXR0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEdsb2JhbEVtaXR0ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oR2xvYmFsRW1pdHRlcik7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhHbG9iYWxFbWl0dGVyKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKlxyXG5NZWFudCB0byBiZSBpbW11dGFibGVcclxuKi9cclxudmFyIEV2ZW50RGF0ZVByb2ZpbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERhdGVQcm9maWxlKHN0YXJ0LCBlbmQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkVW56b25lZFJhbmdlKGNhbGVuZGFyKTtcclxuICAgIH1cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMuc3RhcnQuaGFzVGltZSgpIHx8ICh0aGlzLmVuZCAmJiB0aGlzLmVuZC5oYXNUaW1lKCkpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTmVlZHMgYSBDYWxlbmRhciBvYmplY3RcclxuICAgICovXHJcbiAgICBFdmVudERhdGVQcm9maWxlLnByb3RvdHlwZS5idWlsZFVuem9uZWRSYW5nZSA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gdGhpcy5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICB2YXIgZW5kTXMgPSB0aGlzLmdldEVuZChjYWxlbmRhcikuc3RyaXBab25lKCkudmFsdWVPZigpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydE1zLCBlbmRNcyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGEgQ2FsZW5kYXIgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wcm90b3R5cGUuZ2V0RW5kID0gZnVuY3Rpb24gKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kID9cclxuICAgICAgICAgICAgdGhpcy5lbmQuY2xvbmUoKSA6XHJcbiAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgZW5kIGZyb20gdGhlIHN0YXJ0IGFuZCBhbGxEYXkuIGNvbXB1dGUgYWxsRGF5IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQodGhpcy5pc0FsbERheSgpLCB0aGlzLnN0YXJ0KTtcclxuICAgIH07XHJcbiAgICBFdmVudERhdGVQcm9maWxlLmlzU3RhbmRhcmRQcm9wID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BOYW1lID09PSAnc3RhcnQnIHx8IHByb3BOYW1lID09PSAnZGF0ZScgfHwgcHJvcE5hbWUgPT09ICdlbmQnIHx8IHByb3BOYW1lID09PSAnYWxsRGF5JztcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTmVlZHMgYW4gRXZlbnRTb3VyY2Ugb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdQcm9wcywgc291cmNlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0SW5wdXQgPSByYXdQcm9wcy5zdGFydCB8fCByYXdQcm9wcy5kYXRlO1xyXG4gICAgICAgIHZhciBlbmRJbnB1dCA9IHJhd1Byb3BzLmVuZDtcclxuICAgICAgICBpZiAoIXN0YXJ0SW5wdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSBzb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gY2FsZW5kYXIubW9tZW50KHN0YXJ0SW5wdXQpO1xyXG4gICAgICAgIHZhciBlbmQgPSBlbmRJbnB1dCA/IGNhbGVuZGFyLm1vbWVudChlbmRJbnB1dCkgOiBudWxsO1xyXG4gICAgICAgIHZhciBmb3JjZWRBbGxEYXkgPSByYXdQcm9wcy5hbGxEYXk7XHJcbiAgICAgICAgdmFyIGZvcmNlRXZlbnREdXJhdGlvbiA9IGNhbGVuZGFyLm9wdCgnZm9yY2VFdmVudER1cmF0aW9uJyk7XHJcbiAgICAgICAgaWYgKCFzdGFydC5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kICYmICghZW5kLmlzVmFsaWQoKSB8fCAhZW5kLmlzQWZ0ZXIoc3RhcnQpKSkge1xyXG4gICAgICAgICAgICBlbmQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9yY2VkQWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yY2VkQWxsRGF5ID0gc291cmNlLmFsbERheURlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZWRBbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VkQWxsRGF5ID0gY2FsZW5kYXIub3B0KCdhbGxEYXlEZWZhdWx0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcmNlZEFsbERheSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZvcmNlZEFsbERheSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKCFzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVuZCAmJiAhZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnRpbWUoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlbmQgJiYgZm9yY2VFdmVudER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZCghc3RhcnQuaGFzVGltZSgpLCBzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnREYXRlUHJvZmlsZShzdGFydCwgZW5kLCBjYWxlbmRhcik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGF0ZVByb2ZpbGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGF0ZVByb2ZpbGU7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgUHJvbWlzZVN0dWIgPSB7XHJcbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChleGVjdXRvcikge1xyXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGV4ZWN1dG9yKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfSxcclxuICAgIHJlc29sdmU6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVzb2x2ZSh2YWwpO1xyXG4gICAgICAgIHZhciBwcm9taXNlID0gZGVmZXJyZWQucHJvbWlzZSgpO1xyXG4gICAgICAgIGF0dGFjaEltbWVkaWF0ZWx5UmVzb2x2aW5nVGhlbihwcm9taXNlLCB2YWwpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfSxcclxuICAgIHJlamVjdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKS5yZWplY3QoKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFByb21pc2VTdHViO1xyXG5mdW5jdGlvbiBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKSB7XHJcbiAgICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvblJlc29sdmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VTdHViLnJlc29sdmUob25SZXNvbHZlKHZhbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpIHtcclxuICAgIHByb21pc2UudGhlbiA9IGZ1bmN0aW9uIChvblJlc29sdmUsIG9uUmVqZWN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBvblJlamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBFdmVudFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxuLypcclxuSXQncyBleHBlY3RlZCB0aGF0IHRoZXJlIHdpbGwgYmUgYXQgbGVhc3Qgb25lIEV2ZW50SW5zdGFuY2UsXHJcbk9SIHRoYXQgYW4gZXhwbGljaXRFdmVudERlZiBpcyBhc3NpZ25lZC5cclxuKi9cclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50SW5zdGFuY2VHcm91cChldmVudEluc3RhbmNlcykge1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZXMgPSBldmVudEluc3RhbmNlcyB8fCBbXTtcclxuICAgIH1cclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuZ2V0QWxsRXZlbnRSYW5nZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZU5vcm1hbFJlbmRlclJhbmdlcyhjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5zbGljZVJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0ludmVyc2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGljZUludmVyc2VSZW5kZXJSYW5nZXMoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlTm9ybWFsUmVuZGVyUmFuZ2VzKGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50SW5zdGFuY2VHcm91cC5wcm90b3R5cGUuc2xpY2VOb3JtYWxSZW5kZXJSYW5nZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gdGhpcy5ldmVudEluc3RhbmNlcztcclxuICAgICAgICB2YXIgaSwgZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB2YXIgc2xpY2VkUmFuZ2U7XHJcbiAgICAgICAgdmFyIHNsaWNlZEV2ZW50UmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlc1tpXTtcclxuICAgICAgICAgICAgc2xpY2VkUmFuZ2UgPSBldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLnVuem9uZWRSYW5nZS5pbnRlcnNlY3QoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKHNsaWNlZFJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBzbGljZWRFdmVudFJhbmdlcy5wdXNoKG5ldyBFdmVudFJhbmdlXzEuZGVmYXVsdChzbGljZWRSYW5nZSwgZXZlbnRJbnN0YW5jZS5kZWYsIGV2ZW50SW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2xpY2VkRXZlbnRSYW5nZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5zbGljZUludmVyc2VSZW5kZXJSYW5nZXMgPSBmdW5jdGlvbiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZXMgPSB0aGlzLmV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlKTtcclxuICAgICAgICB2YXIgb3duZXJEZWYgPSB0aGlzLmdldEV2ZW50RGVmKCk7XHJcbiAgICAgICAgdW56b25lZFJhbmdlcyA9IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQuaW52ZXJ0UmFuZ2VzKHVuem9uZWRSYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIHVuem9uZWRSYW5nZXMubWFwKGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudFJhbmdlXzEuZGVmYXVsdCh1bnpvbmVkUmFuZ2UsIG93bmVyRGVmKTsgLy8gZG9uJ3QgZ2l2ZSBhbiBFdmVudEluc3RhbmNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5pc0ludmVyc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnREZWYoKS5oYXNJbnZlcnNlUmVuZGVyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5nZXRFdmVudERlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5leHBsaWNpdEV2ZW50RGVmIHx8IHRoaXMuZXZlbnRJbnN0YW5jZXNbMF0uZGVmO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEluc3RhbmNlR3JvdXA7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50SW5zdGFuY2VHcm91cDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuLyogVHJhY2tzIG1vdXNlIG1vdmVtZW50cyBvdmVyIGEgY29tcG9uZW50IGFuZCByYWlzZXMgZXZlbnRzIGFib3V0IHdoaWNoIGhpdCB0aGUgbW91c2UgaXMgb3Zlci5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbm9wdGlvbnM6XHJcbi0gc3ViamVjdEVsXHJcbi0gc3ViamVjdENlbnRlclxyXG4qL1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGl0RHJhZ0xpc3RlbmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGl0RHJhZ0xpc3RlbmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxyXG4gICAgLy8gZXYgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGRyYWdnaW5nIHdhcyBzdGFydGVkIG1hbnVhbGx5LlxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVjdDtcclxuICAgICAgICB2YXIgb3JpZ1BvaW50O1xyXG4gICAgICAgIHZhciBwb2ludDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2Nyb2xsQm91bmRzKCk7IC8vIGZvciBhdXRvc2Nyb2xsXHJcbiAgICAgICAgaWYgKGV2KSB7XHJcbiAgICAgICAgICAgIG9yaWdQb2ludCA9IHsgbGVmdDogdXRpbF8xLmdldEV2WChldiksIHRvcDogdXRpbF8xLmdldEV2WShldikgfTtcclxuICAgICAgICAgICAgcG9pbnQgPSBvcmlnUG9pbnQ7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViamVjdFJlY3QgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHN1YmplY3RFbCk7IC8vIHVzZWQgZm9yIGNlbnRlcmluZyBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHV0aWxfMS5jb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ0hpdCA9IHRoaXMucXVlcnlIaXQocG9pbnQubGVmdCwgcG9pbnQudG9wKTtcclxuICAgICAgICAgICAgLy8gdHJlYXQgdGhlIGNlbnRlciBvZiB0aGUgc3ViamVjdCBhcyB0aGUgY29sbGlzaW9uIHBvaW50P1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsICYmIHRoaXMub3B0aW9ucy5zdWJqZWN0Q2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2tpcCB0aGlzIGlmIGhpdCBkaWRuJ3Qgc3VwcGx5IGxlZnQvcmlnaHQvdG9wL2JvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gdXRpbF8xLmludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0OyAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSB1dGlsXzEuZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHV0aWxfMS5kaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZC4gZG8gaXQgYWZ0ZXIgb3JpZ0hpdCBoYXMgYmVlbiBjb21wdXRlZFxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYWN0dWFsIGRyYWcgaGFzIHN0YXJ0ZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICAvLyBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGlzLm9yaWdIaXQgaWYgdGhlIG1pbi1kaXN0YW5jZSBpcyBsYXJnZVxyXG4gICAgICAgIGhpdCA9IHRoaXMucXVlcnlIaXQodXRpbF8xLmdldEV2WChldiksIHV0aWxfMS5nZXRFdlkoZXYpKTtcclxuICAgICAgICAvLyByZXBvcnQgdGhlIGluaXRpYWwgaGl0IHRoZSBtb3VzZSBpcyBvdmVyXHJcbiAgICAgICAgLy8gZXNwZWNpYWxseSBpbXBvcnRhbnQgaWYgbm8gbWluLWRpc3RhbmNlIGFuZCBkcmFnIHN0YXJ0cyBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnIG1vdmVzXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZHgsIGR5LCBldikge1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnLmNhbGwodGhpcywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgaGl0ID0gdGhpcy5xdWVyeUhpdCh1dGlsXzEuZ2V0RXZYKGV2KSwgdXRpbF8xLmdldEV2WShldikpO1xyXG4gICAgICAgIGlmICghaXNIaXRzRXF1YWwoaGl0LCB0aGlzLmhpdCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUhpdE91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0T3ZlcihoaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWdnaW5nIGhhcyBiZWVuIHN0b3BwZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlRHJhZ0VuZC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBhIHRoZSBtb3VzZSBoYXMganVzdCBtb3ZlZCBvdmVyIGEgbmV3IGhpdFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVIaXRPdmVyID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciBpc09yaWcgPSBpc0hpdHNFcXVhbChoaXQsIHRoaXMub3JpZ0hpdCk7XHJcbiAgICAgICAgdGhpcy5oaXQgPSBoaXQ7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXRPdmVyJywgdGhpcy5oaXQsIGlzT3JpZywgdGhpcy5vcmlnSGl0KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgbW91c2UgaGFzIGp1c3QgbW92ZWQgb3V0IG9mIGEgaGl0XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUhpdE91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXRPdXQnLCB0aGlzLmhpdCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0RG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBhIGhpdE91dC4gQWxzbyBjYWxsZWQgYmVmb3JlIGEgZHJhZ1N0b3BcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSGl0RG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaXREb25lJywgdGhpcy5oaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgaW50ZXJhY3Rpb24gZW5kcywgd2hldGhlciB0aGVyZSB3YXMgYSByZWFsIGRyYWcgb3Igbm90XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uRW5kID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQuY2FsbCh0aGlzLCBldiwgaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgIHRoaXMub3JpZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oaXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmhpdHNOb3ROZWVkZWQoKTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIC8vIGhpdHMnIGFic29sdXRlIHBvc2l0aW9ucyB3aWxsIGJlIGluIG5ldyBwbGFjZXMgYWZ0ZXIgYSB1c2VyJ3Mgc2Nyb2xsLlxyXG4gICAgICAgIC8vIEhBQ0sgZm9yIHJlY29tcHV0aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVsZWFzZUhpdHMoKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgaGl0IHVuZGVybmVhdGggdGhlIGNvb3JkaW5hdGVzIGZvciB0aGUgZ2l2ZW4gbW91c2UgZXZlbnRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdCwgdG9wKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29vcmRBZGp1c3QpIHtcclxuICAgICAgICAgICAgbGVmdCArPSB0aGlzLmNvb3JkQWRqdXN0LmxlZnQ7XHJcbiAgICAgICAgICAgIHRvcCArPSB0aGlzLmNvb3JkQWRqdXN0LnRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnF1ZXJ5SGl0KGxlZnQsIHRvcCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhpdERyYWdMaXN0ZW5lcjtcclxufShEcmFnTGlzdGVuZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEhpdERyYWdMaXN0ZW5lcjtcclxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGhpdHMgYXJlIGlkZW50aWNhbGx5IGVxdWFsLiBgZmFsc2VgIG90aGVyd2lzZS4gTXVzdCBiZSBmcm9tIHRoZSBzYW1lIGNvbXBvbmVudC5cclxuLy8gVHdvIG51bGwgdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBlcXVhbCwgYXMgdHdvIFwib3V0IG9mIHRoZSBjb21wb25lbnRcIiBzdGF0ZXMgYXJlIHRoZSBzYW1lLlxyXG5mdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwLCBoaXQxKSB7XHJcbiAgICBpZiAoIWhpdDAgJiYgIWhpdDEpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChoaXQwICYmIGhpdDEpIHtcclxuICAgICAgICByZXR1cm4gaGl0MC5jb21wb25lbnQgPT09IGhpdDEuY29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgIGlzSGl0UHJvcHNXaXRoaW4oaGl0MCwgaGl0MSkgJiZcclxuICAgICAgICAgICAgaXNIaXRQcm9wc1dpdGhpbihoaXQxLCBoaXQwKTsgLy8gZW5zdXJlcyBhbGwgcHJvcHMgYXJlIGlkZW50aWNhbFxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIFJldHVybnMgdHJ1ZSBpZiBhbGwgb2Ygc3ViSGl0J3Mgbm9uLXN0YW5kYXJkIHByb3BlcnRpZXMgYXJlIHdpdGhpbiBzdXBlckhpdFxyXG5mdW5jdGlvbiBpc0hpdFByb3BzV2l0aGluKHN1YkhpdCwgc3VwZXJIaXQpIHtcclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHN1YkhpdCkge1xyXG4gICAgICAgIGlmICghL14oY29tcG9uZW50fGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkkLy50ZXN0KHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICBpZiAoc3ViSGl0W3Byb3BOYW1lXSAhPT0gc3VwZXJIaXRbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5leHBvcnRzLmdsb2JhbERlZmF1bHRzID0ge1xyXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXHJcbiAgICBtb250aFllYXJGb3JtYXQ6ICdNTU1NIFlZWVknLFxyXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAyOjAwOjAwJyxcclxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgIGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXHJcbiAgICBuZXh0RGF5VGhyZXNob2xkOiAnMDk6MDA6MDAnLFxyXG4gICAgLy8gZGlzcGxheVxyXG4gICAgY29sdW1uSGVhZGVyOiB0cnVlLFxyXG4gICAgZGVmYXVsdFZpZXc6ICdtb250aCcsXHJcbiAgICBhc3BlY3RSYXRpbzogMS4zNSxcclxuICAgIGhlYWRlcjoge1xyXG4gICAgICAgIGxlZnQ6ICd0aXRsZScsXHJcbiAgICAgICAgY2VudGVyOiAnJyxcclxuICAgICAgICByaWdodDogJ3RvZGF5IHByZXYsbmV4dCdcclxuICAgIH0sXHJcbiAgICB3ZWVrZW5kczogdHJ1ZSxcclxuICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcclxuICAgIHdlZWtOdW1iZXJUaXRsZTogJ1cnLFxyXG4gICAgd2Vla051bWJlckNhbGN1bGF0aW9uOiAnbG9jYWwnLFxyXG4gICAgLy9lZGl0YWJsZTogZmFsc2UsXHJcbiAgICAvL25vd0luZGljYXRvcjogZmFsc2UsXHJcbiAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgbWluVGltZTogJzAwOjAwOjAwJyxcclxuICAgIG1heFRpbWU6ICcyNDowMDowMCcsXHJcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgLy8gZXZlbnQgYWpheFxyXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcclxuICAgIGVuZFBhcmFtOiAnZW5kJyxcclxuICAgIHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXHJcbiAgICB0aW1lem9uZTogZmFsc2UsXHJcbiAgICAvL2FsbERheURlZmF1bHQ6IHVuZGVmaW5lZCxcclxuICAgIC8vIGxvY2FsZVxyXG4gICAgbG9jYWxlOiBudWxsLFxyXG4gICAgaXNSVEw6IGZhbHNlLFxyXG4gICAgYnV0dG9uVGV4dDoge1xyXG4gICAgICAgIHByZXY6IFwicHJldlwiLFxyXG4gICAgICAgIG5leHQ6IFwibmV4dFwiLFxyXG4gICAgICAgIHByZXZZZWFyOiBcInByZXYgeWVhclwiLFxyXG4gICAgICAgIG5leHRZZWFyOiBcIm5leHQgeWVhclwiLFxyXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcclxuICAgICAgICB0b2RheTogJ3RvZGF5JyxcclxuICAgICAgICBtb250aDogJ21vbnRoJyxcclxuICAgICAgICB3ZWVrOiAnd2VlaycsXHJcbiAgICAgICAgZGF5OiAnZGF5J1xyXG4gICAgfSxcclxuICAgIC8vYnV0dG9uSWNvbnM6IG51bGwsXHJcbiAgICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXHJcbiAgICAvLyBhbGxvd3Mgc2V0dGluZyBhIG1pbi1oZWlnaHQgdG8gdGhlIGV2ZW50IHNlZ21lbnQgdG8gcHJldmVudCBzaG9ydCBldmVudHMgb3ZlcmxhcHBpbmcgZWFjaCBvdGhlclxyXG4gICAgYWdlbmRhRXZlbnRNaW5IZWlnaHQ6IDAsXHJcbiAgICAvLyBqcXVlcnktdWkgdGhlbWluZ1xyXG4gICAgdGhlbWU6IGZhbHNlLFxyXG4gICAgLy90aGVtZUJ1dHRvbkljb25zOiBudWxsLFxyXG4gICAgLy9ldmVudFJlc2l6YWJsZUZyb21TdGFydDogZmFsc2UsXHJcbiAgICBkcmFnT3BhY2l0eTogLjc1LFxyXG4gICAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXHJcbiAgICBkcmFnU2Nyb2xsOiB0cnVlLFxyXG4gICAgLy9zZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcclxuICAgIC8vc2VsZWN0TWluRGlzdGFuY2U6IDAsXHJcbiAgICBkcm9wQWNjZXB0OiAnKicsXHJcbiAgICBldmVudE9yZGVyOiAndGl0bGUnLFxyXG4gICAgLy9ldmVudFJlbmRlcldhaXQ6IG51bGwsXHJcbiAgICBldmVudExpbWl0OiBmYWxzZSxcclxuICAgIGV2ZW50TGltaXRUZXh0OiAnbW9yZScsXHJcbiAgICBldmVudExpbWl0Q2xpY2s6ICdwb3BvdmVyJyxcclxuICAgIGRheVBvcG92ZXJGb3JtYXQ6ICdMTCcsXHJcbiAgICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXHJcbiAgICB3aW5kb3dSZXNpemVEZWxheTogMTAwLFxyXG4gICAgbG9uZ1ByZXNzRGVsYXk6IDEwMDBcclxufTtcclxuZXhwb3J0cy5lbmdsaXNoRGVmYXVsdHMgPSB7XHJcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiAnZGRkZCwgTU1NTSBEJ1xyXG59O1xyXG5leHBvcnRzLnJ0bERlZmF1bHRzID0ge1xyXG4gICAgaGVhZGVyOiB7XHJcbiAgICAgICAgbGVmdDogJ25leHQscHJldiB0b2RheScsXHJcbiAgICAgICAgY2VudGVyOiAnJyxcclxuICAgICAgICByaWdodDogJ3RpdGxlJ1xyXG4gICAgfSxcclxuICAgIGJ1dHRvbkljb25zOiB7XHJcbiAgICAgICAgcHJldjogJ3JpZ2h0LXNpbmdsZS1hcnJvdycsXHJcbiAgICAgICAgbmV4dDogJ2xlZnQtc2luZ2xlLWFycm93JyxcclxuICAgICAgICBwcmV2WWVhcjogJ3JpZ2h0LWRvdWJsZS1hcnJvdycsXHJcbiAgICAgICAgbmV4dFllYXI6ICdsZWZ0LWRvdWJsZS1hcnJvdydcclxuICAgIH0sXHJcbiAgICB0aGVtZUJ1dHRvbkljb25zOiB7XHJcbiAgICAgICAgcHJldjogJ2NpcmNsZS10cmlhbmdsZS1lJyxcclxuICAgICAgICBuZXh0OiAnY2lyY2xlLXRyaWFuZ2xlLXcnLFxyXG4gICAgICAgIG5leHRZZWFyOiAnc2Vlay1wcmV2JyxcclxuICAgICAgICBwcmV2WWVhcjogJ3NlZWstbmV4dCdcclxuICAgIH1cclxufTtcclxudmFyIGNvbXBsZXhPcHRpb25zID0gW1xyXG4gICAgJ2hlYWRlcicsXHJcbiAgICAnZm9vdGVyJyxcclxuICAgICdidXR0b25UZXh0JyxcclxuICAgICdidXR0b25JY29ucycsXHJcbiAgICAndGhlbWVCdXR0b25JY29ucydcclxuXTtcclxuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25PYmpzKSB7XHJcbiAgICByZXR1cm4gdXRpbF8xLm1lcmdlUHJvcHMob3B0aW9uT2JqcywgY29tcGxleE9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gbWVyZ2VPcHRpb25zO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBuYW1lc3BhY2VfaG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBsb2NhbGVPcHRpb25IYXNoID0gbmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC5sb2NhbGVzO1xyXG5leHBvcnRzLmxvY2FsZU9wdGlvbkhhc2ggPSBsb2NhbGVPcHRpb25IYXNoO1xyXG4vLyBJbml0aWFsaXplIGpRdWVyeSBVSSBkYXRlcGlja2VyIHRyYW5zbGF0aW9ucyB3aGlsZSB1c2luZyBzb21lIG9mIHRoZSB0cmFuc2xhdGlvbnNcclxuLy8gV2lsbCBzZXQgdGhpcyBhcyB0aGUgZGVmYXVsdCBsb2NhbGVzIGZvciBkYXRlcGlja2VyLlxyXG5mdW5jdGlvbiBkYXRlcGlja2VyTG9jYWxlKGxvY2FsZUNvZGUsIGRwTG9jYWxlQ29kZSwgZHBPcHRpb25zKSB7XHJcbiAgICAvLyBnZXQgdGhlIEZ1bGxDYWxlbmRhciBpbnRlcm5hbCBvcHRpb24gaGFzaCBmb3IgdGhpcyBsb2NhbGUuIGNyZWF0ZSBpZiBuZWNlc3NhcnlcclxuICAgIHZhciBmY09wdGlvbnMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0ge30pO1xyXG4gICAgLy8gdHJhbnNmZXIgc29tZSBzaW1wbGUgb3B0aW9ucyBmcm9tIGRhdGVwaWNrZXIgdG8gZmNcclxuICAgIGZjT3B0aW9ucy5pc1JUTCA9IGRwT3B0aW9ucy5pc1JUTDtcclxuICAgIGZjT3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgPSBkcE9wdGlvbnMud2Vla0hlYWRlcjtcclxuICAgIC8vIGNvbXB1dGUgc29tZSBtb3JlIGNvbXBsZXggb3B0aW9ucyBmcm9tIGRhdGVwaWNrZXJcclxuICAgICQuZWFjaChkcENvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xyXG4gICAgICAgIGZjT3B0aW9uc1tuYW1lXSA9IGZ1bmMoZHBPcHRpb25zKTtcclxuICAgIH0pO1xyXG4gICAgdmFyIGpxRGF0ZVBpY2tlciA9ICQuZGF0ZXBpY2tlcjtcclxuICAgIC8vIGlzIGpRdWVyeSBVSSBEYXRlcGlja2VyIGlzIG9uIHRoZSBwYWdlP1xyXG4gICAgaWYgKGpxRGF0ZVBpY2tlcikge1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBsb2NhbGUgZGF0YS5cclxuICAgICAgICAvLyBGdWxsQ2FsZW5kYXIgYW5kIE1vbWVudEpTIHVzZSBsb2NhbGUgY29kZXMgbGlrZSBcInB0LWJyXCIgYnV0IERhdGVwaWNrZXJcclxuICAgICAgICAvLyBkb2VzIGl0IGxpa2UgXCJwdC1CUlwiIG9yIGlmIGl0IGRvZXNuJ3QgaGF2ZSB0aGUgbG9jYWxlLCBtYXliZSBqdXN0IFwicHRcIi5cclxuICAgICAgICAvLyBNYWtlIGFuIGFsaWFzIHNvIHRoZSBsb2NhbGUgY2FuIGJlIHJlZmVyZW5jZWQgZWl0aGVyIHdheS5cclxuICAgICAgICBqcURhdGVQaWNrZXIucmVnaW9uYWxbZHBMb2NhbGVDb2RlXSA9XHJcbiAgICAgICAgICAgIGpxRGF0ZVBpY2tlci5yZWdpb25hbFtsb2NhbGVDb2RlXSA9IC8vIGFsaWFzXHJcbiAgICAgICAgICAgICAgICBkcE9wdGlvbnM7XHJcbiAgICAgICAgLy8gQWxpYXMgJ2VuJyB0byB0aGUgZGVmYXVsdCBsb2NhbGUgZGF0YS4gRG8gdGhpcyBldmVyeSB0aW1lLlxyXG4gICAgICAgIGpxRGF0ZVBpY2tlci5yZWdpb25hbC5lbiA9IGpxRGF0ZVBpY2tlci5yZWdpb25hbFsnJ107XHJcbiAgICAgICAgLy8gU2V0IGFzIERhdGVwaWNrZXIncyBnbG9iYWwgZGVmYXVsdHMuXHJcbiAgICAgICAganFEYXRlUGlja2VyLnNldERlZmF1bHRzKGRwT3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5kYXRlcGlja2VyTG9jYWxlID0gZGF0ZXBpY2tlckxvY2FsZTtcclxuLy8gU2V0cyBGdWxsQ2FsZW5kYXItc3BlY2lmaWMgdHJhbnNsYXRpb25zLiBXaWxsIHNldCB0aGUgbG9jYWxlcyBhcyB0aGUgZ2xvYmFsIGRlZmF1bHQuXHJcbmZ1bmN0aW9uIGxvY2FsZShsb2NhbGVDb2RlLCBuZXdGY09wdGlvbnMpIHtcclxuICAgIHZhciBmY09wdGlvbnM7XHJcbiAgICB2YXIgbW9tT3B0aW9ucztcclxuICAgIC8vIGdldCB0aGUgRnVsbENhbGVuZGFyIGludGVybmFsIG9wdGlvbiBoYXNoIGZvciB0aGlzIGxvY2FsZS4gY3JlYXRlIGlmIG5lY2Vzc2FyeVxyXG4gICAgZmNPcHRpb25zID0gbG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSB8fCAobG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcclxuICAgIC8vIHByb3ZpZGVkIG5ldyBvcHRpb25zIGZvciB0aGlzIGxvY2FsZXM/IG1lcmdlIHRoZW0gaW5cclxuICAgIGlmIChuZXdGY09wdGlvbnMpIHtcclxuICAgICAgICBmY09wdGlvbnMgPSBsb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhbZmNPcHRpb25zLCBuZXdGY09wdGlvbnNdKTtcclxuICAgIH1cclxuICAgIC8vIGNvbXB1dGUgbG9jYWxlIG9wdGlvbnMgdGhhdCB3ZXJlbid0IGRlZmluZWQuXHJcbiAgICAvLyBhbHdheXMgZG8gdGhpcy4gbmV3RmNPcHRpb25zIGNhbiBiZSB1bmRlZmluZWQgd2hlbiBpbml0aWFsaXppbmcgZnJvbSBpMThuIGZpbGUsXHJcbiAgICAvLyBzbyBubyB3YXkgdG8gdGVsbCBpZiB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIG9yIGEgZGVmYXVsdC1zZXR0aW5nLlxyXG4gICAgbW9tT3B0aW9ucyA9IGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSk7IC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXHJcbiAgICAkLmVhY2gobW9tQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgaWYgKGZjT3B0aW9uc1tuYW1lXSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZjT3B0aW9uc1tuYW1lXSA9IGZ1bmMobW9tT3B0aW9ucywgZmNPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIHNldCBpdCBhcyB0aGUgZGVmYXVsdCBsb2NhbGUgZm9yIEZ1bGxDYWxlbmRhclxyXG4gICAgb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzLmxvY2FsZSA9IGxvY2FsZUNvZGU7XHJcbn1cclxuZXhwb3J0cy5sb2NhbGUgPSBsb2NhbGU7XHJcbjtcclxuLy8gTk9URTogY2FuJ3QgZ3VhcmFudGVlIGFueSBvZiB0aGVzZSBjb21wdXRhdGlvbnMgd2lsbCBydW4gYmVjYXVzZSBub3QgZXZlcnkgbG9jYWxlIGhhcyBkYXRlcGlja2VyXHJcbi8vIGNvbmZpZ3MsIHNvIG1ha2Ugc3VyZSB0aGVyZSBhcmUgRW5nbGlzaCBmYWxsYmFja3MgZm9yIHRoZXNlIGluIHRoZSBkZWZhdWx0cyBmaWxlLlxyXG52YXIgZHBDb21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIGJ1dHRvblRleHQ6IGZ1bmN0aW9uIChkcE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyB0aGUgdHJhbnNsYXRpb25zIHNvbWV0aW1lcyB3cm9uZ2x5IGNvbnRhaW4gSFRNTCBlbnRpdGllc1xyXG4gICAgICAgICAgICBwcmV2OiB1dGlsXzEuc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLnByZXZUZXh0KSxcclxuICAgICAgICAgICAgbmV4dDogdXRpbF8xLnN0cmlwSHRtbEVudGl0aWVzKGRwT3B0aW9ucy5uZXh0VGV4dCksXHJcbiAgICAgICAgICAgIHRvZGF5OiB1dGlsXzEuc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLmN1cnJlbnRUZXh0KVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcIk1NTU0gWVlZWVwiIC0+IFwiU2VwdGVtYmVyIDIwMTRcIlxyXG4gICAgbW9udGhZZWFyRm9ybWF0OiBmdW5jdGlvbiAoZHBPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGRwT3B0aW9ucy5zaG93TW9udGhBZnRlclllYXIgP1xyXG4gICAgICAgICAgICAnWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSBNTU1NJyA6XHJcbiAgICAgICAgICAgICdNTU1NIFlZWVlbJyArIGRwT3B0aW9ucy55ZWFyU3VmZml4ICsgJ10nO1xyXG4gICAgfVxyXG59O1xyXG52YXIgbW9tQ29tcHV0YWJsZU9wdGlvbnMgPSB7XHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiZGRkIE0vRFwiIC0+IFwiRnJpIDkvMTVcIlxyXG4gICAgZGF5T2ZNb250aEZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMsIGZjT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdsJyk7IC8vIGZvciB0aGUgZm9ybWF0IGxpa2UgXCJNL0QvWVlZWVwiXHJcbiAgICAgICAgLy8gc3RyaXAgdGhlIHllYXIgb2ZmIHRoZSBlZGdlLCBhcyB3ZWxsIGFzIG90aGVyIG1pc2Mgbm9uLXdoaXRlc3BhY2UgY2hhcnNcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXlkrW15cXHdcXHNdKnxbXlxcd1xcc10qWSskL2csICcnKTtcclxuICAgICAgICBpZiAoZmNPcHRpb25zLmlzUlRMKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCArPSAnIGRkZCc7IC8vIGZvciBSVEwsIGFkZCBkYXktb2Ytd2VlayB0byBlbmRcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9ICdkZGQgJyArIGZvcm1hdDsgLy8gZm9yIExUUiwgYWRkIGRheS1vZi13ZWVrIHRvIGJlZ2lubmluZ1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0O1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoOm1tYVwiIC0+IFwiNjowMHBtXCJcclxuICAgIG1lZGl1bVRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnYScpOyAvLyBjb252ZXJ0IEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZS4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoKDptbSlhXCIgLT4gXCI2cG1cIiAvIFwiNjozMHBtXCJcclxuICAgIHNtYWxsVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgnOm1tJywgJyg6bW0pJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXFdtbSkkLywgJygkMSknKSAvLyBsaWtlIGFib3ZlLCBidXQgZm9yIGZvcmVpZ24gbG9jYWxlc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKXRcIiAtPiBcIjZwXCIgLyBcIjY6MzBwXCJcclxuICAgIGV4dHJhU21hbGxUaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnKDptbSknKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ3QnKTsgLy8gY29udmVydCB0byBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2Ugb25lLWxldHRlci4gcmVtb3ZlIGFueSBzcGFjZXMgYmVmb3JlaGFuZFxyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJoYVwiIC8gXCJIXCIgLT4gXCI2cG1cIiAvIFwiMThcIlxyXG4gICAgaG91ckZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgnOm1tJywgJycpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxXbW0pJC8sICcnKSAvLyBsaWtlIGFib3ZlLCBidXQgZm9yIGZvcmVpZ24gbG9jYWxlc1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1cIiAtPiBcIjY6MzBcIiAod2l0aCBubyBBTS9QTSlcclxuICAgIG5vTWVyaWRpZW1UaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgQU0vUE1cclxuICAgIH1cclxufTtcclxuLy8gb3B0aW9ucyB0aGF0IHNob3VsZCBiZSBjb21wdXRlZCBvZmYgbGl2ZSBjYWxlbmRhciBvcHRpb25zIChjb25zaWRlcnMgb3ZlcnJpZGUgb3B0aW9ucylcclxuLy8gVE9ETzogYmVzdCBwbGFjZSBmb3IgdGhpcz8gcmVsYXRlZCB0byBsb2NhbGU/XHJcbi8vIFRPRE86IGZsaXBwaW5nIHRleHQgYmFzZWQgb24gaXNSVEwgaXMgYSBiYWQgaWRlYSBiZWNhdXNlIHRoZSBDU1MgYGRpcmVjdGlvbmAgbWlnaHQgd2FudCB0byBoYW5kbGUgaXRcclxudmFyIGluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMgPSB7XHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiTW8gMTZcIlxyXG4gICAgc21hbGxEYXlEYXRlRm9ybWF0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmlzUlRMID9cclxuICAgICAgICAgICAgJ0QgZGQnIDpcclxuICAgICAgICAgICAgJ2RkIEQnO1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXayA1XCJcclxuICAgIHdlZWtGb3JtYXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xyXG4gICAgICAgICAgICAnd1sgJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcclxuICAgICAgICAgICAgJ1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnIF13JztcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBmb3IgcmVzdWx0cyBsaWtlIFwiV2s1XCJcclxuICAgIHNtYWxsV2Vla0Zvcm1hdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5pc1JUTCA/XHJcbiAgICAgICAgICAgICd3WycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICddJyA6XHJcbiAgICAgICAgICAgICdbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ113JztcclxuICAgIH1cclxufTtcclxuLy8gVE9ETzogbWFrZSB0aGVzZSBjb21wdXRhYmxlIHByb3BlcnRpZXMgaW4gb3B0aW9uc01hbmFnZXJcclxuZnVuY3Rpb24gcG9wdWxhdGVJbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICQuZWFjaChpbnN0YW5jZUNvbXB1dGFibGVPcHRpb25zLCBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xyXG4gICAgICAgIGlmIChvcHRpb25zW25hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IGZ1bmMob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5wb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMgPSBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnM7XHJcbi8vIFJldHVybnMgbW9tZW50J3MgaW50ZXJuYWwgbG9jYWxlIGRhdGEuIElmIGRvZXNuJ3QgZXhpc3QsIHJldHVybnMgRW5nbGlzaC5cclxuZnVuY3Rpb24gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmxvY2FsZURhdGEobG9jYWxlQ29kZSkgfHwgbW9tZW50LmxvY2FsZURhdGEoJ2VuJyk7XHJcbn1cclxuZXhwb3J0cy5nZXRNb21lbnRMb2NhbGVEYXRhID0gZ2V0TW9tZW50TG9jYWxlRGF0YTtcclxuLy8gSW5pdGlhbGl6ZSBFbmdsaXNoIGJ5IGZvcmNpbmcgY29tcHV0YXRpb24gb2YgbW9tZW50LWRlcml2ZWQgb3B0aW9ucy5cclxuLy8gQWxzbywgc2V0cyBpdCBhcyB0aGUgZGVmYXVsdC5cclxubG9jYWxlKCdlbicsIG9wdGlvbnNfMS5lbmdsaXNoRGVmYXVsdHMpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8vIENsYXNzIHRoYXQgYWxsIG90aGVyIGNsYXNzZXMgd2lsbCBpbmhlcml0IGZyb21cclxudmFyIENsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2xhc3MoKSB7XHJcbiAgICB9XHJcbiAgICAvLyBDYWxsZWQgb24gYSBjbGFzcyB0byBjcmVhdGUgYSBzdWJjbGFzcy5cclxuICAgIC8vIExJTUlUQVRJT046IGNhbm5vdCBwcm92aWRlIGEgY29uc3RydWN0b3IhXHJcbiAgICBDbGFzcy5leHRlbmQgPSBmdW5jdGlvbiAobWVtYmVycykge1xyXG4gICAgICAgIHZhciBTdWJDbGFzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViQ2xhc3MsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN1YkNsYXNzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTdWJDbGFzcztcclxuICAgICAgICB9KHRoaXMpKTtcclxuICAgICAgICA7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhtZW1iZXJzLCBTdWJDbGFzcy5wcm90b3R5cGUpO1xyXG4gICAgICAgIHJldHVybiBTdWJDbGFzcztcclxuICAgIH07XHJcbiAgICAvLyBBZGRzIG5ldyBtZW1iZXIgdmFyaWFibGVzL21ldGhvZHMgdG8gdGhlIGNsYXNzJ3MgcHJvdG90eXBlLlxyXG4gICAgLy8gQ2FuIGJlIGNhbGxlZCB3aXRoIGFub3RoZXIgY2xhc3MsIG9yIGEgcGxhaW4gb2JqZWN0IGhhc2ggY29udGFpbmluZyBuZXcgbWVtYmVycy5cclxuICAgIENsYXNzLm1peGluID0gZnVuY3Rpb24gKG1lbWJlcnMpIHtcclxuICAgICAgICB1dGlsXzEuY29weU93blByb3BzKG1lbWJlcnMsIHRoaXMucHJvdG90eXBlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2xhc3M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENsYXNzO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XHJcbnZhciBFdmVudERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVmKHNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gW107XHJcbiAgICAgICAgdGhpcy5taXNjUHJvcHMgPSB7fTtcclxuICAgIH1cclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuc291cmNlKTtcclxuICAgICAgICBjb3B5LmlkID0gdGhpcy5pZDtcclxuICAgICAgICBjb3B5LnJhd0lkID0gdGhpcy5yYXdJZDtcclxuICAgICAgICBjb3B5LnVpZCA9IHRoaXMudWlkOyAvLyBub3QgcmVhbGx5IHVuaXF1ZSBhbnltb3JlIDooXHJcbiAgICAgICAgRXZlbnREZWYuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLCBjb3B5KTtcclxuICAgICAgICBjb3B5LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnNsaWNlKCk7IC8vIGNvcHlcclxuICAgICAgICBjb3B5Lm1pc2NQcm9wcyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmhhc0ludmVyc2VSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyaW5nKCkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5oYXNCZ1JlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVuZGVyaW5nID0gdGhpcy5nZXRSZW5kZXJpbmcoKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJyB8fCByZW5kZXJpbmcgPT09ICdiYWNrZ3JvdW5kJztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuZ2V0UmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmluZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnJlbmRlcmluZztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuZ2V0Q29uc3RyYWludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlLmNvbnN0cmFpbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY29uc3RyYWludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNhbGVuZGFyLm9wdCgnZXZlbnRDb25zdHJhaW50Jyk7IC8vIHdoYXQgYWJvdXQgVmlldyBvcHRpb24/XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldE92ZXJsYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZS5vdmVybGFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLm92ZXJsYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jYWxlbmRhci5vcHQoJ2V2ZW50T3ZlcmxhcCcpOyAvLyB3aGF0IGFib3V0IFZpZXcgb3B0aW9uP1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5pc1N0YXJ0RXhwbGljaXRseUVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydEVkaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3RhcnRFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaXNEdXJhdGlvbkV4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb25FZGl0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmlzRXhwbGljaXRseUVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5lZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9ICQuZXh0ZW5kKHt9LCB0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgb2JqLl9pZCA9IHRoaXMudWlkO1xyXG4gICAgICAgIG9iai5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICBvYmouY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUuc2xpY2UoKTsgLy8gY29weVxyXG4gICAgICAgIG9iai5hbGxEYXkgPSB0aGlzLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmF3SWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvYmouaWQgPSB0aGlzLnJhd0lkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERlZi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzKHRoaXMsIG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzLmlkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IEV2ZW50RGVmLm5vcm1hbGl6ZUlkKCh0aGlzLnJhd0lkID0gcmF3UHJvcHMuaWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudERlZi5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcy5faWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnVpZCA9IFN0cmluZyhyYXdQcm9wcy5faWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBFdmVudERlZi5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGNvbnZlcmdlIHdpdGggRXZlbnRTb3VyY2VcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd1Byb3BzLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICAkLmV4dGVuZCh0aGlzLm1pc2NQcm9wcywgcmF3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBzb3VyY2UpIHtcclxuICAgICAgICB2YXIgZGVmID0gbmV3IHRoaXMoc291cmNlKTtcclxuICAgICAgICBpZiAoZGVmLmFwcGx5UHJvcHMocmF3SW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5ub3JtYWxpemVJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoaWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdfZmMnICsgKEV2ZW50RGVmLnV1aWQrKyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQuZGVmaW5lU3RhbmRhcmRQcm9wcztcclxuICAgIEV2ZW50RGVmLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICAvLyBJRHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gVE9ETzogY29udmVyZ2Ugd2l0aCBFdmVudFNvdXJjZVxyXG4gICAgRXZlbnREZWYudXVpZCA9IDA7XHJcbiAgICByZXR1cm4gRXZlbnREZWY7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnREZWYpO1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5FdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIC8vIG5vdCBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIChgZmFsc2VgKVxyXG4gICAgX2lkOiBmYWxzZSxcclxuICAgIGlkOiBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogZmFsc2UsXHJcbiAgICBzb3VyY2U6IGZhbHNlLFxyXG4gICAgLy8gYXV0b21hdGljYWxseSBhc3NpZ25lZCAoYHRydWVgKVxyXG4gICAgdGl0bGU6IHRydWUsXHJcbiAgICB1cmw6IHRydWUsXHJcbiAgICByZW5kZXJpbmc6IHRydWUsXHJcbiAgICBjb25zdHJhaW50OiB0cnVlLFxyXG4gICAgb3ZlcmxhcDogdHJ1ZSxcclxuICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICBjb2xvcjogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcclxuICAgIGJvcmRlckNvbG9yOiB0cnVlLFxyXG4gICAgdGV4dENvbG9yOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbmZ1bmN0aW9uIGV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMoZXZlbnREZWZzLCB1bnpvbmVkUmFuZ2UpIHtcclxuICAgIHZhciBldmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZXMucHVzaC5hcHBseShldmVudEluc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgZXZlbnREZWZzW2ldLmJ1aWxkSW5zdGFuY2VzKHVuem9uZWRSYW5nZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VzO1xyXG59XHJcbmV4cG9ydHMuZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcyA9IGV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXM7XHJcbmZ1bmN0aW9uIGV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFdmVudFJhbmdlXzEuZGVmYXVsdChldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLnVuem9uZWRSYW5nZSwgZXZlbnRJbnN0YW5jZS5kZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG59XHJcbmV4cG9ydHMuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSA9IGV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2U7XHJcbmZ1bmN0aW9uIGV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50KGV2ZW50UmFuZ2UpIHtcclxuICAgIHJldHVybiBuZXcgRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KGV2ZW50UmFuZ2UudW56b25lZFJhbmdlLCBldmVudFJhbmdlLmV2ZW50RGVmLmlzQWxsRGF5KCkpLCBldmVudFJhbmdlLmV2ZW50RGVmLCBldmVudFJhbmdlLmV2ZW50SW5zdGFuY2UgLy8gbWlnaHQgbm90IGV4aXN0XHJcbiAgICApO1xyXG59XHJcbmV4cG9ydHMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQgPSBldmVudFJhbmdlVG9FdmVudEZvb3RwcmludDtcclxuZnVuY3Rpb24gZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLnVuem9uZWRSYW5nZTtcclxufVxyXG5leHBvcnRzLmV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZSA9IGV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZTtcclxuZnVuY3Rpb24gZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludChldmVudEZvb3RwcmludCkge1xyXG4gICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxufVxyXG5leHBvcnRzLmV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQgPSBldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudEZvb3RwcmludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50Rm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudEZvb3RwcmludCA9IGNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmID0gZXZlbnREZWY7XHJcbiAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudEluc3RhbmNlID0gZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBFdmVudEZvb3RwcmludC5wcm90b3R5cGUuZ2V0RXZlbnRMZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmV2ZW50SW5zdGFuY2UgfHwgdGhpcy5ldmVudERlZikudG9MZWdhY3koKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRGb290cHJpbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50Rm9vdHByaW50O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIHNvdXJjZUNsYXNzZXM6IFtdLFxyXG4gICAgcmVnaXN0ZXJDbGFzczogZnVuY3Rpb24gKEV2ZW50U291cmNlQ2xhc3MpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZUNsYXNzZXMudW5zaGlmdChFdmVudFNvdXJjZUNsYXNzKTsgLy8gZ2l2ZSBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICB9LFxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc291cmNlQ2xhc3NlcyA9IHRoaXMuc291cmNlQ2xhc3NlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZXZlbnRTb3VyY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VDbGFzc2VzW2ldLnBhcnNlKHJhd0lucHV0LCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBFdmVudERlZk11dGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnREZWZNdXRhdGlvbigpIHtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBldmVudERlZiBhc3N1bWVkIHRvIGJlIGEgU2luZ2xlRXZlbnREZWYuXHJcbiAgICByZXR1cm5zIGFuIHVuZG8gZnVuY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5wcm90b3R5cGUubXV0YXRlU2luZ2xlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9yaWdEYXRlUHJvZmlsZTtcclxuICAgICAgICBpZiAodGhpcy5kYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgb3JpZ0RhdGVQcm9maWxlID0gZXZlbnREZWYuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmRhdGVQcm9maWxlID0gdGhpcy5kYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShvcmlnRGF0ZVByb2ZpbGUsIGV2ZW50RGVmLnNvdXJjZS5jYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIEV2ZW50RGVmOjphcHBseU1hbnVhbFN0YW5kYXJkUHJvcHNcclxuICAgICAgICBpZiAodGhpcy5ldmVudERlZklkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnREZWYuaWQgPSBFdmVudERlZl8xLmRlZmF1bHQubm9ybWFsaXplSWQoKGV2ZW50RGVmLnJhd0lkID0gdGhpcy5ldmVudERlZklkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIEV2ZW50RGVmOjphcHBseU1hbnVhbFN0YW5kYXJkUHJvcHNcclxuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgZXZlbnREZWYuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICBpZiAodGhpcy52ZXJiYXRpbVN0YW5kYXJkUHJvcHMpIHtcclxuICAgICAgICAgICAgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHModGhpcy52ZXJiYXRpbVN0YW5kYXJkUHJvcHMsIC8vIHNyY1xyXG4gICAgICAgICAgICBldmVudERlZiAvLyBkZXN0XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICBpZiAodGhpcy5taXNjUHJvcHMpIHtcclxuICAgICAgICAgICAgZXZlbnREZWYuYXBwbHlNaXNjUHJvcHModGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3JpZ0RhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZi5kYXRlUHJvZmlsZSA9IG9yaWdEYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmTXV0YXRpb24ucHJvdG90eXBlLnNldERhdGVNdXRhdGlvbiA9IGZ1bmN0aW9uIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uICYmICFkYXRlTXV0YXRpb24uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZU11dGF0aW9uID0gZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZk11dGF0aW9uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRlTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5jcmVhdGVGcm9tUmF3UHJvcHMgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgcmF3UHJvcHMsIGxhcmdlVW5pdCkge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50SW5zdGFuY2UuZGVmO1xyXG4gICAgICAgIHZhciBkYXRlUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBtaXNjUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgdmVyYmF0aW1TdGFuZGFyZFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQgPSBudWxsO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZGVmTXV0YXRpb247XHJcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQuaXNTdGFuZGFyZFByb3AocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50RGVmLmlzU3RhbmRhcmRQcm9wKHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnREZWYubWlzY1Byb3BzW3Byb3BOYW1lXSAhPT0gcmF3UHJvcHNbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNjUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVQcm9maWxlID0gRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQucGFyc2UoZGF0ZVByb3BzLCBldmVudERlZi5zb3VyY2UpO1xyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQuY3JlYXRlRnJvbURpZmYoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGUsIGxhcmdlVW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFuZGFyZFByb3BzLmlkICE9PSBldmVudERlZi5pZCkge1xyXG4gICAgICAgICAgICBldmVudERlZklkID0gc3RhbmRhcmRQcm9wcy5pZDsgLy8gb25seSBhcHBseSBpZiB0aGVyZSdzIGEgY2hhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXRpbF8xLmlzQXJyYXlzRXF1YWwoc3RhbmRhcmRQcm9wcy5jbGFzc05hbWUsIGV2ZW50RGVmLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gc3RhbmRhcmRQcm9wcy5jbGFzc05hbWU7IC8vIG9ubHkgYXBwbHkgaWYgdGhlcmUncyBhIGNoYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERlZl8xLmRlZmF1bHQuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyhzdGFuZGFyZFByb3BzLCAvLyBzcmNcclxuICAgICAgICB2ZXJiYXRpbVN0YW5kYXJkUHJvcHMgLy8gZGVzdFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgZGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbigpO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLmV2ZW50RGVmSWQgPSBldmVudERlZklkO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuICAgICAgICBkZWZNdXRhdGlvbi52ZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSB2ZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICAgICAgZGVmTXV0YXRpb24ubWlzY1Byb3BzID0gbWlzY1Byb3BzO1xyXG4gICAgICAgIGlmIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgZGVmTXV0YXRpb24uZGF0ZU11dGF0aW9uID0gZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmTXV0YXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmTXV0YXRpb247XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUaGVtZShvcHRpb25zTWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIgPSBvcHRpb25zTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnByb2Nlc3NJY29uT3ZlcnJpZGUoKTtcclxuICAgIH1cclxuICAgIFRoZW1lLnByb3RvdHlwZS5wcm9jZXNzSWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldEljb25PdmVycmlkZSh0aGlzLm9wdGlvbnNNYW5hZ2VyLmdldCh0aGlzLmljb25PdmVycmlkZU9wdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuc2V0SWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICB2YXIgaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgIHZhciBidXR0b25OYW1lO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoaWNvbk92ZXJyaWRlSGFzaCkpIHtcclxuICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gJC5leHRlbmQoe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5pY29uT3ZlcnJpZGVQcmVmaXg7XHJcbiAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlc1trZXldIHx8ICcnO1xyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRJY29uQ2xhc3MgPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xyXG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArICcgJyArIGNsYXNzTmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MgPSBmdW5jdGlvbiAoY3VzdG9tQnV0dG9uUHJvcHMpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XHJcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyAnICcgKyB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaGVtZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGhlbWU7XHJcblRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge307XHJcblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9O1xyXG5UaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xyXG5UaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJyc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG4vKlxyXG5FbWJvZGllcyBhIGRpdiB0aGF0IGhhcyBwb3RlbnRpYWwgc2Nyb2xsYmFyc1xyXG4qL1xyXG52YXIgU2Nyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTY3JvbGxlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNjcm9sbGVyKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIF90aGlzLm92ZXJmbG93WCA9IG9wdGlvbnMub3ZlcmZsb3dYIHx8IG9wdGlvbnMub3ZlcmZsb3cgfHwgJ2F1dG8nO1xyXG4gICAgICAgIF90aGlzLm92ZXJmbG93WSA9IG9wdGlvbnMub3ZlcmZsb3dZIHx8IG9wdGlvbnMub3ZlcmZsb3cgfHwgJ2F1dG8nO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMucmVuZGVyRWwoKTtcclxuICAgICAgICB0aGlzLmFwcGx5T3ZlcmZsb3coKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUucmVuZGVyRWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNjcm9sbEVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXNjcm9sbGVyXCI+PC9kaXY+JykpO1xyXG4gICAgfTtcclxuICAgIC8vIHNldHMgdG8gbmF0dXJhbCBoZWlnaHQsIHVubG9ja3Mgb3ZlcmZsb3dcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNldEhlaWdodCgnYXV0bycpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlPdmVyZmxvdygpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gT3ZlcmZsb3dcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuYXBwbHlPdmVyZmxvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbEVsLmNzcyh7XHJcbiAgICAgICAgICAgICdvdmVyZmxvdy14JzogdGhpcy5vdmVyZmxvd1gsXHJcbiAgICAgICAgICAgICdvdmVyZmxvdy15JzogdGhpcy5vdmVyZmxvd1lcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDYXVzZXMgYW55ICdhdXRvJyBvdmVyZmxvdyB2YWx1ZXMgdG8gcmVzb2x2ZXMgdG8gJ3Njcm9sbCcgb3IgJ2hpZGRlbicuXHJcbiAgICAvLyBVc2VmdWwgZm9yIHByZXNlcnZpbmcgc2Nyb2xsYmFyIHdpZHRocyByZWdhcmRsZXNzIG9mIGZ1dHVyZSByZXNpemVzLlxyXG4gICAgLy8gQ2FuIHBhc3MgaW4gc2Nyb2xsYmFyV2lkdGhzIGZvciBvcHRpbWl6YXRpb24uXHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUubG9ja092ZXJmbG93ID0gZnVuY3Rpb24gKHNjcm9sbGJhcldpZHRocykge1xyXG4gICAgICAgIHZhciBvdmVyZmxvd1ggPSB0aGlzLm92ZXJmbG93WDtcclxuICAgICAgICB2YXIgb3ZlcmZsb3dZID0gdGhpcy5vdmVyZmxvd1k7XHJcbiAgICAgICAgc2Nyb2xsYmFyV2lkdGhzID0gc2Nyb2xsYmFyV2lkdGhzIHx8IHRoaXMuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgaWYgKG92ZXJmbG93WCA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WCA9IChzY3JvbGxiYXJXaWR0aHMudG9wIHx8IHNjcm9sbGJhcldpZHRocy5ib3R0b20gfHwgLy8gaG9yaXpvbnRhbCBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgLy8gT1Igc2Nyb2xsaW5nIHBhbmUgd2l0aCBtYXNzbGVzcyBzY3JvbGxiYXJzP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbFswXS5zY3JvbGxXaWR0aCAtIDEgPiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudFdpZHRoKSA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdmVyZmxvd1kgPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICBvdmVyZmxvd1kgPSAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0IHx8IC8vIHZlcnRpY2FsIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICAvLyBPUiBzY3JvbGxpbmcgcGFuZSB3aXRoIG1hc3NsZXNzIHNjcm9sbGJhcnM/XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsWzBdLnNjcm9sbEhlaWdodCAtIDEgPiB0aGlzLnNjcm9sbEVsWzBdLmNsaWVudEhlaWdodCkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbEVsLmNzcyh7ICdvdmVyZmxvdy14Jzogb3ZlcmZsb3dYLCAnb3ZlcmZsb3cteSc6IG92ZXJmbG93WSB9KTtcclxuICAgIH07XHJcbiAgICAvLyBHZXR0ZXJzIC8gU2V0dGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5oZWlnaHQoaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCgpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AodG9wKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50V2lkdGg7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldENsaWVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRIZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbGJhcldpZHRocyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbF8xLmdldFNjcm9sbGJhcldpZHRocyh0aGlzLnNjcm9sbEVsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2Nyb2xsZXI7XHJcbn0oQ2xhc3NfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbGVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIERhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQoX3ZpZXcsIF9vcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgX3ZpZXcsIF9vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIHNlbGYtY29uZmlnLCBvdmVycmlkYWJsZSBieSBzdWJjbGFzc2VzXHJcbiAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgPSAnLmZjLWV2ZW50LWNvbnRhaW5lciA+IConOyAvLyB3aGF0IGNvbnN0aXR1dGVzIGFuIGV2ZW50IGVsZW1lbnQ/XHJcbiAgICAgICAgaWYgKF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRlQ2xpY2tpbmcgPSBuZXcgX3RoaXMuZGF0ZUNsaWNraW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmRhdGVTZWxlY3RpbmcgPSBuZXcgX3RoaXMuZGF0ZVNlbGVjdGluZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmV2ZW50UG9pbnRpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFBvaW50aW5nID0gbmV3IF90aGlzLmV2ZW50UG9pbnRpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudERyYWdnaW5nQ2xhc3MgJiYgX3RoaXMuZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudERyYWdnaW5nID0gbmV3IF90aGlzLmV2ZW50RHJhZ2dpbmdDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRQb2ludGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudFJlc2l6aW5nQ2xhc3MgJiYgX3RoaXMuZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgICAgICBfdGhpcy5ldmVudFJlc2l6aW5nID0gbmV3IF90aGlzLmV2ZW50UmVzaXppbmdDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRQb2ludGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5leHRlcm5hbERyb3BwaW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXh0ZXJuYWxEcm9wcGluZyA9IG5ldyBfdGhpcy5leHRlcm5hbERyb3BwaW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTZXRzIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSB2aWV3IHNob3VsZCByZW5kZXIgaW5zaWRlIG9mLCBkb2VzIGdsb2JhbCBET00tcmVsYXRlZCBpbml0aWFsaXphdGlvbnMsXHJcbiAgICAvLyBhbmQgcmVuZGVycyBhbGwgdGhlIG5vbi1kYXRlLXJlbGF0ZWQgY29udGVudCBpbnNpZGUuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEVsZW1lbnQuY2FsbCh0aGlzLCBlbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZUNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZUNsaWNraW5nLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlbGVjdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVTZWxlY3RpbmcuYmluZFRvRWwoZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwoZWwpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEludGVyYWN0aW9ucygpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbnMoKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbERyb3BwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEcm9wcGluZy5iaW5kVG9Eb2N1bWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbERyb3BwaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEcm9wcGluZy51bmJpbmRGcm9tRG9jdW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRGF0ZUhhbmRsZXJUb0VsID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIHRoZSBncmlkJ3Mgcm9vdCBlbGVtZW50LlxyXG4gICAgICAgIC8vIGpRdWVyeSB3aWxsIHRha2UgY2FyZSBvZiB1bnJlZ2lzdGVyaW5nIHRoZW0gd2hlbiByZW1vdmVFbGVtZW50IGdldHMgY2FsbGVkLlxyXG4gICAgICAgIHRoaXMuZWwub24obmFtZSwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghJChldi50YXJnZXQpLmlzKF90aGlzLnNlZ1NlbGVjdG9yICsgJywnICsgLy8gZGlyZWN0bHkgb24gYW4gZXZlbnQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgKyAnICosJyArIC8vIHdpdGhpbiBhbiBldmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAnLmZjLW1vcmUsJyArIC8vIGEgXCJtb3JlLi5cIiBsaW5rXHJcbiAgICAgICAgICAgICAgICAnYVtkYXRhLWdvdG9dJyAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKF90aGlzLCBldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRQb2ludGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudERyYWdnaW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVzaXppbmdcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW50ZXJhY3Rpb24uYmluZFRvRWwoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kU2VnSGFuZGxlclRvRWwgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGVsLm9uKG5hbWUsIHRoaXMuc2VnU2VsZWN0b3IsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgc2VnID0gJChldi5jdXJyZW50VGFyZ2V0KS5kYXRhKCdmYy1zZWcnKTsgLy8gZ3JhYiBzZWdtZW50IGRhdGEuIHB1dCB0aGVyZSBieSBWaWV3OjpyZW5kZXJFdmVudHNQYXlsb2FkXHJcbiAgICAgICAgICAgIGlmIChzZWcgJiYgIV90aGlzLnNob3VsZElnbm9yZUV2ZW50UG9pbnRpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChfdGhpcywgc2VnLCBldik7IC8vIGNvbnRleHQgd2lsbCBiZSB0aGUgR3JpZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRJZ25vcmVNb3VzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBIQUNLXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIHN0aWxsIHdvcmsgZXZlbiB0aG91Z2ggYmluZERhdGVIYW5kbGVyVG9FbCBkb2Vzbid0IHVzZSBHbG9iYWxFbWl0dGVyLlxyXG4gICAgICAgIHJldHVybiBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkSWdub3JlVG91Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgLy8gT24gaU9TIChhbmQgQW5kcm9pZD8pIHdoZW4gYSBuZXcgc2VsZWN0aW9uIGlzIGluaXRpYXRlZCBvdmVydG9wIGFub3RoZXIgc2VsZWN0aW9uLFxyXG4gICAgICAgIC8vIHRoZSB0b3VjaGVuZCBuZXZlciBmaXJlcyBiZWNhdXNlIHRoZSBlbGVtZW50cyBnZXRzIHJlbW92ZWQgbWlkLXRvdWNoLWludGVyYWN0aW9uIChteSB0aGVvcnkpLlxyXG4gICAgICAgIC8vIEhBQ0s6IHNpbXBseSBkb24ndCBhbGxvdyB0aGlzIHRvIGhhcHBlbi5cclxuICAgICAgICAvLyBBTFNPOiBwcmV2ZW50IHNlbGVjdGlvbiB3aGVuIGFuICpldmVudCogaXMgYWxyZWFkeSByYWlzZWQuXHJcbiAgICAgICAgcmV0dXJuIHZpZXcuaXNTZWxlY3RlZCB8fCB2aWV3LnNlbGVjdGVkRXZlbnQ7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRJZ25vcmVFdmVudFBvaW50aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIG9ubHkgY2FsbCB0aGUgaGFuZGxlcnMgaWYgdGhlcmUgaXMgbm90IGEgZHJhZy9yZXNpemUgaW4gcHJvZ3Jlc3NcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnREcmFnZ2luZyAmJiB0aGlzLmV2ZW50RHJhZ2dpbmcuaXNEcmFnZ2luZykgfHxcclxuICAgICAgICAgICAgKHRoaXMuZXZlbnRSZXNpemluZyAmJiB0aGlzLmV2ZW50UmVzaXppbmcuaXNSZXNpemluZyk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYW5TdGFydFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRFdklzVG91Y2goZXYpICYmXHJcbiAgICAgICAgICAgICF0aGlzLmNhblN0YXJ0UmVzaXplKHNlZywgZXYpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmlzRXZlbnREZWZEcmFnZ2FibGUoc2VnLmZvb3RwcmludC5ldmVudERlZikgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYW5TdGFydERyYWcgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5jYW5TdGFydFJlc2l6ZShzZWcsIGV2KSAmJlxyXG4gICAgICAgICAgICB0aGlzLmlzRXZlbnREZWZEcmFnZ2FibGUoc2VnLmZvb3RwcmludC5ldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYW5TdGFydFJlc2l6ZSA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICByZXR1cm4gKCF1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KSB8fCB2aWV3LmlzRXZlbnREZWZTZWxlY3RlZChldmVudERlZikpICYmXHJcbiAgICAgICAgICAgIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShldmVudERlZikgJiZcclxuICAgICAgICAgICAgJChldi50YXJnZXQpLmlzKCcuZmMtcmVzaXplcicpO1xyXG4gICAgfTtcclxuICAgIC8vIEtpbGxzIGFsbCBpbi1wcm9ncmVzcyBkcmFnZ2luZy5cclxuICAgIC8vIFVzZWZ1bCBmb3Igd2hlbiBwdWJsaWMgQVBJIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gcmUtcmVuZGVyaW5nIGFyZSBpbnZva2VkIGR1cmluZyBhIGRyYWcuXHJcbiAgICAvLyBBbHNvIHVzZWZ1bCBmb3Igd2hlbiB0b3VjaCBkZXZpY2VzIG1pc2JlaGF2ZSBhbmQgZG9uJ3QgZmlyZSB0aGVpciB0b3VjaGVuZC5cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZW5kSW50ZXJhY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgdGhpcy5kYXRlQ2xpY2tpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVNlbGVjdGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudFBvaW50aW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RHJhZ2dpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZXNpemluZ1xyXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5lbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERyYWctbi1Ecm9wXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIGRyYWdnZWQgYnkgdGhlIHVzZXJcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZkRyYWdnYWJsZSA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRXZlbnREZWZTdGFydEVkaXRhYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZTdGFydEVkaXRhYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGlzRWRpdGFibGUgPSBldmVudERlZi5pc1N0YXJ0RXhwbGljaXRseUVkaXRhYmxlKCk7XHJcbiAgICAgICAgaWYgKGlzRWRpdGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc0VkaXRhYmxlID0gdGhpcy5vcHQoJ2V2ZW50U3RhcnRFZGl0YWJsZScpO1xyXG4gICAgICAgICAgICBpZiAoaXNFZGl0YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpc0VkaXRhYmxlID0gdGhpcy5pc0V2ZW50RGVmR2VuZXJhbGx5RWRpdGFibGUoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0VkaXRhYmxlO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZkdlbmVyYWxseUVkaXRhYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGlzRWRpdGFibGUgPSBldmVudERlZi5pc0V4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc0VkaXRhYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNFZGl0YWJsZSA9IHRoaXMub3B0KCdlZGl0YWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZXNpemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGZyb20gaXRzIHN0YXJ0aW5nIGVkZ2VcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydCA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnZXZlbnRSZXNpemFibGVGcm9tU3RhcnQnKSAmJiB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgZnJvbSBpdHMgZW5kaW5nIGVkZ2VcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKGV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYWxsb3dlZCB0byBiZSByZXNpemVkIGJ5IHRoZSB1c2VyIGF0IGFsbFxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmUmVzaXphYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlID0gZXZlbnREZWYuaXNEdXJhdGlvbkV4cGxpY2l0bHlFZGl0YWJsZSgpO1xyXG4gICAgICAgIGlmIChpc1Jlc2l6YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzUmVzaXphYmxlID0gdGhpcy5vcHQoJ2V2ZW50RHVyYXRpb25FZGl0YWJsZScpO1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaXNSZXNpemFibGUgPSB0aGlzLmlzRXZlbnREZWZHZW5lcmFsbHlFZGl0YWJsZShldmVudERlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzUmVzaXphYmxlO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IE11dGF0aW9uIC8gQ29uc3RyYWludHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gRGlmZnMgdGhlIHR3byBkYXRlcywgcmV0dXJuaW5nIGEgZHVyYXRpb24sIGJhc2VkIG9uIGdyYW51bGFyaXR5IG9mIHRoZSBncmlkXHJcbiAgICAvLyBUT0RPOiBwb3J0IGlzVGltZVNjYWxlIGludG8gdGhpcyBzeXN0ZW0/XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmRpZmZEYXRlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFyZ2VVbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkJ5VW5pdChhLCBiLCB0aGlzLmxhcmdlVW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZEYXlUaW1lKGEsIGIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBpcyBpdCBhbGxvd2VkLCBpbiByZWxhdGlvbiB0byB0aGUgdmlldydzIHZhbGlkUmFuZ2U/XHJcbiAgICAvLyBOT1RFOiB2ZXJ5IHNpbWlsYXIgdG8gaXNFeHRlcm5hbEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEFsbEV2ZW50UmFuZ2VzKCkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gVE9ETzoganVzdCB1c2UgZ2V0QWxsRXZlbnRSYW5nZXMgZGlyZWN0bHlcclxuICAgICAgICAgICAgaWYgKCFkYXRlUHJvZmlsZS52YWxpZFVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3LmNhbGVuZGFyLmNvbnN0cmFpbnRzLmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZChldmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgfTtcclxuICAgIC8vIE5PVEU6IHZlcnkgc2ltaWxhciB0byBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgIC8vIHdoZW4gaXQncyBhIGNvbXBsZXRlbHkgYW5vbnltb3VzIGV4dGVybmFsIGRyYWcsIG5vIGV2ZW50LlxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9nZXRWaWV3KCk7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5nZXRBbGxFdmVudFJhbmdlcygpKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghZGF0ZVByb2ZpbGUudmFsaWRVbnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRyZWF0IGl0IGFzIGEgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE86IHBhc3MgaW4gZXZlbnRJbnN0YW5jZUdyb3VwIGluc3RlYWRcclxuICAgICAgICAgICAgLy8gIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBjYWxlbmRhcidzIGNvbnN0cmFpbnQgc3lzdGVtIHRvIGRlcGVuZCBvbiBhIGNvbXBvbmVudCdzXHJcbiAgICAgICAgICAgIC8vICBkZXRlcm1pbmF0aW9uIG9mIGZvb3RwcmludHMuXHJcbiAgICAgICAgICAgIGlmICghdmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50O1xyXG59KERhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudDtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgUmVuZGVyUXVldWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIG90aGVyIHZpZXdzIGluaGVyaXQgZnJvbVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCB2aWV3U3BlYy5vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmJhdGNoUmVuZGVyRGVwdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gYm9vbGVhbiB3aGV0aGVyIGEgcmFuZ2Ugb2YgdGltZSBpcyB1c2VyLXNlbGVjdGVkIG9yIG5vdFxyXG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMudmlld1NwZWMgPSB2aWV3U3BlYztcclxuICAgICAgICAvLyBzaG9ydGN1dHNcclxuICAgICAgICBfdGhpcy50eXBlID0gdmlld1NwZWMudHlwZTtcclxuICAgICAgICAvLyAubmFtZSBpcyBkZXByZWNhdGVkXHJcbiAgICAgICAgX3RoaXMubmFtZSA9IF90aGlzLnR5cGU7XHJcbiAgICAgICAgX3RoaXMuaW5pdFJlbmRlclF1ZXVlKCk7XHJcbiAgICAgICAgX3RoaXMuaW5pdEhpZGRlbkRheXMoKTtcclxuICAgICAgICBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvciA9IG5ldyBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5iaW5kQmFzZVJlbmRlckhhbmRsZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRPcmRlclNwZWNzID0gdXRpbF8xLnBhcnNlRmllbGRTcGVjcyhfdGhpcy5vcHQoJ2V2ZW50T3JkZXInKSk7XHJcbiAgICAgICAgLy8gbGVnYWN5XHJcbiAgICAgICAgaWYgKF90aGlzWydpbml0aWFsaXplJ10pIHtcclxuICAgICAgICAgICAgX3RoaXNbJ2luaXRpYWxpemUnXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBWaWV3LnByb3RvdHlwZS5fZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYW4gb3B0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgIFZpZXcucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICAvKiBSZW5kZXIgUXVldWVcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pbml0UmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZSA9IG5ldyBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBldmVudDogdGhpcy5vcHQoJ2V2ZW50UmVuZGVyV2FpdCcpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5vbignc3RhcnQnLCB0aGlzLm9uUmVuZGVyUXVldWVTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uKCdzdG9wJywgdGhpcy5vblJlbmRlclF1ZXVlU3RvcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6Y2hhbmdlJywgdGhpcy5zdGFydEJhdGNoUmVuZGVyKTtcclxuICAgICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnN0b3BCYXRjaFJlbmRlcik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKHRoaXMucXVlcnlTY3JvbGwoKSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXIudXBkYXRlVmlld1NpemUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RhcnRCYXRjaFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmJhdGNoUmVuZGVyRGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdG9wQmF0Y2hSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmJhdGNoUmVuZGVyRGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RSZW5kZXIgPSBmdW5jdGlvbiAoZnVuYywgbmFtZXNwYWNlLCBhY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5xdWV1ZShmdW5jLCBuYW1lc3BhY2UsIGFjdGlvblR5cGUpO1xyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGZ1bmMgd2lsbCBhdXRvLWJpbmQgdG8gYHRoaXNgXHJcbiAgICBWaWV3LnByb3RvdHlwZS53aGVuU2l6ZVVwZGF0ZWQgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclF1ZXVlLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uZSgnc3RvcCcsIGZ1bmMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFRpdGxlIGFuZCBEYXRlIEZvcm1hdHRpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZVRpdGxlID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZTtcclxuICAgICAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UmFuZ2Uoe1xyXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jYWxlbmRhci5tc1RvTW9tZW50KHVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KSxcclxuICAgICAgICAgICAgZW5kOiB0aGlzLmNhbGVuZGFyLm1zVG9Nb21lbnQodW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KVxyXG4gICAgICAgIH0sIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksIHRoaXMub3B0KCd0aXRsZUZvcm1hdCcpIHx8IHRoaXMuY29tcHV0ZVRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSwgdGhpcy5vcHQoJ3RpdGxlUmFuZ2VTZXBhcmF0b3InKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxyXG4gICAgLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cclxuICAgIFZpZXcucHJvdG90eXBlLmNvbXB1dGVUaXRsZUZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UmFuZ2VVbml0ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdDtcclxuICAgICAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PSAneWVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdZWVlZJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudFJhbmdlVW5pdCA9PSAnbW9udGgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdCgnbW9udGhZZWFyRm9ybWF0Jyk7IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2UuYXMoJ2RheXMnKSA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdsbCc7IC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0xMJzsgLy8gb25lIGRheS4gbG9uZ2VyLCBsaWtlIFwiU2VwdGVtYmVyIDkgMjAxNFwiXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIERhdGUgU2V0dGluZy9VbnNldHRpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZXREYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgY3VycmVudERhdGVQcm9maWxlID0gdGhpcy5nZXQoJ2RhdGVQcm9maWxlJyk7XHJcbiAgICAgICAgdmFyIG5ld0RhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChkYXRlLCB1bmRlZmluZWQsIHRydWUpOyAvLyBmb3JjZVRvVmFsaWQ9dHJ1ZVxyXG4gICAgICAgIGlmICghY3VycmVudERhdGVQcm9maWxlIHx8XHJcbiAgICAgICAgICAgICFjdXJyZW50RGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmVxdWFscyhuZXdEYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0KCdkYXRlUHJvZmlsZScsIG5ld0RhdGVQcm9maWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2RhdGVQcm9maWxlJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgRGF0YVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLmZldGNoSW5pdGlhbEV2ZW50cyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGZvcmNlQWxsRGF5ID0gZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSAmJiAhdGhpcy51c2VzTWluTWF4VGltZTtcclxuICAgICAgICByZXR1cm4gY2FsZW5kYXIucmVxdWVzdEV2ZW50cyhjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5zdGFydE1zLCBmb3JjZUFsbERheSksIGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmVuZE1zLCBmb3JjZUFsbERheSkpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmJpbmRFdmVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNhbGVuZGFyLCAnZXZlbnRzUmVzZXQnLCB0aGlzLnJlc2V0RXZlbnRzKTsgLy8gVE9ETzogbWFrZSB0aGlzIGEgcmVhbCBldmVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnVuYmluZEV2ZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbyh0aGlzLmNhbGVuZGFyLCAnZXZlbnRzUmVzZXQnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZXRFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHRoaXMuc2V0KCdjdXJyZW50RXZlbnRzJywgZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgdGhpcy5zZXQoJ2hhc0V2ZW50cycsIHRydWUpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnVuc2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2N1cnJlbnRFdmVudHMnKTtcclxuICAgICAgICB0aGlzLnVuc2V0KCdoYXNFdmVudHMnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydEJhdGNoUmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy51bnNldEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuc2V0RXZlbnRzKGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoUmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZSBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3REYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5leGVjdXRlRGF0ZVJlbmRlcihkYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgfSwgJ2RhdGUnLCAnaW5pdCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3REYXRlVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5leGVjdXRlRGF0ZVVucmVuZGVyKCk7XHJcbiAgICAgICAgfSwgJ2RhdGUnLCAnZGVzdHJveScpO1xyXG4gICAgfTtcclxuICAgIC8vIGlmIGRhdGVQcm9maWxlIG5vdCBzcGVjaWZpZWQsIHVzZXMgY3VycmVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyLmNhbGwodGhpcywgZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIGlmICh0aGlzWydyZW5kZXInXSkge1xyXG4gICAgICAgICAgICB0aGlzWydyZW5kZXInXSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRlc1JlbmRlcmVkJyk7XHJcbiAgICAgICAgdGhpcy5hZGRTY3JvbGwoeyBpc0RhdGVJbml0OiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuc3RhcnROb3dJbmRpY2F0b3IoKTsgLy8gc2hvdWxkbid0IHJlbmRlciB5ZXQgYmVjYXVzZSB1cGRhdGVTaXplIHdpbGwgYmUgY2FsbGVkIHNvb25cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICB0aGlzLnN0b3BOb3dJbmRpY2F0b3IoKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZTpkYXRlc1VucmVuZGVyZWQnKTtcclxuICAgICAgICBpZiAodGhpc1snZGVzdHJveSddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ2Rlc3Ryb3knXSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRGF0ZVVucmVuZGVyLmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gXCJCYXNlXCIgcmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEJhc2VSZW5kZXJIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMub24oJ2RhdGVzUmVuZGVyZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLndoZW5TaXplVXBkYXRlZChfdGhpcy50cmlnZ2VyVmlld1JlbmRlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vbignYmVmb3JlOmRhdGVzVW5yZW5kZXJlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMudHJpZ2dlclZpZXdEZXN0cm95KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlclZpZXdSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdSZW5kZXInLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCB0aGlzLmVsXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJWaWV3RGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld0Rlc3Ryb3knLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFt0aGlzLCB0aGlzLmVsXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEhpZ2gtbGV2ZWwgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEV2ZW50c1JlbmRlciA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5leGVjdXRlRXZlbnRSZW5kZXIoZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgICAgIF90aGlzLndoZW5TaXplVXBkYXRlZChfdGhpcy50cmlnZ2VyQWZ0ZXJFdmVudHNSZW5kZXJlZCk7XHJcbiAgICAgICAgfSwgJ2V2ZW50JywgJ2luaXQnKTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyQmVmb3JlRXZlbnRzRGVzdHJveWVkKCk7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVFdmVudFVucmVuZGVyKCk7XHJcbiAgICAgICAgfSwgJ2V2ZW50JywgJ2Rlc3Ryb3knKTtcclxuICAgIH07XHJcbiAgICAvLyBCdXNpbmVzcyBIb3VyIEhpZ2gtbGV2ZWwgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEJ1c2luZXNzSG91cnNSZW5kZXIgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJCdXNpbmVzc0hvdXJzKGJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbiAgICAgICAgfSwgJ2J1c2luZXNzSG91cnMnLCAnaW5pdCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RCdXNpbmVzc0hvdXJzVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy51bnJlbmRlckJ1c2luZXNzSG91cnMoKTtcclxuICAgICAgICB9LCAnYnVzaW5lc3NIb3VycycsICdkZXN0cm95Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gTWlzYyB2aWV3IHJlbmRlcmluZyB1dGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIEJpbmRzIERPTSBoYW5kbGVycyB0byBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lciwgc3VjaCBhcyB0aGUgZG9jdW1lbnRcclxuICAgIFZpZXcucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJpbmRHbG9iYWxIYW5kbGVycy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMubGlzdGVuVG8oR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCksIHtcclxuICAgICAgICAgICAgdG91Y2hzdGFydDogdGhpcy5wcm9jZXNzVW5zZWxlY3QsXHJcbiAgICAgICAgICAgIG1vdXNlZG93bjogdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNlZG93blxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFVuYmluZHMgRE9NIGhhbmRsZXJzIGZyb20gZWxlbWVudHMgdGhhdCByZXNpZGUgb3V0c2lkZSB0aGUgdmlldyBjb250YWluZXJcclxuICAgIFZpZXcucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbyhHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKSk7XHJcbiAgICB9O1xyXG4gICAgLyogTm93IEluZGljYXRvclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEltbWVkaWF0ZWx5IHJlbmRlciB0aGUgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgYmVnaW5zIHJlLXJlbmRlcmluZyBpdCBhdCBhbiBpbnRlcnZhbCxcclxuICAgIC8vIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhpcy5nZXROb3dJbmRpY2F0b3JVbml0KCkuXHJcbiAgICAvLyBUT0RPOiBzb21laG93IGRvIHRoaXMgZm9yIHRoZSBjdXJyZW50IHdob2xlIGRheSdzIGJhY2tncm91bmQgdG9vXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdGFydE5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1bml0O1xyXG4gICAgICAgIHZhciB1cGRhdGU7XHJcbiAgICAgICAgdmFyIGRlbGF5OyAvLyBtcyB3YWl0IHZhbHVlXHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdub3dJbmRpY2F0b3InKSkge1xyXG4gICAgICAgICAgICB1bml0ID0gdGhpcy5nZXROb3dJbmRpY2F0b3JVbml0KCk7XHJcbiAgICAgICAgICAgIGlmICh1bml0KSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUgPSB1dGlsXzEucHJveHkodGhpcywgJ3VwZGF0ZU5vd0luZGljYXRvcicpOyAvLyBiaW5kIHRvIGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93RGF0ZSA9IHRoaXMuY2FsZW5kYXIuZ2V0Tm93KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSArbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHdhaXQgdW50aWwgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgZGVsYXkgPSB0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuc3RhcnRPZih1bml0KS5hZGQoMSwgdW5pdCkgLSB0aGlzLmluaXRpYWxOb3dEYXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ID0gK21vbWVudC5kdXJhdGlvbigxLCB1bml0KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9IE1hdGgubWF4KDEwMCwgZGVsYXkpOyAvLyBwcmV2ZW50IHRvbyBmcmVxdWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGUsIGRlbGF5KTsgLy8gdXBkYXRlIGV2ZXJ5IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVuZGVyaW5nIHdpbGwgYmUgaW5pdGlhdGVkIGluIHVwZGF0ZVNpemVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gcmVyZW5kZXJzIHRoZSBub3cgaW5kaWNhdG9yLCBjb21wdXRpbmcgdGhlIG5ldyBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgcGFzc2VkXHJcbiAgICAvLyBzaW5jZSB0aGUgaW5pdGlhbCBnZXROb3cgY2FsbC5cclxuICAgIFZpZXcucHJvdG90eXBlLnVwZGF0ZU5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93RGF0ZSAvLyBhY3RpdmF0ZWQgYmVmb3JlP1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICB0aGlzLnVucmVuZGVyTm93SW5kaWNhdG9yKCk7IC8vIHdvbid0IHVucmVuZGVyIGlmIHVubmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5hZGQobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMpIC8vIGFkZCBtc1xyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBJbW1lZGlhdGVseSB1bnJlbmRlcnMgdGhlIHZpZXcncyBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBzdG9wcyBhbnkgcmUtcmVuZGVyaW5nIHRpbWVycy5cclxuICAgIC8vIFdvbid0IGNhdXNlIHNpZGUgZWZmZWN0cyBpZiBpbmRpY2F0b3IgaXNuJ3QgcmVuZGVyZWQuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdG9wTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JUaW1lb3V0SUQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpO1xyXG4gICAgICAgICAgICB0aGlzLmlzTm93SW5kaWNhdG9yUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogRGltZW5zaW9uc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICBpZiAodGhpc1snc2V0SGVpZ2h0J10pIHtcclxuICAgICAgICAgICAgdGhpc1snc2V0SGVpZ2h0J10odG90YWxIZWlnaHQsIGlzQXV0byk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlTm93SW5kaWNhdG9yKCk7XHJcbiAgICB9O1xyXG4gICAgLyogU2Nyb2xsZXJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5hZGRTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgdmFyIHF1ZXVlZFNjcm9sbCA9IHRoaXMucXVldWVkU2Nyb2xsIHx8ICh0aGlzLnF1ZXVlZFNjcm9sbCA9IHt9KTtcclxuICAgICAgICAkLmV4dGVuZChxdWV1ZWRTY3JvbGwsIHNjcm9sbCk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucG9wU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYXBwbHlRdWV1ZWRTY3JvbGwoKTtcclxuICAgICAgICB0aGlzLnF1ZXVlZFNjcm9sbCA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYXBwbHlRdWV1ZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucXVldWVkU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlTY3JvbGwodGhpcy5xdWV1ZWRTY3JvbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5xdWVyeVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHNjcm9sbCwgdGhpcy5xdWVyeURhdGVTY3JvbGwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY3JvbGw7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYXBwbHlTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbC5pc0RhdGVJbml0ICYmIHRoaXMuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHNjcm9sbCwgdGhpcy5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5RGF0ZVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHt9OyAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIChzY3JvbGwpIHtcclxuICAgICAgICA7IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBEcmFnLW4tRHJvcFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydEV2ZW50RHJvcCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBldmVudE11dGF0aW9uLCBlbCwgZXYpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5jYWxlbmRhci5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHVuZG9GdW5jID0gZXZlbnRNYW5hZ2VyLm11dGF0ZUV2ZW50c1dpdGhJZChldmVudEluc3RhbmNlLmRlZi5pZCwgZXZlbnRNdXRhdGlvbiwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbiA9IGV2ZW50TXV0YXRpb24uZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgRXZlbnRJbnN0YW5jZSwgZm9yIGhhbmRsZXJzXHJcbiAgICAgICAgaWYgKGRhdGVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlLmRhdGVQcm9maWxlID0gZGF0ZU11dGF0aW9uLmJ1aWxkTmV3RGF0ZVByb2ZpbGUoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50RHJvcChldmVudEluc3RhbmNlLCBcclxuICAgICAgICAvLyBhIGRyb3AgZG9lc24ndCBuZWNlc3NhcmlseSBtZWFuIGEgZGF0ZSBtdXRhdGlvbiAoZXg6IHJlc291cmNlIGNoYW5nZSlcclxuICAgICAgICAoZGF0ZU11dGF0aW9uICYmIGRhdGVNdXRhdGlvbi5kYXRlRGVsdGEpIHx8IG1vbWVudC5kdXJhdGlvbigpLCB1bmRvRnVuYywgZWwsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBldmVudC1kcm9wIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXZlbnREcm9wID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGRhdGVEZWx0YSwgdW5kb0Z1bmMsIGVsLCBldikge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudERyb3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlLnRvTGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICBkYXRlRGVsdGEsXHJcbiAgICAgICAgICAgICAgICB1bmRvRnVuYyxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKiBFeHRlcm5hbCBFbGVtZW50IERyYWctbi1Ecm9wXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50LCB2aWEgalF1ZXJ5IFVJLCBoYXMgYmVlbiBkcm9wcGVkIG9udG8gdGhlIGNhbGVuZGFyLlxyXG4gICAgLy8gYG1ldGFgIGlzIHRoZSBwYXJzZWQgZGF0YSB0aGF0IGhhcyBiZWVuIGVtYmVkZGVkIGludG8gdGhlIGRyYWdnaW5nIGV2ZW50LlxyXG4gICAgLy8gYGRyb3BMb2NhdGlvbmAgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB6b25lZCBzdGFydC9lbmQvYWxsRGF5IHZhbHVlcyBmb3IgdGhlIGV2ZW50LlxyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXh0ZXJuYWxEcm9wID0gZnVuY3Rpb24gKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBpc1N0aWNreSwgZWwsIGV2LCB1aSkge1xyXG4gICAgICAgIGlmIChpc0V2ZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50RGVmKHNpbmdsZUV2ZW50RGVmLCBpc1N0aWNreSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlckV4dGVybmFsRHJvcChzaW5nbGVFdmVudERlZiwgaXNFdmVudCwgZWwsIGV2LCB1aSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgZXh0ZXJuYWwtZHJvcCBoYW5kbGVycyB0aGF0IGhhdmUgc3Vic2NyaWJlZCB2aWEgdGhlIEFQSVxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChzaW5nbGVFdmVudERlZiwgaXNFdmVudCwgZWwsIGV2LCB1aSkge1xyXG4gICAgICAgIC8vIHRyaWdnZXIgJ2Ryb3AnIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBlbGVtZW50IHJlcHJlc2VudHMgYW4gZXZlbnRcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZHJvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmLmRhdGVQcm9maWxlLnN0YXJ0LmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICBldixcclxuICAgICAgICAgICAgICAgIHVpLFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzRXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gc2lnbmFsIGFuIGV4dGVybmFsIGV2ZW50IGxhbmRlZFxyXG4gICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZWNlaXZlJywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZi5idWlsZEluc3RhbmNlKCkudG9MZWdhY3koKSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBSZXNpemluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIE11c3QgYmUgY2FsbGVkIHdoZW4gYW4gZXZlbnQgaW4gdGhlIHZpZXcgaGFzIGJlZW4gcmVzaXplZCB0byBhIG5ldyBsZW5ndGhcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydEV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGV2ZW50TXV0YXRpb24sIGVsLCBldikge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgdW5kb0Z1bmMgPSBldmVudE1hbmFnZXIubXV0YXRlRXZlbnRzV2l0aElkKGV2ZW50SW5zdGFuY2UuZGVmLmlkLCBldmVudE11dGF0aW9uLCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICAvLyB1cGRhdGUgdGhlIEV2ZW50SW5zdGFuY2UsIGZvciBoYW5kbGVyc1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUgPSBldmVudE11dGF0aW9uLmRhdGVNdXRhdGlvbi5idWlsZE5ld0RhdGVQcm9maWxlKGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUsIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50UmVzaXplKGV2ZW50SW5zdGFuY2UsIGV2ZW50TXV0YXRpb24uZGF0ZU11dGF0aW9uLmVuZERlbHRhLCB1bmRvRnVuYywgZWwsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBldmVudC1yZXNpemUgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBkdXJhdGlvbkRlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBlbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25EZWx0YSxcclxuICAgICAgICAgICAgICAgIHVuZG9GdW5jLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIFNlbGVjdGlvbiAodGltZSByYW5nZSlcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBTZWxlY3RzIGEgZGF0ZSBzcGFuIG9uIHRoZSB2aWV3LiBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgYm90aCBNb21lbnRzLlxyXG4gICAgLy8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnaW4gdGhlIGludGVyYWN0aW9uLlxyXG4gICAgVmlldy5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZXYpIHtcclxuICAgICAgICB0aGlzLnVuc2VsZWN0KGV2KTtcclxuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChmb290cHJpbnQpO1xyXG4gICAgICAgIHRoaXMucmVwb3J0U2VsZWN0aW9uKGZvb3RwcmludCwgZXYpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChmb290cHJpbnQpIHtcclxuICAgICAgICBpZiAodGhpc1sncmVuZGVyU2VsZWN0aW9uJ10pIHtcclxuICAgICAgICAgICAgdGhpc1sncmVuZGVyU2VsZWN0aW9uJ10oZm9vdHByaW50LnRvTGVnYWN5KHRoaXMuY2FsZW5kYXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50LmNhbGwodGhpcywgZm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBuZXcgc2VsZWN0aW9uIGlzIG1hZGUuIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzLlxyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZXYpIHtcclxuICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlclNlbGVjdChmb290cHJpbnQsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBoYW5kbGVycyB0byAnc2VsZWN0J1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlclNlbGVjdCA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGV2KSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5jYWxlbmRhci5mb290cHJpbnRUb0RhdGVQcm9maWxlKGZvb3RwcmludCk7IC8vIGFidXNlIG9mIFwiRXZlbnRcIkRhdGVQcm9maWxlP1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdzZWxlY3QnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUuZW5kLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBVbmRvZXMgYSBzZWxlY3Rpb24uIHVwZGF0ZXMgaW4gdGhlIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cclxuICAgIC8vIGBldmAgaXMgdGhlIG5hdGl2ZSBtb3VzZSBldmVudCB0aGF0IGJlZ2FuIHRoZSBpbnRlcmFjdGlvbi5cclxuICAgIFZpZXcucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKGV2ID09PSB2b2lkIDApIHsgZXYgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXNbJ2Rlc3Ryb3lTZWxlY3Rpb24nXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpc1snZGVzdHJveVNlbGVjdGlvbiddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5yZW5kZXJTZWxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtldiwgdGhpc11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFZpZXcucHJvdG90eXBlLnNlbGVjdEV2ZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgfHxcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgIT09IGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdEV2ZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZm9vdHByaW50LmV2ZW50SW5zdGFuY2UgPT09IGV2ZW50SW5zdGFuY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZWwgLy8gbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsLmFkZENsYXNzKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNlbGVjdEV2ZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5pc0V2ZW50RGVmU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAvLyBldmVudCByZWZlcmVuY2VzIG1pZ2h0IGNoYW5nZSBvbiByZWZldGNoRXZlbnRzKCksIHdoaWxlIHNlbGVjdGVkRXZlbnRJbnN0YW5jZSBkb2Vzbid0LFxyXG4gICAgICAgIC8vIHNvIGNvbXBhcmUgSURzXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlICYmIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlLmRlZi5pZCA9PT0gZXZlbnREZWYuaWQ7XHJcbiAgICB9O1xyXG4gICAgLyogTW91c2UgLyBUb3VjaCBVbnNlbGVjdGluZyAodGltZSByYW5nZSAmIGV2ZW50IHVuc2VsZWN0aW9uKVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFRPRE86IG1vdmUgY29uc2lzdGVudGx5IHRvIGRvd24vc3RhcnQgb3IgdXAvZW5kP1xyXG4gICAgLy8gVE9ETzogZG9uJ3Qga2lsbCBwcmV2aW91cyBzZWxlY3Rpb24gaWYgdG91Y2ggc2Nyb2xsaW5nXHJcbiAgICBWaWV3LnByb3RvdHlwZS5oYW5kbGVEb2N1bWVudE1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh1dGlsXzEuaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Vuc2VsZWN0KGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucHJvY2Vzc1Vuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmFuZ2VVbnNlbGVjdChldik7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzRXZlbnRVbnNlbGVjdChldik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucHJvY2Vzc1JhbmdlVW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgaWdub3JlO1xyXG4gICAgICAgIC8vIGlzIHRoZXJlIGEgdGltZS1yYW5nZSBzZWxlY3Rpb24/XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLm9wdCgndW5zZWxlY3RBdXRvJykpIHtcclxuICAgICAgICAgICAgLy8gb25seSB1bnNlbGVjdCBpZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIG5vdCBpZGVudGljYWwgdG8gb3IgaW5zaWRlIG9mIGFuICd1bnNlbGVjdENhbmNlbCcgZWxlbWVudFxyXG4gICAgICAgICAgICBpZ25vcmUgPSB0aGlzLm9wdCgndW5zZWxlY3RDYW5jZWwnKTtcclxuICAgICAgICAgICAgaWYgKCFpZ25vcmUgfHwgISQoZXYudGFyZ2V0KS5jbG9zZXN0KGlnbm9yZSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0KGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5wcm9jZXNzRXZlbnRVbnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoISQoZXYudGFyZ2V0KS5jbG9zZXN0KCcuZmMtc2VsZWN0ZWQnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3RFdmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogVHJpZ2dlcnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyQmFzZVJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyQmFzZVVucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdEZXN0cm95Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBoYW5kbGVycyB0byAnZGF5Q2xpY2snXHJcbiAgICAvLyBTcGFuIGhhcyBzdGFydC9lbmQgb2YgdGhlIGNsaWNrZWQgYXJlYS4gT25seSB0aGUgc3RhcnQgaXMgdXNlZnVsLlxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckRheUNsaWNrID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZGF5RWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5jYWxlbmRhci5mb290cHJpbnRUb0RhdGVQcm9maWxlKGZvb3RwcmludCk7IC8vIGFidXNlIG9mIFwiRXZlbnRcIkRhdGVQcm9maWxlP1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXlDbGljaycsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZGF5RWwsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtkYXRlUHJvZmlsZS5zdGFydCwgZXYsIHRoaXNdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBVdGlsc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEZvciBEYXRlQ29tcG9uZW50OjpnZXREYXlDbGFzc2VzXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pc0RhdGVJbk90aGVyTW9udGggPSBmdW5jdGlvbiAoZGF0ZSwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gQXJndW1lbnRzIGFmdGVyIG5hbWUgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYSBoeXBvdGhldGljYWwgZnVuY3Rpb24gdmFsdWVcclxuICAgIC8vIFdBUk5JTkc6IHBhc3NlZC1pbiBhcmd1bWVudHMgd2lsbCBiZSBnaXZlbiB0byBnZW5lcmF0b3IgZnVuY3Rpb25zIGFzLWlzIGFuZCBjYW4gY2F1c2Ugc2lkZS1lZmZlY3RzLlxyXG4gICAgLy8gQWx3YXlzIGNsb25lIHlvdXIgb2JqZWN0cyBpZiB5b3UgZmVhciBtdXRhdGlvbi5cclxuICAgIFZpZXcucHJvdG90eXBlLmdldFVuem9uZWRSYW5nZU9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMub3B0KG5hbWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhci5wYXJzZVVuem9uZWRSYW5nZSh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBIaWRkZW4gRGF5c1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEluaXRpYWxpemVzIGludGVybmFsIHZhcmlhYmxlcyByZWxhdGVkIHRvIGNhbGN1bGF0aW5nIGhpZGRlbiBkYXlzLW9mLXdlZWtcclxuICAgIFZpZXcucHJvdG90eXBlLmluaXRIaWRkZW5EYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoaWRkZW5EYXlzID0gdGhpcy5vcHQoJ2hpZGRlbkRheXMnKSB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cclxuICAgICAgICB2YXIgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcclxuICAgICAgICB2YXIgZGF5Q250ID0gMDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ3dlZWtlbmRzJykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSAkLmluQXJyYXkoaSwgaGlkZGVuRGF5cykgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5Q250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkYXlDbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgaGlkZGVuRGF5cyc7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXHJcbiAgICAvLyBJZiB0aGUgd2hvbGUgcmFuZ2UgaXMgdHJpbW1lZCBvZmYsIHJldHVybnMgbnVsbFxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAoaW5wdXRVbnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBpbnB1dFVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBlbmQgPSBpbnB1dFVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICBpZiAoc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cclxuICAgIC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgTW9tZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5pc0hpZGRlbkRheSA9IGZ1bmN0aW9uIChkYXkpIHtcclxuICAgICAgICBpZiAobW9tZW50LmlzTW9tZW50KGRheSkpIHtcclxuICAgICAgICAgICAgZGF5ID0gZGF5LmRheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcclxuICAgIH07XHJcbiAgICAvLyBJbmNyZW1lbnRpbmcgdGhlIGN1cnJlbnQgZGF5IHVudGlsIGl0IGlzIG5vIGxvbmdlciBhIGhpZGRlbiBkYXksIHJldHVybmluZyBhIGNvcHkuXHJcbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFVuem9uZWRSYW5nZSFcclxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXHJcbiAgICAvLyBgaW5jYCBkZWZhdWx0cyB0byBgMWAgKGluY3JlbWVudCBvbmUgZGF5IGZvcndhcmQgZWFjaCB0aW1lKVxyXG4gICAgVmlldy5wcm90b3R5cGUuc2tpcEhpZGRlbkRheXMgPSBmdW5jdGlvbiAoZGF0ZSwgaW5jLCBpc0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIGlmIChpbmMgPT09IHZvaWQgMCkgeyBpbmMgPSAxOyB9XHJcbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlID09PSB2b2lkIDApIHsgaXNFeGNsdXNpdmUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBvdXQgPSBkYXRlLmNsb25lKCk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNIaWRkZW5EYXlIYXNoWyhvdXQuZGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcclxuICAgICAgICAgICAgb3V0LmFkZChpbmMsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZpZXc7XHJcbn0oSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBWaWV3O1xyXG5WaWV3LnByb3RvdHlwZS51c2VzTWluTWF4VGltZSA9IGZhbHNlO1xyXG5WaWV3LnByb3RvdHlwZS5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG5WaWV3LndhdGNoKCdkaXNwbGF5aW5nRGF0ZXMnLCBbJ2lzSW5Eb20nLCAnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHRoaXMucmVxdWVzdERhdGVSZW5kZXIoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdERhdGVVbnJlbmRlcigpO1xyXG59KTtcclxuVmlldy53YXRjaCgnZGlzcGxheWluZ0J1c2luZXNzSG91cnMnLCBbJ2Rpc3BsYXlpbmdEYXRlcycsICdidXNpbmVzc0hvdXJHZW5lcmF0b3InXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHRoaXMucmVxdWVzdEJ1c2luZXNzSG91cnNSZW5kZXIoZGVwcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RCdXNpbmVzc0hvdXJzVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2luaXRpYWxFdmVudHMnLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5mZXRjaEluaXRpYWxFdmVudHMoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdiaW5kaW5nRXZlbnRzJywgWydpbml0aWFsRXZlbnRzJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICB0aGlzLnNldEV2ZW50cyhkZXBzLmluaXRpYWxFdmVudHMpO1xyXG4gICAgdGhpcy5iaW5kRXZlbnRDaGFuZ2VzKCk7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMudW5iaW5kRXZlbnRDaGFuZ2VzKCk7XHJcbiAgICB0aGlzLnVuc2V0RXZlbnRzKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdkaXNwbGF5aW5nRXZlbnRzJywgWydkaXNwbGF5aW5nRGF0ZXMnLCAnaGFzRXZlbnRzJ10sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdEV2ZW50c1JlbmRlcih0aGlzLmdldCgnY3VycmVudEV2ZW50cycpKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0RXZlbnRzVW5yZW5kZXIoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ3RpdGxlJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgcmV0dXJuICh0aGlzLnRpdGxlID0gdGhpcy5jb21wdXRlVGl0bGUoZGVwcy5kYXRlUHJvZmlsZSkpOyAvLyBhc3NpZ24gdG8gVmlldyBmb3IgbGVnYWN5IHJlYXNvbnNcclxufSk7XHJcblZpZXcud2F0Y2goJ2xlZ2FjeURhdGVQcm9wcycsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICB2YXIgZGF0ZVByb2ZpbGUgPSBkZXBzLmRhdGVQcm9maWxlO1xyXG4gICAgLy8gREVQUkVDQVRFRCwgYnV0IHdlIG5lZWQgdG8ga2VlcCBpdCB1cGRhdGVkLi4uXHJcbiAgICB0aGlzLnN0YXJ0ID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbiAgICB0aGlzLmVuZCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxuICAgIHRoaXMuaW50ZXJ2YWxTdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxuICAgIHRoaXMuaW50ZXJ2YWxFbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2UuZW5kTXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG59KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UmVuZGVyZXIoY29tcG9uZW50LCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBjb21wb25lbnQuX2dldFZpZXcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZpbGxSZW5kZXJlciA9IGZpbGxSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB2YWx1ZXMgdGhhdCByZWx5IG9uIG9wdGlvbnMgYW5kIGFsc28gcmVsYXRlIHRvIHJhbmdlXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yYW5nZVVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlFdmVudFRpbWU7XHJcbiAgICAgICAgdmFyIGRpc3BsYXlFdmVudEVuZDtcclxuICAgICAgICB0aGlzLmV2ZW50VGltZUZvcm1hdCA9XHJcbiAgICAgICAgICAgIHRoaXMub3B0KCdldmVudFRpbWVGb3JtYXQnKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHQoJ3RpbWVGb3JtYXQnKSB8fCAvLyBkZXByZWNhdGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQoKTtcclxuICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gdGhpcy5vcHQoJ2Rpc3BsYXlFdmVudFRpbWUnKTtcclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSB0aGlzLmNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSB0aGlzLm9wdCgnZGlzcGxheUV2ZW50RW5kJyk7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudEVuZCgpOyAvLyBtaWdodCBiZSBiYXNlZCBvZmYgb2YgcmFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwbGF5RXZlbnRUaW1lID0gZGlzcGxheUV2ZW50VGltZTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlFdmVudEVuZCA9IGRpc3BsYXlFdmVudEVuZDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY29tcG9uZW50Ll9nZXREYXRlUHJvZmlsZSgpO1xyXG4gICAgICAgIHZhciBldmVudERlZklkO1xyXG4gICAgICAgIHZhciBpbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgIHZhciBldmVudFJhbmdlcztcclxuICAgICAgICB2YXIgYmdSYW5nZXMgPSBbXTtcclxuICAgICAgICB2YXIgZmdSYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGV2ZW50RGVmSWQgaW4gZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZUdyb3VwID0gZXZlbnRzUGF5bG9hZFtldmVudERlZklkXTtcclxuICAgICAgICAgICAgZXZlbnRSYW5nZXMgPSBpbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCkuaGFzQmdSZW5kZXJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaC5hcHBseShiZ1JhbmdlcywgZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmdSYW5nZXMucHVzaC5hcHBseShmZ1JhbmdlcywgZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyQmdSYW5nZXMoYmdSYW5nZXMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRmdSYW5nZXMoZmdSYW5nZXMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJCZ1JhbmdlcygpO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJGZ1JhbmdlcygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnQuZXZlbnRGb290cHJpbnRzVG9TZWdzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgLy8gcmVuZGVyIGFuIGAuZWxgIG9uIGVhY2ggc2VnXHJcbiAgICAgICAgLy8gcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgc2Vncy4gc2VncyB0aGF0IHdlcmUgYWN0dWFsbHkgcmVuZGVyZWRcclxuICAgICAgICBzZWdzID0gdGhpcy5yZW5kZXJGZ1NlZ0VscyhzZWdzKTtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJGZ1NlZ3Moc2VncykgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmdTZWdzID0gc2VncztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJGZ1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyRmdTZWdzKHRoaXMuZmdTZWdzIHx8IFtdKTtcclxuICAgICAgICB0aGlzLmZnU2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmdSYW5nZXMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5jb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudC5ldmVudEZvb3RwcmludHNUb1NlZ3MoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5yZW5kZXJCZ1NlZ3Moc2VncykgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmdTZWdzID0gc2VncztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJCZ1JhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQmdTZWdzKCk7XHJcbiAgICAgICAgdGhpcy5iZ1NlZ3MgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJnU2VncyB8fCBbXSkuY29uY2F0KHRoaXMuZmdTZWdzIHx8IFtdKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudHMgb250byB0aGUgZ3JpZFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICAgICAgLy8gc2VncyBhbHJlYWR5IGhhcyByZW5kZXJlZCBlbHMsIGFuZCBoYXMgYmVlbiBmaWx0ZXJlZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHNpZ25hbCBmYWlsdXJlIGlmIG5vdCBpbXBsZW1lbnRlZFxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbGwgY3VycmVudGx5IHJlbmRlcmVkIGZvcmVncm91bmQgc2VnbWVudHNcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmZpbGxSZW5kZXJlci5yZW5kZXJTZWdzKCdiZ0V2ZW50Jywgc2Vncywge1xyXG4gICAgICAgICAgICAgICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRCZ0NsYXNzZXMoc2VnLmZvb3RwcmludC5ldmVudERlZik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0Q3NzOiBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBfdGhpcy5nZXRCZ0NvbG9yKHNlZy5mb290cHJpbnQuZXZlbnREZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJFbDogZnVuY3Rpb24gKHNlZywgZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZmlsdGVyRXZlbnRSZW5kZXJFbChzZWcuZm9vdHByaW50LCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzaWduYWwgZmFpbHVyZSBpZiBubyBmaWxsUmVuZGVyZXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJCZ1NlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdiZ0V2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ0VscyA9IGZ1bmN0aW9uIChzZWdzLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChkaXNhYmxlUmVzaXppbmcgPT09IHZvaWQgMCkgeyBkaXNhYmxlUmVzaXppbmcgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBoYXNFdmVudFJlbmRlckhhbmRsZXJzID0gdGhpcy52aWV3Lmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudFJlbmRlcicpO1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkU2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBidWlsZCBhIGxhcmdlIGNvbmNhdGVuYXRpb24gb2YgZXZlbnQgc2VnbWVudCBIVE1MXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJlZm9yZUZnU2VnSHRtbChzZWdzW2ldKTtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5mZ1NlZ0h0bWwoc2Vnc1tpXSwgZGlzYWJsZVJlc2l6aW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHcmFiIGluZGl2aWR1YWwgZWxlbWVudHMgZnJvbSB0aGUgY29tYmluZWQgSFRNTCBzdHJpbmcuIFVzZSBlYWNoIGFzIHRoZSBkZWZhdWx0IHJlbmRlcmluZy5cclxuICAgICAgICAgICAgLy8gVGhlbiwgY29tcHV0ZSB0aGUgJ2VsJyBmb3IgZWFjaCBzZWdtZW50LiBBbiBlbCBtaWdodCBiZSBudWxsIGlmIHRoZSBldmVudFJlbmRlciBjYWxsYmFjayByZXR1cm5lZCBmYWxzZS5cclxuICAgICAgICAgICAgJChodG1sKS5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXZlbnRSZW5kZXJIYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gX3RoaXMuZmlsdGVyRXZlbnRSZW5kZXJFbChzZWcuZm9vdHByaW50LCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdmYy1zZWcnLCBzZWcpOyAvLyB1c2VkIGJ5IGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZFNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYmVmb3JlRmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LiBVc2VkIGJ5IHJlbmRlckZnU2VnRWxzKClcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyaWMgdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB0aGUgSFRNTCBjbGFzc05hbWVzIGZvciBhbiBldmVudCBzZWdtZW50J3MgZWxlbWVudFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2VnQ2xhc3NlcyA9IGZ1bmN0aW9uIChzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZSkge1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gW1xyXG4gICAgICAgICAgICAnZmMtZXZlbnQnLFxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCA/ICdmYy1zdGFydCcgOiAnZmMtbm90LXN0YXJ0JyxcclxuICAgICAgICAgICAgc2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcclxuICAgICAgICBdLmNvbmNhdCh0aGlzLmdldENsYXNzZXMoc2VnLmZvb3RwcmludC5ldmVudERlZikpO1xyXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWRyYWdnYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZXNpemFibGUpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1yZXNpemFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXZlbnQgaXMgY3VycmVudGx5IHNlbGVjdGVkPyBhdHRhY2ggYSBjbGFzc05hbWUuXHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBldmVudCBhbmQgdGhlIGRlZmF1bHQgZWxlbWVudCB1c2VkIGZvciByZW5kZXJpbmcsIHJldHVybnMgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYWN0dWFsbHkgYmUgdXNlZC5cclxuICAgIC8vIEJhc2ljYWxseSBydW5zIGV2ZW50cyBhbmQgZWxlbWVudHMgdGhyb3VnaCB0aGUgZXZlbnRSZW5kZXIgaG9vay5cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZpbHRlckV2ZW50UmVuZGVyRWwgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnQsIGVsKSB7XHJcbiAgICAgICAgdmFyIGxlZ2FjeSA9IGV2ZW50Rm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgdmFyIGN1c3RvbSA9IHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIGVsLCB0aGlzLnZpZXddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGN1c3RvbSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdXN0b20gJiYgY3VzdG9tICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGVsID0gJChjdXN0b20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZSB0aGUgdGV4dCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgb24gYW4gZXZlbnQncyBlbGVtZW50LlxyXG4gICAgLy8gYHJhbmdlYCBjYW4gYmUgdGhlIEV2ZW50IG9iamVjdCBpdHNlbGYsIG9yIHNvbWV0aGluZyByYW5nZS1saWtlLCB3aXRoIGF0IGxlYXN0IGEgYHN0YXJ0YC5cclxuICAgIC8vIElmIGV2ZW50IHRpbWVzIGFyZSBkaXNhYmxlZCwgb3IgdGhlIGV2ZW50IGhhcyBubyB0aW1lLCB3aWxsIHJldHVybiBhIGJsYW5rIHN0cmluZy5cclxuICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGZvcm1hdFN0ciB3aWxsIGRlZmF1bHQgdG8gdGhlIGV2ZW50VGltZUZvcm1hdCBzZXR0aW5nLFxyXG4gICAgLy8gYW5kIGRpc3BsYXlFbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBkaXNwbGF5RXZlbnRFbmQgc2V0dGluZy5cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFRpbWVUZXh0ID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50LCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGltZVRleHQoZXZlbnRGb290cHJpbnQuZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS5zdGFydCwgZXZlbnRGb290cHJpbnQuZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZS5lbmQsIGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0VGltZVRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgaXNBbGxEYXksIGZvcm1hdFN0ciwgZGlzcGxheUVuZCkge1xyXG4gICAgICAgIGlmIChmb3JtYXRTdHIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3JtYXRTdHIgPSB0aGlzLmV2ZW50VGltZUZvcm1hdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFbmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RW5kID0gdGhpcy5kaXNwbGF5RXZlbnRFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlFdmVudFRpbWUgJiYgIWlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5RW5kICYmIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5mb3JtYXRSYW5nZSh7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSwgZmFsc2UsIC8vIGFsbERheVxyXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydC5mb3JtYXQoZm9ybWF0U3RyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ3NtYWxsVGltZUZvcm1hdCcpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0QmdDbGFzc2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLmdldENsYXNzZXMoZXZlbnREZWYpO1xyXG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtYmdldmVudCcpO1xyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldENsYXNzZXMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzLCBvYmpzW2ldLmV2ZW50Q2xhc3NOYW1lIHx8IG9ianNbaV0uY2xhc3NOYW1lIHx8IFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBldmVudCBza2luLXJlbGF0ZWQgQ1NTIHByb3BlcnRpZXNcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFNraW5Dc3MgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMuZ2V0QmdDb2xvcihldmVudERlZiksXHJcbiAgICAgICAgICAgICdib3JkZXItY29sb3InOiB0aGlzLmdldEJvcmRlckNvbG9yKGV2ZW50RGVmKSxcclxuICAgICAgICAgICAgY29sb3I6IHRoaXMuZ2V0VGV4dENvbG9yKGV2ZW50RGVmKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gUXVlcmllcyBmb3IgY2FsbGVyLXNwZWNpZmllZCBjb2xvciwgdGhlbiBmYWxscyBiYWNrIHRvIGRlZmF1bHRcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldEJnQ29sb3IgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoICYmICF2YWw7IGkrKykge1xyXG4gICAgICAgICAgICB2YWwgPSBvYmpzW2ldLmV2ZW50QmFja2dyb3VuZENvbG9yIHx8IG9ianNbaV0uZXZlbnRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS5iYWNrZ3JvdW5kQ29sb3IgfHwgb2Jqc1tpXS5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF2YWwpIHtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5vcHQoJ2V2ZW50QmFja2dyb3VuZENvbG9yJykgfHwgdGhpcy5vcHQoJ2V2ZW50Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICAvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0Qm9yZGVyQ29sb3IgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoICYmICF2YWw7IGkrKykge1xyXG4gICAgICAgICAgICB2YWwgPSBvYmpzW2ldLmV2ZW50Qm9yZGVyQ29sb3IgfHwgb2Jqc1tpXS5ldmVudENvbG9yIHx8XHJcbiAgICAgICAgICAgICAgICBvYmpzW2ldLmJvcmRlckNvbG9yIHx8IG9ianNbaV0uY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudEJvcmRlckNvbG9yJykgfHwgdGhpcy5vcHQoJ2V2ZW50Q29sb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcbiAgICAvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGV4dENvbG9yID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldFN0eWxpbmdPYmpzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aCAmJiAhdmFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFsID0gb2Jqc1tpXS5ldmVudFRleHRDb2xvciB8fFxyXG4gICAgICAgICAgICAgICAgb2Jqc1tpXS50ZXh0Q29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0KCdldmVudFRleHRDb2xvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmdldFN0eWxpbmdPYmpzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9ianMgPSB0aGlzLmdldEZhbGxiYWNrU3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIG9ianMudW5zaGlmdChldmVudERlZik7XHJcbiAgICAgICAgcmV0dXJuIG9ianM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tTdHlsaW5nT2JqcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiBbZXZlbnREZWYuc291cmNlXTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0RXZlbnRTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBzZWdzLnNvcnQodXRpbF8xLnByb3h5KHRoaXMsICdjb21wYXJlRXZlbnRTZWdzJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBzZWdtZW50cyBzaG91bGQgdGFrZSB2aXN1YWwgcHJpb3JpdHlcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXBhcmVFdmVudFNlZ3MgPSBmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xyXG4gICAgICAgIHZhciBmMSA9IHNlZzEuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgcjEgPSBmMS51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGYyID0gc2VnMi5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHZhciByMiA9IGYyLnVuem9uZWRSYW5nZTtcclxuICAgICAgICByZXR1cm4gcjEuc3RhcnRNcyAtIHIyLnN0YXJ0TXMgfHwgLy8gZWFybGllciBldmVudHMgZ28gZmlyc3RcclxuICAgICAgICAgICAgKHIyLmVuZE1zIC0gcjIuc3RhcnRNcykgLSAocjEuZW5kTXMgLSByMS5zdGFydE1zKSB8fCAvLyB0aWU/IGxvbmdlciBldmVudHMgZ28gZmlyc3RcclxuICAgICAgICAgICAgZjIuaXNBbGxEYXkgLSBmMS5pc0FsbERheSB8fCAvLyB0aWU/IHB1dCBhbGwtZGF5IGV2ZW50cyBmaXJzdCAoYm9vbGVhbnMgY2FzdCB0byAwLzEpXHJcbiAgICAgICAgICAgIHV0aWxfMS5jb21wYXJlQnlGaWVsZFNwZWNzKHNlZzEuZm9vdHByaW50LmV2ZW50RGVmLCBzZWcyLmZvb3RwcmludC5ldmVudERlZiwgdGhpcy52aWV3LmV2ZW50T3JkZXJTcGVjcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9kZWwsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNb2RlbCgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl93YXRjaGVycyA9IHt9O1xyXG4gICAgICAgIF90aGlzLl9wcm9wcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLmFwcGx5R2xvYmFsV2F0Y2hlcnMoKTtcclxuICAgICAgICBfdGhpcy5jb25zdHJ1Y3RlZCgpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIHVzZWZ1bCBmb3IgbW9ua2V5cGF0Y2hpbmcuIFRPRE86IEJhc2VDbGFzcz9cclxuICAgIE1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuYXBwbHlHbG9iYWxXYXRjaGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fZ2xvYmFsV2F0Y2hBcmdzO1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBtYXApIHtcclxuICAgICAgICAgICAgdGhpcy53YXRjaC5hcHBseSh0aGlzLCBbbmFtZV0uY29uY2F0KG1hcFtuYW1lXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmFtZSBpbiB0aGlzLl9wcm9wcztcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzW25hbWVdO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcbiAgICAgICAgdmFyIG5ld1Byb3BzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmV3UHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgbmV3UHJvcHNbbmFtZV0gPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdQcm9wcyA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJvcHMobmV3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChuZXdQcm9wcykge1xyXG4gICAgICAgIHZhciBvbGRQcm9wcyA9IHRoaXMuX3Byb3BzO1xyXG4gICAgICAgIHZhciBjaGFuZ2VzZXQgPSB7fTsgLy8gd2lsbCBoYXZlIHVuZGVmaW5lZCdzIHRvIHNpZ25hbCB1bnNldHNcclxuICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgY2hhbmdlc2V0W25hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKG5hbWUgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgY2hhbmdlc2V0W25hbWVdID0gbmV3UHJvcHNbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJvcHMoY2hhbmdlc2V0KTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBuYW1lcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5hbWVzID0gW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbmFtZXMgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbmV3UHJvcHNbbmFtZXNbaV1dID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFByb3BzKG5ld1Byb3BzKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbiAobmV3UHJvcHMpIHtcclxuICAgICAgICB2YXIgY2hhbmdlZFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIGNoYW5nZWRDbnQgPSAwO1xyXG4gICAgICAgIHZhciBuYW1lLCB2YWw7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG5ld1Byb3BzW25hbWVdO1xyXG4gICAgICAgICAgICAvLyBhIGNoYW5nZSBpbiB2YWx1ZT9cclxuICAgICAgICAgICAgLy8gaWYgYW4gb2JqZWN0LCBkb24ndCBjaGVjayBlcXVhbGl0eSwgYmVjYXVzZSBtaWdodCBoYXZlIGJlZW4gbXV0YXRlZCBpbnRlcm5hbGx5LlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBldmVudHVhbGx5IGVuZm9yY2UgaW1tdXRhYmlsaXR5LlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgIHZhbCAhPT0gdGhpcy5fcHJvcHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRQcm9wc1tuYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlZENudCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZTpiYXRjaENoYW5nZScsIGNoYW5nZWRQcm9wcyk7XHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBjaGFuZ2VkUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGNoYW5nZWRQcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmNoYW5nZScsIG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZTpjaGFuZ2U6JyArIG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChuYW1lIGluIGNoYW5nZWRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gY2hhbmdlZFByb3BzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Byb3BzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JhdGNoQ2hhbmdlJywgY2hhbmdlZFByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKG5hbWUsIGRlcExpc3QsIHN0YXJ0RnVuYywgc3RvcEZ1bmMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMudW53YXRjaChuYW1lKTtcclxuICAgICAgICB0aGlzLl93YXRjaGVyc1tuYW1lXSA9IHRoaXMuX3dhdGNoRGVwcyhkZXBMaXN0LCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gc3RhcnRGdW5jLmNhbGwoX3RoaXMsIGRlcHMpO1xyXG4gICAgICAgICAgICBpZiAocmVzICYmIHJlcy50aGVuKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51bnNldChuYW1lKTsgLy8gcHV0IGluIGFuIHVuc2V0IHN0YXRlIHdoaWxlIHJlc29sdmluZ1xyXG4gICAgICAgICAgICAgICAgcmVzLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldChuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXQobmFtZSwgcmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVuc2V0KG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoc3RvcEZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIHN0b3BGdW5jLmNhbGwoX3RoaXMsIGRlcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnVud2F0Y2ggPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlcnNbbmFtZV07XHJcbiAgICAgICAgaWYgKHdhdGNoZXIpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dhdGNoZXJzW25hbWVdO1xyXG4gICAgICAgICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5fd2F0Y2hEZXBzID0gZnVuY3Rpb24gKGRlcExpc3QsIHN0YXJ0RnVuYywgc3RvcEZ1bmMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBxdWV1ZWRDaGFuZ2VDbnQgPSAwO1xyXG4gICAgICAgIHZhciBkZXBDbnQgPSBkZXBMaXN0Lmxlbmd0aDtcclxuICAgICAgICB2YXIgc2F0aXNmeUNudCA9IDA7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9OyAvLyB3aGF0J3MgcGFzc2VkIGFzIHRoZSBgZGVwc2AgYXJndW1lbnRzXHJcbiAgICAgICAgdmFyIGJpbmRUdXBsZXMgPSBbXTsgLy8gYXJyYXkgb2YgWyBldmVudE5hbWUsIGhhbmRsZXJGdW5jIF0gYXJyYXlzXHJcbiAgICAgICAgdmFyIGlzQ2FsbGluZ1N0b3AgPSBmYWxzZTtcclxuICAgICAgICB2YXIgb25CZWZvcmVEZXBDaGFuZ2UgPSBmdW5jdGlvbiAoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlZENoYW5nZUNudCsrO1xyXG4gICAgICAgICAgICBpZiAocXVldWVkQ2hhbmdlQ250ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2F0aXNmeUNudCA9PT0gZGVwQ250KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDYWxsaW5nU3RvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEZ1bmModmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICBpc0NhbGxpbmdTdG9wID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBvbkRlcENoYW5nZSA9IGZ1bmN0aW9uIChkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBkZXBlbmRlbmN5IHRoYXQgd2FzIHByZXZpb3VzbHkgc2V0P1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09wdGlvbmFsICYmIHZhbHVlc1tkZXBOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F0aXNmeUNudC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlc1tkZXBOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGRlcGVuZGVuY3kgdGhhdCB3YXMgcHJldmlvdXNseSB1bnNldD9cclxuICAgICAgICAgICAgICAgIGlmICghaXNPcHRpb25hbCAmJiB2YWx1ZXNbZGVwTmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdGlzZnlDbnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhbHVlc1tkZXBOYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBxdWV1ZWRDaGFuZ2VDbnQtLTtcclxuICAgICAgICAgICAgaWYgKCFxdWV1ZWRDaGFuZ2VDbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vdyBmaW5hbGx5IHNhdGlzZmllZCBvciBzYXRpc2ZpZWQgYWxsIGFsb25nP1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdG9wRnVuYyBpbml0aWF0ZWQgYW5vdGhlciB2YWx1ZSBjaGFuZ2UsIGlnbm9yZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBhbm90aGVyIGNoYW5nZSBldmVudCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhbGxpbmdTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gaW50ZXJjZXB0IGZvciAub24oKSB0aGF0IHJlbWVtYmVycyBoYW5kbGVyc1xyXG4gICAgICAgIHZhciBiaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBiaW5kVHVwbGVzLnB1c2goW2V2ZW50TmFtZSwgaGFuZGxlcl0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbGlzdGVuIHRvIGRlcGVuZGVuY3kgY2hhbmdlc1xyXG4gICAgICAgIGRlcExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVwTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZGVwTmFtZS5jaGFyQXQoMCkgPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IGRlcE5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmluZCgnYmVmb3JlOmNoYW5nZTonICsgZGVwTmFtZSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgb25CZWZvcmVEZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJpbmQoJ2NoYW5nZTonICsgZGVwTmFtZSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgb25EZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcHJvY2VzcyBjdXJyZW50IGRlcGVuZGVuY3kgdmFsdWVzXHJcbiAgICAgICAgZGVwTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXBOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChkZXBOYW1lLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gZGVwTmFtZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFzKGRlcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbZGVwTmFtZV0gPSBfdGhpcy5nZXQoZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBzYXRpc2Z5Q250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gaW5pdGlhbGx5IHNhdGlzZmllZFxyXG4gICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgc3RhcnRGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRUdXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYoYmluZFR1cGxlc1tpXVswXSwgYmluZFR1cGxlc1tpXVsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiaW5kVHVwbGVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIHdhcyBzYXRpc2ZpZWQsIHNvIGNhbGwgc3RvcEZ1bmNcclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbGFzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGdW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5mbGFzaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICB3YXRjaGVyLmZsYXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLndhdGNoID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIG1ha2UgYSBtYXNrZWQtY29weSBvZiB0aGUgc3VwZXJjbGFzcydzIG1hcFxyXG4gICAgICAgIC8vIFRPRE86IHdyaXRlIHRlc3RcclxuICAgICAgICBpZiAoIXRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdfZ2xvYmFsV2F0Y2hBcmdzJykpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm90b3R5cGUuX2dsb2JhbFdhdGNoQXJncyA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuX2dsb2JhbFdhdGNoQXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3NbbmFtZV0gPSBhcmdzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2RlbDtcclxufShDbGFzc18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9kZWw7XHJcbk1vZGVsLnByb3RvdHlwZS5fZ2xvYmFsV2F0Y2hBcmdzID0ge307IC8vIG11dGF0aW9uIHByb3RlY3Rpb24gaW4gTW9kZWwud2F0Y2hcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKE1vZGVsKTtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhNb2RlbCk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgUmVjdXJyaW5nRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSB7XHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKGV2ZW50SW5wdXQsIHNvdXJjZSkge1xyXG4gICAgICAgIGlmICh1dGlsXzEuaXNUaW1lU3RyaW5nKGV2ZW50SW5wdXQuc3RhcnQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGV2ZW50SW5wdXQuc3RhcnQpIHx8XHJcbiAgICAgICAgICAgIHV0aWxfMS5pc1RpbWVTdHJpbmcoZXZlbnRJbnB1dC5lbmQpIHx8IG1vbWVudC5pc0R1cmF0aW9uKGV2ZW50SW5wdXQuZW5kKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQXJyYXlFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFycmF5RXZlbnRTb3VyY2UoY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhcikgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5ldmVudERlZnMgPSBbXTsgLy8gZm9yIGlmIHNldFJhd0V2ZW50RGVmcyBpcyBuZXZlciBjYWxsZWRcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5zZXRSYXdFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdGhpcy5yYXdFdmVudERlZnMgPSByYXdFdmVudERlZnM7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMgPSB0aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcyk7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gdGhpcy5ldmVudERlZnM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFRpbWV6b25lICE9IG51bGwgJiZcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZXpvbmUgIT09IHRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudERlZnNbaV0gaW5zdGFuY2VvZiBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudERlZnNbaV0ucmV6b25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZXpvbmUgPSB0aW1lem9uZTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZShldmVudERlZnMpO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMucHVzaChldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGV2ZW50RGVmSWQgYWxyZWFkeSBub3JtYWxpemVkIHRvIGEgc3RyaW5nXHJcbiAgICAqL1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5yZW1vdmVNYXRjaGluZyh0aGlzLmV2ZW50RGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudERlZi5pZCA9PT0gZXZlbnREZWZJZDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnMgPSBbXTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3RXZlbnREZWZzO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB0aGlzLnNldFJhd0V2ZW50RGVmcyhyYXdQcm9wcy5ldmVudHMpO1xyXG4gICAgICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgcmF3UHJvcHM7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIHJhdyBpbnB1dFxyXG4gICAgICAgIGlmICgkLmlzQXJyYXkocmF3SW5wdXQuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHJhd0lucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkocmF3SW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0geyBldmVudHM6IHJhd0lucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRTb3VyY2VfMS5kZWZhdWx0LnBhcnNlLmNhbGwodGhpcywgcmF3UHJvcHMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBcnJheUV2ZW50U291cmNlO1xyXG59KEV2ZW50U291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBcnJheUV2ZW50U291cmNlO1xyXG5BcnJheUV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgZXZlbnRzOiBmYWxzZSAvLyBkb24ndCBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVmRGF0ZU11dGF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJFbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlVGltZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlQWxsRGF5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgcmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLnByb3RvdHlwZS5idWlsZE5ld0RhdGVQcm9maWxlID0gZnVuY3Rpb24gKGV2ZW50RGF0ZVByb2ZpbGUsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXZlbnREYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIHZhciBzaG91bGRSZXpvbmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZXZlbnREYXRlUHJvZmlsZS5lbmQgJiYgIXRoaXMuY2xlYXJFbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gZXZlbnREYXRlUHJvZmlsZS5lbmQuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmREZWx0YSAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChldmVudERhdGVQcm9maWxlLmlzQWxsRGF5KCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VUaW1lZCkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmICFlbmQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgJiYgZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGVEZWx0YSkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydC5hZGQodGhpcy5kYXRlRGVsdGEpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKHRoaXMuZGF0ZURlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyB0aGlzIGJlZm9yZSBhZGRpbmcgc3RhcnREZWx0YSB0byBzdGFydCwgc28gd2UgY2FuIHdvcmsgb2ZmIG9mIHN0YXJ0XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kRGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmVuZERlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnREZWx0YSkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydC5hZGQodGhpcy5zdGFydERlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFJlem9uZSkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogb2theSB0byBhY2Nlc3MgY2FsZW5kYXIgb3B0aW9uP1xyXG4gICAgICAgIGlmICghZW5kICYmIGNhbGVuZGFyLm9wdCgnZm9yY2VFdmVudER1cmF0aW9uJykpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGF0ZVByb2ZpbGUuaXNBbGxEYXkoKSwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIGNhbGVuZGFyKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuc2V0RGF0ZURlbHRhID0gZnVuY3Rpb24gKGRhdGVEZWx0YSkge1xyXG4gICAgICAgIGlmIChkYXRlRGVsdGEgJiYgZGF0ZURlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVEZWx0YSA9IGRhdGVEZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZURlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldFN0YXJ0RGVsdGEgPSBmdW5jdGlvbiAoc3RhcnREZWx0YSkge1xyXG4gICAgICAgIGlmIChzdGFydERlbHRhICYmIHN0YXJ0RGVsdGEudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREZWx0YSA9IHN0YXJ0RGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuc2V0RW5kRGVsdGEgPSBmdW5jdGlvbiAoZW5kRGVsdGEpIHtcclxuICAgICAgICBpZiAoZW5kRGVsdGEgJiYgZW5kRGVsdGEudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGVsdGEgPSBlbmREZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGVsdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2xlYXJFbmQgJiYgIXRoaXMuZm9yY2VUaW1lZCAmJiAhdGhpcy5mb3JjZUFsbERheSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5kYXRlRGVsdGEgJiYgIXRoaXMuc3RhcnREZWx0YSAmJiAhdGhpcy5lbmREZWx0YTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5jcmVhdGVGcm9tRGlmZiA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZTAsIGRhdGVQcm9maWxlMSwgbGFyZ2VVbml0KSB7XHJcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gZGF0ZVByb2ZpbGUwLmVuZCAmJiAhZGF0ZVByb2ZpbGUxLmVuZDtcclxuICAgICAgICB2YXIgZm9yY2VUaW1lZCA9IGRhdGVQcm9maWxlMC5pc0FsbERheSgpICYmICFkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKTtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSAhZGF0ZVByb2ZpbGUwLmlzQWxsRGF5KCkgJiYgZGF0ZVByb2ZpbGUxLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgdmFyIGRhdGVEZWx0YTtcclxuICAgICAgICB2YXIgZW5kRGlmZjtcclxuICAgICAgICB2YXIgZW5kRGVsdGE7XHJcbiAgICAgICAgdmFyIG11dGF0aW9uO1xyXG4gICAgICAgIC8vIHN1YnRyYWN0cyB0aGUgZGF0ZXMgaW4gdGhlIGFwcHJvcHJpYXRlIHdheSwgcmV0dXJuaW5nIGEgZHVyYXRpb25cclxuICAgICAgICBmdW5jdGlvbiBzdWJ0cmFjdERhdGVzKGRhdGUxLCBkYXRlMCkge1xyXG4gICAgICAgICAgICBpZiAobGFyZ2VVbml0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZCeVVuaXQoZGF0ZTEsIGRhdGUwLCBsYXJnZVVuaXQpOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5KGRhdGUxLCBkYXRlMCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmRGF5VGltZShkYXRlMSwgZGF0ZTApOyAvLyBwb29ybHkgbmFtZWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlRGVsdGEgPSBzdWJ0cmFjdERhdGVzKGRhdGVQcm9maWxlMS5zdGFydCwgZGF0ZVByb2ZpbGUwLnN0YXJ0KTtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUxLmVuZCkge1xyXG4gICAgICAgICAgICAvLyB1c2UgdW56b25lZFJhbmdlcyBiZWNhdXNlIGRhdGVQcm9maWxlMC5lbmQgbWlnaHQgYmUgbnVsbFxyXG4gICAgICAgICAgICBlbmREaWZmID0gc3VidHJhY3REYXRlcyhkYXRlUHJvZmlsZTEudW56b25lZFJhbmdlLmdldEVuZCgpLCBkYXRlUHJvZmlsZTAudW56b25lZFJhbmdlLmdldEVuZCgpKTtcclxuICAgICAgICAgICAgZW5kRGVsdGEgPSBlbmREaWZmLnN1YnRyYWN0KGRhdGVEZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uKCk7XHJcbiAgICAgICAgbXV0YXRpb24uY2xlYXJFbmQgPSBjbGVhckVuZDtcclxuICAgICAgICBtdXRhdGlvbi5mb3JjZVRpbWVkID0gZm9yY2VUaW1lZDtcclxuICAgICAgICBtdXRhdGlvbi5mb3JjZUFsbERheSA9IGZvcmNlQWxsRGF5O1xyXG4gICAgICAgIG11dGF0aW9uLnNldERhdGVEZWx0YShkYXRlRGVsdGEpO1xyXG4gICAgICAgIG11dGF0aW9uLnNldEVuZERlbHRhKGVuZERlbHRhKTtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmRGF0ZU11dGF0aW9uO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudERlZkRhdGVNdXRhdGlvbjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3RhbmRhcmRUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcbnZhciBKcXVlcnlVaVRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gICAgdGhlbWVDbGFzc0hhc2g6IHt9LFxyXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uICh0aGVtZU5hbWUsIHRoZW1lQ2xhc3MpIHtcclxuICAgICAgICB0aGlzLnRoZW1lQ2xhc3NIYXNoW3RoZW1lTmFtZV0gPSB0aGVtZUNsYXNzO1xyXG4gICAgfSxcclxuICAgIGdldFRoZW1lQ2xhc3M6IGZ1bmN0aW9uICh0aGVtZVNldHRpbmcpIHtcclxuICAgICAgICBpZiAoIXRoZW1lU2V0dGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RhbmRhcmRUaGVtZV8xLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoZW1lU2V0dGluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSnF1ZXJ5VWlUaGVtZV8xLmRlZmF1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVtZUNsYXNzSGFzaFt0aGVtZVNldHRpbmddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuLy8gUGx1Z2luXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxubW9tZW50X2V4dF8xLm5ld01vbWVudFByb3RvLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIgJiYgYXJndW1lbnRzWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUodGhpcywgYXJndW1lbnRzWzBdKTsgLy8gb3VyIGV4dGVuZGVkIGZvcm1hdHRpbmdcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIpIHtcclxuICAgICAgICAvLyBtb21lbnQuZm9ybWF0KCkgZG9lc24ndCBlbnN1cmUgZW5nbGlzaCwgYnV0IHdlIHdhbnQgdG8uXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5tb21lbnRfZXh0XzEubmV3TW9tZW50UHJvdG8udG9JU09TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tREQnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7XHJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIGJyb3dzZXIsIG1vbWVudCBtaWdodCBub3Qgb3V0cHV0IGVuZ2xpc2guIGVuc3VyZSBlbmdsaXNoLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMi4xOC4xL3NyYy9saWIvbW9tZW50L2Zvcm1hdC5qcyNMMjJcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KGVuZ2xpc2hNb21lbnQodGhpcyksIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuZ2xpc2hNb21lbnQobW9tKSB7XHJcbiAgICBpZiAobW9tLmxvY2FsZSgpICE9PSAnZW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbS5jbG9uZSgpLmxvY2FsZSgnZW4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb207XHJcbn1cclxuLy8gQ29uZmlnXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5JbnNlcnRlZCBiZXR3ZWVuIGNodW5rcyBpbiB0aGUgZmFrZSAoXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0dGluZyBzdHJpbmcuXHJcbkltcG9ydGFudCB0aGF0IGl0IHBhc3NlcyBhcyB3aGl0ZXNwYWNlIChcXHMpIGJlY2F1c2UgbW9tZW50IG9mdGVuIGlkZW50aWZpZXMgbm9uLXN0YW5kYWxvbmUgbW9udGhzXHJcbnZpYSBhIHJlZ2V4cCB3aXRoIGFuIFxccy5cclxuKi9cclxudmFyIFBBUlRfU0VQQVJBVE9SID0gJ1xcdTAwMGInOyAvLyB2ZXJ0aWNhbCB0YWJcclxuLypcclxuSW5zZXJ0ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpdGVyYWwtdGV4dCBjaHVuayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBsaXRlcmFsIHRleHQgaXMgbm90IGFjdHVhbGx5IGxpdGVyYWwgdGV4dCxcclxuYnV0IHJhdGhlciwgYSBcInNwZWNpYWxcIiB0b2tlbiB0aGF0IGhhcyBjdXN0b20gcmVuZGVyaW5nIChzZWUgc3BlY2lhbFRva2VucyBtYXApLlxyXG4qL1xyXG52YXIgU1BFQ0lBTF9UT0tFTl9NQVJLRVIgPSAnXFx1MDAxZic7IC8vIGluZm9ybWF0aW9uIHNlcGFyYXRvciAxXHJcbi8qXHJcbkluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHNwYW4gb2YgdGV4dCB0aGF0IG11c3QgaGF2ZSBub24temVybyBudW1lcmljIGNoYXJhY3RlcnMuXHJcbkhhbmRsaW5nIG9mIHRoZXNlIG1hcmtlcnMgaXMgZG9uZSBpbiBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0ZXh0IHJlbmRlcmluZy5cclxuKi9cclxudmFyIE1BWUJFX01BUktFUiA9ICdcXHUwMDFlJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDJcclxudmFyIE1BWUJFX1JFR0VYUCA9IG5ldyBSZWdFeHAoTUFZQkVfTUFSS0VSICsgJyhbXicgKyBNQVlCRV9NQVJLRVIgKyAnXSopJyArIE1BWUJFX01BUktFUiwgJ2cnKTsgLy8gbXVzdCBiZSBnbG9iYWxcclxuLypcclxuQWRkaXRpb24gZm9ybWF0dGluZyB0b2tlbnMgd2Ugd2FudCByZWNvZ25pemVkXHJcbiovXHJcbnZhciBzcGVjaWFsVG9rZW5zID0ge1xyXG4gICAgdDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChkYXRlLCAnYScpLmNoYXJBdCgwKTtcclxuICAgIH0sXHJcbiAgICBUOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsICdBJykuY2hhckF0KDApO1xyXG4gICAgfVxyXG59O1xyXG4vKlxyXG5UaGUgZmlyc3QgY2hhcmFjdGVycyBvZiBmb3JtYXR0aW5nIHRva2VucyBmb3IgdW5pdHMgdGhhdCBhcmUgMSBkYXkgb3IgbGFyZ2VyLlxyXG5gdmFsdWVgIGlzIGZvciByYW5raW5nIHJlbGF0aXZlIHNpemUgKGxvd2VyIG1lYW5zIGJpZ2dlcikuXHJcbmB1bml0YCBpcyBhIG5vcm1hbGl6ZWQgdW5pdCwgdXNlZCBmb3IgY29tcGFyaW5nIG1vbWVudHMuXHJcbiovXHJcbnZhciBsYXJnZVRva2VuTWFwID0ge1xyXG4gICAgWTogeyB2YWx1ZTogMSwgdW5pdDogJ3llYXInIH0sXHJcbiAgICBNOiB7IHZhbHVlOiAyLCB1bml0OiAnbW9udGgnIH0sXHJcbiAgICBXOiB7IHZhbHVlOiAzLCB1bml0OiAnd2VlaycgfSxcclxuICAgIHc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LFxyXG4gICAgRDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSxcclxuICAgIGQ6IHsgdmFsdWU6IDQsIHVuaXQ6ICdkYXknIH0gLy8gZGF5IG9mIHdlZWtcclxufTtcclxuLy8gU2luZ2xlIERhdGUgRm9ybWF0dGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBgZGF0ZWAgd2l0aCBhIE1vbWVudCBmb3JtYXR0aW5nIHN0cmluZywgYnV0IGFsbG93IG91ciBub24temVybyBhcmVhcyBhbmQgc3BlY2lhbCB0b2tlblxyXG4qL1xyXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0cikge1xyXG4gICAgcmV0dXJuIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZ2V0UGFyc2VkRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikuZmFrZUZvcm1hdFN0cmluZywgZGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuLy8gRGF0ZSBSYW5nZSBGb3JtYXR0aW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVE9ETzogbWFrZSBpdCB3b3JrIHdpdGggdGltZXpvbmUgb2Zmc2V0XHJcbi8qXHJcblVzaW5nIGEgZm9ybWF0dGluZyBzdHJpbmcgbWVhbnQgZm9yIGEgc2luZ2xlIGRhdGUsIGdlbmVyYXRlIGEgcmFuZ2Ugc3RyaW5nLCBsaWtlXHJcblwiU2VwIDIgLSA5IDIwMTNcIiwgdGhhdCBpbnRlbGxpZ2VudGx5IGluc2VydHMgYSBzZXBhcmF0b3Igd2hlcmUgdGhlIGRhdGVzIGRpZmZlci5cclxuSWYgdGhlIGRhdGVzIGFyZSB0aGUgc2FtZSBhcyBmYXIgYXMgdGhlIGZvcm1hdCBzdHJpbmcgaXMgY29uY2VybmVkLCBqdXN0IHJldHVybiBhIHNpbmdsZVxyXG5yZW5kZXJpbmcgb2Ygb25lIGRhdGUsIHdpdGhvdXQgYW55IHNlcGFyYXRvci5cclxuKi9cclxuZnVuY3Rpb24gZm9ybWF0UmFuZ2UoZGF0ZTEsIGRhdGUyLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgaXNSVEwpIHtcclxuICAgIHZhciBsb2NhbGVEYXRhO1xyXG4gICAgZGF0ZTEgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTEpO1xyXG4gICAgZGF0ZTIgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTIpO1xyXG4gICAgbG9jYWxlRGF0YSA9IGRhdGUxLmxvY2FsZURhdGEoKTtcclxuICAgIC8vIEV4cGFuZCBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MsIGxpa2UgXCJMTFwiIC0+IFwiTU1NTSBEIFlZWVlcIi5cclxuICAgIC8vIEJUVywgdGhpcyBpcyBub3QgaW1wb3J0YW50IGZvciBgZm9ybWF0RGF0ZWAgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIHB1dCBjdXN0b20gdG9rZW5zXHJcbiAgICAvLyBvciBub24temVybyBhcmVhcyBpbiBNb21lbnQncyBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MuXHJcbiAgICBmb3JtYXRTdHIgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KGZvcm1hdFN0cikgfHwgZm9ybWF0U3RyO1xyXG4gICAgcmV0dXJuIHJlbmRlclBhcnNlZEZvcm1hdChnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSwgZGF0ZTEsIGRhdGUyLCBzZXBhcmF0b3IgfHwgJyAtICcsIGlzUlRMKTtcclxufVxyXG5leHBvcnRzLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XHJcbi8qXHJcblJlbmRlcnMgYSByYW5nZSB3aXRoIGFuIGFscmVhZHktcGFyc2VkIGZvcm1hdCBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlclBhcnNlZEZvcm1hdChwYXJzZWRGb3JtYXQsIGRhdGUxLCBkYXRlMiwgc2VwYXJhdG9yLCBpc1JUTCkge1xyXG4gICAgdmFyIHNhbWVVbml0cyA9IHBhcnNlZEZvcm1hdC5zYW1lVW5pdHM7XHJcbiAgICB2YXIgdW56b25lZERhdGUxID0gZGF0ZTEuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gZm9yIHNhbWUtdW5pdCBjb21wYXJpc29uc1xyXG4gICAgdmFyIHVuem9uZWREYXRlMiA9IGRhdGUyLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIFwiXHJcbiAgICB2YXIgcmVuZGVyZWRQYXJ0czEgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUxKTtcclxuICAgIHZhciByZW5kZXJlZFBhcnRzMiA9IHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhwYXJzZWRGb3JtYXQuZmFrZUZvcm1hdFN0cmluZywgZGF0ZTIpO1xyXG4gICAgdmFyIGxlZnRJO1xyXG4gICAgdmFyIGxlZnRTdHIgPSAnJztcclxuICAgIHZhciByaWdodEk7XHJcbiAgICB2YXIgcmlnaHRTdHIgPSAnJztcclxuICAgIHZhciBtaWRkbGVJO1xyXG4gICAgdmFyIG1pZGRsZVN0cjEgPSAnJztcclxuICAgIHZhciBtaWRkbGVTdHIyID0gJyc7XHJcbiAgICB2YXIgbWlkZGxlU3RyID0gJyc7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgbGVmdG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHlvdSBoaXQgYSB0b2tlblxyXG4gICAgLy8gdGhhdCBpcyBub3QgdGhlIHNhbWUgYmV0d2VlbiBkYXRlcy5cclxuICAgIGZvciAobGVmdEkgPSAwOyBsZWZ0SSA8IHNhbWVVbml0cy5sZW5ndGggJiYgKCFzYW1lVW5pdHNbbGVmdEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbbGVmdEldKSk7IGxlZnRJKyspIHtcclxuICAgICAgICBsZWZ0U3RyICs9IHJlbmRlcmVkUGFydHMxW2xlZnRJXTtcclxuICAgIH1cclxuICAgIC8vIFNpbWlsYXJseSwgc3RhcnQgYXQgdGhlIHJpZ2h0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgbW92ZSBsZWZ0XHJcbiAgICBmb3IgKHJpZ2h0SSA9IHNhbWVVbml0cy5sZW5ndGggLSAxOyByaWdodEkgPiBsZWZ0SSAmJiAoIXNhbWVVbml0c1tyaWdodEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbcmlnaHRJXSkpOyByaWdodEktLSkge1xyXG4gICAgICAgIC8vIElmIGN1cnJlbnQgY2h1bmsgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHVuaXF1ZSBkYXRlLWNvbnRlbnQsIGFuZCBpcyBhIHNwZWNpYWwtY2FzZVxyXG4gICAgICAgIC8vIGRhdGUtZm9ybWF0dGluZyBwb3N0Zml4IGNoYXJhY3RlciwgdGhlbiBkb24ndCBjb25zdW1lIGl0LiBDb25zaWRlciBpdCB1bmlxdWUgZGF0ZS1jb250ZW50LlxyXG4gICAgICAgIC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXHJcbiAgICAgICAgaWYgKHJpZ2h0SSAtIDEgPT09IGxlZnRJICYmIHJlbmRlcmVkUGFydHMxW3JpZ2h0SV0gPT09ICcuJykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmlnaHRTdHIgPSByZW5kZXJlZFBhcnRzMVtyaWdodEldICsgcmlnaHRTdHI7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgYXJlYSBpbiB0aGUgbWlkZGxlIGlzIGRpZmZlcmVudCBmb3IgYm90aCBvZiB0aGUgZGF0ZXMuXHJcbiAgICAvLyBDb2xsZWN0IHRoZW0gZGlzdGluY3RseSBzbyB3ZSBjYW4gamFtIHRoZW0gdG9nZXRoZXIgbGF0ZXIuXHJcbiAgICBmb3IgKG1pZGRsZUkgPSBsZWZ0STsgbWlkZGxlSSA8PSByaWdodEk7IG1pZGRsZUkrKykge1xyXG4gICAgICAgIG1pZGRsZVN0cjEgKz0gcmVuZGVyZWRQYXJ0czFbbWlkZGxlSV07XHJcbiAgICAgICAgbWlkZGxlU3RyMiArPSByZW5kZXJlZFBhcnRzMlttaWRkbGVJXTtcclxuICAgIH1cclxuICAgIGlmIChtaWRkbGVTdHIxIHx8IG1pZGRsZVN0cjIpIHtcclxuICAgICAgICBpZiAoaXNSVEwpIHtcclxuICAgICAgICAgICAgbWlkZGxlU3RyID0gbWlkZGxlU3RyMiArIHNlcGFyYXRvciArIG1pZGRsZVN0cjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtaWRkbGVTdHIgPSBtaWRkbGVTdHIxICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvY2Vzc01heWJlTWFya2VycyhsZWZ0U3RyICsgbWlkZGxlU3RyICsgcmlnaHRTdHIpO1xyXG59XHJcbi8vIEZvcm1hdCBTdHJpbmcgUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxudmFyIHBhcnNlZEZvcm1hdFN0ckNhY2hlID0ge307XHJcbi8qXHJcblJldHVybnMgYSBwYXJzZWQgZm9ybWF0IHN0cmluZywgbGV2ZXJhZ2luZyBhIGNhY2hlLlxyXG4qL1xyXG5mdW5jdGlvbiBnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VkRm9ybWF0U3RyQ2FjaGVbZm9ybWF0U3RyXSB8fFxyXG4gICAgICAgIChwYXJzZWRGb3JtYXRTdHJDYWNoZVtmb3JtYXRTdHJdID0gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSk7XHJcbn1cclxuLypcclxuUGFyc2VzIGEgZm9ybWF0IHN0cmluZyBpbnRvIHRoZSBmb2xsb3dpbmc6XHJcbi0gZmFrZUZvcm1hdFN0cmluZzogYSBtb21lbnRKUyBmb3JtYXR0aW5nIHN0cmluZywgbGl0dGVyZWQgd2l0aCBzcGVjaWFsIGNvbnRyb2wgY2hhcmFjdGVycyB0aGF0IGdldCBwb3N0LXByb2Nlc3NlZC5cclxuLSBzYW1lVW5pdHM6IGZvciBldmVyeSBwYXJ0IGluIGZha2VGb3JtYXRTdHJpbmcsIGlmIHRoZSBwYXJ0IGlzIGEgdG9rZW4sIHRoZSB2YWx1ZSB3aWxsIGJlIGEgdW5pdCBzdHJpbmcgKGxpa2UgXCJkYXlcIiksXHJcbiAgdGhhdCBpbmRpY2F0ZXMgaG93IHNpbWlsYXIgYSByYW5nZSdzIHN0YXJ0ICYgZW5kIG11c3QgYmUgaW4gb3JkZXIgdG8gc2hhcmUgdGhlIHNhbWUgZm9ybWF0dGVkIHRleHQuXHJcbiAgSWYgbm90IGEgdG9rZW4sIHRoZW4gdGhlIHZhbHVlIGlzIG51bGwuXHJcbiAgQWx3YXlzIGEgZmxhdCBhcnJheSAobm90IG5lc3RlZCBsaWtlZCBcImNodW5rc1wiKS5cclxuKi9cclxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmFrZUZvcm1hdFN0cmluZzogYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcyksXHJcbiAgICAgICAgc2FtZVVuaXRzOiBidWlsZFNhbWVVbml0cyhjaHVua3MpXHJcbiAgICB9O1xyXG59XHJcbi8qXHJcbkJyZWFrIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGNodW5rcy5cclxuQSAnbWF5YmUnIGNodW5rIHdpbGwgaGF2ZSBuZXN0ZWQgY2h1bmtzLlxyXG4qL1xyXG5mdW5jdGlvbiBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBbXTtcclxuICAgIHZhciBtYXRjaDtcclxuICAgIC8vIFRPRE86IG1vcmUgZGVzY3JpbWluYXRpb25cclxuICAgIC8vIFxcNCBpcyBhIGJhY2tyZWZlcmVuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIG11bHRpLWNoYXJhY3RlciBzZXQuXHJcbiAgICB2YXIgY2h1bmtlciA9IC9cXFsoW15cXF1dKilcXF18XFwoKFteXFwpXSopXFwpfChMVFN8TFR8KFxcdylcXDQqbz8pfChbXlxcd1xcW1xcKF0rKS9nO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IGNodW5rZXIuZXhlYyhmb3JtYXRTdHIpKSkge1xyXG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaC5hcHBseShjaHVua3MsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBzcGxpdFN0cmluZ0xpdGVyYWwobWF0Y2hbMV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMl0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2goeyBtYXliZTogY2h1bmtGb3JtYXRTdHJpbmcobWF0Y2hbMl0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICBjaHVua3MucHVzaCh7IHRva2VuOiBtYXRjaFszXSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbNV0pIHtcclxuICAgICAgICAgICAgY2h1bmtzLnB1c2guYXBwbHkoY2h1bmtzLCAvLyBhcHBlbmRcclxuICAgICAgICAgICAgc3BsaXRTdHJpbmdMaXRlcmFsKG1hdGNoWzVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNodW5rcztcclxufVxyXG4vKlxyXG5Qb3RlbnRpYWxseSBzcGxpdHMgYSBsaXRlcmFsLXRleHQgc3RyaW5nIGludG8gbXVsdGlwbGUgcGFydHMuIEZvciBzcGVjaWFsIGNhc2VzLlxyXG4qL1xyXG5mdW5jdGlvbiBzcGxpdFN0cmluZ0xpdGVyYWwocykge1xyXG4gICAgaWYgKHMgPT09ICcuICcpIHtcclxuICAgICAgICByZXR1cm4gWycuJywgJyAnXTsgLy8gZm9yIGxvY2FsZXMgd2l0aCBwZXJpb2RzIGJvdW5kIHRvIHRoZSBlbmQgb2YgZWFjaCB5ZWFyL21vbnRoL2RhdGVcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBbc107XHJcbiAgICB9XHJcbn1cclxuLypcclxuR2l2ZW4gY2h1bmtzIHBhcnNlZCBmcm9tIGEgcmVhbCBmb3JtYXQgc3RyaW5nLCBnZW5lcmF0ZSBhIGZha2UgKGFrYSBcImludGVybWVkaWF0ZVwiKSBmb3JtYXQgc3RyaW5nIHdpdGggc3BlY2lhbCBjb250cm9sXHJcbmNoYXJhY3RlcnMgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgZ2l2ZW4gdG8gbW9tZW50IGZvciBmb3JtYXR0aW5nLCBhbmQgdGhlbiBwb3N0LXByb2Nlc3NlZC5cclxuKi9cclxuZnVuY3Rpb24gYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcykge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICB2YXIgaSwgY2h1bms7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCgnWycgKyBjaHVuayArICddJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNodW5rLnRva2VuKSB7XHJcbiAgICAgICAgICAgIGlmIChjaHVuay50b2tlbiBpbiBzcGVjaWFsVG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFNQRUNJQUxfVE9LRU5fTUFSS0VSICsgLy8gdXNlZnVsIGR1cmluZyBwb3N0LXByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAnWycgKyBjaHVuay50b2tlbiArICddJyAvLyBwcmVzZXJ2ZSBhcyBsaXRlcmFsIHRleHRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNodW5rLnRva2VuKTsgLy8gdW5wcm90ZWN0ZWQgdGV4dCBpbXBsaWVzIGEgZm9ybWF0IHN0cmluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNodW5rLm1heWJlKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goTUFZQkVfTUFSS0VSICsgLy8gdXNlZnVsIGR1cmluZyBwb3N0LXByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgIGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVuay5tYXliZSkgK1xyXG4gICAgICAgICAgICAgICAgTUFZQkVfTUFSS0VSKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFydHMuam9pbihQQVJUX1NFUEFSQVRPUik7XHJcbn1cclxuLypcclxuR2l2ZW4gcGFyc2VkIGNodW5rcyBmcm9tIGEgcmVhbCBmb3JtYXR0aW5nIHN0cmluZywgZ2VuZXJhdGVzIGFuIGFycmF5IG9mIHVuaXQgc3RyaW5ncyAobGlrZSBcImRheVwiKSB0aGF0IGluZGljYXRlXHJcbmluIHdoaWNoIHJlZ2FyZCB0d28gZGF0ZXMgbXVzdCBiZSBzaW1pbGFyIGluIG9yZGVyIHRvIHNoYXJlIHJhbmdlIGZvcm1hdHRpbmcgdGV4dC5cclxuVGhlIGBjaHVua3NgIGNhbiBiZSBuZXN0ZWQgKGJlY2F1c2Ugb2YgXCJtYXliZVwiIGNodW5rcyksIGhvd2V2ZXIsIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGZsYXQuXHJcbiovXHJcbmZ1bmN0aW9uIGJ1aWxkU2FtZVVuaXRzKGNodW5rcykge1xyXG4gICAgdmFyIHVuaXRzID0gW107XHJcbiAgICB2YXIgaSwgY2h1bms7XHJcbiAgICB2YXIgdG9rZW5JbmZvO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgIGlmIChjaHVuay50b2tlbikge1xyXG4gICAgICAgICAgICB0b2tlbkluZm8gPSBsYXJnZVRva2VuTWFwW2NodW5rLnRva2VuLmNoYXJBdCgwKV07XHJcbiAgICAgICAgICAgIHVuaXRzLnB1c2godG9rZW5JbmZvID8gdG9rZW5JbmZvLnVuaXQgOiAnc2Vjb25kJyk7IC8vIGRlZmF1bHQgdG8gYSB2ZXJ5IHN0cmljdCBzYW1lLXNlY29uZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaHVuay5tYXliZSkge1xyXG4gICAgICAgICAgICB1bml0cy5wdXNoLmFwcGx5KHVuaXRzLCAvLyBhcHBlbmRcclxuICAgICAgICAgICAgYnVpbGRTYW1lVW5pdHMoY2h1bmsubWF5YmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuaXRzO1xyXG59XHJcbi8vIFJlbmRlcmluZyB0byB0ZXh0XHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5Gb3JtYXRzIGEgZGF0ZSB3aXRoIGEgZmFrZSBmb3JtYXQgc3RyaW5nLCBwb3N0LXByb2Nlc3NlcyB0aGUgY29udHJvbCBjaGFyYWN0ZXJzLCB0aGVuIHJldHVybnMuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkge1xyXG4gICAgcmV0dXJuIHByb2Nlc3NNYXliZU1hcmtlcnMocmVuZGVyRmFrZUZvcm1hdFN0cmluZ1BhcnRzKGZha2VGb3JtYXRTdHJpbmcsIGRhdGUpLmpvaW4oJycpKTtcclxufVxyXG4vKlxyXG5Gb3JtYXRzIGEgZGF0ZSBpbnRvIHBhcnRzIHRoYXQgd2lsbCBoYXZlIGJlZW4gcG9zdC1wcm9jZXNzZWQsIEVYQ0VQVCBmb3IgdGhlIFwibWF5YmVcIiBtYXJrZXJzLlxyXG4qL1xyXG5mdW5jdGlvbiByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkge1xyXG4gICAgdmFyIHBhcnRzID0gW107XHJcbiAgICB2YXIgZmFrZVJlbmRlciA9IG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZGF0ZSwgZmFrZUZvcm1hdFN0cmluZyk7XHJcbiAgICB2YXIgZmFrZVBhcnRzID0gZmFrZVJlbmRlci5zcGxpdChQQVJUX1NFUEFSQVRPUik7XHJcbiAgICB2YXIgaSwgZmFrZVBhcnQ7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmFrZVBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZmFrZVBhcnQgPSBmYWtlUGFydHNbaV07XHJcbiAgICAgICAgaWYgKGZha2VQYXJ0LmNoYXJBdCgwKSA9PT0gU1BFQ0lBTF9UT0tFTl9NQVJLRVIpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChcclxuICAgICAgICAgICAgLy8gdGhlIGxpdGVyYWwgc3RyaW5nIElTIHRoZSB0b2tlbidzIG5hbWUuXHJcbiAgICAgICAgICAgIC8vIGNhbGwgc3BlY2lhbCB0b2tlbidzIHJlZ2lzdGVyZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgIHNwZWNpYWxUb2tlbnNbZmFrZVBhcnQuc3Vic3RyaW5nKDEpXShkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGZha2VQYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFydHM7XHJcbn1cclxuLypcclxuQWNjZXB0cyBhbiBhbG1vc3QtZmluYWxseS1mb3JtYXR0ZWQgc3RyaW5nIGFuZCBwcm9jZXNzZXMgdGhlIFwibWF5YmVcIiBjb250cm9sIGNoYXJhY3RlcnMsIHJldHVybmluZyBhIG5ldyBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHByb2Nlc3NNYXliZU1hcmtlcnMocykge1xyXG4gICAgcmV0dXJuIHMucmVwbGFjZShNQVlCRV9SRUdFWFAsIGZ1bmN0aW9uIChtMCwgbTEpIHtcclxuICAgICAgICBpZiAobTEubWF0Y2goL1sxLTldLykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8vIE1pc2MgVXRpbHNcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5SZXR1cm5zIGEgdW5pdCBzdHJpbmcsIGVpdGhlciAneWVhcicsICdtb250aCcsICdkYXknLCBvciBudWxsIGZvciB0aGUgbW9zdCBncmFudWxhciBmb3JtYXR0aW5nIHRva2VuIGluIHRoZSBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdChmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpO1xyXG4gICAgdmFyIGksIGNodW5rO1xyXG4gICAgdmFyIGNhbmRpZGF0ZTtcclxuICAgIHZhciBiZXN0O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgIGlmIChjaHVuay50b2tlbikge1xyXG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBsYXJnZVRva2VuTWFwW2NodW5rLnRva2VuLmNoYXJBdCgwKV07XHJcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYmVzdCB8fCBjYW5kaWRhdGUudmFsdWUgPiBiZXN0LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdCA9IGNhbmRpZGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChiZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGJlc3QudW5pdDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMucXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0ID0gcXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8qXHJcbkEgY2FjaGUgZm9yIHRoZSBsZWZ0L3JpZ2h0L3RvcC9ib3R0b20vd2lkdGgvaGVpZ2h0IHZhbHVlcyBmb3Igb25lIG9yIG1vcmUgZWxlbWVudHMuXHJcbldvcmtzIHdpdGggYm90aCBvZmZzZXQgKGZyb20gdG9wbGVmdCBkb2N1bWVudCkgYW5kIHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCkuXHJcblxyXG5vcHRpb25zOlxyXG4tIGVsc1xyXG4tIGlzSG9yaXpvbnRhbFxyXG4tIGlzVmVydGljYWxcclxuKi9cclxudmFyIENvb3JkQ2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb29yZENhY2hlKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IGZhbHNlOyAvLyB3aGV0aGVyIHRvIHF1ZXJ5IGZvciBsZWZ0L3JpZ2h0L3dpZHRoXHJcbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gZmFsc2U7IC8vIHdoZXRoZXIgdG8gcXVlcnkgZm9yIHRvcC9ib3R0b20vaGVpZ2h0XHJcbiAgICAgICAgdGhpcy5lbHMgPSAkKG9wdGlvbnMuZWxzKTtcclxuICAgICAgICB0aGlzLmlzSG9yaXpvbnRhbCA9IG9wdGlvbnMuaXNIb3Jpem9udGFsO1xyXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbCA9IG9wdGlvbnMuaXNWZXJ0aWNhbDtcclxuICAgICAgICB0aGlzLmZvcmNlZE9mZnNldFBhcmVudEVsID0gb3B0aW9ucy5vZmZzZXRQYXJlbnQgPyAkKG9wdGlvbnMub2Zmc2V0UGFyZW50KSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyaWVzIHRoZSBlbHMgZm9yIGNvb3JkaW5hdGVzIGFuZCBzdG9yZXMgdGhlbS5cclxuICAgIC8vIENhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIGFuZCBvZiB0aGUgZ2V0KiBtZXRob2RzIGJlbG93LlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEVsID0gdGhpcy5mb3JjZWRPZmZzZXRQYXJlbnRFbDtcclxuICAgICAgICBpZiAoIW9mZnNldFBhcmVudEVsICYmIHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50RWwgPSB0aGlzLmVscy5lcSgwKS5vZmZzZXRQYXJlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBvZmZzZXRQYXJlbnRFbCA/XHJcbiAgICAgICAgICAgIG9mZnNldFBhcmVudEVsLm9mZnNldCgpIDpcclxuICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmVjdCA9IHRoaXMucXVlcnlCb3VuZGluZ1JlY3QoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZEVsSG9yaXpvbnRhbHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGVzdHJveXMgYWxsIGludGVybmFsIGRhdGEgYWJvdXQgY29vcmRpbmF0ZXMsIGZyZWVpbmcgbWVtb3J5XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1JlY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVmdHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRvcHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm90dG9tcyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gV2hlbiBjYWxsZWQsIGlmIGNvb3JkIGNhY2hlcyBhcmVuJ3QgYnVpbHQsIGJ1aWxkcyB0aGVtXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5lbnN1cmVCdWlsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZEVsSG9yaXpvbnRhbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRzID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWxzLmVhY2goZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGVsID0gJChub2RlKTtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBlbC5vZmZzZXQoKS5sZWZ0O1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBlbC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgICAgIGxlZnRzLnB1c2gobGVmdCk7XHJcbiAgICAgICAgICAgIHJpZ2h0cy5wdXNoKGxlZnQgKyB3aWR0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5sZWZ0cyA9IGxlZnRzO1xyXG4gICAgICAgIHRoaXMucmlnaHRzID0gcmlnaHRzO1xyXG4gICAgfTtcclxuICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuYnVpbGRFbFZlcnRpY2FscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdG9wcyA9IFtdO1xyXG4gICAgICAgIHZhciBib3R0b21zID0gW107XHJcbiAgICAgICAgdGhpcy5lbHMuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gZWwub2Zmc2V0KCkudG9wO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZWwub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICAgICAgdG9wcy5wdXNoKHRvcCk7XHJcbiAgICAgICAgICAgIGJvdHRvbXMucHVzaCh0b3AgKyBoZWlnaHQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMudG9wcyA9IHRvcHM7XHJcbiAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0cy5cclxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldEhvcml6b250YWxJbmRleCA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHZhciBsZWZ0cyA9IHRoaXMubGVmdHM7XHJcbiAgICAgICAgdmFyIHJpZ2h0cyA9IHRoaXMucmlnaHRzO1xyXG4gICAgICAgIHZhciBsZW4gPSBsZWZ0cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0T2Zmc2V0ID49IGxlZnRzW2ldICYmIGxlZnRPZmZzZXQgPCByaWdodHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApLCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWwgdGhhdCBpdCB2ZXJ0aWNhbGx5IGludGVyc2VjdHMuXHJcbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRWZXJ0aWNhbEluZGV4ID0gZnVuY3Rpb24gKHRvcE9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICB2YXIgdG9wcyA9IHRoaXMudG9wcztcclxuICAgICAgICB2YXIgYm90dG9tcyA9IHRoaXMuYm90dG9tcztcclxuICAgICAgICB2YXIgbGVuID0gdG9wcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0b3BPZmZzZXQgPj0gdG9wc1tpXSAmJiB0b3BPZmZzZXQgPCBib3R0b21zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldExlZnRPZmZzZXQgPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgbGVmdCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRMZWZ0UG9zaXRpb24gPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRzW2xlZnRJbmRleF0gLSB0aGlzLm9yaWdpbi5sZWZ0O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHJpZ2h0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRSaWdodE9mZnNldCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgcmlnaHQgcG9zaXRpb24gKGZyb20gb2Zmc2V0UGFyZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQncyByaWdodCBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcInJpZ2h0XCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRSaWdodFBvc2l0aW9uID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdG9wIG9mZnNldCAoZnJvbSBkb2N1bWVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0VG9wT2Zmc2V0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRvcCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFRvcFBvc2l0aW9uID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcHNbdG9wSW5kZXhdIC0gdGhpcy5vcmlnaW4udG9wO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGJvdHRvbSBvZmZzZXQgKGZyb20gdGhlIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0Qm90dG9tT2Zmc2V0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiAoZnJvbSB0aGUgb2Zmc2V0UGFyZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIGJvdHRvbSBlZGdlLCBsaWtlIHRoZSBDU1MgY29uY2VwdCBvZiBcImJvdHRvbVwiIHdvdWxkIGJlLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0Qm90dG9tUG9zaXRpb24gPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLm9yaWdpbi50b3A7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBCb3VuZGluZyBSZWN0XHJcbiAgICAvLyBUT0RPOiBkZWNvdXBsZSB0aGlzIGZyb20gQ29vcmRDYWNoZVxyXG4gICAgLy8gQ29tcHV0ZSBhbmQgcmV0dXJuIHdoYXQgdGhlIGVsZW1lbnRzJyBib3VuZGluZyByZWN0YW5nbGUgaXMsIGZyb20gdGhlIHVzZXIncyBwZXJzcGVjdGl2ZS5cclxuICAgIC8vIFJpZ2h0IG5vdywgb25seSByZXR1cm5zIGEgcmVjdGFuZ2xlIGlmIGNvbnN0cmFpbmVkIGJ5IGFuIG92ZXJmbG93OnNjcm9sbCBlbGVtZW50LlxyXG4gICAgLy8gUmV0dXJucyBudWxsIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50c1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUucXVlcnlCb3VuZGluZ1JlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbFBhcmVudEVsO1xyXG4gICAgICAgIGlmICh0aGlzLmVscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsID0gdXRpbF8xLmdldFNjcm9sbFBhcmVudCh0aGlzLmVscy5lcSgwKSk7XHJcbiAgICAgICAgICAgIGlmICghc2Nyb2xsUGFyZW50RWwuaXMoZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmdldENsaWVudFJlY3Qoc2Nyb2xsUGFyZW50RWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmlzUG9pbnRJbkJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xlZnRJbkJvdW5kcyhsZWZ0T2Zmc2V0KSAmJiB0aGlzLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KTtcclxuICAgIH07XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5pc0xlZnRJbkJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0T2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAobGVmdE9mZnNldCA+PSB0aGlzLmJvdW5kaW5nUmVjdC5sZWZ0ICYmIGxlZnRPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5yaWdodCk7XHJcbiAgICB9O1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuaXNUb3BJbkJvdW5kcyA9IGZ1bmN0aW9uICh0b3BPZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYm91bmRpbmdSZWN0IHx8ICh0b3BPZmZzZXQgPj0gdGhpcy5ib3VuZGluZ1JlY3QudG9wICYmIHRvcE9mZnNldCA8IHRoaXMuYm91bmRpbmdSZWN0LmJvdHRvbSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvb3JkQ2FjaGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvb3JkQ2FjaGU7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuLyogVHJhY2tzIGEgZHJhZydzIG1vdXNlIG1vdmVtZW50LCBmaXJpbmcgdmFyaW91cyBoYW5kbGVyc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gVE9ETzogdXNlIEVtaXR0ZXJcclxudmFyIERyYWdMaXN0ZW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERyYWdMaXN0ZW5lcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVG91Y2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzR2VuZXJpYyA9IGZhbHNlOyAvLyBpbml0aWF0ZWQgYnkgJ2RyYWdzdGFydCcgKGpxdWkpXHJcbiAgICAgICAgdGhpcy5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxBbHdheXNLaWxscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZGVmYXVsdHNcclxuICAgICAgICB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5ID0gMzA7IC8vIHBpeGVscyBmcm9tIGVkZ2UgZm9yIHNjcm9sbGluZyB0byBzdGFydFxyXG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSAyMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kLCBhdCBtYXhpbXVtIHNwZWVkXHJcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbE1zID0gNTA7IC8vIG1pbGxpc2Vjb25kIHdhaXQgYmV0d2VlbiBzY3JvbGwgaW5jcmVtZW50XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8vIEludGVyYWN0aW9uIChoaWdoLWxldmVsKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldiwgZXh0cmFPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGV4dHJhT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGV4dHJhT3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgaWYgKGV2LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XHJcbiAgICAgICAgICAgIGlmIChHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWxfMS5pc1ByaW1hcnlNb3VzZUJ1dHRvbihldikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIG5hdGl2ZSBzZWxlY3Rpb24gaW4gbW9zdCBicm93c2Vyc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3Mgb3B0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gdXRpbF8xLmZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGVsYXksIHRoaXMub3B0aW9ucy5kZWxheSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMubWluRGlzdGFuY2UgPSB1dGlsXzEuZmlyc3REZWZpbmVkKGV4dHJhT3B0aW9ucy5kaXN0YW5jZSwgdGhpcy5vcHRpb25zLmRpc3RhbmNlLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSB0aGlzLm9wdGlvbnMuc3ViamVjdEVsO1xyXG4gICAgICAgICAgICB1dGlsXzEucHJldmVudFNlbGVjdGlvbigkKCdib2R5JykpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmlzVG91Y2ggPSB1dGlsXzEuZ2V0RXZJc1RvdWNoKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5pc0dlbmVyaWMgPSBldi50eXBlID09PSAnZHJhZ3N0YXJ0JztcclxuICAgICAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luWCA9IHV0aWxfMS5nZXRFdlgoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblkgPSB1dGlsXzEuZ2V0RXZZKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQoJChldi50YXJnZXQpKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0QXV0b1Njcm9sbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludGVyYWN0aW9uU3RhcnQoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignaW50ZXJhY3Rpb25TdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZEludGVyYWN0aW9uID0gZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmREcmFnKGV2KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUF1dG9TY3JvbGwoKTtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRIYW5kbGVycygpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvbkVuZChldiwgaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICB1dGlsXzEuYWxsb3dTZWxlY3Rpb24oJCgnYm9keScpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZCA9IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludGVyYWN0aW9uRW5kJywgZXYsIGlzQ2FuY2VsbGVkIHx8IGZhbHNlKTtcclxuICAgIH07XHJcbiAgICAvLyBCaW5kaW5nIFRvIERPTVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgKFNhZmFyaSBpbiBpT1MgMTApIGRvbid0IGFsbG93IHByZXZlbnREZWZhdWx0IG9uIHRvdWNoIGV2ZW50cyB0aGF0IGFyZSBib3VuZCBhZnRlciB0b3VjaHN0YXJ0LFxyXG4gICAgICAgIC8vIHNvIGxpc3RlbiB0byB0aGUgR2xvYmFsRW1pdHRlciBzaW5nbGV0b24sIHdoaWNoIGlzIGFsd2F5cyBib3VuZCwgaW5zdGVhZCBvZiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXHJcbiAgICAgICAgdmFyIGdsb2JhbEVtaXR0ZXIgPSBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKTtcclxuICAgICAgICBpZiAodGhpcy5pc0dlbmVyaWMpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICAgICAgZHJhZzogdGhpcy5oYW5kbGVNb3ZlLFxyXG4gICAgICAgICAgICAgICAgZHJhZ3N0b3A6IHRoaXMuZW5kSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNUb3VjaCkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIHRvdWNobW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXHJcbiAgICAgICAgICAgICAgICB0b3VjaGVuZDogdGhpcy5lbmRJbnRlcmFjdGlvbixcclxuICAgICAgICAgICAgICAgIHNjcm9sbDogdGhpcy5oYW5kbGVUb3VjaFNjcm9sbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlTW92ZSxcclxuICAgICAgICAgICAgICAgIG1vdXNldXA6IHRoaXMuZW5kSW50ZXJhY3Rpb25cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGlzdGVuVG8oZ2xvYmFsRW1pdHRlciwge1xyXG4gICAgICAgICAgICBzZWxlY3RzdGFydDogdXRpbF8xLnByZXZlbnREZWZhdWx0LFxyXG4gICAgICAgICAgICBjb250ZXh0bWVudTogdXRpbF8xLnByZXZlbnREZWZhdWx0IC8vIGxvbmcgdGFwcyB3b3VsZCBvcGVuIG1lbnUgb24gQ2hyb21lIGRldiB0b29sc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUudW5iaW5kSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkpO1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTsgLy8gZm9yIGlzR2VuZXJpY1xyXG4gICAgfTtcclxuICAgIC8vIERyYWcgKGhpZ2gtbGV2ZWwpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXh0cmFPcHRpb25zIGlnbm9yZWQgaWYgZHJhZyBhbHJlYWR5IHN0YXJ0ZWRcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc3RhcnREcmFnID0gZnVuY3Rpb24gKGV2LCBleHRyYU9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIGV4dHJhT3B0aW9ucyk7IC8vIGVuc3VyZSBpbnRlcmFjdGlvbiBiZWdhblxyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWdTdGFydCcsIGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgZHggPSB1dGlsXzEuZ2V0RXZYKGV2KSAtIHRoaXMub3JpZ2luWDtcclxuICAgICAgICB2YXIgZHkgPSB1dGlsXzEuZ2V0RXZZKGV2KSAtIHRoaXMub3JpZ2luWTtcclxuICAgICAgICB2YXIgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlO1xyXG4gICAgICAgIHZhciBkaXN0YW5jZVNxOyAvLyBjdXJyZW50IGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiwgc3F1YXJlZFxyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgIGRpc3RhbmNlU3EgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWcoZHgsIGR5LCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGlsZSB0aGUgbW91c2UgaXMgYmVpbmcgbW92ZWQgYW5kIHdoZW4gd2Uga25vdyBhIGxlZ2l0aW1hdGUgZHJhZyBpcyB0YWtpbmcgcGxhY2VcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChkeCwgZHksIGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnJywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBdXRvU2Nyb2xsKGV2KTsgLy8gd2lsbCBwb3NzaWJseSBjYXVzZSBzY3JvbGxpbmdcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZERyYWcgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RyYWdFbmQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gRGVsYXlcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0RGVsYXkgPSBmdW5jdGlvbiAoaW5pdGlhbEV2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5kZWxheSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEZWxheUVuZChpbml0aWFsRXYpO1xyXG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEZWxheUVuZCA9IGZ1bmN0aW9uIChpbml0aWFsRXYpIHtcclxuICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhpbml0aWFsRXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEaXN0YW5jZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIE1vdXNlIC8gVG91Y2hcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIHByZXZlbnQgaW5lcnRpYSBhbmQgdG91Y2htb3ZlLXNjcm9sbGluZyB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBTY3JvbGxpbmcgKHVucmVsYXRlZCB0byBhdXRvLXNjcm9sbClcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIGRyYWcgaXMgYmVpbmcgaW5pdGlhdGVkIGJ5IHRvdWNoLCBidXQgYSBzY3JvbGwgaGFwcGVucyBiZWZvcmVcclxuICAgICAgICAvLyB0aGUgZHJhZy1pbml0aWF0aW5nIGRlbGF5IGlzIG92ZXIsIGNhbmNlbCB0aGUgZHJhZ1xyXG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nIHx8IHRoaXMuc2Nyb2xsQWx3YXlzS2lsbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbihldiwgdHJ1ZSk7IC8vIGlzQ2FuY2VsbGVkPXRydWVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBUcmlnZ2VycyBhIGNhbGxiYWNrLiBDYWxscyBhIGZ1bmN0aW9uIGluIHRoZSBvcHRpb24gaGFzaCBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAgLy8gQXJndW1lbnRzIGJleW9uZCB0aGUgZmlyc3QgYG5hbWVgIGFyZSBmb3J3YXJkZWQgb24uXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ha2VzIF9tZXRob2RzIGNhbGxhYmxlIGJ5IGV2ZW50IG5hbWUuIFRPRE86IGtpbGwgdGhpc1xyXG4gICAgICAgIGlmICh0aGlzWydfJyArIG5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ18nICsgbmFtZV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEF1dG8tc2Nyb2xsXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5pbml0QXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIHRoaXMuaXNBdXRvU2Nyb2xsID1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbCAmJlxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsRWwgJiZcclxuICAgICAgICAgICAgICAgICFzY3JvbGxFbC5pcyh3aW5kb3cpICYmXHJcbiAgICAgICAgICAgICAgICAhc2Nyb2xsRWwuaXMoZG9jdW1lbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQXV0b1Njcm9sbCkge1xyXG4gICAgICAgICAgICAvLyBkZWJvdW5jZSBtYWtlcyBzdXJlIHJhcGlkIGNhbGxzIGRvbid0IGhhcHBlblxyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHNjcm9sbEVsLCAnc2Nyb2xsJywgdXRpbF8xLmRlYm91bmNlKHRoaXMuaGFuZGxlRGVib3VuY2VkU2Nyb2xsLCAxMDApKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5kZXN0cm95QXV0b1Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVuZEF1dG9TY3JvbGwoKTsgLy8ga2lsbCBhbnkgYW5pbWF0aW9uIGxvb3BcclxuICAgICAgICAvLyByZW1vdmUgdGhlIHNjcm9sbCBoYW5kbGVyIGlmIHRoZXJlIGlzIGEgc2Nyb2xsRWxcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8odGhpcy5zY3JvbGxFbCwgJ3Njcm9sbCcpOyAvLyB3aWxsIHByb2JhYmx5IGdldCByZW1vdmVkIGJ5IHVuYmluZEhhbmRsZXJzIHRvbyA6KFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgc3RvcmVzIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2Ygc2Nyb2xsRWxcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxCb3VuZHMgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHRoaXMuc2Nyb2xsRWwpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiB1c2UgZ2V0Q2xpZW50UmVjdCBpbiBmdXR1cmUuIGJ1dCBwcmV2ZW50cyBhdXRvIHNjcm9sbGluZyB3aGVuIG9uIHRvcCBvZiBzY3JvbGxiYXJzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnZ2luZyBpcyBpbiBwcm9ncmVzcyBhbmQgc2Nyb2xsaW5nIHNob3VsZCBiZSB1cGRhdGVkXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnVwZGF0ZUF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgc2Vuc2l0aXZpdHkgPSB0aGlzLnNjcm9sbFNlbnNpdGl2aXR5O1xyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLnNjcm9sbEJvdW5kcztcclxuICAgICAgICB2YXIgdG9wQ2xvc2VuZXNzLCBib3R0b21DbG9zZW5lc3M7XHJcbiAgICAgICAgdmFyIGxlZnRDbG9zZW5lc3MsIHJpZ2h0Q2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciB0b3BWZWwgPSAwO1xyXG4gICAgICAgIHZhciBsZWZ0VmVsID0gMDtcclxuICAgICAgICBpZiAoYm91bmRzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgY2xvc2VuZXNzIHRvIGVkZ2VzLiB2YWxpZCByYW5nZSBpcyBmcm9tIDAuMCAtIDEuMFxyXG4gICAgICAgICAgICB0b3BDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAodXRpbF8xLmdldEV2WShldikgLSBib3VuZHMudG9wKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgYm90dG9tQ2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5ib3R0b20gLSB1dGlsXzEuZ2V0RXZZKGV2KSkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIGxlZnRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAodXRpbF8xLmdldEV2WChldikgLSBib3VuZHMubGVmdCkpIC8gc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgIHJpZ2h0Q2xvc2VuZXNzID0gKHNlbnNpdGl2aXR5IC0gKGJvdW5kcy5yaWdodCAtIHV0aWxfMS5nZXRFdlgoZXYpKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHZlcnRpY2FsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5LlxyXG4gICAgICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGNvbXBsZXRlbHkgaW4gYm91bmRzIGZvciB2ZWxvY2l0eSB0byBoYXBwZW4uXHJcbiAgICAgICAgICAgIGlmICh0b3BDbG9zZW5lc3MgPj0gMCAmJiB0b3BDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgdG9wVmVsID0gdG9wQ2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyB1cFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJvdHRvbUNsb3NlbmVzcyA+PSAwICYmIGJvdHRvbUNsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BWZWwgPSBib3R0b21DbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBob3Jpem9udGFsIGNsb3NlbmVzcyBpbnRvIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2xvc2VuZXNzID49IDAgJiYgbGVmdENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0VmVsID0gbGVmdENsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQgKiAtMTsgLy8gbmVnYXRpdmUuIGZvciBzY3JvbGxpbmcgbGVmdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0Q2xvc2VuZXNzID49IDAgJiYgcmlnaHRDbG9zZW5lc3MgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdFZlbCA9IHJpZ2h0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFNjcm9sbFZlbCh0b3BWZWwsIGxlZnRWZWwpO1xyXG4gICAgfTtcclxuICAgIC8vIFNldHMgdGhlIHNwZWVkLW9mLXNjcm9sbGluZyBmb3IgdGhlIHNjcm9sbEVsXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnNldFNjcm9sbFZlbCA9IGZ1bmN0aW9uICh0b3BWZWwsIGxlZnRWZWwpIHtcclxuICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IHRvcFZlbDtcclxuICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSBsZWZ0VmVsO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWluU2Nyb2xsVmVsKCk7IC8vIG1hc3NhZ2VzIGludG8gcmVhbGlzdGljIHZhbHVlc1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vbi16ZXJvIHZlbG9jaXR5LCBhbmQgYW4gYW5pbWF0aW9uIGxvb3AgaGFzbid0IGFscmVhZHkgc3RhcnRlZCwgdGhlbiBTVEFSVFxyXG4gICAgICAgIGlmICgodGhpcy5zY3JvbGxUb3BWZWwgfHwgdGhpcy5zY3JvbGxMZWZ0VmVsKSAmJiAhdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHV0aWxfMS5wcm94eSh0aGlzLCAnc2Nyb2xsSW50ZXJ2YWxGdW5jJyksIC8vIHNjb3BlIHRvIGB0aGlzYFxyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsTXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBGb3JjZXMgc2Nyb2xsVG9wVmVsIGFuZCBzY3JvbGxMZWZ0VmVsIHRvIGJlIHplcm8gaWYgc2Nyb2xsaW5nIGhhcyBhbHJlYWR5IGdvbmUgYWxsIHRoZSB3YXlcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuY29uc3RyYWluU2Nyb2xsVmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKCkgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsVG9wKCkgKyBlbFswXS5jbGllbnRIZWlnaHQgPj0gZWxbMF0uc2Nyb2xsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbExlZnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbExlZnQoKSArIGVsWzBdLmNsaWVudFdpZHRoID49IGVsWzBdLnNjcm9sbFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZHVyaW5nIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnNjcm9sbEludGVydmFsRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLnNjcm9sbEVsO1xyXG4gICAgICAgIHZhciBmcmFjID0gdGhpcy5zY3JvbGxJbnRlcnZhbE1zIC8gMTAwMDsgLy8gY29uc2lkZXJpbmcgYW5pbWF0aW9uIGZyZXF1ZW5jeSwgd2hhdCB0aGUgdmVsIHNob3VsZCBiZSBtdWx0J2QgYnlcclxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHZhbHVlIG9mIHNjcm9sbEVsJ3Mgc2Nyb2xsXHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wVmVsKSB7XHJcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvcChlbC5zY3JvbGxUb3AoKSArIHRoaXMuc2Nyb2xsVG9wVmVsICogZnJhYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnRWZWwpIHtcclxuICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdChlbC5zY3JvbGxMZWZ0KCkgKyB0aGlzLnNjcm9sbExlZnRWZWwgKiBmcmFjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gc2luY2UgdGhlIHNjcm9sbCB2YWx1ZXMgY2hhbmdlZCwgcmVjb21wdXRlIHRoZSB2ZWxvY2l0aWVzXHJcbiAgICAgICAgLy8gaWYgc2Nyb2xsZWQgYWxsIHRoZSB3YXksIHdoaWNoIGNhdXNlcyB0aGUgdmVscyB0byBiZSB6ZXJvLCBzdG9wIHRoZSBhbmltYXRpb24gbG9vcFxyXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxUb3BWZWwgJiYgIXRoaXMuc2Nyb2xsTGVmdFZlbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuZEF1dG9TY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gS2lsbHMgYW55IGV4aXN0aW5nIHNjcm9sbGluZyBhbmltYXRpb24gbG9vcFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmRBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbEludGVydmFsSWQpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEludGVydmFsSWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXQgY2FsbGVkIHdoZW4gdGhlIHNjcm9sbEVsIGlzIHNjcm9sbGVkIChOT1RFOiB0aGlzIGlzIGRlbGF5ZWQgdmlhIGRlYm91bmNlKVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEZWJvdW5jZWRTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gcmVjb21wdXRlIGFsbCBjb29yZGluYXRlcywgYnV0ICpvbmx5KiBpZiB0aGlzIGlzICpub3QqIHBhcnQgb2Ygb3VyIHNjcm9sbGluZyBhbmltYXRpb25cclxuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbEVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiBzY3JvbGxpbmcgaGFzIHN0b3BwZWQsIHdoZXRoZXIgdGhyb3VnaCBhdXRvIHNjcm9sbCwgb3IgdGhlIHVzZXIgc2Nyb2xsaW5nXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZVNjcm9sbEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRHJhZ0xpc3RlbmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnTGlzdGVuZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRHJhZ0xpc3RlbmVyKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG4vKlxyXG5BIHNldCBvZiByZW5kZXJpbmcgYW5kIGRhdGUtcmVsYXRlZCBtZXRob2RzIGZvciBhIHZpc3VhbCBjb21wb25lbnQgY29tcHJpc2VkIG9mIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNvbHVtbnMuXHJcblByZXJlcXVpc2l0ZTogdGhlIG9iamVjdCBiZWluZyBtaXhlZCBpbnRvIG5lZWRzIHRvIGJlIGEgKkdyaWQqXHJcbiovXHJcbnZhciBEYXlUYWJsZU1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5VGFibGVNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheVRhYmxlTWl4aW4oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuYnJlYWtPbldlZWtzID0gZmFsc2U7IC8vIHNob3VsZCBjcmVhdGUgYSBuZXcgcm93IGZvciBlYWNoIHdlZWs/XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUG9wdWxhdGVzIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIGZvciBkYXRlIGNhbGN1bGF0aW9uIGFuZCByZW5kZXJpbmdcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnVwZGF0ZURheVRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHQudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBkYXRlID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgZW5kID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRheUluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGRheUluZGljZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5RGF0ZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5c1BlclJvdztcclxuICAgICAgICB2YXIgZmlyc3REYXk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICB3aGlsZSAoZGF0ZS5pc0JlZm9yZShlbmQpKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3LmlzSGlkZGVuRGF5KGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRheUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICBkYXlJbmRpY2VzLnB1c2goZGF5SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGF5RGF0ZXMucHVzaChkYXRlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRhdGUuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJyZWFrT25XZWVrcykge1xyXG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXHJcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF5RGF0ZXNbMF0uZGF5KCk7XHJcbiAgICAgICAgICAgIGZvciAoZGF5c1BlclJvdyA9IDE7IGRheXNQZXJSb3cgPCBkYXlEYXRlcy5sZW5ndGg7IGRheXNQZXJSb3crKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRheURhdGVzW2RheXNQZXJSb3ddLmRheSgpID09IGZpcnN0RGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93Q250ID0gTWF0aC5jZWlsKGRheURhdGVzLmxlbmd0aCAvIGRheXNQZXJSb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcm93Q250ID0gMTtcclxuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRheURhdGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xyXG4gICAgICAgIHRoaXMuZGF5SW5kaWNlcyA9IGRheUluZGljZXM7XHJcbiAgICAgICAgdGhpcy5kYXlzUGVyUm93ID0gZGF5c1BlclJvdztcclxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcclxuICAgICAgICB0aGlzLnVwZGF0ZURheVRhYmxlQ29scygpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuZCBhc3NpZ25lZCB0aGUgY29sQ250IHByb3BlcnR5IGFuZCB1cGRhdGVzIGFueSBvcHRpb25zIHRoYXQgbWF5IGJlIGNvbXB1dGVkIGZyb20gaXRcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnVwZGF0ZURheVRhYmxlQ29scyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENudCA9IHRoaXMuY29tcHV0ZUNvbENudCgpO1xyXG4gICAgICAgIHRoaXMuY29sSGVhZEZvcm1hdCA9IHRoaXMub3B0KCdjb2x1bW5Gb3JtYXQnKSB8fCB0aGlzLmNvbXB1dGVDb2xIZWFkRm9ybWF0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGV0ZXJtaW5lcyBob3cgbWFueSBjb2x1bW5zIHRoZXJlIHNob3VsZCBiZSBpbiB0aGUgdGFibGVcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmNvbXB1dGVDb2xDbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5c1BlclJvdztcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgYW1iaWd1b3VzbHktdGltZWQgbW9tZW50IGZvciB0aGUgZ2l2ZW4gY2VsbFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q2VsbERhdGUgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXlEYXRlc1t0aGlzLmdldENlbGxEYXlJbmRleChyb3csIGNvbCldLmNsb25lKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGFtYmlndW91c2x5LXRpbWVkIGRhdGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBjZWxsXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDZWxsUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcclxuICAgICAgICB2YXIgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheSBjZWxscywgY2hyb25vbG9naWNhbGx5LCBmcm9tIHRoZSBmaXJzdCBvZiB0aGUgZ3JpZCAoMC1iYXNlZClcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENlbGxEYXlJbmRleCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiByb3cgKiB0aGlzLmRheXNQZXJSb3cgKyB0aGlzLmdldENvbERheUluZGV4KGNvbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtbmVyIG9mIGRheSBjZWxscywgY2hyb25vbG9naWNhbGx5LCBmcm9tIHRoZSBmaXJzdCBjZWxsIGluICphbnkgZ2l2ZW4gcm93KlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q29sRGF5SW5kZXggPSBmdW5jdGlvbiAoY29sKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sQ250IC0gMSAtIGNvbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2w7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZGF0ZSwgcmV0dXJucyBpdHMgY2hyb25vbG9jaWFsIGNlbGwtaW5kZXggZnJvbSB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgZ3JpZC5cclxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cclxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxyXG4gICAgLy8gSWYgYWZ0ZXIgdGhlIGxhc3Qgb2Zmc2V0LCByZXR1cm5zIGFuIG9mZnNldCBwYXN0IHRoZSBsYXN0IGNlbGwgb2Zmc2V0LlxyXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXREYXRlRGF5SW5kZXggPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXlJbmRpY2VzID0gdGhpcy5kYXlJbmRpY2VzO1xyXG4gICAgICAgIHZhciBkYXlPZmZzZXQgPSBkYXRlLmRpZmYodGhpcy5kYXlEYXRlc1swXSwgJ2RheXMnKTtcclxuICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1swXSAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRheU9mZnNldCA+PSBkYXlJbmRpY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5SW5kaWNlc1tkYXlJbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXlJbmRpY2VzW2RheU9mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIE9wdGlvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5jb21wdXRlQ29sSGVhZEZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBpZiBtb3JlIHRoYW4gb25lIHdlZWsgcm93LCBvciBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgY29sdW1ucyB3aXRoIG5vdCBtdWNoIHNwYWNlLFxyXG4gICAgICAgIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxyXG4gICAgICAgIGlmICh0aGlzLnJvd0NudCA+IDEgfHwgdGhpcy5jb2xDbnQgPiAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZCc7IC8vIFwiU2F0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb2xDbnQgPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdCgnZGF5T2ZNb250aEZvcm1hdCcpOyAvLyBcIlNhdCAxMi8xMFwiXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQnOyAvLyBcIlNhdHVyZGF5XCJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogU2xpY2luZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFNsaWNlcyB1cCBhIGRhdGUgcmFuZ2UgaW50byBhIHNlZ21lbnQgZm9yIGV2ZXJ5IHdlZWstcm93IGl0IGludGVyc2VjdHMgd2l0aFxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5Um93ID0gZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBkYXlzUGVyUm93ID0gdGhpcy5kYXlzUGVyUm93O1xyXG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9IHRoaXMudmlldy5jb21wdXRlRGF5UmFuZ2UodW56b25lZFJhbmdlKTsgLy8gbWFrZSB3aG9sZS1kYXkgcmFuZ2UsIGNvbnNpZGVyaW5nIG5leHREYXlUaHJlc2hvbGRcclxuICAgICAgICB2YXIgcmFuZ2VGaXJzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgdmFyIHJhbmdlTGFzdCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KG5vcm1hbFJhbmdlLmVuZC5jbG9uZSgpLnN1YnRyYWN0KDEsICdkYXlzJykpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgcm93Rmlyc3QsIHJvd0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIGN1cnJlbnQgcm93XHJcbiAgICAgICAgdmFyIHNlZ0ZpcnN0LCBzZWdMYXN0OyAvLyBpbmNsdXNpdmUgZGF5LWluZGV4IHJhbmdlIGZvciBzZWdtZW50XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCB0aGlzLnJvd0NudDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93Rmlyc3QgPSByb3cgKiBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICByb3dMYXN0ID0gcm93Rmlyc3QgKyBkYXlzUGVyUm93IC0gMTtcclxuICAgICAgICAgICAgLy8gaW50ZXJzZWN0IHNlZ21lbnQncyBvZmZzZXQgcmFuZ2Ugd2l0aCB0aGUgcm93J3NcclxuICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLm1heChyYW5nZUZpcnN0LCByb3dGaXJzdCk7XHJcbiAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLm1pbihyYW5nZUxhc3QsIHJvd0xhc3QpO1xyXG4gICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIHNlZ0ZpcnN0ID0gTWF0aC5jZWlsKHNlZ0ZpcnN0KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXHJcbiAgICAgICAgICAgIHNlZ0xhc3QgPSBNYXRoLmZsb29yKHNlZ0xhc3QpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgIGlmIChzZWdGaXJzdCA8PSBzZWdMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJvd0RheUluZGV4OiBzZWdGaXJzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSBkYXktY2VsbCBpdCBpbnRlcnNlY3RzIHdpdGguXHJcbiAgICAvLyBUT0RPOiBtYWtlIG1vcmUgRFJZIHdpdGggc2xpY2VSYW5nZUJ5Um93IHNvbWVob3cuXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5zbGljZVJhbmdlQnlEYXkgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3cgPSB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gdGhpcy52aWV3LmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpOyAvLyBtYWtlIHdob2xlLWRheSByYW5nZSwgY29uc2lkZXJpbmcgbmV4dERheVRocmVzaG9sZFxyXG4gICAgICAgIHZhciByYW5nZUZpcnN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcclxuICAgICAgICB2YXIgcmFuZ2VMYXN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheXMnKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgIHZhciByb3dGaXJzdCwgcm93TGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3IgY3VycmVudCByb3dcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnRmlyc3QsIHNlZ0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIHNlZ21lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICByb3dGaXJzdCA9IHJvdyAqIGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHJvd0xhc3QgPSByb3dGaXJzdCArIGRheXNQZXJSb3cgLSAxO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSByb3dGaXJzdDsgaSA8PSByb3dMYXN0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXHJcbiAgICAgICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIGkpO1xyXG4gICAgICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGgubWluKHJhbmdlTGFzdCwgaSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcclxuICAgICAgICAgICAgICAgIGlmIChzZWdGaXJzdCA8PSBzZWdMYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RSb3dEYXlJbmRleDogc2VnRmlyc3QgLSByb3dGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJvd0RheUluZGV4OiBzZWdMYXN0IC0gcm93Rmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnRmlyc3QgPT09IHJhbmdlRmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdMYXN0ID09PSByYW5nZUxhc3RcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBIZWFkZXIgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZEh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcm93ICcgKyB0aGVtZS5nZXRDbGFzcygnaGVhZGVyUm93JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGUgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlR3JpZCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRoZWFkPicgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhlYWRUckh0bWwoKSArXHJcbiAgICAgICAgICAgICc8L3RoZWFkPicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nICtcclxuICAgICAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTsgLy8gZmFsbCBiYWNrIHRvIGdlbmVyaWNcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJIZWFkVHJIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSkgK1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhlYWREYXRlQ2VsbHNIdG1sKCkgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/IHRoaXMucmVuZGVySGVhZEludHJvSHRtbCgpIDogJycpICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHRtbHMgPSBbXTtcclxuICAgICAgICB2YXIgY29sLCBkYXRlO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKDAsIGNvbCk7XHJcbiAgICAgICAgICAgIGh0bWxzLnB1c2godGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxIdG1sKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IHdoZW4gaW50ZXJuYWxBcGlWZXJzaW9uLCBhY2NlcHQgYW4gb2JqZWN0IGZvciBIVE1MIGF0dHJpYnV0ZXNcclxuICAgIC8vIChjb2xzcGFuIHNob3VsZCBiZSBubyBkaWZmZXJlbnQpXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJIZWFkRGF0ZUNlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUsIGNvbHNwYW4sIG90aGVyQXR0cnMpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdC5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy1kYXktaGVhZGVyJyxcclxuICAgICAgICAgICAgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJylcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBpbm5lckh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZShkYXRlLmZvcm1hdCh0LmNvbEhlYWRGb3JtYXQpKTtcclxuICAgICAgICAvLyBpZiBvbmx5IG9uZSByb3cgb2YgZGF5cywgdGhlIGNsYXNzTmFtZXMgb24gdGhlIGhlYWRlciBjYW4gcmVwcmVzZW50IHRoZSBzcGVjaWZpYyBkYXlzIGJlbmVhdGhcclxuICAgICAgICBpZiAodC5yb3dDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuY29uY2F0KFxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICAgICAgLy8gbm9UaGVtZUhpZ2hsaWdodD10cnVlIChkb24ndCBoaWdobGlnaHQgdGhlIGhlYWRlcilcclxuICAgICAgICAgICAgdC5nZXREYXlDbGFzc2VzKGRhdGUsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtJyArIHV0aWxfMS5kYXlJRHNbZGF0ZS5kYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoKGlzRGF0ZVZhbGlkICYmIHQucm93Q250KSA9PT0gMSA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoY29sc3BhbiA+IDEgP1xyXG4gICAgICAgICAgICAgICAgJyBjb2xzcGFuPVwiJyArIGNvbHNwYW4gKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgYSBsaW5rIGlmIHRoZSBoZWFkaW5nIGNvdWxkIHJlcHJlc2VudCBtdWx0aXBsZSBkYXlzLCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGRheSAoZm9yY2VPZmYpXHJcbiAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoeyBkYXRlOiBkYXRlLCBmb3JjZU9mZjogdC5yb3dDbnQgPiAxIHx8IHQuY29sQ250ID09PSAxIH0sIGlubmVySHRtbCkgOlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHZhbGlkLCBkaXNwbGF5IHRleHQsIGJ1dCBubyBsaW5rXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwpICtcclxuICAgICAgICAgICAgJzwvdGg+JztcclxuICAgIH07XHJcbiAgICAvKiBCYWNrZ3JvdW5kIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnVHJIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ0NlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykgOiAnJykgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpOyAvLyBmYWxsIGJhY2sgdG8gZ2VuZXJpY1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2wsIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyQmdDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ0NlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUsIG90aGVyQXR0cnMpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdC5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0LmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXknLCB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykpO1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6IC8vIGlmIGRhdGUgaGFzIGEgdGltZSwgd29uJ3QgZm9ybWF0IGl0XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAob3RoZXJBdHRycyA/XHJcbiAgICAgICAgICAgICAgICAnICcgKyBvdGhlckF0dHJzIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC90ZD4nO1xyXG4gICAgfTtcclxuICAgIC8qIEdlbmVyaWNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIGRlZmF1bHQgSFRNTCBpbnRybyBmb3IgYW55IHJvdy4gVXNlciBjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE86IGEgZ2VuZXJpYyBtZXRob2QgZm9yIGRlYWxpbmcgd2l0aCA8dHI+LCBSVEwsIGludHJvXHJcbiAgICAvLyB3aGVuIGluY3JlbWVudCBpbnRlcm5hbEFwaVZlcnNpb25cclxuICAgIC8vIHdyYXBUciAoc2NoZWR1bGVyKVxyXG4gICAgLyogVXRpbHNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBBcHBsaWVzIHRoZSBnZW5lcmljIFwiaW50cm9cIiBhbmQgXCJvdXRyb1wiIEhUTUwgdG8gdGhlIGdpdmVuIGNlbGxzLlxyXG4gICAgLy8gSW50cm8gbWVhbnMgdGhlIGxlZnRtb3N0IGNlbGwgd2hlbiB0aGUgY2FsZW5kYXIgaXMgTFRSIGFuZCB0aGUgcmlnaHRtb3N0IGNlbGwgd2hlbiBSVEwuIFZpY2UtdmVyc2EgZm9yIG91dHJvLlxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuYm9va2VuZENlbGxzID0gZnVuY3Rpb24gKHRyRWwpIHtcclxuICAgICAgICB2YXIgaW50cm9IdG1sID0gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTtcclxuICAgICAgICBpZiAoaW50cm9IdG1sKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICB0ckVsLmFwcGVuZChpbnRyb0h0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJFbC5wcmVwZW5kKGludHJvSHRtbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheVRhYmxlTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheVRhYmxlTWl4aW47XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBsZW1lbnRzOlxyXG4gICAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAgIC0gZXZlbnRGb290cHJpbnRzVG9TZWdzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnVzaW5lc3NIb3VyUmVuZGVyZXIoY29tcG9uZW50LCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZpbGxSZW5kZXJlciA9IGZpbGxSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBjb21wb25lbnQuX2dldERhdGVQcm9maWxlKCkuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoY29tcG9uZW50Lmhhc0FsbERheUJ1c2luZXNzSG91cnMsIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IGV2ZW50SW5zdGFuY2VHcm91cCA/XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyh1bnpvbmVkUmFuZ2UpKSA6XHJcbiAgICAgICAgICAgIFtdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2VncyhzZWdzKTtcclxuICAgICAgICB0aGlzLnNlZ3MgPSBzZWdzO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYnVzaW5lc3NIb3VycycsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmYy1ub25idXNpbmVzcycsICdmYy1iZ2V2ZW50J107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdidXNpbmVzc0hvdXJzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnVzaW5lc3NIb3VyUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91clJlbmRlcmVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWxsUmVuZGVyZXIoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5maWxsU2VnVGFnID0gJ2Rpdic7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5lbHNCeUZpbGwgPSB7fTtcclxuICAgIH1cclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRm9vdHByaW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBvbmVudEZvb3RwcmludCwgcHJvcHMpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclNlZ3ModHlwZSwgdGhpcy5jb21wb25lbnQuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKGNvbXBvbmVudEZvb3RwcmludCksIHByb3BzKTtcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2VncywgcHJvcHMpIHtcclxuICAgICAgICB2YXIgZWxzO1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmJ1aWxkU2VnRWxzKHR5cGUsIHNlZ3MsIHByb3BzKTsgLy8gYXNzaWduZXMgYC5lbGAgdG8gZWFjaCBzZWcuIHJldHVybnMgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHNlZ3NcclxuICAgICAgICBlbHMgPSB0aGlzLmF0dGFjaFNlZ0Vscyh0eXBlLCBzZWdzKTtcclxuICAgICAgICBpZiAoZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RWxzKHR5cGUsIGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHNwZWNpZmljIHR5cGUgb2YgZmlsbCB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MsIHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmJ1aWxkU2VnSHRtbCh0eXBlLCBzZWdzW2ldLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC5cclxuICAgICAgICAgICAgJChodG1sKS5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIG1ldGhvZHMgcGVyLXR5cGVcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5maWx0ZXJFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gcHJvcHMuZmlsdGVyRWwoc2VnLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbCA9ICQoZWwpOyAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIHRvIHJldHVybiByYXcgRE9NIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGVsZW1lbnQgdHlwZT8gKHdvdWxkIGJlIGJhZCBpZiBhIG5vbi1URCB3ZXJlIGluc2VydGVkIGludG8gYSB0YWJsZSBmb3IgZXhhbXBsZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuaXMoX3RoaXMuZmlsbFNlZ1RhZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkU2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkU2VncztcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIEhUTUwgbmVlZGVkIGZvciBvbmUgZmlsbCBzZWdtZW50LiBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZFNlZ0h0bWwgPSBmdW5jdGlvbiAodHlwZSwgc2VnLCBwcm9wcykge1xyXG4gICAgICAgIC8vIGN1c3RvbSBob29rcyBwZXItdHlwZVxyXG4gICAgICAgIHZhciBjbGFzc2VzID0gcHJvcHMuZ2V0Q2xhc3NlcyA/IHByb3BzLmdldENsYXNzZXMoc2VnKSA6IFtdO1xyXG4gICAgICAgIHZhciBjc3MgPSB1dGlsXzEuY3NzVG9TdHIocHJvcHMuZ2V0Q3NzID8gcHJvcHMuZ2V0Q3NzKHNlZykgOiB7fSk7XHJcbiAgICAgICAgcmV0dXJuICc8JyArIHRoaXMuZmlsbFNlZ1RhZyArXHJcbiAgICAgICAgICAgIChjbGFzc2VzLmxlbmd0aCA/ICcgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInIDogJycpICtcclxuICAgICAgICAgICAgKGNzcyA/ICcgc3R5bGU9XCInICsgY3NzICsgJ1wiJyA6ICcnKSArXHJcbiAgICAgICAgICAgICcgLz4nO1xyXG4gICAgfTtcclxuICAgIC8vIFNob3VsZCByZXR1cm4gd3JhcHBpbmcgRE9NIHN0cnVjdHVyZVxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlcG9ydEVscyA9IGZ1bmN0aW9uICh0eXBlLCBub2Rlcykge1xyXG4gICAgICAgIGlmICh0aGlzLmVsc0J5RmlsbFt0eXBlXSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsc0J5RmlsbFt0eXBlXSA9IHRoaXMuZWxzQnlGaWxsW3R5cGVdLmFkZChub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVsc0J5RmlsbFt0eXBlXSA9ICQobm9kZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRmlsbFJlbmRlcmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxsUmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgSGVscGVyUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIZWxwZXJSZW5kZXJlcihjb21wb25lbnQsIGV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnZpZXcgPSBjb21wb25lbnQuX2dldFZpZXcoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIgPSBldmVudFJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudEZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhbXHJcbiAgICAgICAgICAgIHRoaXMuZmFicmljYXRlRXZlbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50KVxyXG4gICAgICAgIF0pO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCAnZmMtZHJhZ2dpbmcnLCBpc1RvdWNoID8gbnVsbCA6IHRoaXMudmlldy5vcHQoJ2RyYWdPcGFjaXR5JykpO1xyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCAnZmMtcmVzaXppbmcnKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc291cmNlU2VnLCBleHRyYUNsYXNzTmFtZXMsIG9wYWNpdHkpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gJ2ZjLWhlbHBlciAnICsgKGV4dHJhQ2xhc3NOYW1lcyB8fCAnJyk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gYXNzaWducyBlYWNoIHNlZydzIGVsIGFuZCByZXR1cm5zIGEgc3Vic2V0IG9mIHNlZ3MgdGhhdCB3ZXJlIHJlbmRlcmVkXHJcbiAgICAgICAgc2VncyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ0VscyhzZWdzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzW2ldLmVsLmFkZENsYXNzKGNsYXNzTmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3BhY2l0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzW2ldLmVsLmNzcygnb3BhY2l0eScsIG9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVscGVyRWxzID0gdGhpcy5yZW5kZXJTZWdzKHNlZ3MsIHNvdXJjZVNlZyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE11c3QgcmV0dXJuIGFsbCBtb2NrIGV2ZW50IGVsZW1lbnRzXHJcbiAgICAqL1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgLy8gU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWxwZXJFbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJFbHMucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLmZhYnJpY2F0ZUV2ZW50Rm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMudmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnREYXRlUHJvZmlsZSA9IGNhbGVuZGFyLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB2YXIgZHVtbXlFdmVudCA9IG5ldyBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQobmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHZhciBkdW1teUluc3RhbmNlO1xyXG4gICAgICAgIGR1bW15RXZlbnQuZGF0ZVByb2ZpbGUgPSBldmVudERhdGVQcm9maWxlO1xyXG4gICAgICAgIGR1bW15SW5zdGFuY2UgPSBkdW1teUV2ZW50LmJ1aWxkSW5zdGFuY2UoKTtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50Rm9vdHByaW50XzEuZGVmYXVsdChjb21wb25lbnRGb290cHJpbnQsIGR1bW15RXZlbnQsIGR1bW15SW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBIZWxwZXJSZW5kZXJlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSGVscGVyUmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudFBvaW50aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXZlbnRQb2ludGluZywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UG9pbnRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBtdXN0IGltcGxlbWVudDpcclxuICAgICAgICAtIHB1YmxpY2x5VHJpZ2dlclxyXG4gICAgKi9cclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmJpbmRUb0VsID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZW50ZXInLCB0aGlzLmhhbmRsZU1vdXNlb3Zlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2VsZWF2ZScsIHRoaXMuaGFuZGxlTW91c2VvdXQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHZhciByZXMgPSB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW3NlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSwgZXYsIHRoaXMudmlld11cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocmVzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycyBmb3Igd2hlbiBhbiBldmVudCBlbGVtZW50IGlzIG1vdXNlZCBvdmVyXHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVNb3VzZW92ZXIgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICghR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5tb3VzZWRPdmVyU2VnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VkT3ZlclNlZyA9IHNlZztcclxuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0byBFdmVudFNlbGVjdGluZydzIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlJlc2l6YWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmFkZENsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TW91c2VvdmVyJywge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW3NlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSwgZXYsIHRoaXMudmlld11cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzIGZvciB3aGVuIGFuIGV2ZW50IGVsZW1lbnQgaXMgbW91c2VkIG91dC5cclxuICAgIC8vIENhbiBiZSBnaXZlbiBubyBhcmd1bWVudHMsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBtb3VzZW91dCB0aGUgc2VnbWVudCB0aGF0IHdhcyBwcmV2aW91c2x5IG1vdXNlZCBvdmVyLlxyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VvdXQgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIGlmICh0aGlzLm1vdXNlZE92ZXJTZWcpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZWRPdmVyU2VnID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0byBFdmVudFNlbGVjdGluZydzIHJlc3BvbnNpYmlsaXR5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaXNFdmVudERlZlJlc2l6YWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1hbGxvdy1tb3VzZS1yZXNpemUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TW91c2VvdXQnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2IHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1vdXNlZE92ZXJTZWcpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZW91dCh0aGlzLm1vdXNlZE92ZXJTZWcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRQb2ludGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRQb2ludGluZztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBEYXRlQ2xpY2tpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xyXG52YXIgRGF0ZVNlbGVjdGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XHJcbnZhciBFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxudmFyIEV2ZW50RHJhZ2dpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xyXG52YXIgRXZlbnRSZXNpemluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGFuZGFyZEludGVyYWN0aW9uc01peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbjtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZGF0ZUNsaWNraW5nQ2xhc3MgPSBEYXRlQ2xpY2tpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5kYXRlU2VsZWN0aW5nQ2xhc3MgPSBEYXRlU2VsZWN0aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXZlbnRQb2ludGluZ0NsYXNzID0gRXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV2ZW50RHJhZ2dpbmdDbGFzcyA9IEV2ZW50RHJhZ2dpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5ldmVudFJlc2l6aW5nQ2xhc3MgPSBFdmVudFJlc2l6aW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzID0gRXh0ZXJuYWxEcm9wcGluZ18xLmRlZmF1bHQ7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBQb3BvdmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XHJcbnZhciBEYXlUYWJsZU1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcclxudmFyIERheUdyaWRIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcclxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIGEgZ3JpZCBvZiB3aG9sZS1kYXlzIHRoYXQgcnVucyBob3Jpem9udGFsbHkuIFRoZXJlIGNhbiBiZSBtdWx0aXBsZSByb3dzLCBvbmUgcGVyIHdlZWsuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgRGF5R3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkKHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTsgLy8gZGlzcGxheSB3ZWVrIG51bWJlcnMgaW4gZGF5IGNlbGw/XHJcbiAgICAgICAgX3RoaXMuYm90dG9tQ29vcmRQYWRkaW5nID0gMDsgLy8gaGFjayBmb3IgZXh0ZW5kaW5nIHRoZSBoaXQgYXJlYSBmb3IgdGhlIGxhc3Qgcm93IG9mIHRoZSBjb29yZGluYXRlIGdyaWRcclxuICAgICAgICAvLyBpc1JpZ2lkIGRldGVybWluZXMgd2hldGhlciB0aGUgaW5kaXZpZHVhbCByb3dzIHNob3VsZCBpZ25vcmUgdGhlIGNvbnRlbnRzIGFuZCBiZSBhIGNvbnN0YW50IGhlaWdodC5cclxuICAgICAgICAvLyBSZWxpZXMgb24gdGhlIHZpZXcncyBjb2xDbnQgYW5kIHJvd0NudC4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb21wb25lbnQgc2hvdWxkIHByb2JhYmx5IGJlIHNlbGYtc3VmZmljaWVudC5cclxuICAgICAgICBfdGhpcy5pc1JpZ2lkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuaGFzQWxsRGF5QnVzaW5lc3NIb3VycyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gU2xpY2VzIHVwIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5zbGljZVJhbmdlQnlSb3coY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmxlZnRDb2wgPSB0aGlzLmRheXNQZXJSb3cgLSAxIC0gc2VnLmxhc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgICAgIHNlZy5yaWdodENvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWcuZmlyc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZy5sZWZ0Q29sID0gc2VnLmZpcnN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBzZWcucmlnaHRDb2wgPSBzZWcubGFzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVEYXlUYWJsZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTZWdQb3BvdmVyKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyB0aGUgcm93cyBhbmQgY29sdW1ucyBpbnRvIHRoZSBjb21wb25lbnQncyBgdGhpcy5lbGAsIHdoaWNoIHNob3VsZCBhbHJlYWR5IGJlIGFzc2lnbmVkLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyR3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgcm93Q250ID0gdGhpcy5yb3dDbnQ7XHJcbiAgICAgICAgdmFyIGNvbENudCA9IHRoaXMuY29sQ250O1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHJvdztcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIGlmICh0aGlzLmhlYWRDb250YWluZXJFbCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRDb250YWluZXJFbC5odG1sKHRoaXMucmVuZGVySGVhZEh0bWwoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICBodG1sICs9IHRoaXMucmVuZGVyRGF5Um93SHRtbChyb3csIHRoaXMuaXNSaWdpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuaHRtbChodG1sKTtcclxuICAgICAgICB0aGlzLnJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdycpO1xyXG4gICAgICAgIHRoaXMuY2VsbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5yb3dFbHMsXHJcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUgPSBuZXcgQ29vcmRDYWNoZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBlbHM6IHRoaXMuY2VsbEVscy5zbGljZSgwLCB0aGlzLmNvbENudCksXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIHRyaWdnZXIgZGF5UmVuZGVyIHdpdGggZWFjaCBjZWxsJ3MgZWxlbWVudFxyXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgcm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXlSZW5kZXInLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdmlldyxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIHJvdywgd2hpY2ggaXMgYSBkaXYgdGhhdCB3cmFwcyBhIHRhYmxlLlxyXG4gICAgLy8gYHJvd2AgaXMgdGhlIHJvdyBudW1iZXIuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJEYXlSb3dIdG1sID0gZnVuY3Rpb24gKHJvdywgaXNSaWdpZCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFsnZmMtcm93JywgJ2ZjLXdlZWsnLCB0aGVtZS5nZXRDbGFzcygnZGF5Um93JyldO1xyXG4gICAgICAgIGlmIChpc1JpZ2lkKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcmlnaWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdcIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdUckh0bWwocm93KSArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudC1za2VsZXRvblwiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlPicgK1xyXG4gICAgICAgICAgICAodGhpcy5nZXRJc051bWJlcnNWaXNpYmxlKCkgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck51bWJlclRySHRtbChyb3cpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSgpIHx8IHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRJc0RheU51bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd0NudCA+IDE7XHJcbiAgICB9O1xyXG4gICAgLyogR3JpZCBOdW1iZXIgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyVHJIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlck51bWJlckludHJvSHRtbChyb3cpKSArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTnVtYmVyQ2VsbHNIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/IHRoaXMucmVuZGVyTnVtYmVySW50cm9IdG1sKHJvdykgOiAnJykgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckludHJvSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJJbnRyb0h0bWwoKTtcclxuICAgIH07XHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJDZWxsc0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbCwgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIGh0bWxzLnB1c2godGhpcy5yZW5kZXJOdW1iZXJDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSA8dGQ+cyBvZiB0aGUgXCJudW1iZXJcIiByb3cgaW4gdGhlIERheUdyaWQncyBjb250ZW50IHNrZWxldG9uLlxyXG4gICAgLy8gVGhlIG51bWJlciByb3cgd2lsbCBvbmx5IGV4aXN0IGlmIGVpdGhlciBkYXkgbnVtYmVycyBvciB3ZWVrIG51bWJlcnMgYXJlIHR1cm5lZCBvbi5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckNlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHRoaXMuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBpc0RheU51bWJlclZpc2libGUgPSB0aGlzLmdldElzRGF5TnVtYmVyc1Zpc2libGUoKSAmJiBpc0RhdGVWYWxpZDtcclxuICAgICAgICB2YXIgY2xhc3NlcztcclxuICAgICAgICB2YXIgd2Vla0NhbGNGaXJzdERvVztcclxuICAgICAgICBpZiAoIWlzRGF5TnVtYmVyVmlzaWJsZSAmJiAhdGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG51bWJlcnMgaW4gZGF5IGNlbGwgKHdlZWsgbnVtYmVyIG11c3QgYmUgYWxvbmcgdGhlIHNpZGUpXHJcbiAgICAgICAgICAgIHJldHVybiAnPHRkLz4nOyAvLyAgd2lsbCBjcmVhdGUgYW4gZW1wdHkgc3BhY2UgYWJvdmUgZXZlbnRzIDooXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzZXMgPSB0aGlzLmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktdG9wJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBUbyBkZXRlcm1pbmUgdGhlIGRheSBvZiB3ZWVrIG51bWJlciBjaGFuZ2UgdW5kZXIgSVNPLCB3ZSBjYW5ub3RcclxuICAgICAgICAgICAgLy8gcmVseSBvbiBtb21lbnQuanMgbWV0aG9kcyBzdWNoIGFzIGZpcnN0RGF5T2ZXZWVrKCkgb3Igd2Vla2RheSgpLFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgcmVseSBvbiB0aGUgbG9jYWxlJ3MgZG93IChwb3NzaWJseSBvdmVycmlkZGVuIGJ5XHJcbiAgICAgICAgICAgIC8vIG91ciBmaXJzdERheSBvcHRpb24pLCB3aGljaCBtYXkgbm90IGJlIE1vbmRheS4gV2UgY2Fubm90IGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBkb3csIGJlY2F1c2UgdGhhdCB3b3VsZCBhZmZlY3QgdGhlIGNhbGVuZGFyIHN0YXJ0IGRheSBhcyB3ZWxsLlxyXG4gICAgICAgICAgICBpZiAoZGF0ZS5fbG9jYWxlLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPT09ICdJU08nKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrQ2FsY0ZpcnN0RG9XID0gMTsgLy8gTW9uZGF5IGJ5IElTTyA4NjAxIGRlZmluaXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdlZWtDYWxjRmlyc3REb1cgPSBkYXRlLl9sb2NhbGUuZmlyc3REYXlPZldlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCkgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JztcclxuICAgICAgICBpZiAodGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlICYmIChkYXRlLmRheSgpID09IHdlZWtDYWxjRmlyc3REb1cpKSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKHsgZGF0ZTogZGF0ZSwgdHlwZTogJ3dlZWsnIH0sIHsgJ2NsYXNzJzogJ2ZjLXdlZWstbnVtYmVyJyB9LCBkYXRlLmZvcm1hdCgndycpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGF5TnVtYmVyVmlzaWJsZSkge1xyXG4gICAgICAgICAgICBodG1sICs9IHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbChkYXRlLCB7ICdjbGFzcyc6ICdmYy1kYXktbnVtYmVyJyB9LCBkYXRlLmRhdGUoKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGh0bWwgKz0gJzwvdGQ+JztcclxuICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgIH07XHJcbiAgICAvKiBIaXQgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlLmJvdHRvbXNbdGhpcy5yb3dDbnQgLSAxXSArPSB0aGlzLmJvdHRvbUNvb3JkUGFkZGluZzsgLy8gaGFja1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbENvb3JkQ2FjaGUuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgdGhpcy5yb3dDb29yZENhY2hlLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2YXIgY29sID0gdGhpcy5jb2xDb29yZENhY2hlLmdldEhvcml6b250YWxJbmRleChsZWZ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbEhpdChyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Q2VsbFJhbmdlKGhpdC5yb3csIGhpdC5jb2wpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSwgdHJ1ZSAvLyBhbGwtZGF5P1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbEVsKGhpdC5yb3csIGhpdC5jb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIENlbGwgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEhpdCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICBjb2w6IGNvbCxcclxuICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2wpLFxyXG4gICAgICAgICAgICByaWdodDogdGhpcy5jb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbCksXHJcbiAgICAgICAgICAgIHRvcDogdGhpcy5yb3dDb29yZENhY2hlLmdldFRvcE9mZnNldChyb3cpLFxyXG4gICAgICAgICAgICBib3R0b206IHRoaXMucm93Q29vcmRDYWNoZS5nZXRCb3R0b21PZmZzZXQocm93KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEVsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVscy5lcShyb3cgKiB0aGlzLmNvbENudCArIGNvbCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBldmVudHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8gcmVtb3ZlcyB0aGUgXCJtb3JlLi5cIiBldmVudHMgcG9wb3ZlclxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYWxsIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldE93bkV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBlbmQgdGhlIHNlZ21lbnRzIGZyb20gdGhlIFwibW9yZS4uLlwiIHBvcG92ZXJcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MuY2FsbCh0aGlzKS5jb25jYXQodGhpcy5wb3BvdmVyU2VncyB8fCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cclxuICAgIC8vIGBldmVudExvY2F0aW9uYCBoYXMgem9uZWQgc3RhcnQgYW5kIGVuZCAob3B0aW9uYWwpXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyIGRyYWdzIGZyb20gT1RIRVIgY29tcG9uZW50cyBhcyBoZWxwZXJzXHJcbiAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50cy5sZW5ndGggJiYgc2VnICYmIHNlZy5jb21wb25lbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzaWduYWwgaGVscGVycyByZW5kZXJlZFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgaG92ZXJpbmcgZXZlbnRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIE1vcmUrIExpbmsgUG9wb3ZlclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbW92ZVNlZ1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VnUG9wb3Zlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlZ1BvcG92ZXIuaGlkZSgpOyAvLyBpbiBoYW5kbGVyLCB3aWxsIGNhbGwgc2VnUG9wb3ZlcidzIHJlbW92ZUVsZW1lbnRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTGltaXRzIHRoZSBudW1iZXIgb2YgXCJsZXZlbHNcIiAodmVydGljYWxseSBzdGFja2luZyBsYXllcnMgb2YgZXZlbnRzKSBmb3IgZWFjaCByb3cgb2YgdGhlIGdyaWQuXHJcbiAgICAvLyBgbGV2ZWxMaW1pdGAgY2FuIGJlIGZhbHNlIChkb24ndCBsaW1pdCksIGEgbnVtYmVyLCBvciB0cnVlIChzaG91bGQgYmUgY29tcHV0ZWQpLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3dzID0gZnVuY3Rpb24gKGxldmVsTGltaXQpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3c7IC8vIHJvdyAjXHJcbiAgICAgICAgdmFyIHJvd0xldmVsTGltaXQ7XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dTdHJ1Y3RzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgdGhpcy51bmxpbWl0Um93KHJvdyk7XHJcbiAgICAgICAgICAgIGlmICghbGV2ZWxMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsZXZlbExpbWl0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IGxldmVsTGltaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gdGhpcy5jb21wdXRlUm93TGV2ZWxMaW1pdChyb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyb3dMZXZlbExpbWl0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFJvdyhyb3csIHJvd0xldmVsTGltaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIGEgcm93IHdpbGwgYWNjb21vZGF0ZSB3aXRob3V0IGdvaW5nIG91dHNpZGUgaXRzIGJvdW5kcy5cclxuICAgIC8vIEFzc3VtZXMgdGhlIHJvdyBpcyBcInJpZ2lkXCIgKG1haW50YWlucyBhIGNvbnN0YW50IGhlaWdodCByZWdhcmRsZXNzIG9mIHdoYXQgaXMgaW5zaWRlKS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuY29tcHV0ZVJvd0xldmVsTGltaXQgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIHJvd0VsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gdGhlIGNvbnRhaW5pbmcgXCJmYWtlXCIgcm93IGRpdlxyXG4gICAgICAgIHZhciByb3dIZWlnaHQgPSByb3dFbC5oZWlnaHQoKTsgLy8gVE9ETzogY2FjaGUgc29tZWhvdz9cclxuICAgICAgICB2YXIgdHJFbHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnRib2R5RWwuY2hpbGRyZW4oKTtcclxuICAgICAgICB2YXIgaSwgdHJFbDtcclxuICAgICAgICB2YXIgdHJIZWlnaHQ7XHJcbiAgICAgICAgZnVuY3Rpb24gaXRlcklubmVySGVpZ2h0cyhpLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgdHJIZWlnaHQgPSBNYXRoLm1heCh0ckhlaWdodCwgJChjaGlsZE5vZGUpLm91dGVySGVpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXZlYWwgb25lIGxldmVsIDx0cj4gYXQgYSB0aW1lIGFuZCBzdG9wIHdoZW4gd2UgZmluZCBvbmUgb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ckVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0ckVsID0gdHJFbHMuZXEoaSkucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc3RhdGUgKHJldmVhbClcclxuICAgICAgICAgICAgLy8gd2l0aCByb3dzcGFucz4xIGFuZCBJRTgsIHRyRWwub3V0ZXJIZWlnaHQoKSB3b3VsZCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgbGFyZ2VzdCBjZWxsLFxyXG4gICAgICAgICAgICAvLyBzbyBpbnN0ZWFkLCBmaW5kIHRoZSB0YWxsZXN0IGlubmVyIGNvbnRlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgdHJIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0ckVsLmZpbmQoJz4gdGQgPiA6Zmlyc3QtY2hpbGQnKS5lYWNoKGl0ZXJJbm5lckhlaWdodHMpO1xyXG4gICAgICAgICAgICBpZiAodHJFbC5wb3NpdGlvbigpLnRvcCArIHRySGVpZ2h0ID4gcm93SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHNob3VsZCBub3QgbGltaXQgYXQgYWxsXHJcbiAgICB9O1xyXG4gICAgLy8gTGltaXRzIHRoZSBnaXZlbiBncmlkIHJvdyB0byB0aGUgbWF4aW11bSBudW1iZXIgb2YgbGV2ZWxzIGFuZCBpbmplY3RzIFwibW9yZVwiIGxpbmtzIGlmIG5lY2Vzc2FyeS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgLy8gYGxldmVsTGltaXRgIGlzIGEgbnVtYmVyIGZvciB0aGUgbWF4aW11bSAoaW5jbHVzaXZlKSBudW1iZXIgb2YgbGV2ZWxzIGFsbG93ZWQuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5saW1pdFJvdyA9IGZ1bmN0aW9uIChyb3csIGxldmVsTGltaXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3QgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddO1xyXG4gICAgICAgIHZhciBtb3JlTm9kZXMgPSBbXTsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPGE+IGxpbmtzIGFuZCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgIHZhciBjb2wgPSAwOyAvLyBjb2wgIywgbGVmdC10by1yaWdodCAobm90IGNocm9ub2xvZ2ljYWxseSlcclxuICAgICAgICB2YXIgbGV2ZWxTZWdzOyAvLyBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMgaW4gdGhlIGxhc3QgYWxsb3dhYmxlIGxldmVsLCBvcmRlcmVkIGxlZnQtdG8tcmlnaHRcclxuICAgICAgICB2YXIgY2VsbE1hdHJpeDsgLy8gYSBtYXRyaXggKGJ5IGxldmVsLCB0aGVuIGNvbHVtbikgb2YgYWxsIDx0ZD4galF1ZXJ5IGVsZW1lbnRzIGluIHRoZSByb3dcclxuICAgICAgICB2YXIgbGltaXRlZE5vZGVzOyAvLyBhcnJheSBvZiB0ZW1wb3JhcmlseSBoaWRkZW4gbGV2ZWwgPHRyPiBhbmQgc2VnbWVudCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgdmFyIHNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGJlbG93IGBzZWdgIGluIHRoZSBjdXJyZW50IGBjb2xgXHJcbiAgICAgICAgdmFyIHRvdGFsU2Vnc0JlbG93OyAvLyB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgYmVsb3cgYHNlZ2AgaW4gYW55IG9mIHRoZSBjb2x1bW5zIGBzZWdgIG9jY3VwaWVzXHJcbiAgICAgICAgdmFyIGNvbFNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBhcnJheXMsIGJlbG93IHNlZywgb25lIGZvciBlYWNoIGNvbHVtbiAob2Zmc2V0IGZyb20gc2VncydzIGZpcnN0IGNvbHVtbilcclxuICAgICAgICB2YXIgdGQsIHJvd3NwYW47XHJcbiAgICAgICAgdmFyIHNlZ01vcmVOb2RlczsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPHRkPiBjZWxscyB0aGF0IHdpbGwgc3RhbmQtaW4gZm9yIHRoZSBjdXJyZW50IHNlZydzIGNlbGxcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgbW9yZVRkLCBtb3JlV3JhcCwgbW9yZUxpbms7XHJcbiAgICAgICAgLy8gSXRlcmF0ZXMgdGhyb3VnaCBlbXB0eSBsZXZlbCBjZWxscyBhbmQgcGxhY2VzIFwibW9yZVwiIGxpbmtzIGluc2lkZSBpZiBuZWVkIGJlXHJcbiAgICAgICAgdmFyIGVtcHR5Q2VsbHNVbnRpbCA9IGZ1bmN0aW9uIChlbmRDb2wpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wsIGxldmVsTGltaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZ3NCZWxvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSBfdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIGNvbCwgc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKG1vcmVXcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlTm9kZXMucHVzaChtb3JlV3JhcFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGxldmVsTGltaXQgJiYgbGV2ZWxMaW1pdCA8IHJvd1N0cnVjdC5zZWdMZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldmVsU2VncyA9IHJvd1N0cnVjdC5zZWdMZXZlbHNbbGV2ZWxMaW1pdCAtIDFdO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4ID0gcm93U3RydWN0LmNlbGxNYXRyaXg7XHJcbiAgICAgICAgICAgIGxpbWl0ZWROb2RlcyA9IHJvd1N0cnVjdC50Ym9keUVsLmNoaWxkcmVuKCkuc2xpY2UobGV2ZWxMaW1pdCkgLy8gZ2V0IGxldmVsIDx0cj4gZWxlbWVudHMgcGFzdCB0aGUgbGltaXRcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmdldCgpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhvdWdoIHNlZ21lbnRzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoc2VnLmxlZnRDb2wpOyAvLyBwcm9jZXNzIGVtcHR5IGNlbGxzIGJlZm9yZSB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lICphbGwqIHNlZ21lbnRzIGJlbG93IGBzZWdgIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGNvbHVtbnNcclxuICAgICAgICAgICAgICAgIGNvbFNlZ3NCZWxvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdG90YWxTZWdzQmVsb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cucHVzaChzZWdzQmVsb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2Vnc0JlbG93ICs9IHNlZ3NCZWxvdy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG90YWxTZWdzQmVsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW3NlZy5sZWZ0Q29sXTsgLy8gdGhlIHNlZ21lbnQncyBwYXJlbnQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgIHJvd3NwYW4gPSB0ZC5hdHRyKCdyb3dzcGFuJykgfHwgMTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgcmVwbGFjZW1lbnQgPHRkPiBmb3IgZWFjaCBjb2x1bW4gdGhlIHNlZ21lbnQgb2NjdXBpZXMuIHdpbGwgYmUgb25lIGZvciBlYWNoIGNvbHNwYW5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29sU2Vnc0JlbG93Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZCA9ICQoJzx0ZCBjbGFzcz1cImZjLW1vcmUtY2VsbFwiLz4nKS5hdHRyKCdyb3dzcGFuJywgcm93c3Bhbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ3NCZWxvdyA9IGNvbFNlZ3NCZWxvd1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSB0aGlzLnJlbmRlck1vcmVMaW5rKHJvdywgc2VnLmxlZnRDb2wgKyBqLCBbc2VnXS5jb25jYXQoc2Vnc0JlbG93KSAvLyBjb3VudCBzZWcgYXMgaGlkZGVuIHRvb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlV3JhcCA9ICQoJzxkaXYvPicpLmFwcGVuZChtb3JlTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZC5hcHBlbmQobW9yZVdyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmFmdGVyKCQoc2VnTW9yZU5vZGVzKSk7IC8vIGhpZGUgb3JpZ2luYWwgPHRkPiBhbmQgaW5qZWN0IHJlcGxhY2VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ZWROb2Rlcy5wdXNoKHRkWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwodGhpcy5jb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSBsZXZlbFxyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscyA9ICQobW9yZU5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9ICQobGltaXRlZE5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cclxuICAgIC8vIGByb3dgIGlzIGEgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnVubGltaXRSb3cgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd107XHJcbiAgICAgICAgaWYgKHJvd1N0cnVjdC5tb3JlRWxzKSB7XHJcbiAgICAgICAgICAgIHJvd1N0cnVjdC5tb3JlRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3dTdHJ1Y3QubGltaXRlZEVscykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscy5yZW1vdmVDbGFzcygnZmMtbGltaXRlZCcpO1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW4gPGE+IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGhpZGRlbiBldmVudCBlbGVtZW50IGZvciBhIGNlbGwuXHJcbiAgICAvLyBSZXNwb25zaWJsZSBmb3IgYXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgYXMgd2VsbC5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck1vcmVMaW5rID0gZnVuY3Rpb24gKHJvdywgY29sLCBoaWRkZW5TZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJCgnPGEgY2xhc3M9XCJmYy1tb3JlXCIvPicpXHJcbiAgICAgICAgICAgIC50ZXh0KHRoaXMuZ2V0TW9yZUxpbmtUZXh0KGhpZGRlblNlZ3MubGVuZ3RoKSlcclxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgY2xpY2tPcHRpb24gPSBfdGhpcy5vcHQoJ2V2ZW50TGltaXRDbGljaycpO1xyXG4gICAgICAgICAgICB2YXIgZGF0ZSA9IF90aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcclxuICAgICAgICAgICAgdmFyIG1vcmVFbCA9ICQoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciBkYXlFbCA9IF90aGlzLmdldENlbGxFbChyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIHZhciBhbGxTZWdzID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wpO1xyXG4gICAgICAgICAgICAvLyByZXNjb3BlIHRoZSBzZWdtZW50cyB0byBiZSB3aXRoaW4gdGhlIGNlbGwncyBkYXRlXHJcbiAgICAgICAgICAgIHZhciByZXNsaWNlZEFsbFNlZ3MgPSBfdGhpcy5yZXNsaWNlRGF5U2VncyhhbGxTZWdzLCBkYXRlKTtcclxuICAgICAgICAgICAgdmFyIHJlc2xpY2VkSGlkZGVuU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGhpZGRlblNlZ3MsIGRhdGUpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIGF0b21pYyBvcHRpb25cclxuICAgICAgICAgICAgICAgIGNsaWNrT3B0aW9uID0gX3RoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudExpbWl0Q2xpY2snLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdmlldyxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IGRhdGUuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsOiBkYXlFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVFbDogbW9yZUVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnczogcmVzbGljZWRBbGxTZWdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuU2VnczogcmVzbGljZWRIaWRkZW5TZWdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNsaWNrT3B0aW9uID09PSAncG9wb3ZlcicpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNob3dTZWdQb3BvdmVyKHJvdywgY29sLCBtb3JlRWwsIHJlc2xpY2VkQWxsU2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNsaWNrT3B0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmlldy5jYWxlbmRhci56b29tVG8oZGF0ZSwgY2xpY2tPcHRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV2ZWFscyB0aGUgcG9wb3ZlciB0aGF0IGRpc3BsYXlzIGFsbCBldmVudHMgd2l0aGluIGEgY2VsbFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuc2hvd1NlZ1BvcG92ZXIgPSBmdW5jdGlvbiAocm93LCBjb2wsIG1vcmVMaW5rLCBzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgbW9yZVdyYXAgPSBtb3JlTGluay5wYXJlbnQoKTsgLy8gdGhlIDxkaXY+IHdyYXBwZXIgYXJvdW5kIHRoZSA8YT5cclxuICAgICAgICB2YXIgdG9wRWw7IC8vIHRoZSBlbGVtZW50IHdlIHdhbnQgdG8gbWF0Y2ggdGhlIHRvcCBjb29yZGluYXRlIG9mXHJcbiAgICAgICAgdmFyIG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHRoaXMucm93Q250ID09IDEpIHtcclxuICAgICAgICAgICAgdG9wRWwgPSB2aWV3LmVsOyAvLyB3aWxsIGNhdXNlIHRoZSBwb3BvdmVyIHRvIGNvdmVyIGFueSBzb3J0IG9mIGhlYWRlclxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdG9wRWwgPSB0aGlzLnJvd0Vscy5lcShyb3cpOyAvLyB3aWxsIGFsaWduIHdpdGggdG9wIG9mIHJvd1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmYy1tb3JlLXBvcG92ZXIgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcclxuICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTZWdQb3BvdmVyQ29udGVudChyb3csIGNvbCwgc2VncyksXHJcbiAgICAgICAgICAgIHBhcmVudEVsOiB2aWV3LmVsLFxyXG4gICAgICAgICAgICB0b3A6IHRvcEVsLm9mZnNldCgpLnRvcCxcclxuICAgICAgICAgICAgYXV0b0hpZGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZpZXdwb3J0Q29uc3RyYWluOiB0aGlzLm9wdCgncG9wb3ZlclZpZXdwb3J0Q29uc3RyYWluJyksXHJcbiAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGtpbGwgZXZlcnl0aGluZyB3aGVuIHRoZSBwb3BvdmVyIGlzIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IGV2ZW50cyB0byBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucG9wb3ZlclNlZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkKF90aGlzLnBvcG92ZXJTZWdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXIucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3ZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wb3BvdmVyU2VncyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIERldGVybWluZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXHJcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBtb3JlV3JhcCBpbnN0ZWFkIG9mIHRoZSA8dGQ+IHRvIGF2b2lkIGJvcmRlciBjb25mdXNpb24uXHJcbiAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yaWdodCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgKyBtb3JlV3JhcC5vdXRlcldpZHRoKCkgKyAxOyAvLyArMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLmxlZnQgPSBtb3JlV3JhcC5vZmZzZXQoKS5sZWZ0IC0gMTsgLy8gLTEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlZ1BvcG92ZXIgPSBuZXcgUG9wb3Zlcl8xLmRlZmF1bHQob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5zZWdQb3BvdmVyLnNob3coKTtcclxuICAgICAgICAvLyB0aGUgcG9wb3ZlciBkb2Vzbid0IGxpdmUgd2l0aGluIHRoZSBncmlkJ3MgY29udGFpbmVyIGVsZW1lbnQsIGFuZCB0aHVzIHdvbid0IGdldCB0aGUgZXZlbnRcclxuICAgICAgICAvLyBkZWxlZ2F0ZWQtaGFuZGxlcnMgZm9yIGZyZWUuIGF0dGFjaCBldmVudC1yZWxhdGVkIGhhbmRsZXJzIHRvIHRoZSBwb3BvdmVyLlxyXG4gICAgICAgIHRoaXMuYmluZEFsbFNlZ0hhbmRsZXJzVG9FbCh0aGlzLnNlZ1BvcG92ZXIuZWwpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckFmdGVyRXZlbnRTZWdzUmVuZGVyZWQoc2Vncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBpbm5lciBET00gY29udGVudHMgb2YgdGhlIHNlZ21lbnQgcG9wb3ZlclxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQgPSBmdW5jdGlvbiAocm93LCBjb2wsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgdGhlbWUgPSB2aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpLmZvcm1hdCh0aGlzLm9wdCgnZGF5UG9wb3ZlckZvcm1hdCcpKTtcclxuICAgICAgICB2YXIgY29udGVudCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLWNsb3NlICcgKyB0aGVtZS5nZXRJY29uQ2xhc3MoJ2Nsb3NlJykgKyAnXCI+PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZSh0aXRsZSkgK1xyXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgICAgICB2YXIgc2VnQ29udGFpbmVyID0gY29udGVudC5maW5kKCcuZmMtZXZlbnQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gcmVuZGVyIGVhY2ggc2VnJ3MgYGVsYCBhbmQgb25seSByZXR1cm4gdGhlIHZpc2libGUgc2Vnc1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyRmdTZWdFbHMoc2VncywgdHJ1ZSk7IC8vIGRpc2FibGVSZXNpemluZz10cnVlXHJcbiAgICAgICAgdGhpcy5wb3BvdmVyU2VncyA9IHNlZ3M7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBzZWdtZW50cyBpbiB0aGUgcG9wb3ZlciBhcmUgbm90IHBhcnQgb2YgYSBncmlkIGNvb3JkaW5hdGUgc3lzdGVtLCBwcm92aWRlIGEgaGludCB0byBhbnlcclxuICAgICAgICAgICAgLy8gZ3JpZHMgdGhhdCB3YW50IHRvIGRvIGRyYWctbi1kcm9wIGFib3V0IHdoaWNoIGNlbGwgaXQgY2FtZSBmcm9tXHJcbiAgICAgICAgICAgIHRoaXMuaGl0c05lZWRlZCgpO1xyXG4gICAgICAgICAgICBzZWdzW2ldLmhpdCA9IHRoaXMuZ2V0Q2VsbEhpdChyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0c05vdE5lZWRlZCgpO1xyXG4gICAgICAgICAgICBzZWdDb250YWluZXIuYXBwZW5kKHNlZ3NbaV0uZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiB0aGUgZXZlbnRzIHdpdGhpbiBhbiBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMsIHJlc2xpY2UgdGhlbSB0byBiZSBpbiBhIHNpbmdsZSBkYXlcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlc2xpY2VEYXlTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGRheURhdGUpIHtcclxuICAgICAgICB2YXIgZGF5U3RhcnQgPSBkYXlEYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdmFyIGRheUVuZCA9IGRheVN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgdmFyIGRheVJhbmdlID0gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5U3RhcnQsIGRheUVuZCk7XHJcbiAgICAgICAgdmFyIG5ld1NlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaSwgc2VnO1xyXG4gICAgICAgIHZhciBzbGljZWRSYW5nZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzbGljZWRSYW5nZSA9IHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5pbnRlcnNlY3QoZGF5UmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NlZ3MucHVzaCgkLmV4dGVuZCh7fSwgc2VnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9vdHByaW50OiBuZXcgRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KHNsaWNlZFJhbmdlLCBzZWcuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSksIHNlZy5mb290cHJpbnQuZXZlbnREZWYsIHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2UuaXNTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmlzRW5kXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yY2UgYW4gb3JkZXIgYmVjYXVzZSBldmVudHNUb1NlZ3MgZG9lc24ndCBndWFyYW50ZWUgb25lXHJcbiAgICAgICAgLy8gVE9ETzogcmVzZWFyY2ggaWYgc3RpbGwgbmVlZGVkXHJcbiAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnNvcnRFdmVudFNlZ3MobmV3U2Vncyk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1NlZ3M7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGluc2lkZSBhIFwibW9yZVwiIGxpbmssIGdpdmVuIHRoZSBudW1iZXIgb2YgZXZlbnRzIGl0IHJlcHJlc2VudHNcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldE1vcmVMaW5rVGV4dCA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICB2YXIgb3B0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXRUZXh0Jyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdChudW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICcrJyArIG51bSArICcgJyArIG9wdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBzZWdtZW50cyB3aXRoaW4gYSBnaXZlbiBjZWxsLlxyXG4gICAgLy8gSWYgYHN0YXJ0TGV2ZWxgIGlzIHNwZWNpZmllZCwgcmV0dXJucyBvbmx5IGV2ZW50cyBpbmNsdWRpbmcgYW5kIGJlbG93IHRoYXQgbGV2ZWwuIE90aGVyd2lzZSByZXR1cm5zIGFsbCBzZWdzLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbFNlZ3MgPSBmdW5jdGlvbiAocm93LCBjb2wsIHN0YXJ0TGV2ZWwpIHtcclxuICAgICAgICB2YXIgc2VnTWF0cml4ID0gdGhpcy5ldmVudFJlbmRlcmVyLnJvd1N0cnVjdHNbcm93XS5zZWdNYXRyaXg7XHJcbiAgICAgICAgdmFyIGxldmVsID0gc3RhcnRMZXZlbCB8fCAwO1xyXG4gICAgICAgIHZhciBzZWdzID0gW107XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB3aGlsZSAobGV2ZWwgPCBzZWdNYXRyaXgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ01hdHJpeFtsZXZlbF1bY29sXTtcclxuICAgICAgICAgICAgaWYgKHNlZykge1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV2ZWwrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWQ7XHJcbn0oSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkO1xyXG5EYXlHcmlkLnByb3RvdHlwZS5ldmVudFJlbmRlcmVyQ2xhc3MgPSBEYXlHcmlkRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmJ1c2luZXNzSG91clJlbmRlcmVyQ2xhc3MgPSBCdXNpbmVzc0hvdXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmhlbHBlclJlbmRlcmVyQ2xhc3MgPSBEYXlHcmlkSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5EYXlHcmlkLnByb3RvdHlwZS5maWxsUmVuZGVyZXJDbGFzcyA9IERheUdyaWRGaWxsUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEuZGVmYXVsdC5taXhJbnRvKERheUdyaWQpO1xyXG5EYXlUYWJsZU1peGluXzEuZGVmYXVsdC5taXhJbnRvKERheUdyaWQpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFNjcm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxudmFyIFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzApO1xyXG52YXIgQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xyXG52YXIgRGF5R3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XHJcbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgXCJiYXNpY1wiIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgRGF5R3JpZCBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cclxuLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxudmFyIEJhc2ljVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJhc2ljVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2ljVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhciwgdmlld1NwZWMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IF90aGlzLmluc3RhbnRpYXRlRGF5R3JpZCgpO1xyXG4gICAgICAgIF90aGlzLmRheUdyaWQuaXNSaWdpZCA9IF90aGlzLmhhc1JpZ2lkUm93cygpO1xyXG4gICAgICAgIGlmIChfdGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnNXaXRoaW5EYXlzJykpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5kYXlHcmlkKTtcclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMuZGF5R3JpZENsYXNzXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlRGF5R3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBhIHN1YmNsYXNzIG9uIHRoZSBmbHkgd2l0aCBCYXNpY1ZpZXctc3BlY2lmaWMgYmVoYXZpb3JcclxuICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGlzIHN1YmNsYXNzXHJcbiAgICAgICAgdmFyIHN1YmNsYXNzID0gbWFrZURheUdyaWRTdWJjbGFzcyh0aGlzLmRheUdyaWRDbGFzcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXlHcmlkLmJyZWFrT25XZWVrcyA9IC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlci5jYWxsKHRoaXMsIGRhdGVQcm9maWxlKTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXlHcmlkQ29udGFpbmVyRWw7XHJcbiAgICAgICAgdmFyIGRheUdyaWRFbDtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1iYXNpYy12aWV3JykuaHRtbCh0aGlzLnJlbmRlclNrZWxldG9uSHRtbCgpKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGRheUdyaWRDb250YWluZXJFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLWRheS1ncmlkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIGRheUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiIC8+JykuYXBwZW5kVG8oZGF5R3JpZENvbnRhaW5lckVsKTtcclxuICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZChkYXlHcmlkQ29udGFpbmVyRWwpO1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5oZWFkQ29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KGRheUdyaWRFbCk7XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cclxuICAgIC8vIFRoZSBkYXktZ3JpZCBjb21wb25lbnQgd2lsbCByZW5kZXIgaW5zaWRlIG9mIGEgY29udGFpbmVyIGRlZmluZWQgYnkgdGhpcyBIVE1MLlxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbkh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XHJcbiAgICAgICAgICAgICAgICAnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj48L3RkPicgK1xyXG4gICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgJzwvdGJvZHk+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIGFuIEhUTUwgYXR0cmlidXRlIHN0cmluZyBmb3Igc2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIHdlZWsgbnVtYmVyIGNvbHVtbiwgaWYgaXQgaXMga25vd25cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUud2Vla051bWJlclN0eWxlQXR0ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyV2lkdGggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N0eWxlPVwid2lkdGg6JyArIHRoaXMud2Vla051bWJlcldpZHRoICsgJ3B4XCInO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGVhY2ggcm93IHNob3VsZCBoYXZlIGEgY29uc3RhbnQgaGVpZ2h0XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmhhc1JpZ2lkUm93cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInO1xyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZWZyZXNoZXMgdGhlIGhvcml6b250YWwgZGltZW5zaW9ucyBvZiB0aGUgdmlld1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgIHZhciBoZWFkUm93RWwgPSB0aGlzLmRheUdyaWQuaGVhZENvbnRhaW5lckVsLmZpbmQoJy5mYy1yb3cnKTtcclxuICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRocztcclxuICAgICAgICAvLyBoYWNrIHRvIGdpdmUgdGhlIHZpZXcgc29tZSBoZWlnaHQgcHJpb3IgdG8gZGF5R3JpZCdzIGNvbHVtbnMgYmVpbmcgcmVuZGVyZWRcclxuICAgICAgICAvLyBUT0RPOiBzZXBhcmF0ZSBzZXR0aW5nIGhlaWdodCBmcm9tIHNjcm9sbGVyIFZTIGRheUdyaWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmRheUdyaWQucm93RWxzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIHdlZWsgbnVtYmVyIGNlbGxzIHJ1bm5pbmcgZG93biB0aGUgc2lkZSBoYXZlIHRoZSBzYW1lIHdpZHRoLlxyXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHdpZHRoIGZvciBjZWxscyBjcmVhdGVkIGxhdGVyLlxyXG4gICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJXaWR0aCA9IHV0aWxfMS5tYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtd2Vlay1udW1iZXInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc2V0IGFsbCBoZWlnaHRzIHRvIGJlIG5hdHVyYWxcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmNsZWFyKCk7XHJcbiAgICAgICAgdXRpbF8xLnVuY29tcGVuc2F0ZVNjcm9sbChoZWFkUm93RWwpO1xyXG4gICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXHJcbiAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGEgY29uc3RhbnQgbGV2ZWwgbnVtYmVyP1xyXG4gICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpOyAvLyBsaW1pdCB0aGUgbGV2ZWxzIGZpcnN0IHNvIHRoZSBoZWlnaHQgY2FuIHJlZGlzdHJpYnV0ZSBhZnRlclxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaXN0cmlidXRlIHRoZSBoZWlnaHQgdG8gdGhlIHJvd3NcclxuICAgICAgICAvLyAodG90YWxIZWlnaHQgaXMgYSBcInJlY29tbWVuZGVkXCIgdmFsdWUgaWYgaXNBdXRvKVxyXG4gICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc2V0R3JpZEhlaWdodChzY3JvbGxlckhlaWdodCwgaXNBdXRvKTtcclxuICAgICAgICAvLyBpcyB0aGUgZXZlbnQgbGltaXQgZHluYW1pY2FsbHkgY2FsY3VsYXRlZD9cclxuICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBhZnRlciB0aGUgZ3JpZCdzIHJvdyBoZWlnaHRzIGhhdmUgYmVlbiBzZXRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICBzY3JvbGxiYXJXaWR0aHMgPSB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGhzLmxlZnQgfHwgc2Nyb2xsYmFyV2lkdGhzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuY29tcGVuc2F0ZVNjcm9sbChoZWFkUm93RWwsIHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2luZyB0aGUgc2Nyb2xsYmFyIGNvbXBlbnNhdGlvbiBtaWdodCBoYXZlIGNyZWF0ZWQgdGV4dCBvdmVyZmxvdyB3aGljaCBjcmVhdGVkIG1vcmUgaGVpZ2h0LiByZWRvXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVzIHRoZSBzYW1lIHNjcm9sbGJhciB3aWR0aHNcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5sb2NrT3ZlcmZsb3coc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5jb21wdXRlU2Nyb2xsZXJIZWlnaHQgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdG90YWxIZWlnaHQgLVxyXG4gICAgICAgICAgICB1dGlsXzEuc3VidHJhY3RJbm5lckVsSGVpZ2h0KHRoaXMuZWwsIHRoaXMuc2Nyb2xsZXIuZWwpOyAvLyBldmVyeXRoaW5nIHRoYXQncyBOT1QgdGhlIHNjcm9sbGVyXHJcbiAgICB9O1xyXG4gICAgLy8gU2V0cyB0aGUgaGVpZ2h0IG9mIGp1c3QgdGhlIERheUdyaWQgY29tcG9uZW50IGluIHRoaXMgdmlld1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5zZXRHcmlkSGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCwgaXNBdXRvKSB7XHJcbiAgICAgICAgaWYgKGlzQXV0bykge1xyXG4gICAgICAgICAgICB1dGlsXzEudW5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMpOyAvLyBsZXQgdGhlIHJvd3MgYmUgdGhlaXIgbmF0dXJhbCBoZWlnaHQgd2l0aCBubyBleHBhbmRpbmdcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgdHJ1ZSk7IC8vIHRydWUgPSBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogMCB9O1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUucXVlcnlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy5zY3JvbGxlci5nZXRTY3JvbGxUb3AoKSB9O1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUuYXBwbHlEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwudG9wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRTY3JvbGxUb3Aoc2Nyb2xsLnRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBCYXNpY1ZpZXc7XHJcbn0oVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzaWNWaWV3O1xyXG5CYXNpY1ZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQ7XHJcbkJhc2ljVmlldy5wcm90b3R5cGUuZGF5R3JpZENsYXNzID0gRGF5R3JpZF8xLmRlZmF1bHQ7XHJcbi8vIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIEJhc2ljVmlldydzIGRheUdyaWRcclxuZnVuY3Rpb24gbWFrZURheUdyaWRTdWJjbGFzcyhTdXBlckNsYXNzKSB7XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKFN1YkNsYXNzLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFN1YkNsYXNzKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAgICAgX3RoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7IC8vIGRpc3BsYXkgd2VlayBudW1iZXJzIGFsb25nIHRoZSBzaWRlP1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIHRoZSBkYXktb2Ygd2VlayBoZWFkZXIgY2VsbHNcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVySGVhZEludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyAvLyBuZWVkZWQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHRoaXMub3B0KCd3ZWVrTnVtYmVyVGl0bGUnKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGg+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSBjb250ZW50LXNrZWxldG9uIGNlbGxzIHRoYXQgZGlzcGxheSB0aGUgZGF5L3dlZWsgbnVtYmVyc1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICB2YXIgd2Vla1N0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZShyb3csIDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoLy8gYXNpZGUgZnJvbSBsaW5rLCBpbXBvcnRhbnQgZm9yIG1hdGNoQ2VsbFdpZHRoc1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZGF0ZTogd2Vla1N0YXJ0LCB0eXBlOiAnd2VlaycsIGZvcmNlT2ZmOiB0aGlzLmNvbENudCA9PT0gMSB9LCB3ZWVrU3RhcnQuZm9ybWF0KCd3JykgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGRheSBiZyBjZWxscyBmb3IgZWFjaCBkYXktcm93XHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBldmVyeSBvdGhlciB0eXBlIG9mIHJvdyBnZW5lcmF0ZWQgYnkgRGF5R3JpZC5cclxuICAgICAgICAvLyBBZmZlY3RzIGhlbHBlci1za2VsZXRvbiBhbmQgaGlnaGxpZ2h0LXNrZWxldG9uIHJvd3MuXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy13ZWVrLW51bWJlclwiICcgKyB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5nZXRJc051bWJlcnNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRGF5R3JpZF8xLmRlZmF1bHQucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTdWJDbGFzcztcclxuICAgIH0oU3VwZXJDbGFzcykpO1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBJdGVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBUb29sYmFyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcclxudmFyIE9wdGlvbnNNYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcclxudmFyIFZpZXdTcGVjTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XHJcbnZhciBDb25zdHJhaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIEV2ZW50TWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XHJcbnZhciBCdXNpbmVzc0hvdXJHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIFRoZW1lUmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgQ2FsZW5kYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDYWxlbmRhcihlbCwgb3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkaW5nTGV2ZWwgPSAwOyAvLyBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzIGxvYWRpbmcgdGFza3NcclxuICAgICAgICB0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplID0gMDtcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHREZXB0aCA9IDA7XHJcbiAgICAgICAgLy8gZGVjbGFyZSB0aGUgY3VycmVudCBjYWxlbmRhciBpbnN0YW5jZSByZWxpZXMgb24gR2xvYmFsRW1pdHRlci4gbmVlZGVkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgLy8gdW5uZWVkZWQoKSBpcyBjYWxsZWQgaW4gZGVzdHJveS5cclxuICAgICAgICBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5uZWVkZWQoKTtcclxuICAgICAgICB0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgdGhpcy52aWV3c0J5VHlwZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIgPSBuZXcgT3B0aW9uc01hbmFnZXJfMS5kZWZhdWx0KHRoaXMsIG92ZXJyaWRlcyk7XHJcbiAgICAgICAgdGhpcy52aWV3U3BlY01hbmFnZXIgPSBuZXcgVmlld1NwZWNNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnNNYW5hZ2VyLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRNb21lbnRJbnRlcm5hbHMoKTsgLy8gbmVlZHMgdG8gaGFwcGVuIGFmdGVyIG9wdGlvbnMgaGFzaCBpbml0aWFsaXplZFxyXG4gICAgICAgIHRoaXMuaW5pdEN1cnJlbnREYXRlKCk7XHJcbiAgICAgICAgdGhpcy5pbml0RXZlbnRNYW5hZ2VyKCk7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IG5ldyBDb25zdHJhaW50c18xLmRlZmF1bHQodGhpcy5ldmVudE1hbmFnZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0ZWQoKTtcclxuICAgIH1cclxuICAgIC8vIHVzZWZ1bCBmb3IgbW9ua2V5cGF0Y2hpbmcuIHVzZWQ/XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldFZpZXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldztcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucHVibGljbHlUcmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIHRyaWdnZXJJbmZvKSB7XHJcbiAgICAgICAgdmFyIG9wdEhhbmRsZXIgPSB0aGlzLm9wdChuYW1lKTtcclxuICAgICAgICB2YXIgY29udGV4dDtcclxuICAgICAgICB2YXIgYXJncztcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHRyaWdnZXJJbmZvKSkge1xyXG4gICAgICAgICAgICBjb250ZXh0ID0gdHJpZ2dlckluZm8uY29udGV4dDtcclxuICAgICAgICAgICAgYXJncyA9IHRyaWdnZXJJbmZvLmFyZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCQuaXNBcnJheSh0cmlnZ2VySW5mbykpIHtcclxuICAgICAgICAgICAgYXJncyA9IHRyaWdnZXJJbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmVsWzBdOyAvLyBmYWxsYmFjayBjb250ZXh0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJncykge1xyXG4gICAgICAgICAgICBhcmdzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJpZ2dlcldpdGgobmFtZSwgY29udGV4dCwgYXJncyk7IC8vIEVtaXR0ZXIncyBtZXRob2RcclxuICAgICAgICBpZiAob3B0SGFuZGxlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0SGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmhhc1B1YmxpY0hhbmRsZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNIYW5kbGVycyhuYW1lKSB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdChuYW1lKTsgLy8gaGFuZGxlciBzcGVjaWZpZWQgaW4gb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIC8vIE9wdGlvbnMgUHVibGljIEFQSVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHB1YmxpYyBnZXR0ZXIvc2V0dGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5ld09wdGlvbkhhc2g7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uSGFzaFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5hZGQobmV3T3B0aW9uSGFzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuYWRkKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBwcml2YXRlIGdldHRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFZpZXdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluc3RhbnRpYXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBzcGVjID0gdGhpcy52aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgc3BlY1snY2xhc3MnXSh0aGlzLCBzcGVjKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSB2aWV3IGlzIG9rYXkgdG8gaW5zdGFudGlhdGUgYXQgc29tZSBwb2ludFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmlzVmFsaWRWaWV3VHlwZSA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbiAodmlld05hbWUsIGRhdGVPclJhbmdlKSB7XHJcbiAgICAgICAgaWYgKGRhdGVPclJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIucmVjb3JkT3ZlcnJpZGVzKHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlUmFuZ2U6IGRhdGVPclJhbmdlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudChkYXRlT3JSYW5nZSkuc3RyaXBab25lKCk7IC8vIGp1c3QgbGlrZSBnb3RvRGF0ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyh2aWV3TmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgIC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnpvb21UbyA9IGZ1bmN0aW9uIChuZXdEYXRlLCB2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBzcGVjO1xyXG4gICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheSc7IC8vIGRheSBpcyBkZWZhdWx0IHpvb21cclxuICAgICAgICBzcGVjID0gdGhpcy52aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWModmlld1R5cGUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9IG5ld0RhdGUuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoc3BlYyA/IHNwZWMudHlwZSA6IG51bGwpO1xyXG4gICAgfTtcclxuICAgIC8vIEN1cnJlbnQgRGF0ZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0Q3VycmVudERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHREYXRlSW5wdXQgPSB0aGlzLm9wdCgnZGVmYXVsdERhdGUnKTtcclxuICAgICAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcclxuICAgICAgICBpZiAoZGVmYXVsdERhdGVJbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1vbWVudChkZWZhdWx0RGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLmdldE5vdygpOyAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHByZXZJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIGlmIChwcmV2SW5mby5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBwcmV2SW5mby5kYXRlO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG5leHRJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIGlmIChuZXh0SW5mby5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBuZXh0SW5mby5kYXRlO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnByZXZZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKC0xLCAneWVhcnMnKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubmV4dFllYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZS5hZGQoMSwgJ3llYXJzJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnRvZGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLmdldE5vdygpOyAvLyBzaG91bGQgZGVueSBsaWtlIHByZXYvbmV4dD9cclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ290b0RhdGUgPSBmdW5jdGlvbiAoem9uZWREYXRlSW5wdXQpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoem9uZWREYXRlSW5wdXQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbmNyZW1lbnREYXRlID0gZnVuY3Rpb24gKGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZS5hZGQobW9tZW50LmR1cmF0aW9uKGRlbHRhKSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gZm9yIGV4dGVybmFsIEFQSVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUaW1lem9uZSh0aGlzLmN1cnJlbnREYXRlKTsgLy8gaW5mdXNlIHRoZSBjYWxlbmRhcidzIHRpbWV6b25lXHJcbiAgICB9O1xyXG4gICAgLy8gTG9hZGluZyBUcmlnZ2VyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gU2hvdWxkIGJlIGNhbGxlZCB3aGVuIGFueSB0eXBlIG9mIGFzeW5jIGRhdGEgZmV0Y2hpbmcgYmVnaW5zXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucHVzaExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5sb2FkaW5nTGV2ZWwrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBbdHJ1ZSwgdGhpcy52aWV3XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGNvbXBsZXRlc1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBvcExvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmxvYWRpbmdMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2xvYWRpbmcnLCBbZmFsc2UsIHRoaXMudmlld10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBIaWdoLWxldmVsIFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRFbCkge1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbGVtZW50VmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIG1haW5seSBmb3IgdGhlIHB1YmxpYyBBUElcclxuICAgICAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0aWFsUmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICBlbC5hZGRDbGFzcygnZmMnKTtcclxuICAgICAgICAvLyBldmVudCBkZWxlZ2F0aW9uIGZvciBuYXYgbGlua3NcclxuICAgICAgICBlbC5vbignY2xpY2suZmMnLCAnYVtkYXRhLWdvdG9dJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBhbmNob3JFbCA9ICQoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIHZhciBnb3RvT3B0aW9ucyA9IGFuY2hvckVsLmRhdGEoJ2dvdG8nKTsgLy8gd2lsbCBhdXRvbWF0aWNhbGx5IHBhcnNlIEpTT05cclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy5tb21lbnQoZ290b09wdGlvbnMuZGF0ZSk7XHJcbiAgICAgICAgICAgIHZhciB2aWV3VHlwZSA9IGdvdG9PcHRpb25zLnR5cGU7XHJcbiAgICAgICAgICAgIC8vIHByb3BlcnR5IGxpa2UgXCJuYXZMaW5rRGF5Q2xpY2tcIi4gbWlnaHQgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICB2YXIgY3VzdG9tQWN0aW9uID0gX3RoaXMudmlldy5vcHQoJ25hdkxpbmsnICsgdXRpbF8xLmNhcGl0YWxpc2VGaXJzdExldHRlcih2aWV3VHlwZSkgKyAnQ2xpY2snKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbihkYXRlLCBldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnpvb21UbyhkYXRlLCB2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB1cG9uIG9wdGlvbiBjaGFuZ2VcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdzZXR0aW5nVGhlbWUnLCBbJz90aGVtZScsICc/dGhlbWVTeXN0ZW0nXSwgZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIHRoZW1lQ2xhc3MgPSBUaGVtZVJlZ2lzdHJ5XzEuZGVmYXVsdC5nZXRUaGVtZUNsYXNzKG9wdHMudGhlbWVTeXN0ZW0gfHwgb3B0cy50aGVtZSk7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZSA9IG5ldyB0aGVtZUNsYXNzKF90aGlzLm9wdGlvbnNNYW5hZ2VyKTtcclxuICAgICAgICAgICAgdmFyIHdpZGdldENsYXNzID0gdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldCcpO1xyXG4gICAgICAgICAgICBfdGhpcy50aGVtZSA9IHRoZW1lO1xyXG4gICAgICAgICAgICBpZiAod2lkZ2V0Q2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGVsLmFkZENsYXNzKHdpZGdldENsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdpZGdldENsYXNzID0gX3RoaXMudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldCcpO1xyXG4gICAgICAgICAgICBfdGhpcy50aGVtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXRDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3Mod2lkZ2V0Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnc2V0dGluZ0J1c2luZXNzSG91ckdlbmVyYXRvcicsIFsnP2J1c2luZXNzSG91cnMnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgX3RoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gbmV3IEJ1c2luZXNzSG91ckdlbmVyYXRvcl8xLmRlZmF1bHQoZGVwcy5idXNpbmVzc0hvdXJzLCBfdGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnNldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJywgX3RoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuYnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjYWxsZWQgaW1tZWRpYXRlbHksIGFuZCB1cG9uIG9wdGlvbiBjaGFuZ2UuXHJcbiAgICAgICAgLy8gSEFDSzogbG9jYWxlIG9mdGVuIGFmZmVjdHMgaXNSVEwsIHNvIHdlIGV4cGxpY2l0bHkgbGlzdGVuIHRvIHRoYXQgdG9vLlxyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIud2F0Y2goJ2FwcGx5aW5nRGlyQ2xhc3NlcycsIFsnP2lzUlRMJywgJz9sb2NhbGUnXSwgZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICAgICAgZWwudG9nZ2xlQ2xhc3MoJ2ZjLWx0cicsICFvcHRzLmlzUlRMKTtcclxuICAgICAgICAgICAgZWwudG9nZ2xlQ2xhc3MoJ2ZjLXJ0bCcsIG9wdHMuaXNSVEwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsID0gJChcIjxkaXYgY2xhc3M9J2ZjLXZpZXctY29udGFpbmVyJy8+XCIpLnByZXBlbmRUbyhlbCk7XHJcbiAgICAgICAgdGhpcy5pbml0VG9vbGJhcnMoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRm9vdGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHRoaXMub3B0KCdkZWZhdWx0VmlldycpKTtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ2hhbmRsZVdpbmRvd1Jlc2l6ZScpKSB7XHJcbiAgICAgICAgICAgICQod2luZG93KS5yZXNpemUodGhpcy53aW5kb3dSZXNpemVQcm94eSA9IHV0aWxfMS5kZWJvdW5jZSgvLyBwcmV2ZW50cyByYXBpZCBjYWxsc1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpLCB0aGlzLm9wdCgnd2luZG93UmVzaXplRGVsYXknKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbCgncmVtb3ZlRWxlbWVudCcpO1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQ2xhc3MoJ2ZjIGZjLWx0ciBmYy1ydGwnKTtcclxuICAgICAgICAvLyByZW1vdmVzIHRoZW1lLXJlbGF0ZWQgcm9vdCBjbGFzc05hbWVcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnVud2F0Y2goJ3NldHRpbmdUaGVtZScpO1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIudW53YXRjaCgnc2V0dGluZ0J1c2luZXNzSG91ckdlbmVyYXRvcicpO1xyXG4gICAgICAgIHRoaXMuZWwub2ZmKCcuZmMnKTsgLy8gdW5iaW5kIG5hdiBsaW5rIGhhbmRsZXJzXHJcbiAgICAgICAgaWYgKHRoaXMud2luZG93UmVzaXplUHJveHkpIHtcclxuICAgICAgICAgICAgJCh3aW5kb3cpLnVuYmluZCgncmVzaXplJywgdGhpcy53aW5kb3dSZXNpemVQcm94eSk7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93UmVzaXplUHJveHkgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC51bm5lZWRlZCgpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5lbGVtZW50VmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbC5pcygnOnZpc2libGUnKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXIgUXVldWVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYmluZFZpZXdIYW5kbGVycyA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2aWV3LndhdGNoKCd0aXRsZUZvckNhbGVuZGFyJywgWyd0aXRsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBpZiAodmlldyA9PT0gX3RoaXMudmlldykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VG9vbGJhcnNUaXRsZShkZXBzLnRpdGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZpZXcud2F0Y2goJ2RhdGVQcm9maWxlRm9yQ2FsZW5kYXInLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3ID09PSBfdGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50RGF0ZSA9IGRlcHMuZGF0ZVByb2ZpbGUuZGF0ZTsgLy8gbWlnaHQgaGF2ZSBiZWVuIGNvbnN0cmFpbmVkIGJ5IHZpZXcgZGF0ZXNcclxuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRvb2xiYXJCdXR0b25zKGRlcHMuZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVuYmluZFZpZXdIYW5kbGVycyA9IGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgdmlldy51bndhdGNoKCd0aXRsZUZvckNhbGVuZGFyJyk7XHJcbiAgICAgICAgdmlldy51bndhdGNoKCdkYXRlUHJvZmlsZUZvckNhbGVuZGFyJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVmlldyBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlldyBiZWNhdXNlIG9mIGEgZGF0ZSBjaGFuZ2UsIHZpZXctdHlwZSBjaGFuZ2UsIG9yIGZvciB0aGUgZmlyc3QgdGltZS5cclxuICAgIC8vIElmIG5vdCBnaXZlbiBhIHZpZXdUeXBlLCBrZWVwIHRoZSBjdXJyZW50IHZpZXcgYnV0IHJlbmRlciBkaWZmZXJlbnQgZGF0ZXMuXHJcbiAgICAvLyBBY2NlcHRzIGFuIG9wdGlvbmFsIHNjcm9sbCBzdGF0ZSB0byByZXN0b3JlIHRvLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlclZpZXcgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgb2xkVmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgbmV3VmlldztcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICBpZiAob2xkVmlldyAmJiB2aWV3VHlwZSAmJiBvbGRWaWV3LnR5cGUgIT09IHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHZpZXdUeXBlIGNoYW5nZWQsIG9yIHRoZSB2aWV3IHdhcyBuZXZlciBjcmVhdGVkLCBjcmVhdGUgYSBmcmVzaCB2aWV3XHJcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcgJiYgdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgbmV3VmlldyA9IHRoaXMudmlldyA9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdzQnlUeXBlW3ZpZXdUeXBlXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnZpZXdzQnlUeXBlW3ZpZXdUeXBlXSA9IHRoaXMuaW5zdGFudGlhdGVWaWV3KHZpZXdUeXBlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZFZpZXdIYW5kbGVycyhuZXdWaWV3KTtcclxuICAgICAgICAgICAgbmV3Vmlldy5zdGFydEJhdGNoUmVuZGVyKCk7IC8vIHNvIHRoYXQgc2V0RWxlbWVudCtzZXREYXRlIHJlbmRlcmluZyBhcmUgam9pbmVkXHJcbiAgICAgICAgICAgIG5ld1ZpZXcuc2V0RWxlbWVudCgkKFwiPGRpdiBjbGFzcz0nZmMtdmlldyBmYy1cIiArIHZpZXdUeXBlICsgXCItdmlldycgLz5cIikuYXBwZW5kVG8odGhpcy5jb250ZW50RWwpKTtcclxuICAgICAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCdhY3RpdmF0ZUJ1dHRvbicsIHZpZXdUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHVubmVjZXNzYXJ5IGNoYW5nZSBmaXJpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5nZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicpICE9PSB0aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJywgdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zZXREYXRlKHRoaXMuY3VycmVudERhdGUpO1xyXG4gICAgICAgICAgICBpZiAobmV3Vmlldykge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlldy5zdG9wQmF0Y2hSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHRoZSBjdXJyZW50IHZpZXcgYW5kIHJlZmxlY3RzIHRoaXMgY2hhbmdlIGluIHRoZSBIZWFkZXIuXHJcbiAgICAvLyBVbnJlZ3NpdGVycyB0aGUgYHZpZXdgLCBidXQgZG9lcyBub3QgcmVtb3ZlIGZyb20gdmlld0J5VHlwZSBoYXNoLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNsZWFyVmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCdkZWFjdGl2YXRlQnV0dG9uJywgY3VycmVudFZpZXcudHlwZSk7XHJcbiAgICAgICAgdGhpcy51bmJpbmRWaWV3SGFuZGxlcnMoY3VycmVudFZpZXcpO1xyXG4gICAgICAgIGN1cnJlbnRWaWV3LnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICBjdXJyZW50Vmlldy51bnNldERhdGUoKTsgLy8gc28gYmluZFZpZXdIYW5kbGVycyBkb2Vzbid0IGZpcmUgd2l0aCBvbGQgdmFsdWVzIG5leHQgdGltZVxyXG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gRGVzdHJveXMgdGhlIHZpZXcsIGluY2x1ZGluZyB0aGUgdmlldyBvYmplY3QuIFRoZW4sIHJlLWluc3RhbnRpYXRlcyBpdCBhbmQgcmVuZGVycyBpdC5cclxuICAgIC8vIE1haW50YWlucyB0aGUgc2FtZSBzY3JvbGwgc3RhdGUuXHJcbiAgICAvLyBUT0RPOiBtYWludGFpbiBhbnkgb3RoZXIgdXNlci1tYW5pcHVsYXRlZCBzdGF0ZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWluaXRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvbGRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBzY3JvbGwgPSBvbGRWaWV3LnF1ZXJ5U2Nyb2xsKCk7IC8vIHdvdWxkbid0IGJlIHNvIGNvbXBsaWNhdGVkIGlmIENhbGVuZGFyIG93bmVkIHRoZSBzY3JvbGxcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcob2xkVmlldy50eXBlKTsgLy8gbmVlZHMgdGhlIHR5cGUgdG8gZnJlc2hseSByZW5kZXJcclxuICAgICAgICB0aGlzLnZpZXcuYXBwbHlTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICB0aGlzLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0U3VnZ2VzdGVkVmlld0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc0hlaWdodEF1dG8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdjb250ZW50SGVpZ2h0JykgPT09ICdhdXRvJyB8fCB0aGlzLm9wdCgnaGVpZ2h0JykgPT09ICdhdXRvJztcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlVmlld1NpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUpIHtcclxuICAgICAgICBpZiAoaXNSZXNpemUgPT09IHZvaWQgMCkgeyBpc1Jlc2l6ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHNjcm9sbDtcclxuICAgICAgICBpZiAoIXRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUgJiYgdmlldykge1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IHZpZXcucXVlcnlTY3JvbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplKys7XHJcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU2l6ZSh0aGlzLmdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSwgdGhpcy5pc0hlaWdodEF1dG8oKSwgaXNSZXNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplLS07XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdmlldy5hcHBseVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzaWduYWwgc3VjY2Vzc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY2FsY1NpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxjU2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuX2NhbGNTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0SW5wdXQgPSB0aGlzLm9wdCgnY29udGVudEhlaWdodCcpO1xyXG4gICAgICAgIHZhciBoZWlnaHRJbnB1dCA9IHRoaXMub3B0KCdoZWlnaHQnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29udGVudEhlaWdodElucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGNvbnRlbnRIZWlnaHRJbnB1dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaGVpZ2h0SW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGhlaWdodElucHV0IC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBoZWlnaHRJbnB1dCgpIC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhlaWdodElucHV0ID09PSAncGFyZW50Jykge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSB0aGlzLmVsLnBhcmVudCgpLmhlaWdodCgpIC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuY29udGVudEVsLndpZHRoKCkgL1xyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgodGhpcy5vcHQoJ2FzcGVjdFJhdGlvJyksIC41KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS53aW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoZXYudGFyZ2V0ID09PSB3aW5kb3cgJiYgLy8gc28gd2UgZG9uJ3QgcHJvY2VzcyBqcXVpIFwicmVzaXplXCIgZXZlbnRzIHRoYXQgaGF2ZSBidWJibGVkIHVwXHJcbiAgICAgICAgICAgIHRoaXMudmlldyAmJlxyXG4gICAgICAgICAgICB0aGlzLnZpZXcuaXNEYXRlc1JlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZVZpZXdTaXplKHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignd2luZG93UmVzaXplJywgW3RoaXMudmlld10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEhlaWdodCBcIkZyZWV6aW5nXCJcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mcmVlemVDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRlbnRFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnRoYXdDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoLS07XHJcbiAgICAgICAgLy8gYWx3YXlzIGJyaW5nIGJhY2sgdG8gbmF0dXJhbCBoZWlnaHRcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5jc3Moe1xyXG4gICAgICAgICAgICB3aWR0aDogJycsXHJcbiAgICAgICAgICAgIGhlaWdodDogJycsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGJ1dCBpZiB0aGVyZSBhcmUgZnV0dXJlIHRoYXdzLCByZS1mcmVlemVcclxuICAgICAgICBpZiAodGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5mb3JjZUZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVG9vbGJhclxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0VG9vbGJhcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgVG9vbGJhcl8xLmRlZmF1bHQodGhpcywgdGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLmZvb3RlciA9IG5ldyBUb29sYmFyXzEuZGVmYXVsdCh0aGlzLCB0aGlzLmNvbXB1dGVGb290ZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyID0gbmV3IEl0ZXJhdG9yXzEuZGVmYXVsdChbdGhpcy5oZWFkZXIsIHRoaXMuZm9vdGVyXSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXB1dGVIZWFkZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NlczogJ2ZjLWhlYWRlci10b29sYmFyJyxcclxuICAgICAgICAgICAgbGF5b3V0OiB0aGlzLm9wdCgnaGVhZGVyJylcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wdXRlRm9vdGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBleHRyYUNsYXNzZXM6ICdmYy1mb290ZXItdG9vbGJhcicsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5vcHQoJ2Zvb3RlcicpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIEhlYWRlciB3aWxsIHJlcmVuZGVyXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcjtcclxuICAgICAgICBoZWFkZXIuc2V0VG9vbGJhck9wdGlvbnModGhpcy5jb21wdXRlSGVhZGVyT3B0aW9ucygpKTtcclxuICAgICAgICBoZWFkZXIucmVuZGVyKCk7XHJcbiAgICAgICAgaWYgKGhlYWRlci5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnByZXBlbmQoaGVhZGVyLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBGb290ZXIgd2lsbCByZXJlbmRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckZvb3RlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZm9vdGVyID0gdGhpcy5mb290ZXI7XHJcbiAgICAgICAgZm9vdGVyLnNldFRvb2xiYXJPcHRpb25zKHRoaXMuY29tcHV0ZUZvb3Rlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgZm9vdGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGlmIChmb290ZXIuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmQoZm9vdGVyLmVsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnNldFRvb2xiYXJzVGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3VwZGF0ZVRpdGxlJywgdGl0bGUpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51cGRhdGVUb29sYmFyQnV0dG9ucyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBub3cgPSB0aGlzLmdldE5vdygpO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciB0b2RheUluZm8gPSB2aWV3LmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKG5vdyk7XHJcbiAgICAgICAgdmFyIHByZXZJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYodmlldy5nZXQoJ2RhdGVQcm9maWxlJykpO1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoKHRvZGF5SW5mby5pc1ZhbGlkICYmICFkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShub3cpKSA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAndG9kYXknKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwocHJldkluZm8uaXNWYWxpZCA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAncHJldicpO1xyXG4gICAgICAgIHRoaXMudG9vbGJhcnNNYW5hZ2VyLnByb3h5Q2FsbChuZXh0SW5mby5pc1ZhbGlkID9cclxuICAgICAgICAgICAgJ2VuYWJsZUJ1dHRvbicgOlxyXG4gICAgICAgICAgICAnZGlzYWJsZUJ1dHRvbicsICduZXh0Jyk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnF1ZXJ5VG9vbGJhcnNIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhcnNNYW5hZ2VyLml0ZW1zLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIHRvb2xiYXIpIHtcclxuICAgICAgICAgICAgdmFyIHRvb2xiYXJIZWlnaHQgPSB0b29sYmFyLmVsID8gdG9vbGJhci5lbC5vdXRlckhlaWdodCh0cnVlKSA6IDA7IC8vIGluY2x1ZGVzIG1hcmdpblxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyB0b29sYmFySGVpZ2h0O1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfTtcclxuICAgIC8vIFNlbGVjdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHRoaXMgcHVibGljIG1ldGhvZCByZWNlaXZlcyBzdGFydC9lbmQgZGF0ZXMgaW4gYW55IGZvcm1hdCwgd2l0aCBhbnkgdGltZXpvbmVcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoem9uZWRTdGFydElucHV0LCB6b25lZEVuZElucHV0KSB7XHJcbiAgICAgICAgdGhpcy52aWV3LnNlbGVjdCh0aGlzLmJ1aWxkU2VsZWN0Rm9vdHByaW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy51bnNlbGVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhcmd1bWVudHMgdG8gdGhlIHNlbGVjdCBtZXRob2QgaW4gdGhlIEFQSSwgcmV0dXJucyBhIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBpbmZvKVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmJ1aWxkU2VsZWN0Rm9vdHByaW50ID0gZnVuY3Rpb24gKHpvbmVkU3RhcnRJbnB1dCwgem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMubW9tZW50KHpvbmVkU3RhcnRJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLm1vbWVudCh6b25lZEVuZElucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKHRoaXMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpLCAhc3RhcnQuaGFzVGltZSgpKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluaXRNb21lbnRJbnRlcm5hbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbicpKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ2RlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24nKSk7XHJcbiAgICAgICAgLy8gQ2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgd2hlbiBhbnkgb2YgdGhlIG9wdGlvbnMgY2hhbmdlLlxyXG4gICAgICAgIC8vIEhhcHBlbnMgYmVmb3JlIGFueSBpbnRlcm5hbCBvYmplY3RzIHJlYnVpbGQgb3IgcmVyZW5kZXIsIGJlY2F1c2UgdGhpcyBpcyB2ZXJ5IGNvcmUuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnYnVpbGRpbmdNb21lbnRMb2NhbGUnLCBbXHJcbiAgICAgICAgICAgICc/bG9jYWxlJywgJz9tb250aE5hbWVzJywgJz9tb250aE5hbWVzU2hvcnQnLCAnP2RheU5hbWVzJywgJz9kYXlOYW1lc1Nob3J0JyxcclxuICAgICAgICAgICAgJz9maXJzdERheScsICc/d2Vla051bWJlckNhbGN1bGF0aW9uJ1xyXG4gICAgICAgIF0sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSBvcHRzLndlZWtOdW1iZXJDYWxjdWxhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGZpcnN0RGF5ID0gb3B0cy5maXJzdERheTtcclxuICAgICAgICAgICAgdmFyIF93ZWVrO1xyXG4gICAgICAgICAgICAvLyBub3JtYWxpemVcclxuICAgICAgICAgICAgaWYgKHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2lzbycpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9ICdJU08nOyAvLyBub3JtYWxpemVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG9jYWxlRGF0YSA9IE9iamVjdC5jcmVhdGUoLy8gbWFrZSBhIGNoZWFwIGNvcHlcclxuICAgICAgICAgICAgbG9jYWxlXzEuZ2V0TW9tZW50TG9jYWxlRGF0YShvcHRzLmxvY2FsZSkgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKG9wdHMubW9udGhOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fbW9udGhzID0gb3B0cy5tb250aE5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm1vbnRoTmFtZXNTaG9ydCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fbW9udGhzU2hvcnQgPSBvcHRzLm1vbnRoTmFtZXNTaG9ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5kYXlOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlRGF0YS5fd2Vla2RheXMgPSBvcHRzLmRheU5hbWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmRheU5hbWVzU2hvcnQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWtkYXlzU2hvcnQgPSBvcHRzLmRheU5hbWVzU2hvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0RGF5ID09IG51bGwgJiYgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgZmlyc3REYXkgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaXJzdERheSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBfd2VlayA9IE9iamVjdC5jcmVhdGUobG9jYWxlRGF0YS5fd2Vlayk7IC8vIF93ZWVrOiB7IGRvdzogIyB9XHJcbiAgICAgICAgICAgICAgICBfd2Vlay5kb3cgPSBmaXJzdERheTtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWsgPSBfd2VlaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJyB8fFxyXG4gICAgICAgICAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnbG9jYWwnIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygd2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPSB3ZWVrTnVtYmVyQ2FsY3VsYXRpb247IC8vIG1vbWVudC1leHQgd2lsbCBrbm93IHdoYXQgdG8gZG8gd2l0aCBpdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaW50ZXJuYWwgY3VycmVudCBkYXRlIG9iamVjdCBhbHJlYWR5IGV4aXN0cywgbW92ZSB0byBuZXcgbG9jYWxlLlxyXG4gICAgICAgICAgICAvLyBXZSBkbyBOT1QgbmVlZCB0byBkbyB0aGlzIHRlY2huaXF1ZSBmb3IgZXZlbnQgZGF0ZXMsIGJlY2F1c2UgdGhpcyBoYXBwZW5zIHdoZW4gY29udmVydGluZyB0byBcInNlZ21lbnRzXCIuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50RGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMubG9jYWxpemVNb21lbnQoX3RoaXMuY3VycmVudERhdGUpOyAvLyBzZXRzIHRvIGxvY2FsZURhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIG1vbWVudCB1c2luZyB0aGUgc2V0dGluZ3Mgb2YgdGhlIGN1cnJlbnQgY2FsZW5kYXI6IHRpbWV6b25lIGFuZCBsb2NhbGUuXHJcbiAgICAvLyBBY2NlcHRzIGFueXRoaW5nIHRoZSB2YW5pbGxhIG1vbWVudCgpIGNvbnN0cnVjdG9yIGFjY2VwdHMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubW9tZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9tO1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIG1vbWVudCB0byBiZSBsb2NhbCwgYmVjYXVzZSBtb21lbnRFeHQgZG9lc24ndCBndWFyYW50ZWUgaXQuXHJcbiAgICAgICAgICAgIGlmIChtb20uaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtb20ubG9jYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wdCgndGltZXpvbmUnKSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBwcm9jZXNzIGFzIFVUQ1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQucGFyc2Vab25lLmFwcGx5KG51bGwsIGFyZ3MpOyAvLyBsZXQgdGhlIGlucHV0IGRlY2lkZSB0aGUgem9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7IC8vIFRPRE9cclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tc1RvTW9tZW50ID0gZnVuY3Rpb24gKG1zLCBmb3JjZUFsbERheSkge1xyXG4gICAgICAgIHZhciBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMobXMpOyAvLyBUT0RPOiBvcHRpbWl6ZSBieSB1c2luZyBEYXRlLlVUQ1xyXG4gICAgICAgIGlmIChmb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBtb20uc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSB0aGlzLmFwcGx5VGltZXpvbmUobW9tKTsgLy8gbWF5IG9yIG1heSBub3QgYXBwbHkgbG9jYWxlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTtcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tc1RvVXRjTW9tZW50ID0gZnVuY3Rpb24gKG1zLCBmb3JjZUFsbERheSkge1xyXG4gICAgICAgIHZhciBtb20gPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMobXMpOyAvLyBUT0RPOiBvcHRpbWl6ZSBieSB1c2luZyBEYXRlLlVUQ1xyXG4gICAgICAgIGlmIChmb3JjZUFsbERheSkge1xyXG4gICAgICAgICAgICBtb20uc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQobW9tKTtcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIGdpdmVuIG1vbWVudCdzIGxvY2FsZSBzZXR0aW5ncyB0byB0aGUgY3VycmVudCBjYWxlbmRhciBsb2NhbGUgc2V0dGluZ3MuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubG9jYWxpemVNb21lbnQgPSBmdW5jdGlvbiAobW9tKSB7XHJcbiAgICAgICAgbW9tLl9sb2NhbGUgPSB0aGlzLmxvY2FsZURhdGE7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciBvciBub3QgdGhlIGNhbGVuZGFyIGtub3dzIGhvdyB0byBjYWxjdWxhdGVcclxuICAgIC8vIHRoZSB0aW1lem9uZSBvZmZzZXQgb2YgYXJiaXRyYXJ5IGRhdGVzIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldElzQW1iaWdUaW1lem9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdsb2NhbCcgJiYgdGhpcy5vcHQoJ3RpbWV6b25lJykgIT09ICdVVEMnO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBjdXJyZW50IHRpbWV6b25lLiBIYXMgbm8gZWZmZWN0IG9uIGRhdGVzIHdpdGhvdXQgdGltZXMuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuYXBwbHlUaW1lem9uZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgaWYgKCFkYXRlLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgem9uZWREYXRlID0gdGhpcy5tb21lbnQoZGF0ZS50b0FycmF5KCkpO1xyXG4gICAgICAgIHZhciB0aW1lQWRqdXN0ID0gZGF0ZS50aW1lKCkgLSB6b25lZERhdGUudGltZSgpO1xyXG4gICAgICAgIHZhciBhZGp1c3RlZFpvbmVkRGF0ZTtcclxuICAgICAgICAvLyBTYWZhcmkgc29tZXRpbWVzIGhhcyBwcm9ibGVtcyB3aXRoIHRoaXMgY29lcnNpb24gd2hlbiBuZWFyIERTVC4gQWRqdXN0IGlmIG5lY2Vzc2FyeS4gKGJ1ZyAjMjM5NilcclxuICAgICAgICBpZiAodGltZUFkanVzdCkge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFpvbmVkRGF0ZSA9IHpvbmVkRGF0ZS5jbG9uZSgpLmFkZCh0aW1lQWRqdXN0KTsgLy8gYWRkIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICBpZiAoZGF0ZS50aW1lKCkgLSBhZGp1c3RlZFpvbmVkRGF0ZS50aW1lKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHpvbmVkRGF0ZSA9IGFkanVzdGVkWm9uZWREYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB6b25lZERhdGU7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIEFzc3VtZXMgdGhlIGZvb3RwcmludCBpcyBub24tb3Blbi1lbmRlZC5cclxuICAgICovXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZm9vdHByaW50VG9EYXRlUHJvZmlsZSA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIGlnbm9yZUVuZCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLnN0YXJ0TXMpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKCFpZ25vcmVFbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZW5kTXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5hcHBseVRpbWV6b25lKHN0YXJ0KTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5hcHBseVRpbWV6b25lKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChzdGFydCwgZW5kLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgbW9tZW50IGZvciB0aGUgY3VycmVudCBkYXRlLCBhcyBkZWZpbmVkIGJ5IHRoZSBjbGllbnQncyBjb21wdXRlciBvciBmcm9tIHRoZSBgbm93YCBvcHRpb24uXHJcbiAgICAvLyBXaWxsIHJldHVybiBhbiBtb21lbnQgd2l0aCBhbiBhbWJpZ3VvdXMgdGltZXpvbmUuXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0Tm93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub3cgPSB0aGlzLm9wdCgnbm93Jyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBub3cgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbm93ID0gbm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1vbWVudChub3cpLnN0cmlwWm9uZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIFByb2R1Y2VzIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uXHJcbiAgICAvLyBTaWRlLWVmZmVjdDogY2hhbmdlcyB0aGUgbG9jYWxlIG9mIHRoZSBnaXZlbiBkdXJhdGlvbi5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5odW1hbml6ZUR1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLmxvY2FsZSh0aGlzLm9wdCgnbG9jYWxlJykpLmh1bWFuaXplKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gd2lsbCByZXR1cm4gYG51bGxgIGlmIGludmFsaWQgcmFuZ2VcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wYXJzZVVuem9uZWRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZUlucHV0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbnVsbDtcclxuICAgICAgICB2YXIgZW5kID0gbnVsbDtcclxuICAgICAgICBpZiAocmFuZ2VJbnB1dC5zdGFydCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMubW9tZW50KHJhbmdlSW5wdXQuc3RhcnQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFuZ2VJbnB1dC5lbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5tb21lbnQocmFuZ2VJbnB1dC5lbmQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kLmlzQmVmb3JlKHN0YXJ0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50LURhdGUgVXRpbGl0aWVzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluaXRFdmVudE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcl8xLmRlZmF1bHQodGhpcyk7XHJcbiAgICAgICAgdmFyIHJhd1NvdXJjZXMgPSB0aGlzLm9wdCgnZXZlbnRTb3VyY2VzJykgfHwgW107XHJcbiAgICAgICAgdmFyIHNpbmdsZVJhd1NvdXJjZSA9IHRoaXMub3B0KCdldmVudHMnKTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcclxuICAgICAgICBpZiAoc2luZ2xlUmF3U291cmNlKSB7XHJcbiAgICAgICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChzaW5nbGVSYXdTb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE1hbmFnZXIub24oJ3JlbGVhc2UnLCBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyKCdldmVudHNSZXNldCcsIGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICByYXdTb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHJhd1NvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKHJhd1NvdXJjZSwgX3RoaXMpO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIuYWRkU291cmNlKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIucmVxdWVzdEV2ZW50cyhzdGFydCwgZW5kLCB0aGlzLm9wdCgndGltZXpvbmUnKSwgIXRoaXMub3B0KCdsYXp5RmV0Y2hpbmcnKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0IGFuIGV2ZW50J3Mgbm9ybWFsaXplZCBlbmQgZGF0ZS4gSWYgbm90IHByZXNlbnQsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBkZWZhdWx0cy5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRFdmVudEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC5lbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmVuZC5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50LmFsbERheSwgZXZlbnQuc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXHJcbiAgICAvLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldERlZmF1bHRFdmVudEVuZCA9IGZ1bmN0aW9uIChhbGxEYXksIHpvbmVkU3RhcnQpIHtcclxuICAgICAgICB2YXIgZW5kID0gem9uZWRTdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIGlmIChhbGxEYXkpIHtcclxuICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpLmFkZCh0aGlzLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZC5hZGQodGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0SXNBbWJpZ1RpbWV6b25lKCkpIHtcclxuICAgICAgICAgICAgZW5kLnN0cmlwWm9uZSgpOyAvLyB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHR6byBzaG91bGQgYmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgIH07XHJcbiAgICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZXJlbmRlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnZpZXcuZmxhc2goJ2Rpc3BsYXlpbmdFdmVudHMnKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVmZXRjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5yZWZldGNoQWxsU291cmNlcygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dHMsIGlzU3RpY2t5KSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudElucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50KGV2ZW50SW5wdXRzW2ldLCBpc1N0aWNreSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dCwgaXNTdGlja3kpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIGV2ZW50SW5wdXQuc291cmNlIHx8IGV2ZW50TWFuYWdlci5zdGlja3lTb3VyY2UpO1xyXG4gICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoZXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gbGVnYWN5UXVlcnkgb3BlcmF0ZXMgb24gbGVnYWN5IGV2ZW50IGluc3RhbmNlIG9iamVjdHNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiAobGVnYWN5UXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGxlZ2FjeUluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZE1hcCA9IHt9O1xyXG4gICAgICAgIHZhciBldmVudERlZjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAobGVnYWN5UXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVtb3ZlQWxsRXZlbnREZWZzKHRydWUpOyAvLyBwZXJzaXN0PXRydWVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGxlZ2FjeUluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZWdhY3lJbnN0YW5jZXMgPSBmaWx0ZXJMZWdhY3lFdmVudEluc3RhbmNlcyhsZWdhY3lJbnN0YW5jZXMsIGxlZ2FjeVF1ZXJ5KTtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB1bmlxdWUgSURzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWdhY3lJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50RGVmID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnREZWZCeVVpZChsZWdhY3lJbnN0YW5jZXNbaV0uX2lkKTtcclxuICAgICAgICAgICAgICAgIGlkTWFwW2V2ZW50RGVmLmlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgaW4gaWRNYXApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVFdmVudERlZnNCeUlkKGksIHRydWUpOyAvLyBwZXJzaXN0PXRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBsZWdhY3lRdWVyeSBvcGVyYXRlcyBvbiBsZWdhY3kgZXZlbnQgaW5zdGFuY2Ugb2JqZWN0c1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNsaWVudEV2ZW50cyA9IGZ1bmN0aW9uIChsZWdhY3lRdWVyeSkge1xyXG4gICAgICAgIHZhciBsZWdhY3lFdmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBsZWdhY3lFdmVudEluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUV2ZW50SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFByb3BzQXJyYXkpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50UHJvcHNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50KGV2ZW50UHJvcHNBcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRQcm9wcykge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50RGVmQnlVaWQoZXZlbnRQcm9wcy5faWQpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmIChldmVudERlZiBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlID0gZXZlbnREZWYuYnVpbGRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQuY3JlYXRlRnJvbVJhd1Byb3BzKGV2ZW50SW5zdGFuY2UsIGV2ZW50UHJvcHMsIC8vIHJhdyBwcm9wc1xyXG4gICAgICAgICAgICBudWxsIC8vIGxhcmdlVW5pdCAtLSB3aG8gdXNlcyBpdD9cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIubXV0YXRlRXZlbnRzV2l0aElkKGV2ZW50RGVmLmlkLCBldmVudERlZk11dGF0aW9uKTsgLy8gd2lsbCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5vdGhlclNvdXJjZXMuc2xpY2UoKTsgLy8gY2xvbmVcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLmdldFNvdXJjZUJ5SWQoRXZlbnRTb3VyY2VfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKGlkKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmFkZEV2ZW50U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZUlucHV0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShzb3VyY2VJbnB1dCwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRTb3VyY2Uoc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbW92ZUV2ZW50U291cmNlcyA9IGZ1bmN0aW9uIChzb3VyY2VNdWx0aVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzb3VyY2VzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzb3VyY2VNdWx0aVF1ZXJ5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIucmVtb3ZlQWxsU291cmNlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc291cmNlcyA9IGV2ZW50TWFuYWdlci5tdWx0aVF1ZXJ5U291cmNlcyhzb3VyY2VNdWx0aVF1ZXJ5KTtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZVNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlUXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBldmVudE1hbmFnZXIucXVlcnlTb3VyY2VzKHNvdXJjZVF1ZXJ5KTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZVNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVmZXRjaEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uIChzb3VyY2VNdWx0aVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gZXZlbnRNYW5hZ2VyLm11bHRpUXVlcnlTb3VyY2VzKHNvdXJjZU11bHRpUXVlcnkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVmZXRjaFNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2FsZW5kYXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENhbGVuZGFyO1xyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oQ2FsZW5kYXIpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKENhbGVuZGFyKTtcclxuZnVuY3Rpb24gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5RXZlbnRJbnN0YW5jZXMsIGxlZ2FjeVF1ZXJ5KSB7XHJcbiAgICBpZiAobGVnYWN5UXVlcnkgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihsZWdhY3lRdWVyeSkpIHtcclxuICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZXMuZmlsdGVyKGxlZ2FjeVF1ZXJ5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxlZ2FjeVF1ZXJ5ICs9ICcnOyAvLyBub3JtYWxpemUgdG8gc3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAobGVnYWN5RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAvLyBzb2Z0IGNvbXBhcmlzb24gYmVjYXVzZSBpZCBub3QgYmUgbm9ybWFsaXplZCB0byBzdHJpbmdcclxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2UuaWQgPT0gbGVnYWN5UXVlcnkgfHxcclxuICAgICAgICAgICAgICAgIGxlZ2FjeUV2ZW50SW5zdGFuY2UuX2lkID09PSBsZWdhY3lRdWVyeTsgLy8gY2FuIHNwZWNpZnkgaW50ZXJuYWwgaWQsIGJ1dCBtdXN0IGV4YWN0bHkgbWF0Y2hcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBDb21wb25lbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIENvbnN0cmFpbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29uc3RyYWludHMoZXZlbnRNYW5hZ2VyLCBfY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9jYWxlbmRhciA9IF9jYWxlbmRhcjtcclxuICAgIH1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxlbmRhci5vcHQobmFtZSk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGRldGVybWluZXMgaWYgZXZlbnRJbnN0YW5jZUdyb3VwIGlzIGFsbG93ZWQsXHJcbiAgICBpbiByZWxhdGlvbiB0byBvdGhlciBFVkVOVFMgYW5kIGJ1c2luZXNzIGhvdXJzLlxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gZXZlbnRJbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEluc3RhbmNlcyA9IHRoaXMuZ2V0UGVlckV2ZW50SW5zdGFuY2VzKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50UmFuZ2VzID0gcGVlckV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMocGVlckV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgY29uc3RyYWludFZhbCA9IGV2ZW50RGVmLmdldENvbnN0cmFpbnQoKTtcclxuICAgICAgICB2YXIgb3ZlcmxhcFZhbCA9IGV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICB2YXIgZXZlbnRBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnZXZlbnRBbGxvdycpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9vdHByaW50QWxsb3dlZChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCBjb25zdHJhaW50VmFsLCBvdmVybGFwVmFsLCBldmVudEZvb3RwcmludHNbaV0uZXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRBbGxvd0Z1bmMpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QWxsb3dGdW5jKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQudG9MZWdhY3kodGhpcy5fY2FsZW5kYXIpLCBldmVudEZvb3RwcmludHNbaV0uZ2V0RXZlbnRMZWdhY3koKSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5nZXRQZWVyRXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXNXaXRob3V0SWQoZXZlbnREZWYuaWQpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudEluc3RhbmNlcyA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCk7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudFJhbmdlcyA9IHBlZXJFdmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIHNlbGVjdEFsbG93RnVuYztcclxuICAgICAgICBpZiAodGhpcy5pc0Zvb3RwcmludEFsbG93ZWQoY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCB0aGlzLm9wdCgnc2VsZWN0Q29uc3RyYWludCcpLCB0aGlzLm9wdCgnc2VsZWN0T3ZlcmxhcCcpKSkge1xyXG4gICAgICAgICAgICBzZWxlY3RBbGxvd0Z1bmMgPSB0aGlzLm9wdCgnc2VsZWN0QWxsb3cnKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdEFsbG93RnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdEFsbG93RnVuYyhjb21wb25lbnRGb290cHJpbnQudG9MZWdhY3kodGhpcy5fY2FsZW5kYXIpKSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzRm9vdHByaW50QWxsb3dlZCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHMsIGNvbnN0cmFpbnRWYWwsIG92ZXJsYXBWYWwsIHN1YmplY3RFdmVudEluc3RhbmNlIC8vIG9wdGlvbmFsXHJcbiAgICApIHtcclxuICAgICAgICB2YXIgY29uc3RyYWludEZvb3RwcmludHM7IC8vIENvbXBvbmVudEZvb3RwcmludFtdXHJcbiAgICAgICAgdmFyIG92ZXJsYXBFdmVudEZvb3RwcmludHM7IC8vIEV2ZW50Rm9vdHByaW50W11cclxuICAgICAgICBpZiAoY29uc3RyYWludFZhbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRGb290cHJpbnRzID0gdGhpcy5jb25zdHJhaW50VmFsVG9Gb290cHJpbnRzKGNvbnN0cmFpbnRWYWwsIGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zvb3RwcmludFdpdGhpbkNvbnN0cmFpbnRzKGNvbXBvbmVudEZvb3RwcmludCwgY29uc3RyYWludEZvb3RwcmludHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IHRoaXMuY29sbGVjdE92ZXJsYXBFdmVudEZvb3RwcmludHMocGVlckV2ZW50Rm9vdHByaW50cywgY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKG92ZXJsYXBFdmVudEZvb3RwcmludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG92ZXJsYXBWYWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFpc092ZXJsYXBzQWxsb3dlZEJ5RnVuYyhvdmVybGFwRXZlbnRGb290cHJpbnRzLCBvdmVybGFwVmFsLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKCFpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29uc3RyYWludFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNGb290cHJpbnRXaXRoaW5Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIGNvbnN0cmFpbnRGb290cHJpbnRzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbnN0cmFpbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50KGNvbnN0cmFpbnRGb290cHJpbnRzW2ldLCBjb21wb25lbnRGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmNvbnN0cmFpbnRWYWxUb0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludFZhbCwgaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRWYWwgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEN1cnJlbnRCdXNpbmVzc0Zvb3RwcmludHMoaXNBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludFZhbCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLnBhcnNlRXZlbnREZWZUb0luc3RhbmNlcyhjb25zdHJhaW50VmFsKTsgLy8gaGFuZGxlcyByZWN1cnJpbmcgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9vdHByaW50cyhjb25zdHJhaW50VmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzKGV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25zdHJhaW50VmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlc1dpdGhJZChjb25zdHJhaW50VmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMoZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyByZXR1cm5zIENvbXBvbmVudEZvb3RwcmludFtdXHJcbiAgICAvLyB1c2VzIGN1cnJlbnQgdmlldydzIHJhbmdlXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuYnVpbGRDdXJyZW50QnVzaW5lc3NGb290cHJpbnRzID0gZnVuY3Rpb24gKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLl9jYWxlbmRhci52aWV3O1xyXG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJHZW5lcmF0b3IgPSB2aWV3LmdldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJyk7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZSA9IHZpZXcuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoaXNBbGxEYXksIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjb252ZXJzaW9uIHV0aWxcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlcykge1xyXG4gICAgICAgIHZhciBldmVudFJhbmdlcyA9IGV2ZW50SW5zdGFuY2VzLm1hcCh1dGlsXzEuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlcyk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50cy5tYXAodXRpbF8xLmV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgfTtcclxuICAgIC8vIE92ZXJsYXBcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmNvbGxlY3RPdmVybGFwRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKHBlZXJFdmVudEZvb3RwcmludHMsIHRhcmdldEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBvdmVybGFwRXZlbnRGb290cHJpbnRzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBlZXJFdmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZm9vdHByaW50c0ludGVyc2VjdCh0YXJnZXRGb290cHJpbnQsIHBlZXJFdmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5wdXNoKHBlZXJFdmVudEZvb3RwcmludHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdmVybGFwRXZlbnRGb290cHJpbnRzO1xyXG4gICAgfTtcclxuICAgIC8vIENvbnZlcnNpb246IGV2ZW50RGVmcyAtPiBldmVudEluc3RhbmNlcyAtPiBldmVudFJhbmdlcyAtPiBldmVudEZvb3RwcmludHMgLT4gY29tcG9uZW50Rm9vdHByaW50c1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBOT1RFOiB0aGlzIG1pZ2h0IHNlZW0gbGlrZSByZXBldGl0aXZlIGNvZGUgd2l0aCB0aGUgR3JpZCBjbGFzcywgaG93ZXZlciwgdGhpcyBjb2RlIGlzIHJlbGF0ZWQgdG9cclxuICAgIC8vIGNvbnN0cmFpbnRzIHdoZXJlYXMgdGhlIEdyaWQgY29kZSBpcyByZWxhdGVkIHRvIHJlbmRlcmluZy4gRWFjaCBhcHByb2FjaCBtaWdodCB3YW50IHRvIGNvbnZlcnRcclxuICAgIC8vIGV2ZW50UmFuZ2VzIC0+IGV2ZW50Rm9vdHByaW50cyBpbiBhIGRpZmZlcmVudCB3YXkuIFJlZ2FyZGxlc3MsIHRoZXJlIGFyZSBvcHBvcnR1bml0aWVzIHRvIG1ha2VcclxuICAgIC8vIHRoaXMgbW9yZSBEUlkuXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBmYWxzZSBvbiBpbnZhbGlkIGlucHV0LlxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUV2ZW50RGVmVG9JbnN0YW5jZXMgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dCkge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UoZXZlbnRJbnB1dCwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLl9jYWxlbmRhcikpO1xyXG4gICAgICAgIGlmICghZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXMoZXZlbnRNYW5hZ2VyLmN1cnJlbnRQZXJpb2QudW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLnB1c2guYXBwbHkoLy8gZm9vdHByaW50c1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMsIHRoaXMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1dGlsXzEuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSldO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBQYXJzZXMgZm9vdHByaW50cyBkaXJlY3RseS5cclxuICAgIFZlcnkgc2ltaWxhciB0byBFdmVudERhdGVQcm9maWxlOjpwYXJzZSA6KFxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUZvb3RwcmludHMgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQsIGVuZDtcclxuICAgICAgICBpZiAocmF3SW5wdXQuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jYWxlbmRhci5tb21lbnQocmF3SW5wdXQuc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdJbnB1dC5lbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5fY2FsZW5kYXIubW9tZW50KHJhd0lucHV0LmVuZCk7XHJcbiAgICAgICAgICAgIGlmICghZW5kLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgKHN0YXJ0ICYmICFzdGFydC5oYXNUaW1lKCkpIHx8IChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIC8vIGlzQWxsRGF5XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIC8vIEZvb3RwcmludCBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50ID0gZnVuY3Rpb24gKG91dGVyRm9vdHByaW50LCBpbm5lckZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiBvdXRlckZvb3RwcmludC51bnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShpbm5lckZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5mb290cHJpbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICByZXR1cm4gZm9vdHByaW50MC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0c1dpdGgoZm9vdHByaW50MS51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25zdHJhaW50cztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uc3RyYWludHM7XHJcbi8vIG9wdGlvbmFsIHN1YmplY3RFdmVudEluc3RhbmNlXHJcbmZ1bmN0aW9uIGlzT3ZlcmxhcHNBbGxvd2VkQnlGdW5jKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIG92ZXJsYXBGdW5jLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb3ZlcmxhcEZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlLnRvTGVnYWN5KCksIHN1YmplY3RFdmVudEluc3RhbmNlID8gc3ViamVjdEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSA6IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHZhciBzdWJqZWN0TGVnYWN5SW5zdGFuY2UgPSBzdWJqZWN0RXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50SW5zdGFuY2U7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50RGVmO1xyXG4gICAgdmFyIG92ZXJsYXBWYWw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG92ZXJsYXBFdmVudEluc3RhbmNlID0gb3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlO1xyXG4gICAgICAgIG92ZXJsYXBFdmVudERlZiA9IG92ZXJsYXBFdmVudEluc3RhbmNlLmRlZjtcclxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHBhc3MgaW4gY2FsZW5kYXIsIGJlY2F1c2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBnbG9iYWwgZXZlbnRPdmVybGFwIHByb3BlcnR5LFxyXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBjb25zaWRlcmVkIHRoYXQgZWFybGllciBpbiB0aGUgcHJvY2Vzcy5cclxuICAgICAgICBvdmVybGFwVmFsID0gb3ZlcmxhcEV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3ZlcmxhcFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXBWYWwob3ZlcmxhcEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSwgc3ViamVjdExlZ2FjeUluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLypcclxuVVNBR0U6XHJcbiAgICBpbXBvcnQgeyBkZWZhdWx0IGFzIFBhcnNhYmxlTW9kZWxNaXhpbiwgUGFyc2FibGVNb2RlbEludGVyZmFjZSB9IGZyb20gJy4vUGFyc2FibGVNb2RlbE1peGluJ1xyXG5pbiBjbGFzczpcclxuICAgIGFwcGx5UHJvcHM6IFBhcnNhYmxlTW9kZWxJbnRlcmZhY2VbJ2FwcGx5UHJvcHMnXVxyXG4gICAgYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydhcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMnXVxyXG4gICAgYXBwbHlNaXNjUHJvcHM6IFBhcnNhYmxlTW9kZWxJbnRlcmZhY2VbJ2FwcGx5TWlzY1Byb3BzJ11cclxuICAgIGlzU3RhbmRhcmRQcm9wOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydpc1N0YW5kYXJkUHJvcCddXHJcbiAgICBzdGF0aWMgZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbi5kZWZpbmVTdGFuZGFyZFByb3BzXHJcbiAgICBzdGF0aWMgY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzXHJcbmFmdGVyIGNsYXNzOlxyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnNhYmxlTW9kZWxNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhcnNhYmxlTW9kZWxNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyB0cnVlL2ZhbHNlIGZvciBzdWNjZXNzLlxyXG4gICAgTWVhbnQgdG8gYmUgb25seSBjYWxsZWQgT05DRSwgYXQgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BNYXAgPSB0aGlzLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgICAgICB2YXIgbWFudWFsUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbWlzY1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYW51YWxQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtaXNjUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXBwbHlNaXNjUHJvcHMobWlzY1Byb3BzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMobWFudWFsUHJvcHMpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBJZiBzdWJjbGFzc2VzIG92ZXJyaWRlLCB0aGV5IG11c3QgY2FsbCB0aGlzIHN1cGVybWV0aG9kIGFuZCByZXR1cm4gdGhlIGJvb2xlYW4gcmVzcG9uc2UuXHJcbiAgICBNZWFudCB0byBiZSBvbmx5IGNhbGxlZCBPTkNFLCBhdCBvYmplY3QgY3JlYXRpb24uXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgQ2FuIGJlIGNhbGxlZCBldmVuIGFmdGVyIGluaXRpYWwgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgVE9ETzogd2h5IGlzIHRoaXMgYSBtZXRob2Qgd2hlbiBkZWZpbmVTdGFuZGFyZFByb3BzIGlzIHN0YXRpY1xyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuaXNTdGFuZGFyZFByb3AgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcE5hbWUgaW4gdGhpcy5zdGFuZGFyZFByb3BNYXA7XHJcbiAgICB9O1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocHJvcERlZnMpIHtcclxuICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLnByb3RvdHlwZTtcclxuICAgICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdzdGFuZGFyZFByb3BNYXAnKSkge1xyXG4gICAgICAgICAgICBwcm90by5zdGFuZGFyZFByb3BNYXAgPSBPYmplY3QuY3JlYXRlKHByb3RvLnN0YW5kYXJkUHJvcE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMocHJvcERlZnMsIHByb3RvLnN0YW5kYXJkUHJvcE1hcCk7XHJcbiAgICB9O1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAoc3JjLCBkZXN0KSB7XHJcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMucHJvdG90eXBlLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgICAgICB2YXIgcHJvcE5hbWU7XHJcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBtYXApIHtcclxuICAgICAgICAgICAgaWYgKHNyY1twcm9wTmFtZV0gIT0gbnVsbCAmJiAvLyBpbiB0aGUgc3JjIG9iamVjdD9cclxuICAgICAgICAgICAgICAgIG1hcFtwcm9wTmFtZV0gPT09IHRydWUgLy8gZmFsc2UgbWVhbnMgXCJjb3B5IHZlcmJhdGltXCJcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0W3Byb3BOYW1lXSA9IHNyY1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhcnNhYmxlTW9kZWxNaXhpbjtcclxufShNaXhpbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGFyc2FibGVNb2RlbE1peGluO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLnN0YW5kYXJkUHJvcE1hcCA9IHt9OyAvLyB3aWxsIGJlIGNsb25lZCBieSBkZWZpbmVTdGFuZGFyZFByb3BzXHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV2ZW50SW5zdGFuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudEluc3RhbmNlKGRlZiwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB0aGlzLmRlZiA9IGRlZjtcclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XHJcbiAgICB9XHJcbiAgICBFdmVudEluc3RhbmNlLnByb3RvdHlwZS50b0xlZ2FjeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLmRlZi50b0xlZ2FjeSgpO1xyXG4gICAgICAgIG9iai5zdGFydCA9IGRhdGVQcm9maWxlLnN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgb2JqLmVuZCA9IGRhdGVQcm9maWxlLmVuZCA/IGRhdGVQcm9maWxlLmVuZC5jbG9uZSgpIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEluc3RhbmNlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEluc3RhbmNlO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIEV2ZW50SW5zdGFuY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbnZhciBSZWN1cnJpbmdFdmVudERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFJlY3VycmluZ0V2ZW50RGVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUmVjdXJyaW5nRXZlbnREZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydFRpbWUgJiYgIXRoaXMuZW5kVGltZTtcclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5zb3VyY2UuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHVuem9uZWREYXRlID0gdW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIHVuem9uZWRFbmQgPSB1bnpvbmVkUmFuZ2UuZ2V0RW5kKCk7XHJcbiAgICAgICAgdmFyIHpvbmVkRGF5U3RhcnQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlU3RhcnQsIGluc3RhbmNlRW5kO1xyXG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAodW56b25lZERhdGUuaXNCZWZvcmUodW56b25lZEVuZCkpIHtcclxuICAgICAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZG93SGFzaCB8fCB0aGlzLmRvd0hhc2hbdW56b25lZERhdGUuZGF5KCldKSB7XHJcbiAgICAgICAgICAgICAgICB6b25lZERheVN0YXJ0ID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZSh1bnpvbmVkRGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gem9uZWREYXlTdGFydC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydC50aW1lKHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VFbmQgPSB6b25lZERheVN0YXJ0LmNsb25lKCkudGltZSh0aGlzLmVuZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VzLnB1c2gobmV3IEV2ZW50SW5zdGFuY2VfMS5kZWZhdWx0KHRoaXMsIC8vIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICAgIG5ldyBFdmVudERhdGVQcm9maWxlXzEuZGVmYXVsdChpbnN0YW5jZVN0YXJ0LCBpbnN0YW5jZUVuZCwgY2FsZW5kYXIpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW56b25lZERhdGUuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLnNldERvdyA9IGZ1bmN0aW9uIChkb3dOdW1iZXJzKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRvd0hhc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5kb3dIYXNoID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG93TnVtYmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmRvd0hhc2hbZG93TnVtYmVyc1tpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IF9zdXBlci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICBpZiAoZGVmLnN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICBkZWYuc3RhcnRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuc3RhcnRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZi5lbmRUaW1lKSB7XHJcbiAgICAgICAgICAgIGRlZi5lbmRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMuZW5kVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRvd0hhc2gpIHtcclxuICAgICAgICAgICAgZGVmLmRvd0hhc2ggPSAkLmV4dGVuZCh7fSwgdGhpcy5kb3dIYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVjdXJyaW5nRXZlbnREZWY7XHJcbn0oRXZlbnREZWZfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlY3VycmluZ0V2ZW50RGVmO1xyXG4vKlxyXG5IQUNLIHRvIHdvcmsgd2l0aCBUeXBlU2NyaXB0IG1peGluc1xyXG5OT1RFOiBpZiBzdXBlci1tZXRob2QgZmFpbHMsIHNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGFwcGx5XHJcbiovXHJcblJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5hcHBseVByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICB2YXIgc3VwZXJTdWNjZXNzID0gRXZlbnREZWZfMS5kZWZhdWx0LnByb3RvdHlwZS5hcHBseVByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgaWYgKHJhd1Byb3BzLnN0YXJ0KSB7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBtb21lbnQuZHVyYXRpb24ocmF3UHJvcHMuc3RhcnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmVuZCkge1xyXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG1vbWVudC5kdXJhdGlvbihyYXdQcm9wcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmRvdykge1xyXG4gICAgICAgIHRoaXMuc2V0RG93KHJhd1Byb3BzLmRvdyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG59O1xyXG4vLyBQYXJzaW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5SZWN1cnJpbmdFdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIHN0YXJ0OiBmYWxzZSxcclxuICAgIGVuZDogZmFsc2UsXHJcbiAgICBkb3c6IGZhbHNlXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRSYW5nZSh1bnpvbmVkUmFuZ2UsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB1bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZiA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50UmFuZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmFuZ2U7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDU0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgUmVjdXJyaW5nRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTID0ge1xyXG4gICAgc3RhcnQ6ICcwOTowMCcsXHJcbiAgICBlbmQ6ICcxNzowMCcsXHJcbiAgICBkb3c6IFsxLCAyLCAzLCA0LCA1XSxcclxuICAgIHJlbmRlcmluZzogJ2ludmVyc2UtYmFja2dyb3VuZCdcclxuICAgIC8vIGNsYXNzTmFtZXMgYXJlIGRlZmluZWQgaW4gYnVzaW5lc3NIb3Vyc1NlZ0NsYXNzZXNcclxufTtcclxudmFyIEJ1c2luZXNzSG91ckdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1c2luZXNzSG91ckdlbmVyYXRvcihyYXdDb21wbGV4RGVmLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMucmF3Q29tcGxleERlZiA9IHJhd0NvbXBsZXhEZWY7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgfVxyXG4gICAgQnVzaW5lc3NIb3VyR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEV2ZW50SW5zdGFuY2VHcm91cCA9IGZ1bmN0aW9uIChpc0FsbERheSwgdW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuYnVpbGRFdmVudERlZnMoaXNBbGxEYXkpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQodXRpbF8xLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMoZXZlbnREZWZzLCB1bnpvbmVkUmFuZ2UpKTtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBpbnZlcnNlLWJhY2tncm91bmQgcmVuZGVyaW5nIGNhbiBoYXBwZW4gZXZlbiB3aGVuIG5vIGV2ZW50UmFuZ2VzIGluIHZpZXdcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwLmV4cGxpY2l0RXZlbnREZWYgPSBldmVudERlZnNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91ckdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRFdmVudERlZnMgPSBmdW5jdGlvbiAoaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmF3Q29tcGxleERlZiA9IHRoaXMucmF3Q29tcGxleERlZjtcclxuICAgICAgICB2YXIgcmF3RGVmcyA9IFtdO1xyXG4gICAgICAgIHZhciByZXF1aXJlRG93ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBbXTtcclxuICAgICAgICBpZiAocmF3Q29tcGxleERlZiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QocmF3Q29tcGxleERlZikpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFtyYXdDb21wbGV4RGVmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0NvbXBsZXhEZWYpKSB7XHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSByYXdDb21wbGV4RGVmO1xyXG4gICAgICAgICAgICByZXF1aXJlRG93ID0gdHJ1ZTsgLy8gZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVEb3cgfHwgcmF3RGVmc1tpXS5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGRlZnMucHVzaCh0aGlzLmJ1aWxkRXZlbnREZWYoaXNBbGxEYXksIHJhd0RlZnNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmcztcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRXZlbnREZWYgPSBmdW5jdGlvbiAoaXNBbGxEYXksIHJhd0RlZikge1xyXG4gICAgICAgIHZhciBmdWxsUmF3RGVmID0gJC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIHJhd0RlZik7XHJcbiAgICAgICAgaWYgKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGZ1bGxSYXdEZWYuc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICBmdWxsUmF3RGVmLmVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoZnVsbFJhd0RlZiwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLmNhbGVuZGFyKSAvLyBkdW1teSBzb3VyY2VcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCdXNpbmVzc0hvdXJHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91ckdlbmVyYXRvcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XHJcbnZhciBTdGFuZGFyZFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhbmRhcmRUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YW5kYXJkVGhlbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0YW5kYXJkVGhlbWU7XHJcbn0oVGhlbWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YW5kYXJkVGhlbWU7XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICB3aWRnZXQ6ICdmYy11bnRoZW1lZCcsXHJcbiAgICB3aWRnZXRIZWFkZXI6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIHdpZGdldENvbnRlbnQ6ICdmYy13aWRnZXQtY29udGVudCcsXHJcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXHJcbiAgICBidXR0b246ICdmYy1idXR0b24nLFxyXG4gICAgY29ybmVyTGVmdDogJ2ZjLWNvcm5lci1sZWZ0JyxcclxuICAgIGNvcm5lclJpZ2h0OiAnZmMtY29ybmVyLXJpZ2h0JyxcclxuICAgIHN0YXRlRGVmYXVsdDogJ2ZjLXN0YXRlLWRlZmF1bHQnLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdmYy1zdGF0ZS1hY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2ZjLXN0YXRlLWRpc2FibGVkJyxcclxuICAgIHN0YXRlSG92ZXI6ICdmYy1zdGF0ZS1ob3ZlcicsXHJcbiAgICBzdGF0ZURvd246ICdmYy1zdGF0ZS1kb3duJyxcclxuICAgIHBvcG92ZXJIZWFkZXI6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIHBvcG92ZXJDb250ZW50OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgLy8gZGF5IGdyaWRcclxuICAgIGhlYWRlclJvdzogJ2ZjLXdpZGdldC1oZWFkZXInLFxyXG4gICAgZGF5Um93OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ2ZjLXdpZGdldC1jb250ZW50J1xyXG59O1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcclxuICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcclxuICAgIHByZXY6ICdmYy1pY29uLWxlZnQtc2luZ2xlLWFycm93JyxcclxuICAgIG5leHQ6ICdmYy1pY29uLXJpZ2h0LXNpbmdsZS1hcnJvdycsXHJcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tbGVmdC1kb3VibGUtYXJyb3cnLFxyXG4gICAgbmV4dFllYXI6ICdmYy1pY29uLXJpZ2h0LWRvdWJsZS1hcnJvdydcclxufTtcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxudmFyIEpxdWVyeVVpVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhKcXVlcnlVaVRoZW1lLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSnF1ZXJ5VWlUaGVtZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSnF1ZXJ5VWlUaGVtZTtcclxufShUaGVtZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSnF1ZXJ5VWlUaGVtZTtcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgIHdpZGdldDogJ3VpLXdpZGdldCcsXHJcbiAgICB3aWRnZXRIZWFkZXI6ICd1aS13aWRnZXQtaGVhZGVyJyxcclxuICAgIHdpZGdldENvbnRlbnQ6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXHJcbiAgICBidXR0b246ICd1aS1idXR0b24nLFxyXG4gICAgY29ybmVyTGVmdDogJ3VpLWNvcm5lci1sZWZ0JyxcclxuICAgIGNvcm5lclJpZ2h0OiAndWktY29ybmVyLXJpZ2h0JyxcclxuICAgIHN0YXRlRGVmYXVsdDogJ3VpLXN0YXRlLWRlZmF1bHQnLFxyXG4gICAgc3RhdGVBY3RpdmU6ICd1aS1zdGF0ZS1hY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ3VpLXN0YXRlLWRpc2FibGVkJyxcclxuICAgIHN0YXRlSG92ZXI6ICd1aS1zdGF0ZS1ob3ZlcicsXHJcbiAgICBzdGF0ZURvd246ICd1aS1zdGF0ZS1kb3duJyxcclxuICAgIHRvZGF5OiAndWktc3RhdGUtaGlnaGxpZ2h0JyxcclxuICAgIHBvcG92ZXJIZWFkZXI6ICd1aS13aWRnZXQtaGVhZGVyJyxcclxuICAgIHBvcG92ZXJDb250ZW50OiAndWktd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgLy8gZGF5IGdyaWRcclxuICAgIGhlYWRlclJvdzogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgZGF5Um93OiAndWktd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ3VpLXdpZGdldC1jb250ZW50J1xyXG59O1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ3VpLWljb24nO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcclxuICAgIGNsb3NlOiAndWktaWNvbi1jbG9zZXRoaWNrJyxcclxuICAgIHByZXY6ICd1aS1pY29uLWNpcmNsZS10cmlhbmdsZS13JyxcclxuICAgIG5leHQ6ICd1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1lJyxcclxuICAgIHByZXZZZWFyOiAndWktaWNvbi1zZWVrLXByZXYnLFxyXG4gICAgbmV4dFllYXI6ICd1aS1pY29uLXNlZWstbmV4dCdcclxufTtcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ3RoZW1lQnV0dG9uSWNvbnMnO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAndGhlbWVJY29uJztcclxuSnF1ZXJ5VWlUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ3VpLWljb24tJztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGdW5jRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGdW5jRXZlbnRTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRnVuY0V2ZW50U291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhci5wdXNoTG9hZGluZygpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5mdW5jLmNhbGwoX3RoaXMuY2FsZW5kYXIsIHN0YXJ0LmNsb25lKCksIGVuZC5jbG9uZSgpLCB0aW1lem9uZSwgZnVuY3Rpb24gKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgb25SZXNvbHZlKF90aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mdW5jO1xyXG4gICAgfTtcclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyU3VjY2VzcyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgICAgIHRoaXMuZnVuYyA9IHJhd1Byb3BzLmV2ZW50cztcclxuICAgICAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG4gICAgfTtcclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgcmF3UHJvcHM7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIHJhdyBpbnB1dFxyXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24ocmF3SW5wdXQuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHJhd0lucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24ocmF3SW5wdXQpKSB7XHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0geyBldmVudHM6IHJhd0lucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRTb3VyY2VfMS5kZWZhdWx0LnBhcnNlLmNhbGwodGhpcywgcmF3UHJvcHMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGdW5jRXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZ1bmNFdmVudFNvdXJjZTtcclxuRnVuY0V2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgZXZlbnRzOiBmYWxzZSAvLyBkb24ndCBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBKc29uRmVlZEV2ZW50U291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSnNvbkZlZWRFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEpzb25GZWVkRXZlbnRTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhamF4U2V0dGluZ3MgPSB0aGlzLmFqYXhTZXR0aW5ncztcclxuICAgICAgICB2YXIgb25TdWNjZXNzID0gYWpheFNldHRpbmdzLnN1Y2Nlc3M7XHJcbiAgICAgICAgdmFyIG9uRXJyb3IgPSBhamF4U2V0dGluZ3MuZXJyb3I7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSB0aGlzLmJ1aWxkUmVxdWVzdFBhcmFtcyhzdGFydCwgZW5kLCB0aW1lem9uZSk7XHJcbiAgICAgICAgLy8gdG9kbzogZXZlbnR1YWxseSBoYW5kbGUgdGhlIHByb21pc2UncyB0aGVuLFxyXG4gICAgICAgIC8vIGRvbid0IGludGVyY2VwdCBzdWNjZXNzL2Vycm9yXHJcbiAgICAgICAgLy8gdGhvIHdpbGwgYmUgYSBicmVha2luZyBBUEkgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5jYWxlbmRhci5wdXNoTG9hZGluZygpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcclxuICAgICAgICAgICAgJC5hamF4KCQuZXh0ZW5kKHt9LCAvLyBkZXN0aW5hdGlvblxyXG4gICAgICAgICAgICBKc29uRmVlZEV2ZW50U291cmNlLkFKQVhfREVGQVVMVFMsIGFqYXhTZXR0aW5ncywge1xyXG4gICAgICAgICAgICAgICAgdXJsOiBfdGhpcy51cmwsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiByZXF1ZXN0UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJhd0V2ZW50RGVmcywgc3RhdHVzLCB4aHIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdFdmVudERlZnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tSZXMgPSB1dGlsXzEuYXBwbHlBbGwob25TdWNjZXNzLCBfdGhpcywgW3Jhd0V2ZW50RGVmcywgc3RhdHVzLCB4aHJdKTsgLy8gcmVkaXJlY3QgYHRoaXNgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoY2FsbGJhY2tSZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdFdmVudERlZnMgPSBjYWxsYmFja1JlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlc29sdmUoX3RoaXMucGFyc2VFdmVudERlZnMocmF3RXZlbnREZWZzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGRhdGEsIHN0YXR1cywgeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hcHBseUFsbChvbkVycm9yLCBfdGhpcywgW2RhdGEsIHN0YXR1cywgeGhyXSk7IC8vIHJlZGlyZWN0IGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5idWlsZFJlcXVlc3RQYXJhbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBhamF4U2V0dGluZ3MgPSB0aGlzLmFqYXhTZXR0aW5ncztcclxuICAgICAgICB2YXIgc3RhcnRQYXJhbSwgZW5kUGFyYW0sIHRpbWV6b25lUGFyYW07XHJcbiAgICAgICAgdmFyIGN1c3RvbVJlcXVlc3RQYXJhbXM7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgICAgIHN0YXJ0UGFyYW0gPSB0aGlzLnN0YXJ0UGFyYW07XHJcbiAgICAgICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFBhcmFtID0gY2FsZW5kYXIub3B0KCdzdGFydFBhcmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZFBhcmFtID0gdGhpcy5lbmRQYXJhbTtcclxuICAgICAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmRQYXJhbSA9IGNhbGVuZGFyLm9wdCgnZW5kUGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGltZXpvbmVQYXJhbSA9IHRoaXMudGltZXpvbmVQYXJhbTtcclxuICAgICAgICBpZiAodGltZXpvbmVQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRpbWV6b25lUGFyYW0gPSBjYWxlbmRhci5vcHQoJ3RpbWV6b25lUGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUICQuYWpheCBkYXRhIGZyb20gdGhlIG9wdGlvbnNcclxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGFqYXhTZXR0aW5ncy5kYXRhKSkge1xyXG4gICAgICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IGFqYXhTZXR0aW5ncy5kYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IGFqYXhTZXR0aW5ncy5kYXRhIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGN1c3RvbVJlcXVlc3RQYXJhbXMpO1xyXG4gICAgICAgIHBhcmFtc1tzdGFydFBhcmFtXSA9IHN0YXJ0LmZvcm1hdCgpO1xyXG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBlbmQuZm9ybWF0KCk7XHJcbiAgICAgICAgaWYgKHRpbWV6b25lICYmIHRpbWV6b25lICE9PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1t0aW1lem9uZVBhcmFtXSA9IHRpbWV6b25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cmw7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB0aGlzLmFqYXhTZXR0aW5ncyA9IHJhd1Byb3BzO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAodHlwZW9mIHJhd0lucHV0LnVybCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhd0lucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHsgdXJsOiByYXdJbnB1dCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50U291cmNlXzEuZGVmYXVsdC5wYXJzZS5jYWxsKHRoaXMsIHJhd1Byb3BzLCBjYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLkFKQVhfREVGQVVMVFMgPSB7XHJcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICBjYWNoZTogZmFsc2VcclxuICAgIH07XHJcbiAgICByZXR1cm4gSnNvbkZlZWRFdmVudFNvdXJjZTtcclxufShFdmVudFNvdXJjZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSnNvbkZlZWRFdmVudFNvdXJjZTtcclxuSnNvbkZlZWRFdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIC8vIGF1dG9tYXRpY2FsbHkgdHJhbnNmZXIgKHRydWUpLi4uXHJcbiAgICB1cmw6IHRydWUsXHJcbiAgICBzdGFydFBhcmFtOiB0cnVlLFxyXG4gICAgZW5kUGFyYW06IHRydWUsXHJcbiAgICB0aW1lem9uZVBhcmFtOiB0cnVlXHJcbn0pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbnZhciBUYXNrUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUYXNrUXVldWUoKSB7XHJcbiAgICAgICAgdGhpcy5xID0gW107XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnEucHVzaC5hcHBseSh0aGlzLnEsIGFyZ3MpOyAvLyBhcHBlbmRcclxuICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUuZ2V0SXNJZGxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQ7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS50cnlTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmIHRoaXMuY2FuUnVuTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzdGFydCcpO1xyXG4gICAgICAgICAgICB0aGlzLnJ1blJlbWFpbmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLmNhblJ1bk5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzUGF1c2VkICYmIHRoaXMucS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5ydW5SZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdGFzaztcclxuICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdGFzayA9IHRoaXMucS5zaGlmdCgpOyAvLyBhbHdheXMgZnJlc2hseSByZWZlcmVuY2UgcS4gbWlnaHQgaGF2ZSBiZWVuIHJlYXNzaWduZWQuXHJcbiAgICAgICAgICAgIHJlcyA9IHRoaXMucnVuVGFzayh0YXNrKTtcclxuICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMudGhlbikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jYW5SdW5OZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuUmVtYWluaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHByZXZlbnQgbWFya2luZyBhcyBzdG9wcGVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICh0aGlzLmNhblJ1bk5leHQoKSk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzdG9wJyk7IC8vIG5vdCByZWFsbHkgYSAnc3RvcCcgLi4uIG1vcmUgb2YgYSAnZHJhaW5lZCdcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGlmICdzdG9wJyBoYW5kbGVyIGFkZGVkIG1vcmUgdGFza3MuLi4uIFRPRE86IHdyaXRlIHRlc3QgZm9yIHRoaXNcclxuICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5ydW5UYXNrID0gZnVuY3Rpb24gKHRhc2spIHtcclxuICAgICAgICByZXR1cm4gdGFzaygpOyAvLyB0YXNrICppcyogdGhlIGZ1bmN0aW9uLCBidXQgc3ViY2xhc3NlcyBjYW4gY2hhbmdlIHRoZSBmb3JtYXQgb2YgYSB0YXNrXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRhc2tRdWV1ZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGFza1F1ZXVlO1xyXG5FbWl0dGVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGFza1F1ZXVlKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBUYXNrUXVldWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xyXG52YXIgUmVuZGVyUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZW5kZXJRdWV1ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclF1ZXVlKHdhaXRzQnlOYW1lc3BhY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLndhaXRzQnlOYW1lc3BhY2UgPSB3YWl0c0J5TmFtZXNwYWNlIHx8IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICh0YXNrRnVuYywgbmFtZXNwYWNlLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHRhc2sgPSB7XHJcbiAgICAgICAgICAgIGZ1bmM6IHRhc2tGdW5jLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHdhaXRNcztcclxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIHdhaXRNcyA9IHRoaXMud2FpdHNCeU5hbWVzcGFjZVtuYW1lc3BhY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVdhaXQod2FpdE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG91bmRUYXNrKHRhc2spKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy53YWl0TmFtZXNwYWNlICYmIHdhaXRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0V2FpdChuYW1lc3BhY2UsIHdhaXRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLnN0YXJ0V2FpdCA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIHdhaXRNcykge1xyXG4gICAgICAgIHRoaXMud2FpdE5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcclxuICAgICAgICB0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5kZWxheVdhaXQgPSBmdW5jdGlvbiAod2FpdE1zKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FpdElkKTtcclxuICAgICAgICB0aGlzLnNwYXduV2FpdCh3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5zcGF3bldhaXQgPSBmdW5jdGlvbiAod2FpdE1zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLndhaXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy53YWl0TmFtZXNwYWNlID0gbnVsbDtcclxuICAgICAgICAgICAgX3RoaXMudHJ5U3RhcnQoKTtcclxuICAgICAgICB9LCB3YWl0TXMpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jbGVhcldhaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy53YWl0SWQpO1xyXG4gICAgICAgICAgICB0aGlzLndhaXRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMud2FpdE5hbWVzcGFjZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX3N1cGVyLnByb3RvdHlwZS5jYW5SdW5OZXh0LmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YWl0aW5nIGZvciBhIGNlcnRhaW4gbmFtZXNwYWNlIHRvIHN0b3AgcmVjZWl2aW5nIHRhc2tzP1xyXG4gICAgICAgIGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgZGlmZmVyZW50IG5hbWVzcGFjZSB0YXNrIGluIHRoZSBtZWFudGltZSxcclxuICAgICAgICAgICAgLy8gdGhhdCBmb3JjZXMgYWxsIHByZXZpb3VzbHktd2FpdGluZyB0YXNrcyB0byBzdWRkZW5seSBleGVjdXRlLlxyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGRvIHRoaXMgaW4gY29uc3RhbnQgdGltZS5cclxuICAgICAgICAgICAgZm9yICh2YXIgcSA9IHRoaXMucSwgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocVtpXS5uYW1lc3BhY2UgIT09IHRoaXMud2FpdE5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBhbGxvdyBleGVjdXRpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5ydW5UYXNrID0gZnVuY3Rpb24gKHRhc2spIHtcclxuICAgICAgICB0YXNrLmZ1bmMoKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuY29tcG91bmRUYXNrID0gZnVuY3Rpb24gKG5ld1Rhc2spIHtcclxuICAgICAgICB2YXIgcSA9IHRoaXMucTtcclxuICAgICAgICB2YXIgc2hvdWxkQXBwZW5kID0gdHJ1ZTtcclxuICAgICAgICB2YXIgaSwgdGFzaztcclxuICAgICAgICBpZiAobmV3VGFzay5uYW1lc3BhY2UgJiYgbmV3VGFzay50eXBlID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBpbml0L2FkZC9yZW1vdmUgb3BzIHdpdGggc2FtZSBuYW1lc3BhY2UsIHJlZ2FyZGxlc3Mgb2Ygb3JkZXJcclxuICAgICAgICAgICAgZm9yIChpID0gcS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgdGFzayA9IHFbaV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhc2sudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luaXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRBcHBlbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGF0ZXN0IGRlc3Ryb3kgaXMgY2FuY2VsbGVkIG91dCBieSBub3QgZG9pbmcgdGhlIGluaXRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZmFsbHRocm91Z2guLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxLnNwbGljZShpLCAxKTsgLy8gcmVtb3ZlIHRhc2tcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hvdWxkQXBwZW5kKSB7XHJcbiAgICAgICAgICAgIHEucHVzaChuZXdUYXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNob3VsZEFwcGVuZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVuZGVyUXVldWU7XHJcbn0oVGFza1F1ZXVlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJRdWV1ZTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIGRhdGVfZm9ybWF0dGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbnZhciBDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xyXG52YXIgdXRpbF8yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbnZhciBEYXRlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF0ZUNvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERhdGVDb21wb25lbnQoX3ZpZXcsIF9vcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc1JUTCA9IGZhbHNlOyAvLyBmcmVxdWVudGx5IGFjY2Vzc2VkIG9wdGlvbnNcclxuICAgICAgICBfdGhpcy5oaXRzTmVlZGVkRGVwdGggPSAwOyAvLyBuZWNlc3NhcnkgYmVjYXVzZSBtdWx0aXBsZSBjYWxsZXJzIG1pZ2h0IG5lZWQgdGhlIHNhbWUgaGl0c1xyXG4gICAgICAgIF90aGlzLmhhc0FsbERheUJ1c2luZXNzSG91cnMgPSBmYWxzZTsgLy8gVE9ETzogdW5pZnkgd2l0aCBsYXJnZVVuaXQgYW5kIGlzVGltZVNjYWxlP1xyXG4gICAgICAgIF90aGlzLmlzRGF0ZXNSZW5kZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGhhY2sgdG8gc2V0IG9wdGlvbnMgcHJpb3IgdG8gdGhlIHRoaXMub3B0IGNhbGxzXHJcbiAgICAgICAgaWYgKF92aWV3KSB7XHJcbiAgICAgICAgICAgIF90aGlzWyd2aWV3J10gPSBfdmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9vcHRpb25zKSB7XHJcbiAgICAgICAgICAgIF90aGlzWydvcHRpb25zJ10gPSBfb3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMudWlkID0gU3RyaW5nKERhdGVDb21wb25lbnQuZ3VpZCsrKTtcclxuICAgICAgICBfdGhpcy5jaGlsZHJlbkJ5VWlkID0ge307XHJcbiAgICAgICAgX3RoaXMubmV4dERheVRocmVzaG9sZCA9IG1vbWVudC5kdXJhdGlvbihfdGhpcy5vcHQoJ25leHREYXlUaHJlc2hvbGQnKSk7XHJcbiAgICAgICAgX3RoaXMuaXNSVEwgPSBfdGhpcy5vcHQoJ2lzUlRMJyk7XHJcbiAgICAgICAgaWYgKF90aGlzLmZpbGxSZW5kZXJlckNsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmZpbGxSZW5kZXJlciA9IG5ldyBfdGhpcy5maWxsUmVuZGVyZXJDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudFJlbmRlcmVyQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRSZW5kZXJlciA9IG5ldyBfdGhpcy5ldmVudFJlbmRlcmVyQ2xhc3MoX3RoaXMsIF90aGlzLmZpbGxSZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5oZWxwZXJSZW5kZXJlckNsYXNzICYmIF90aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGVscGVyUmVuZGVyZXIgPSBuZXcgX3RoaXMuaGVscGVyUmVuZGVyZXJDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRSZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzICYmIF90aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlciA9IG5ldyBfdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzKF90aGlzLCBfdGhpcy5maWxsUmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF0gPSBjaGlsZDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF07XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETzogb25seSBkbyBpZiBpc0luRG9tP1xyXG4gICAgLy8gVE9ETzogbWFrZSBwYXJ0IG9mIENvbXBvbmVudCwgYWxvbmcgd2l0aCBjaGlsZHJlbi9iYXRjaC1yZW5kZXIgc3lzdGVtP1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1cGRhdGVTaXplJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBPcHRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlldygpLm9wdChuYW1lKTsgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnB1YmxpY2x5VHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5fZ2V0Q2FsZW5kYXIoKTtcclxuICAgICAgICByZXR1cm4gY2FsZW5kYXIucHVibGljbHlUcmlnZ2VyLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oYXNQdWJsaWNIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5fZ2V0Q2FsZW5kYXIoKTtcclxuICAgICAgICByZXR1cm4gY2FsZW5kYXIuaGFzUHVibGljSGFuZGxlcnMuYXBwbHkoY2FsZW5kYXIsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIERhdGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTsgLy8gZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0ZXMoZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIHRoaXMuaXNEYXRlc1JlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZURhdGVSZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVEYXRlVW5yZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJEYXRlcygpO1xyXG4gICAgICAgIHRoaXMuaXNEYXRlc1JlbmRlcmVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gZGF0ZS1jZWxsIGNvbnRlbnQgb25seVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBkYXRlLWNlbGwgY29udGVudCBvbmx5XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgLy8gTm93LUluZGljYXRvclxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcgdW5pdCwgbGlrZSAnc2Vjb25kJyBvciAnbWludXRlJyB0aGF0IGRlZmluZWQgaG93IG9mdGVuIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yXHJcbiAgICAvLyBzaG91bGQgYmUgcmVmcmVzaGVkLiBJZiBzb21ldGhpbmcgZmFsc3kgaXMgcmV0dXJuZWQsIG5vIHRpbWUgaW5kaWNhdG9yIGlzIHJlbmRlcmVkIGF0IGFsbC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldE5vd0luZGljYXRvclVuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBhIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYXQgdGhlIGdpdmVuIGRhdGV0aW1lXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJOb3dJbmRpY2F0b3InLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVuZG9lcyB0aGUgcmVuZGVyaW5nIGFjdGlvbnMgZnJvbSByZW5kZXJOb3dJbmRpY2F0b3JcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlck5vd0luZGljYXRvcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVzaW5lc3MgSG91cnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyLnJlbmRlcihidXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyQnVzaW5lc3NIb3VycycsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHByZXZpb3VzbHktcmVuZGVyZWQgYnVzaW5lc3MtaG91cnNcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJCdXNpbmVzc0hvdXJzJywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERpc3BsYXlpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRXZlbnRSZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJhbmdlVXBkYXRlZCgpOyAvLyBwb29ybHkgbmFtZWQgbm93XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXIoZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXNbJ3JlbmRlckV2ZW50cyddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlckV2ZW50cyddKGNvbnZlcnRFdmVudHNQYXlsb2FkVG9MZWdhY3lBcnJheShldmVudHNQYXlsb2FkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdleGVjdXRlRXZlbnRSZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdleGVjdXRlRXZlbnRVbnJlbmRlcicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpc1snZGVzdHJveUV2ZW50cyddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ2Rlc3Ryb3lFdmVudHMnXSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRCdXNpbmVzc0hvdXJTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5nZXRPd25CdXNpbmVzc0hvdXJTZWdzKCk7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHNlZ3MucHVzaC5hcHBseShzZWdzLCBjaGlsZC5nZXRCdXNpbmVzc0hvdXJTZWdzKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldE93bkJ1c2luZXNzSG91clNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVzaW5lc3NIb3VyUmVuZGVyZXIuZ2V0U2VncygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0RXZlbnRTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5nZXRPd25FdmVudFNlZ3MoKTtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIGNoaWxkLmdldEV2ZW50U2VncygpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRSZW5kZXJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlbmRlcmVyLmdldFNlZ3MoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IFJlbmRlcmluZyBUcmlnZ2VyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudHJpZ2dlckFmdGVyRXZlbnRzUmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyQWZ0ZXJFdmVudFNlZ3NSZW5kZXJlZCh0aGlzLmdldEV2ZW50U2VncygpKTtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRBZnRlckFsbFJlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXNdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudHJpZ2dlckFmdGVyRXZlbnRTZWdzUmVuZGVyZWQgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gYW4gb3B0aW1pemF0aW9uLCBiZWNhdXNlIGdldEV2ZW50TGVnYWN5IGlzIGV4cGVuc2l2ZVxyXG4gICAgICAgIGlmICh0aGlzLmhhc1B1YmxpY0hhbmRsZXJzKCdldmVudEFmdGVyUmVuZGVyJykpIHtcclxuICAgICAgICAgICAgc2Vncy5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZWdhY3k7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnYWN5ID0gc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRBZnRlclJlbmRlcicsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbGVnYWN5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbbGVnYWN5LCBzZWcuZWwsIF90aGlzXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudHJpZ2dlckJlZm9yZUV2ZW50c0Rlc3Ryb3llZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXJCZWZvcmVFdmVudFNlZ3NEZXN0cm95ZWQodGhpcy5nZXRFdmVudFNlZ3MoKSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudHJpZ2dlckJlZm9yZUV2ZW50U2Vnc0Rlc3Ryb3llZCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5oYXNQdWJsaWNIYW5kbGVycygnZXZlbnREZXN0cm95JykpIHtcclxuICAgICAgICAgICAgc2Vncy5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZWdhY3k7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnYWN5ID0gc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREZXN0cm95Jywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIHNlZy5lbCwgX3RoaXNdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZW5kZXJpbmcgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBIaWRlcyBhbGwgcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgbGlua2VkIHRvIHRoZSBnaXZlbiBldmVudFxyXG4gICAgLy8gUkVDVVJTSVZFIHdpdGggc3ViY29tcG9uZW50c1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvd0V2ZW50c1dpdGhJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgaWYgKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQgPT09IGV2ZW50RGVmSWQgJiZcclxuICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcygndmlzaWJpbGl0eScsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdzaG93RXZlbnRzV2l0aElkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBTaG93cyBhbGwgcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgbGlua2VkIHRvIHRoZSBnaXZlbiBldmVudFxyXG4gICAgLy8gUkVDVVJTSVZFIHdpdGggc3ViY29tcG9uZW50c1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGlkZUV2ZW50c1dpdGhJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgaWYgKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQgPT09IGV2ZW50RGVmSWQgJiZcclxuICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdoaWRlRXZlbnRzV2l0aElkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBEcmFnLW4tRHJvcCBSZW5kZXJpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGV2ZW50IG9yIGV4dGVybmFsLWVsZW1lbnQgZHJhZyBvdmVyIHRoZSBnaXZlbiBkcm9wIHpvbmUuXHJcbiAgICAvLyBJZiBhbiBleHRlcm5hbC1lbGVtZW50LCBzZWcgd2lsbCBiZSBgbnVsbGAuXHJcbiAgICAvLyBNdXN0IHJldHVybiBlbGVtZW50cyB1c2VkIGZvciBhbnkgbW9jayBldmVudHMuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkSGVscGVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5yZW5kZXJEcmFnKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRIZWxwZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkSGVscGVyO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsLWVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJEcmFnJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZXNpemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlckV2ZW50UmVzaXplJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJFdmVudFJlc2l6ZScsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VsZWN0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiB0aGUgc2VsZWN0aW9uXHJcbiAgICAvLyBUT0RPOiByZW5hbWUgdG8gYHJlbmRlclNlbGVjdGlvbmAgYWZ0ZXIgbGVnYWN5IGlzIGdvbmVcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHNlbGVjdGlvblxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlclNlbGVjdGlvbicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSGlnaGxpZ2h0XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYW4gZW1waGFzaXMgb24gdGhlIGdpdmVuIGRhdGUgcmFuZ2UuIEdpdmVuIGEgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIG1pc2MgZGF0YSlcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckhpZ2hsaWdodCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyRm9vdHByaW50KCdoaWdobGlnaHQnLCBjb21wb25lbnRGb290cHJpbnQsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmYy1oaWdobGlnaHQnXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJIaWdobGlnaHQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyB0aGUgZW1waGFzaXMgb24gYSBkYXRlIHJhbmdlXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIudW5yZW5kZXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJIaWdobGlnaHQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEhpdCBBcmVhc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBqdXN0IGJlY2F1c2UgYWxsIERhdGVDb21wb25lbnRzIHN1cHBvcnQgdGhpcyBpbnRlcmZhY2VcclxuICAgIC8vIGRvZXNuJ3QgbWVhbiB0aGV5IG5lZWQgdG8gaGF2ZSB0aGVpciBvd24gaW50ZXJuYWwgY29vcmQgc3lzdGVtLiB0aGV5IGNhbiBkZWZlciB0byBzdWItY29tcG9uZW50cy5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhpdHNOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5oaXRzTmVlZGVkRGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignaGl0c05lZWRlZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGl0c05vdE5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXRzTmVlZGVkRGVwdGggJiYgISgtLXRoaXMuaGl0c05lZWRlZERlcHRoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VIaXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdoaXRzTm90TmVlZGVkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBjb29yZGluYXRlcyBmcm9tIHRoZSB0b3BsZWZ0IG9mIHRoZSBkb2N1bWVudCwgcmV0dXJuIGRhdGEgYWJvdXQgdGhlIGRhdGUtcmVsYXRlZCBhcmVhIHVuZGVybmVhdGguXHJcbiAgICAvLyBDYW4gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGFyYml0cmFyeSBwcm9wZXJ0aWVzIChhbHRob3VnaCB0b3AvcmlnaHQvbGVmdC9ib3R0b20gYXJlIGVuY291cmFnZWQpLlxyXG4gICAgLy8gTXVzdCBoYXZlIGEgYGdyaWRgIHByb3BlcnR5LCBhIHJlZmVyZW5jZSB0byB0aGlzIGN1cnJlbnQgZ3JpZC4gVE9ETzogYXZvaWQgdGhpc1xyXG4gICAgLy8gVGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBnZXRIaXRGb290cHJpbnQgYW5kIGdldEhpdEVsLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuQnlVaWQgPSB0aGlzLmNoaWxkcmVuQnlVaWQ7XHJcbiAgICAgICAgdmFyIHVpZDtcclxuICAgICAgICB2YXIgaGl0O1xyXG4gICAgICAgIGZvciAodWlkIGluIGNoaWxkcmVuQnlVaWQpIHtcclxuICAgICAgICAgICAgaGl0ID0gY2hpbGRyZW5CeVVpZFt1aWRdLnF1ZXJ5SGl0KGxlZnRPZmZzZXQsIHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2FmZUhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgZm9vdHByaW50ID0gdGhpcy5nZXRIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoZm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb290cHJpbnQ7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIHdoYXQgYWJvdXQgYmVpbmcgYWJzdHJhY3QhP1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHBvc2l0aW9uLWxldmVsIGluZm9ybWF0aW9uIGFib3V0IGEgZGF0ZS1yZWxhdGVkIGFyZWEgd2l0aGluIHRoZSBncmlkLFxyXG4gICAgLy8gc2hvdWxkIHJldHVybiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgYmVzdCByZXByZXNlbnRzIGl0LiBwYXNzZWQgdG8gZGF5Q2xpY2sgY2FsbGJhY2suXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRIaXRFbCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyB3aGF0IGFib3V0IGJlaW5nIGFic3RyYWN0IT9cclxuICAgIH07XHJcbiAgICAvKiBDb252ZXJ0aW5nIGV2ZW50UmFuZ2UgLT4gZXZlbnRGb290cHJpbnRcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudFJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMucHVzaC5hcHBseSgvLyBhcHBlbmRcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLCB0aGlzLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRGb290cHJpbnRzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1dGlsXzIuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSldO1xyXG4gICAgfTtcclxuICAgIC8qIENvbnZlcnRpbmcgY29tcG9uZW50Rm9vdHByaW50L2V2ZW50Rm9vdHByaW50IC0+IHNlZ3NcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudEZvb3RwcmludHNUb1NlZ3MgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3MucHVzaC5hcHBseShzZWdzLCB0aGlzLmV2ZW50Rm9vdHByaW50VG9TZWdzKGV2ZW50Rm9vdHByaW50c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBldmVudCdzIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpLCBhbmQgdGhlIGV2ZW50IGl0c2VsZixcclxuICAgIC8vIHNsaWNlcyBpbnRvIHNlZ21lbnRzIGFuZCBhdHRhY2hlcyBldmVudC1kZXJpdmVkIHByb3BlcnRpZXMgdG8gdGhlbS5cclxuICAgIC8vIGV2ZW50U3BhbiAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQsIG90aGVydGhpbmdzLi4uIH1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZSA9IGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIHNlZ3M7XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICBzZWdzID0gdGhpcy5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MoZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXVuem9uZWRSYW5nZS5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdW56b25lZFJhbmdlLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWcuZm9vdHByaW50ID0gZXZlbnRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbmFtZSB0byBzZWcuZXZlbnRGb290cHJpbnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZFttZXRob2ROYW1lXS5hcHBseShjaGlsZCwgYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXRlckNoaWxkcmVuID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW5CeVVpZCA9IHRoaXMuY2hpbGRyZW5CeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIGZvciAodWlkIGluIGNoaWxkcmVuQnlVaWQpIHtcclxuICAgICAgICAgICAgZnVuYyhjaGlsZHJlbkJ5VWlkW3VpZF0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5fZ2V0Q2FsZW5kYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0LmNhbGVuZGFyIHx8IHQudmlldy5jYWxlbmRhcjtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5fZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLl9nZXREYXRlUHJvZmlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlldygpLmdldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgSFRNTCBmb3IgYW4gYW5jaG9yIHRvIGFub3RoZXIgdmlldyBpbnRvIHRoZSBjYWxlbmRhci5cclxuICAgIC8vIFdpbGwgZWl0aGVyIGdlbmVyYXRlIGFuIDxhPiB0YWcgb3IgYSBub24tY2xpY2thYmxlIDxzcGFuPiB0YWcsIGRlcGVuZGluZyBvbiBlbmFibGVkIHNldHRpbmdzLlxyXG4gICAgLy8gYGdvdG9PcHRpb25zYCBjYW4gZWl0aGVyIGJlIGEgbW9tZW50IGlucHV0LCBvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9ybTpcclxuICAgIC8vIHsgZGF0ZSwgdHlwZSwgZm9yY2VPZmYgfVxyXG4gICAgLy8gYHR5cGVgIGlzIGEgdmlldy10eXBlIGxpa2UgXCJkYXlcIiBvciBcIndlZWtcIi4gZGVmYXVsdCB2YWx1ZSBpcyBcImRheVwiLlxyXG4gICAgLy8gYGF0dHJzYCBhbmQgYGlubmVySHRtbGAgYXJlIHVzZSB0byBnZW5lcmF0ZSB0aGUgcmVzdCBvZiB0aGUgSFRNTCB0YWcuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZEdvdG9BbmNob3JIdG1sID0gZnVuY3Rpb24gKGdvdG9PcHRpb25zLCBhdHRycywgaW5uZXJIdG1sKSB7XHJcbiAgICAgICAgdmFyIGRhdGUsIHR5cGUsIGZvcmNlT2ZmO1xyXG4gICAgICAgIHZhciBmaW5hbE9wdGlvbnM7XHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChnb3RvT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IGdvdG9PcHRpb25zLmRhdGU7XHJcbiAgICAgICAgICAgIHR5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICBmb3JjZU9mZiA9IGdvdG9PcHRpb25zLmZvcmNlT2ZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0ZSA9IGdvdG9PcHRpb25zOyAvLyBhIHNpbmdsZSBtb21lbnQgaW5wdXRcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZSA9IG1vbWVudF9leHRfMS5kZWZhdWx0KGRhdGUpOyAvLyBpZiBhIHN0cmluZywgcGFyc2UgaXRcclxuICAgICAgICBmaW5hbE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyksXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgJ2RheSdcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IGF0dHJzO1xyXG4gICAgICAgICAgICBhdHRycyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF0dHJzID0gYXR0cnMgPyAnICcgKyB1dGlsXzEuYXR0cnNUb1N0cihhdHRycykgOiAnJzsgLy8gd2lsbCBoYXZlIGEgbGVhZGluZyBzcGFjZVxyXG4gICAgICAgIGlubmVySHRtbCA9IGlubmVySHRtbCB8fCAnJztcclxuICAgICAgICBpZiAoIWZvcmNlT2ZmICYmIHRoaXMub3B0KCduYXZMaW5rcycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPGEnICsgYXR0cnMgK1xyXG4gICAgICAgICAgICAgICAgJyBkYXRhLWdvdG89XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoSlNPTi5zdHJpbmdpZnkoZmluYWxPcHRpb25zKSkgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwgK1xyXG4gICAgICAgICAgICAgICAgJzwvYT4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8c3BhbicgKyBhdHRycyArICc+JyArXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwgK1xyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBbGxEYXlIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnYWxsRGF5SHRtbCcpIHx8IHV0aWxfMS5odG1sRXNjYXBlKHRoaXMub3B0KCdhbGxEYXlUZXh0JykpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIEhUTUwgY2xhc3NOYW1lcyBmb3IgYSBzaW5nbGUtZGF5IGVsZW1lbnRcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldERheUNsYXNzZXMgPSBmdW5jdGlvbiAoZGF0ZSwgbm9UaGVtZUhpZ2hsaWdodCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gW107XHJcbiAgICAgICAgdmFyIHRvZGF5O1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZGlzYWJsZWQtZGF5Jyk7IC8vIFRPRE86IGpRdWVyeSBVSSB0aGVtZT9cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtJyArIHV0aWxfMS5kYXlJRHNbZGF0ZS5kYXkoKV0pO1xyXG4gICAgICAgICAgICBpZiAodmlldy5pc0RhdGVJbk90aGVyTW9udGgoZGF0ZSwgdGhpcy5kYXRlUHJvZmlsZSkpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtb3RoZXItbW9udGgnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b2RheSA9IHZpZXcuY2FsZW5kYXIuZ2V0Tm93KCk7XHJcbiAgICAgICAgICAgIGlmIChkYXRlLmlzU2FtZSh0b2RheSwgJ2RheScpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLXRvZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9UaGVtZUhpZ2hsaWdodCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRlIDwgdG9kYXkpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtcGFzdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1mdXR1cmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH07XHJcbiAgICAvLyBVdGlsaXR5IGZvciBmb3JtYXR0aW5nIGEgcmFuZ2UuIEFjY2VwdHMgYSByYW5nZSBvYmplY3QsIGZvcm1hdHRpbmcgc3RyaW5nLCBhbmQgb3B0aW9uYWwgc2VwYXJhdG9yLlxyXG4gICAgLy8gRGlzcGxheXMgYWxsLWRheSByYW5nZXMgbmF0dXJhbGx5LCB3aXRoIGFuIGluY2x1c2l2ZSBlbmQuIFRha2VzIHRoZSBjdXJyZW50IGlzUlRMIGludG8gYWNjb3VudC5cclxuICAgIC8vIFRoZSB0aW1lem9uZXMgb2YgdGhlIGRhdGVzIHdpdGhpbiBgcmFuZ2VgIHdpbGwgYmUgcmVzcGVjdGVkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIGlzQWxsRGF5LCBmb3JtYXRTdHIsIHNlcGFyYXRvcikge1xyXG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XHJcbiAgICAgICAgaWYgKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KDEpOyAvLyBjb252ZXJ0IHRvIGluY2x1c2l2ZS4gbGFzdCBtcyBvZiBwcmV2aW91cyBkYXlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCBlbmQsIGZvcm1hdFN0ciwgc2VwYXJhdG9yLCB0aGlzLmlzUlRMKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlIHRoZSBudW1iZXIgb2YgdGhlIGdpdmUgdW5pdHMgaW4gdGhlIFwiY3VycmVudFwiIHJhbmdlLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuIFdvbid0IHJvdW5kLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudFJhbmdlQXMgPSBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREYXRlUHJvZmlsZSgpLmN1cnJlbnRVbnpvbmVkUmFuZ2UuYXModW5pdCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgZGF0ZSByYW5nZSBvZiB0aGUgZnVsbCBkYXlzIHRoZSBnaXZlbiByYW5nZSB2aXN1YWxseSBhcHBlYXJzIHRvIG9jY3VweS5cclxuICAgIC8vIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBzdGFydC9lbmQsIE5PVCBhbiBVbnpvbmVkUmFuZ2UhXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wdXRlRGF5UmFuZ2UgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5fZ2V0Q2FsZW5kYXIoKTtcclxuICAgICAgICB2YXIgc3RhcnREYXkgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KHVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBzdGFydHNcclxuICAgICAgICB2YXIgZW5kID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh1bnpvbmVkUmFuZ2UuZW5kTXMpO1xyXG4gICAgICAgIHZhciBlbmRUaW1lTVMgPSArZW5kLnRpbWUoKTsgLy8gIyBvZiBtaWxsaXNlY29uZHMgaW50byBgZW5kRGF5YFxyXG4gICAgICAgIHZhciBlbmREYXkgPSBlbmQuY2xvbmUoKS5zdHJpcFRpbWUoKTsgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBleGNsdXNpdmVseSBlbmRzXHJcbiAgICAgICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxyXG4gICAgICAgIC8vIGJleW9uZCB0aGUgbmV4dCBkYXkgdGhyZXNob2xkLCBhZGp1c3QgdGhlIGVuZCB0byBiZSB0aGUgZXhjbHVzaXZlIGVuZCBvZiBgZW5kRGF5YC5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cclxuICAgICAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSB0aGlzLm5leHREYXlUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgZW5kRGF5LmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxyXG4gICAgICAgIGlmIChlbmREYXkgPD0gc3RhcnREYXkpIHtcclxuICAgICAgICAgICAgZW5kRGF5ID0gc3RhcnREYXkuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xyXG4gICAgfTtcclxuICAgIC8vIERvZXMgdGhlIGdpdmVuIHJhbmdlIHZpc3VhbGx5IGFwcGVhciB0byBvY2N1cHkgbW9yZSB0aGFuIG9uZSBkYXk/XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc011bHRpRGF5UmFuZ2UgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGRheVJhbmdlID0gdGhpcy5jb21wdXRlRGF5UmFuZ2UodW56b25lZFJhbmdlKTtcclxuICAgICAgICByZXR1cm4gZGF5UmFuZ2UuZW5kLmRpZmYoZGF5UmFuZ2Uuc3RhcnQsICdkYXlzJykgPiAxO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQuZ3VpZCA9IDA7IC8vIFRPRE86IGJldHRlciBzeXN0ZW0gZm9yIHRoaXM/XHJcbiAgICByZXR1cm4gRGF0ZUNvbXBvbmVudDtcclxufShDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVDb21wb25lbnQ7XHJcbi8vIGxlZ2FjeVxyXG5mdW5jdGlvbiBjb252ZXJ0RXZlbnRzUGF5bG9hZFRvTGVnYWN5QXJyYXkoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgdmFyIGV2ZW50RGVmSWQ7XHJcbiAgICB2YXIgZXZlbnRJbnN0YW5jZXM7XHJcbiAgICB2YXIgbGVnYWN5RXZlbnRzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoZXZlbnREZWZJZCBpbiBldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZXMgPSBldmVudHNQYXlsb2FkW2V2ZW50RGVmSWRdLmV2ZW50SW5zdGFuY2VzO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZWdhY3lFdmVudHMucHVzaChldmVudEluc3RhbmNlc1tpXS50b0xlZ2FjeSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVnYWN5RXZlbnRzO1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlUHJvZmlsZUdlbmVyYXRvcihfdmlldykge1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcclxuICAgIH1cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcudHJpbUhpZGRlbkRheXModW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUubXNUb1V0Y01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5jYWxlbmRhci5tc1RvVXRjTW9tZW50KG1zLCBmb3JjZUFsbERheSk7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUHJldiA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgcHJldkRhdGUgPSBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZS5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5zdGFydE9mKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxyXG4gICAgICAgICAgICAuc3VidHJhY3QoY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGROZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBuZXh0RGF0ZSA9IGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlLmNsb25lKClcclxuICAgICAgICAgICAgLnN0YXJ0T2YoY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpXHJcbiAgICAgICAgICAgIC5hZGQoY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBPcHRpb25hbCBkaXJlY3Rpb24gcGFyYW0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgYmVpbmcgaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWRcclxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCA9PT0gdm9pZCAwKSB7IGZvcmNlVG9WYWxpZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGlzRGF0ZUFsbERheSA9ICFkYXRlLmhhc1RpbWUoKTtcclxuICAgICAgICB2YXIgdmFsaWRVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIG1pblRpbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBtYXhUaW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgY3VycmVudEluZm87XHJcbiAgICAgICAgdmFyIGlzUmFuZ2VBbGxEYXk7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBpc1ZhbGlkO1xyXG4gICAgICAgIHZhbGlkVW56b25lZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcclxuICAgICAgICB2YWxpZFVuem9uZWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRVbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMubXNUb1V0Y01vbWVudCh2YWxpZFVuem9uZWRSYW5nZS5jb25zdHJhaW5EYXRlKGRhdGUpLCAvLyByZXR1cm5zIE1TXHJcbiAgICAgICAgICAgIGlzRGF0ZUFsbERheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xyXG4gICAgICAgIHJlbmRlclVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZSksIGN1cnJlbnRJbmZvLnVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHJlbmRlclVuem9uZWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyVW56b25lZFJhbmdlKTtcclxuICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2UgPSByZW5kZXJVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgICAgICBpZiAoIXRoaXMub3B0KCdzaG93Tm9uQ3VycmVudERhdGVzJykpIHtcclxuICAgICAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gYWN0aXZlVW56b25lZFJhbmdlLmludGVyc2VjdChjdXJyZW50SW5mby51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5UaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtaW5UaW1lJykpO1xyXG4gICAgICAgIG1heFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ21heFRpbWUnKSk7XHJcbiAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVVbnpvbmVkUmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpO1xyXG4gICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IGFjdGl2ZVVuem9uZWRSYW5nZS5pbnRlcnNlY3QodmFsaWRVbnpvbmVkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxyXG4gICAgICAgIGlmIChhY3RpdmVVbnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMubXNUb1V0Y01vbWVudChhY3RpdmVVbnpvbmVkUmFuZ2UuY29uc3RyYWluRGF0ZShkYXRlKSwgLy8gcmV0dXJucyBNU1xyXG4gICAgICAgICAgICBpc0RhdGVBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcclxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAgICBpc1ZhbGlkID0gY3VycmVudEluZm8udW56b25lZFJhbmdlLmludGVyc2VjdHNXaXRoKHZhbGlkVW56b25lZFJhbmdlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxyXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIHZhbGlkVW56b25lZFJhbmdlOiB2YWxpZFVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxyXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcclxuICAgICAgICAgICAgY3VycmVudFVuem9uZWRSYW5nZTogY3VycmVudEluZm8udW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXHJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXHJcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXk6IGlzUmFuZ2VBbGxEYXksXHJcbiAgICAgICAgICAgIC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXHJcbiAgICAgICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZTogYWN0aXZlVW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cclxuICAgICAgICAgICAgcmVuZGVyVW56b25lZFJhbmdlOiByZW5kZXJVbnpvbmVkUmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XHJcbiAgICAgICAgICAgIG1pblRpbWU6IG1pblRpbWUsXHJcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgbWF4VGltZTogbWF4VGltZSxcclxuICAgICAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcclxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcclxuICAgICAgICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKVxyXG4gICAgICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cclxuICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXHJcbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkVmFsaWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRVbnpvbmVkUmFuZ2VPcHRpb24oJ3ZhbGlkUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmdldE5vdygpKSB8fFxyXG4gICAgICAgICAgICBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdCgpOyAvLyBjb21wbGV0ZWx5IG9wZW4tZW5kZWRcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcclxuICAgIC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxyXG4gICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXHJcbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgdmlld1NwZWMgPSB0aGlzLl92aWV3LnZpZXdTcGVjO1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIHZhciBkYXlDb3VudDtcclxuICAgICAgICBpZiAodmlld1NwZWMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB2aWV3U3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdW5pdCA9IHZpZXdTcGVjLmR1cmF0aW9uVW5pdDtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLm9wdCgnZGF5Q291bnQnKSkpIHtcclxuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xyXG4gICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQodW56b25lZFJhbmdlLmdldFN0YXJ0KCksIHVuem9uZWRSYW5nZS5nZXRFbmQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xyXG4gICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgdW56b25lZFJhbmdlOiB1bnpvbmVkUmFuZ2UgfTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogMSB9KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgbmV3IGFjdGl2ZVVuem9uZWRSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXHJcbiAgICAvLyBtaW5UaW1lIG9yIG1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYWRqdXN0QWN0aXZlUmFuZ2UgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlLCBtaW5UaW1lLCBtYXhUaW1lKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICBpZiAodGhpcy5fdmlldy51c2VzTWluTWF4VGltZSkge1xyXG4gICAgICAgICAgICBpZiAobWluVGltZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCkuYWRkKG1pblRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhUaW1lID4gMjQgKiA2MCAqIDYwICogMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnRpbWUobWF4VGltZSAtICgyNCAqIDYwICogNjAgKiAxMDAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBpdCBpcyBzcGVjaWZpZWQgYXMgYW4gZXhwbGljaXQgZHVyYXRpb24uXHJcbiAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgY29tcHV0ZUdyZWF0ZXN0VW5pdCB2YWx1ZSBvZiBkdXJhdGlvbi5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EdXJhdGlvbiA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XHJcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50Jyk7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnRJbnB1dDtcclxuICAgICAgICB2YXIgZGF0ZUluY3JlbWVudER1cmF0aW9uO1xyXG4gICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIHZhciByZXM7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXHJcbiAgICAgICAgaWYgKCFhbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudElucHV0ID0gdGhpcy5vcHQoJ2RhdGVJbmNyZW1lbnQnKTtcclxuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnREdXJhdGlvbiA8IGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdXRpbF8xLmNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkYXRlSW5jcmVtZW50RHVyYXRpb24sIGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxyXG4gICAgICAgIGlmIChkdXJhdGlvbi5hcygnZGF5cycpIDw9IDEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZXcuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX3ZpZXcuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5zdGFydE9mKCdkYXknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUmVzKCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKGR1cmF0aW9uKTtcclxuICAgICAgICAgICAgcmVzID0gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXB1dGVSZXMoKTtcclxuICAgICAgICAvLyBpZiByYW5nZSBpcyBjb21wbGV0ZWx5IGVudmVsb3BlZCBieSBoaWRkZW4gZGF5cywgZ28gcGFzdCB0aGUgaGlkZGVuIGRheXNcclxuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5fdmlldy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxyXG4gICAgLy8gVE9ETzogYWNjZXB0IGEgTVMtdGltZSBpbnN0ZWFkIG9mIGEgbW9tZW50IGBkYXRlYD9cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbURheUNvdW50ID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcclxuICAgICAgICB2YXIgY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5vcHQoJ2RhdGVBbGlnbm1lbnQnKTtcclxuICAgICAgICB2YXIgcnVubmluZ0NvdW50ID0gMDtcclxuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAoY3VzdG9tQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0YXJ0T2YoY3VzdG9tQWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnQuc3RhcnRPZignZGF5Jyk7XHJcbiAgICAgICAgc3RhcnQgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBlbmQuYWRkKDEsICdkYXknKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl92aWV3LmlzSGlkZGVuRGF5KGVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHJ1bm5pbmdDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxyXG4gICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50VW56b25lZFJhbmdlIGFuZCBhY3RpdmVVbnpvbmVkUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cclxuICAgIC8vIFRPRE86IGFjY2VwdCBhIE1TLXRpbWUgaW5zdGVhZCBvZiBhIG1vbWVudCBgZGF0ZWA/XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciB2aXNpYmxlVW56b25lZFJhbmdlID0gdGhpcy5fdmlldy5nZXRVbnpvbmVkUmFuZ2VPcHRpb24oJ3Zpc2libGVSYW5nZScsIHRoaXMuX3ZpZXcuY2FsZW5kYXIuYXBwbHlUaW1lem9uZShkYXRlKSAvLyBjb3JyZWN0IHpvbmUuIGFsc28gZ2VuZXJhdGVzIG5ldyBvYmogdGhhdCBhdm9pZHMgbXV0YXRpb25zXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodmlzaWJsZVVuem9uZWRSYW5nZSAmJiAodmlzaWJsZVVuem9uZWRSYW5nZS5zdGFydE1zID09IG51bGwgfHwgdmlzaWJsZVVuem9uZWRSYW5nZS5lbmRNcyA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpc2libGVVbnpvbmVkUmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHJhbmdlIHRoYXQgd2lsbCByZXByZXNlbnQgdGhlIGVsZW1lbnQvY2VsbHMgZm9yICpyZW5kZXJpbmcqLFxyXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxyXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudFVuem9uZWRSYW5nZS5jbG9uZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIGR1cmF0aW9uIHZhbHVlIHRoYXQgc2hvdWxkIGJlIGFkZGVkL3N1YnN0cmFjdGVkIHRvIHRoZSBjdXJyZW50IGRhdGVcclxuICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGREYXRlSW5jcmVtZW50ID0gZnVuY3Rpb24gKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGRhdGVJbmNyZW1lbnRJbnB1dCA9IHRoaXMub3B0KCdkYXRlSW5jcmVtZW50Jyk7XHJcbiAgICAgICAgdmFyIGN1c3RvbUFsaWdubWVudDtcclxuICAgICAgICBpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMub3B0KCdkYXRlQWxpZ25tZW50JykpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbmFtZXNwYWNlX2hvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIEV4dGVybmFsRHJvcHBpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFeHRlcm5hbERyb3BwaW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxEcm9wcGluZygpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGpxdWktZHJhZ2dpbmcgYW4gZXh0ZXJuYWwgZWxlbWVudD8gYm9vbGVhblxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wZW1lbnRzOlxyXG4gICAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgICAgLSBpc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICAgICAtIHJlbmRlckRyYWdcclxuICAgICAgICAtIHVucmVuZGVyRHJhZ1xyXG4gICAgKi9cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuYmluZFRvRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwge1xyXG4gICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICBzb3J0c3RhcnQ6IHRoaXMuaGFuZGxlRHJhZ1N0YXJ0IC8vIGpxdWlcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS51bmJpbmRGcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgaXMgaW5pdGlhdGVkIGFueXdoZXJlIGluIHRoZSBET01cclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIChldiwgdWkpIHtcclxuICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgdmFyIGFjY2VwdDtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ2Ryb3BwYWJsZScpKSB7XHJcbiAgICAgICAgICAgIGVsID0gJCgodWkgPyB1aS5pdGVtIDogbnVsbCkgfHwgZXYudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBkcmFnZ2VkIGVsZW1lbnQgcGFzc2VzIHRoZSBkcm9wQWNjZXB0IHNlbGVjdG9yIG9yIGZpbHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8gRllJLCB0aGUgZGVmYXVsdCBpcyBcIipcIiAobWF0Y2hlcyBhbGwpXHJcbiAgICAgICAgICAgIGFjY2VwdCA9IHRoaXMub3B0KCdkcm9wQWNjZXB0Jyk7XHJcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdC5jYWxsKGVsWzBdLCBlbCkgOiBlbC5pcyhhY2NlcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG9FeHRlcm5hbERyYWcoZWwsIGV2LCB1aSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBzdGFydHMgYW5kIGl0IG5lZWRzIHRvIGJlIG1vbml0b3JlZCBmb3IgZHJvcHBpbmdcclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLmxpc3RlblRvRXh0ZXJuYWxEcmFnID0gZnVuY3Rpb24gKGVsLCBldiwgdWkpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgbWV0YSA9IGdldERyYWdnZWRFbE1ldGEoZWwpOyAvLyBleHRyYSBkYXRhIGFib3V0IGV2ZW50IGRyb3AsIGluY2x1ZGluZyBwb3NzaWJsZSBldmVudCB0byBjcmVhdGVcclxuICAgICAgICB2YXIgc2luZ2xlRXZlbnREZWY7IC8vIGEgbnVsbCB2YWx1ZSBzaWduYWxzIGFuIHVuc3VjY2Vzc2Z1bCBkcmFnXHJcbiAgICAgICAgLy8gbGlzdGVuZXIgdGhhdCB0cmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciBkYXRlLWFzc29jaWF0ZWQgcGl4ZWwgcmVnaW9uc1xyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGl0Rm9vdHByaW50ID0gaGl0LmNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGhpdCk7IC8vIGhpdCBtaWdodCBub3QgYmVsb25nIHRvIHRoaXMgZ3JpZFxyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBfdGhpcy5jb21wdXRlRXh0ZXJuYWxEcm9wKGhpdEZvb3RwcmludCwgbWV0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZUV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBuZXcgRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdChzaW5nbGVFdmVudERlZi5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gbWV0YS5ldmVudFByb3BzID8gLy8gaXNFdmVudD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZChtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFdmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXJEcmFnKC8vIGNhbGxlZCB3aXRob3V0IGEgc2VnIHBhcmFtZXRlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgdmlldy5jYWxlbmRhcikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVFdmVudERlZiA9IG51bGw7IC8vIHNpZ25hbCB1bnN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0RG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVucmVuZGVyRHJhZygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV4dGVybmFsRHJvcChzaW5nbGVFdmVudERlZiwgQm9vbGVhbihtZXRhLmV2ZW50UHJvcHMpLCAvLyBpc0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihtZXRhLnN0aWNrKSwgLy8gaXNTdGlja3lcclxuICAgICAgICAgICAgICAgICAgICBlbCwgZXYsIHVpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnREcmFnKGV2KTsgLy8gc3RhcnQgbGlzdGVuaW5nIGltbWVkaWF0ZWx5XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBoaXQgdG8gYmUgZHJvcHBlZCB1cG9uLCBhbmQgbWlzYyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUganF1aSBkcmFnIChndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0KSxcclxuICAgIC8vIHJldHVybnMgdGhlIHpvbmVkIHN0YXJ0L2VuZCBkYXRlcyBmb3IgdGhlIGV2ZW50IHRoYXQgd291bGQgcmVzdWx0IGZyb20gdGhlIGh5cG90aGV0aWNhbCBkcm9wLiBlbmQgbWlnaHQgYmUgbnVsbC5cclxuICAgIC8vIFJldHVybmluZyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiBpbnZhbGlkIGRyb3AgaGl0LlxyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuY29tcHV0ZUV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIG1ldGEpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2Uuc3RhcnRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgZXZlbnREZWY7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICAvLyBpZiBkcm9wcGVkIG9uIGFuIGFsbC1kYXkgc3BhbiwgYW5kIGVsZW1lbnQncyBtZXRhZGF0YSBzcGVjaWZpZWQgYSB0aW1lLCBzZXQgaXRcclxuICAgICAgICAgICAgaWYgKG1ldGEuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKG1ldGEuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRhLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKG1ldGEuZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudERlZiA9IFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZSgkLmV4dGVuZCh7fSwgbWV0YS5ldmVudFByb3BzLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9KSwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHJldHVybiBldmVudERlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXh0ZXJuYWxEcm9wcGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXh0ZXJuYWxEcm9wcGluZztcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFeHRlcm5hbERyb3BwaW5nKTtcclxuLyogRXh0ZXJuYWwtRHJhZ2dpbmctRWxlbWVudCBEYXRhXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBHaXZlbiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgbWlnaHQgcmVwcmVzZW50IGEgZHJhZ2dlZCBGdWxsQ2FsZW5kYXIgZXZlbnQsIHJldHVybnMgYW4gaW50ZXJtZWRpYXRlIGRhdGEgc3RydWN0dXJlXHJcbi8vIHRvIGJlIHVzZWQgZm9yIEV2ZW50IE9iamVjdCBjcmVhdGlvbi5cclxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbmZ1bmN0aW9uIGdldERyYWdnZWRFbE1ldGEoZWwpIHtcclxuICAgIHZhciBwcmVmaXggPSBuYW1lc3BhY2VfaG9va3NfMS5kZWZhdWx0LmRhdGFBdHRyUHJlZml4O1xyXG4gICAgdmFyIGV2ZW50UHJvcHM7IC8vIHByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIHRoZSBldmVudCwgbm90IHJlbGF0ZWQgdG8gZGF0ZS90aW1lXHJcbiAgICB2YXIgc3RhcnRUaW1lOyAvLyBhIER1cmF0aW9uXHJcbiAgICB2YXIgZHVyYXRpb247XHJcbiAgICB2YXIgc3RpY2s7XHJcbiAgICBpZiAocHJlZml4KSB7XHJcbiAgICAgICAgcHJlZml4ICs9ICctJztcclxuICAgIH1cclxuICAgIGV2ZW50UHJvcHMgPSBlbC5kYXRhKHByZWZpeCArICdldmVudCcpIHx8IG51bGw7XHJcbiAgICBpZiAoZXZlbnRQcm9wcykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnRQcm9wcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZXZlbnRQcm9wcyA9ICQuZXh0ZW5kKHt9LCBldmVudFByb3BzKTsgLy8gbWFrZSBhIGNvcHlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50UHJvcHMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGx1Y2sgc3BlY2lhbC1jYXNlZCBkYXRlL3RpbWUgcHJvcGVydGllc1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IGV2ZW50UHJvcHMuc3RhcnQ7XHJcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZSA9IGV2ZW50UHJvcHMudGltZTtcclxuICAgICAgICB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxyXG4gICAgICAgIGR1cmF0aW9uID0gZXZlbnRQcm9wcy5kdXJhdGlvbjtcclxuICAgICAgICBzdGljayA9IGV2ZW50UHJvcHMuc3RpY2s7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuc3RhcnQ7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMudGltZTtcclxuICAgICAgICBkZWxldGUgZXZlbnRQcm9wcy5kdXJhdGlvbjtcclxuICAgICAgICBkZWxldGUgZXZlbnRQcm9wcy5zdGljaztcclxuICAgIH1cclxuICAgIC8vIGZhbGxiYWNrIHRvIHN0YW5kYWxvbmUgYXR0cmlidXRlIHZhbHVlcyBmb3IgZWFjaCBvZiB0aGUgZGF0ZS90aW1lIHByb3BlcnRpZXNcclxuICAgIGlmIChzdGFydFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0YXJ0VGltZSA9IGVsLmRhdGEocHJlZml4ICsgJ3N0YXJ0Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhcnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICd0aW1lJyk7XHJcbiAgICB9IC8vIGFjY2VwdCAndGltZScgYXMgd2VsbFxyXG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcclxuICAgICAgICBkdXJhdGlvbiA9IGVsLmRhdGEocHJlZml4ICsgJ2R1cmF0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RpY2sgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0aWNrID0gZWwuZGF0YShwcmVmaXggKyAnc3RpY2snKTtcclxuICAgIH1cclxuICAgIC8vIG1hc3NhZ2UgaW50byBjb3JyZWN0IGRhdGEgdHlwZXNcclxuICAgIHN0YXJ0VGltZSA9IHN0YXJ0VGltZSAhPSBudWxsID8gbW9tZW50LmR1cmF0aW9uKHN0YXJ0VGltZSkgOiBudWxsO1xyXG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAhPSBudWxsID8gbW9tZW50LmR1cmF0aW9uKGR1cmF0aW9uKSA6IG51bGw7XHJcbiAgICBzdGljayA9IEJvb2xlYW4oc3RpY2spO1xyXG4gICAgcmV0dXJuIHsgZXZlbnRQcm9wczogZXZlbnRQcm9wcywgc3RhcnRUaW1lOiBzdGFydFRpbWUsIGR1cmF0aW9uOiBkdXJhdGlvbiwgc3RpY2s6IHN0aWNrIH07XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBFdmVudERlZk11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcclxudmFyIEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBFdmVudFJlc2l6aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXZlbnRSZXNpemluZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wZW1lbnRzOlxyXG4gICAgICAgIC0gYmluZFNlZ0hhbmRsZXJUb0VsXHJcbiAgICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICAgICAtIGRpZmZEYXRlc1xyXG4gICAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXZlbnRSZXNpemluZyhjb21wb25lbnQsIGV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcgPSBldmVudFBvaW50aW5nO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmNhblN0YXJ0UmVzaXplKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREcmFnTGlzdGVuZXIoc2VnLCAkKGV2LnRhcmdldCkuaXMoJy5mYy1zdGFydC1yZXNpemVyJykpXHJcbiAgICAgICAgICAgICAgICAuc3RhcnRJbnRlcmFjdGlvbihldiwgeyBkaXN0YW5jZTogNSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmNhblN0YXJ0UmVzaXplKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREcmFnTGlzdGVuZXIoc2VnLCAkKGV2LnRhcmdldCkuaXMoJy5mYy1zdGFydC1yZXNpemVyJykpXHJcbiAgICAgICAgICAgICAgICAuc3RhcnRJbnRlcmFjdGlvbihldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IHRyYWNrcyB0aGUgdXNlciBhcyB0aGV5IHJlc2l6ZSBhbiBldmVudCBzZWdtZW50LlxyXG4gICAgLy8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5idWlsZERyYWdMaXN0ZW5lciA9IGZ1bmN0aW9uIChzZWcsIGlzU3RhcnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSBjYWxlbmRhci5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGVsID0gc2VnLmVsO1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBzZWcuZm9vdHByaW50LmV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmc7XHJcbiAgICAgICAgdmFyIHJlc2l6ZU11dGF0aW9uOyAvLyB6b25lZCBldmVudCBkYXRlIHByb3BlcnRpZXMuIGZhbHN5IGlmIGludmFsaWQgcmVzaXplXHJcbiAgICAgICAgLy8gVHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgdGhlICpncmlkJ3MqIGNvb3JkaW5hdGUgbWFwXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgIHNjcm9sbDogdGhpcy5vcHQoJ2RyYWdTY3JvbGwnKSxcclxuICAgICAgICAgICAgc3ViamVjdEVsOiBlbCxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcclxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcuaGFuZGxlTW91c2VvdXQoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdSZXNpemVTdGFydChzZWcsIGV2KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnSGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQob3JpZ0hpdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdIaXRGb290cHJpbnQgJiYgaGl0Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplTXV0YXRpb24gPSBpc1N0YXJ0ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUV2ZW50U3RhcnRSZXNpemVNdXRhdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQsIHNlZy5mb290cHJpbnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcHV0ZUV2ZW50RW5kUmVzaXplTXV0YXRpb24ob3JpZ0hpdEZvb3RwcmludCwgaGl0Rm9vdHByaW50LCBzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzaXplTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50TWFuYWdlci5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAoZXZlbnREZWYuaWQsIHJlc2l6ZU11dGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gY29tcG9uZW50LmlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZChtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc2l6ZU11dGF0aW9uLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIGNoYW5nZS4gKEZZSSwgZXZlbnQgZGF0ZXMgbWlnaHQgaGF2ZSB6b25lcylcclxuICAgICAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LmhpZGVFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZW5kZXJFdmVudFJlc2l6ZShjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGNvbXBvbmVudC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UsIGNhbGVuZGFyKSksIHNlZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3LnVucmVuZGVyRXZlbnRSZXNpemUoc2VnKTtcclxuICAgICAgICAgICAgICAgIHZpZXcuc2hvd0V2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWdSZXNpemVTdG9wKHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byByZS1zaG93IG9yaWdpbmFsLCB3aWxsIHJlcmVuZGVyIGFsbCBhbnl3YXlzLiBlc3AgaW1wb3J0YW50IGlmIGV2ZW50UmVuZGVyV2FpdFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVwb3J0RXZlbnRSZXNpemUoZXZlbnRJbnN0YW5jZSwgcmVzaXplTXV0YXRpb24sIGVsLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYmVmb3JlIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RhcnRzXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5zZWdSZXNpemVTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplU3RhcnQnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RvcHNcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLnNlZ1Jlc2l6ZVN0b3AgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHRoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemVTdG9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBzdGFydFxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50U3RhcnRSZXNpemVNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50LCBvcmlnRXZlbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgb3JpZ1JhbmdlID0gb3JpZ0V2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSB0aGlzLmNvbXBvbmVudC5kaWZmRGF0ZXMoZW5kRm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpLCBzdGFydEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKSk7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAob3JpZ1JhbmdlLmdldFN0YXJ0KCkuYWRkKHN0YXJ0RGVsdGEpIDwgb3JpZ1JhbmdlLmdldEVuZCgpKSB7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uLnNldFN0YXJ0RGVsdGEoc3RhcnREZWx0YSk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5zZXREYXRlTXV0YXRpb24oZGF0ZU11dGF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgZW5kXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnRFbmRSZXNpemVNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50LCBvcmlnRXZlbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgb3JpZ1JhbmdlID0gb3JpZ0V2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGVuZERlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0RW5kKCksIHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRFbmQoKSk7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAob3JpZ1JhbmdlLmdldEVuZCgpLmFkZChlbmREZWx0YSkgPiBvcmlnUmFuZ2UuZ2V0U3RhcnQoKSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbi5zZXRFbmREZWx0YShlbmREZWx0YSk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5zZXREYXRlTXV0YXRpb24oZGF0ZU11dGF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRSZXNpemluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRSZXNpemluZztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcbnZhciBEcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIE1vdXNlRm9sbG93ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRXZlbnREcmFnZ2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50RHJhZ2dpbmcsIF9zdXBlcik7XHJcbiAgICAvKlxyXG4gICAgY29tcG9uZW50IGltcGxlbWVudHM6XHJcbiAgICAgICAgLSBiaW5kU2VnSGFuZGxlclRvRWxcclxuICAgICAgICAtIHB1YmxpY2x5VHJpZ2dlclxyXG4gICAgICAgIC0gZGlmZkRhdGVzXHJcbiAgICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgICAgLSBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudERyYWdnaW5nKGNvbXBvbmVudCwgZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IGV2ZW50UG9pbnRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5nZXRTZWxlY3Rpb25EZWxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdCgnZXZlbnRMb25nUHJlc3NEZWxheScpO1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gdGhpcy5vcHQoJ2xvbmdQcmVzc0RlbGF5Jyk7IC8vIGZhbGxiYWNrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZWRvd24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnREcmFnKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREcmFnTGlzdGVuZXIoc2VnKS5zdGFydEludGVyYWN0aW9uKGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBkZWxheTogdGhpcy52aWV3LmlzRXZlbnREZWZTZWxlY3RlZChzZWcuZm9vdHByaW50LmV2ZW50RGVmKSA/IC8vIGFscmVhZHkgc2VsZWN0ZWQ/XHJcbiAgICAgICAgICAgICAgICAwIDogdGhpcy5nZXRTZWxlY3Rpb25EZWxheSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoY29tcG9uZW50LmNhblN0YXJ0RHJhZyhzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQuY2FuU3RhcnRTZWxlY3Rpb24oc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFNlbGVjdExpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBzZWcgaXNuJ3QgZHJhZ2dhYmxlLCBidXQgbGV0J3MgdXNlIGEgZ2VuZXJpYyBEcmFnTGlzdGVuZXJcclxuICAgIC8vIHNpbXBseSBmb3IgdGhlIGRlbGF5LCBzbyBpdCBjYW4gYmUgc2VsZWN0ZWQuXHJcbiAgICAvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYGRyYWdMaXN0ZW5lcmBcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkU2VsZWN0TGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlOyAvLyBudWxsIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNlbGVjdEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB0cmFjayB1c2VyLWRyYWdnaW5nIG9uIGFuIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cclxuICAgIC8vIEhhcyBzaWRlIGVmZmVjdCBvZiBzZXR0aW5nL3Vuc2V0dGluZyBgZHJhZ0xpc3RlbmVyYFxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBlbCA9IHNlZy5lbDtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlID0gc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlOyAvLyBudWxsIGZvciBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgdmFyIGlzRHJhZ2dpbmc7XHJcbiAgICAgICAgdmFyIG1vdXNlRm9sbG93ZXI7IC8vIEEgY2xvbmUgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCB3aWxsIG1vdmUgd2l0aCB0aGUgbW91c2VcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKnZpZXcncyogY29vcmRpbmF0ZSBtYXAuIEFsbG93cyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgYmV0d2VlbiBzdWJjb21wb25lbnRzXHJcbiAgICAgICAgLy8gb2YgdGhlIHZpZXcuXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQodmlldywge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIHN1YmplY3RFbDogZWwsXHJcbiAgICAgICAgICAgIHN1YmplY3RDZW50ZXI6IHRydWUsXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgc2VnLmNvbXBvbmVudCA9IGNvbXBvbmVudDsgLy8gZm9yIHJlbmRlckRyYWdcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIgPSBuZXcgTW91c2VGb2xsb3dlcl8xLmRlZmF1bHQoc2VnLmVsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYXNzOiAnZmMtZHJhZ2dpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEVsOiB2aWV3LmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGRyYWdMaXN0ZW5lci5pc1RvdWNoID8gbnVsbCA6IF90aGlzLm9wdCgnZHJhZ09wYWNpdHknKSxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnREdXJhdGlvbjogX3RoaXMub3B0KCdkcmFnUmV2ZXJ0RHVyYXRpb24nKSxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDIgLy8gb25lIGFib3ZlIHRoZSAuZmMtdmlld1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLmhpZGUoKTsgLy8gZG9uJ3Qgc2hvdyB1bnRpbCB3ZSBrbm93IHRoaXMgaXMgYSByZWFsIGRyYWdcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc3RhcnQoZXYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lci5pc1RvdWNoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgcHJldmlvdXNseSBzZWxlY3RlZCwgd2lsbCBmaXJlIGFmdGVyIGEgZGVsYXkuIHRoZW4sIHNlbGVjdCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNlbGVjdEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZy5oYW5kbGVNb3VzZW91dChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ0RyYWdTdGFydChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIHZpZXcuaGlkZUV2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnRm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRpbmcgaGl0IGNvdWxkIGJlIGZvcmNlZCAoRGF5R3JpZC5saW1pdClcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0hpdCA9IHNlZy5oaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWQsIHNvIHF1ZXJ5IG9yaWdpbiBncmlkXHJcbiAgICAgICAgICAgICAgICBvcmlnRm9vdHByaW50ID0gb3JpZ0hpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgIGZvb3RwcmludCA9IGhpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdGb290cHJpbnQgJiYgZm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IF90aGlzLmNvbXB1dGVFdmVudERyb3BNdXRhdGlvbihvcmlnRm9vdHByaW50LCBmb290cHJpbnQsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRNYW5hZ2VyLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cChldmVudERlZi5pZCwgZXZlbnREZWZNdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IGNvbXBvbmVudC5pc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIGEgdmFsaWQgZHJvcCBsb2NhdGlvbiwgaGF2ZSB0aGUgc3ViY2xhc3MgcmVuZGVyIGEgdmlzdWFsIGluZGljYXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChldmVudERlZk11dGF0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5yZW5kZXJEcmFnKC8vIHRydXRoeSBpZiByZW5kZXJlZCBzb21ldGhpbmdcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGNvbXBvbmVudC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UsIGNhbGVuZGFyKSksIHNlZywgZHJhZ0xpc3RlbmVyLmlzVG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGlmIHRoZSBzdWJjbGFzcyBpcyBhbHJlYWR5IHVzaW5nIGEgbW9jayBldmVudCBcImhlbHBlclwiLCBoaWRlIG91ciBvd25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBvdGhlcndpc2UsIGhhdmUgdGhlIGhlbHBlciBmb2xsb3cgdGhlIG1vdXNlIChubyBzbmFwcGluZylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc09yaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0byBoYXZlIG1vdmVkIGhpdHMgdG8gYmUgYSB2YWxpZCBkcm9wXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmlldy51bnJlbmRlckRyYWcoc2VnKTsgLy8gdW5yZW5kZXIgd2hhdGV2ZXIgd2FzIGRvbmUgaW4gcmVuZGVyRHJhZ1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5zaG93KCk7IC8vIHNob3cgaW4gY2FzZSB3ZSBhcmUgbW92aW5nIG91dCBvZiBhbGwgaGl0c1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlZy5jb21wb25lbnQ7IC8vIHByZXZlbnQgc2lkZSBlZmZlY3RzXHJcbiAgICAgICAgICAgICAgICAvLyBkbyByZXZlcnQgYW5pbWF0aW9uIGlmIGhhc24ndCBjaGFuZ2VkLiBjYWxscyBhIGNhbGxiYWNrIHdoZW4gZmluaXNoZWQgKHdoZXRoZXIgYW5pbWF0aW9uIG9yIG5vdClcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc3RvcCghZXZlbnREZWZNdXRhdGlvbiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJEcmFnKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ0RyYWdTdG9wKHNlZywgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnNob3dFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byByZS1zaG93IG9yaWdpbmFsLCB3aWxsIHJlcmVuZGVyIGFsbCBhbnl3YXlzLiBlc3AgaW1wb3J0YW50IGlmIGV2ZW50UmVuZGVyV2FpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV2ZW50RHJvcChldmVudEluc3RhbmNlLCBldmVudERlZk11dGF0aW9uLCBlbCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGJlZm9yZSBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0YXJ0c1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuc2VnRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgZHJhZ2dpbmcgc3RvcHNcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLnNlZ0RyYWdTdG9wID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnREcm9wTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCwgZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbiA9IG5ldyBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb24uc2V0RGF0ZU11dGF0aW9uKHRoaXMuY29tcHV0ZUV2ZW50RGF0ZU11dGF0aW9uKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQpKTtcclxuICAgICAgICByZXR1cm4gZXZlbnREZWZNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnREYXRlTXV0YXRpb24gPSBmdW5jdGlvbiAoc3RhcnRGb290cHJpbnQsIGVuZEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBkYXRlMCA9IHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpO1xyXG4gICAgICAgIHZhciBkYXRlMSA9IGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgY2xlYXJFbmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZm9yY2VUaW1lZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkYXRlRGVsdGE7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICBpZiAoc3RhcnRGb290cHJpbnQuaXNBbGxEYXkgIT09IGVuZEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBjbGVhckVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChlbmRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlQWxsRGF5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRhdGUwLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VUaW1lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZURlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGRhdGUxLCBkYXRlMCk7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uID0gbmV3IEV2ZW50RGVmRGF0ZU11dGF0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5jbGVhckVuZCA9IGNsZWFyRW5kO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbi5mb3JjZVRpbWVkID0gZm9yY2VUaW1lZDtcclxuICAgICAgICBkYXRlTXV0YXRpb24uZm9yY2VBbGxEYXkgPSBmb3JjZUFsbERheTtcclxuICAgICAgICBkYXRlTXV0YXRpb24uc2V0RGF0ZURlbHRhKGRhdGVEZWx0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVNdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREcmFnZ2luZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREcmFnZ2luZztcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBEYXRlU2VsZWN0aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF0ZVNlbGVjdGluZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgICAgLSBiaW5kRGF0ZUhhbmRsZXJUb0VsXHJcbiAgICAgICAgLSBnZXRTYWZlSGl0Rm9vdHByaW50XHJcbiAgICAgICAgLSByZW5kZXJIaWdobGlnaHRcclxuICAgICAgICAtIHVucmVuZGVySGlnaGxpZ2h0XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGF0ZVNlbGVjdGluZyhjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gX3RoaXMuYnVpbGREcmFnTGlzdGVuZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgIH07XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5nZXREZWxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdCgnc2VsZWN0TG9uZ1ByZXNzRGVsYXknKTtcclxuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IHRoaXMub3B0KCdsb25nUHJlc3NEZWxheScpOyAvLyBmYWxsYmFja1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVsYXk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXI7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmREYXRlSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnc2VsZWN0YWJsZScpICYmICFjb21wb25lbnQuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogX3RoaXMub3B0KCdzZWxlY3RNaW5EaXN0YW5jZScpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCdzZWxlY3RhYmxlJykgJiYgIWNvbXBvbmVudC5zaG91bGRJZ25vcmVUb3VjaCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiBfdGhpcy5nZXREZWxheSgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHV0aWxfMS5wcmV2ZW50U2VsZWN0aW9uKGVsKTtcclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgc2VsZWN0aW5nLlxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHNlbGVjdGlvbkZvb3RwcmludDsgLy8gbnVsbCBpZiBpbnZhbGlkIHNlbGVjdGlvblxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Gb290cHJpbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy51bnNlbGVjdChldik7IC8vIHNpbmNlIHdlIGNvdWxkIGJlIHJlbmRlcmluZyBhIG5ldyBzZWxlY3Rpb24sIHdlIHdhbnQgdG8gY2xlYXIgYW55IG9sZCBvbmVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0hpdEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdIaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBoaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnSGl0Rm9vdHByaW50ICYmIGhpdEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Gb290cHJpbnQgPSBfdGhpcy5jb21wdXRlU2VsZWN0aW9uKG9yaWdIaXRGb290cHJpbnQsIGhpdEZvb3RwcmludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Gb290cHJpbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uRm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoc2VsZWN0aW9uRm9vdHByaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uRm9vdHByaW50ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Gb290cHJpbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVucmVuZGVyU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQgJiYgc2VsZWN0aW9uRm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIHJlbmRlcmVkLiBqdXN0IHJlcG9ydCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXcucmVwb3J0U2VsZWN0aW9uKHNlbGVjdGlvbkZvb3RwcmludCwgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiB0aGUgZmlyc3QgYW5kIGxhc3QgZGF0ZS1zcGFucyBvZiBhIHNlbGVjdGlvbiwgcmV0dXJucyBhbm90aGVyIGRhdGUtc3BhbiBvYmplY3QuXHJcbiAgICAvLyBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZSBhbmQgcHJvdmlkZSBhZGRpdGlvbmFsIGRhdGEgaW4gdGhlIHNwYW4gb2JqZWN0LiBXaWxsIGJlIHBhc3NlZCB0byByZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQoKS5cclxuICAgIC8vIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBzZWxlY3Rpb24gaXMgaW52YWxpZCBhbmQgdGhpcyBzaG91bGQgYmUgaW5kaWNhdGVkIHRvIHRoZSB1c2VyLlxyXG4gICAgLy8gV2lsbCByZXR1cm4gbnVsbC91bmRlZmluZWQgaWYgYSBzZWxlY3Rpb24gaW52YWxpZCBidXQgbm8gZXJyb3Igc2hvdWxkIGJlIHJlcG9ydGVkLlxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuY29tcHV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChmb290cHJpbnQwLCBmb290cHJpbnQxKSB7XHJcbiAgICAgICAgdmFyIHdob2xlRm9vdHByaW50ID0gdGhpcy5jb21wdXRlU2VsZWN0aW9uRm9vdHByaW50KGZvb3RwcmludDAsIGZvb3RwcmludDEpO1xyXG4gICAgICAgIGlmICh3aG9sZUZvb3RwcmludCAmJiAhdGhpcy5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQod2hvbGVGb290cHJpbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdob2xlRm9vdHByaW50O1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHR3byBzcGFucywgbXVzdCByZXR1cm4gdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSB0d28uXHJcbiAgICAvLyBUT0RPOiBkbyB0aGlzIHNlcGFyYXRpb24gb2YgY29uY2VybnMgKGNvbWJpbmluZyBWUyB2YWxpZGF0aW9uKSBmb3IgZXZlbnQgZG5kL3Jlc2l6ZSB0b28uXHJcbiAgICAvLyBBc3N1bWVzIGJvdGggZm9vdHByaW50cyBhcmUgbm9uLW9wZW4tZW5kZWQuXHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5jb21wdXRlU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICB2YXIgbXMgPSBbXHJcbiAgICAgICAgICAgIGZvb3RwcmludDAudW56b25lZFJhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgIGZvb3RwcmludDAudW56b25lZFJhbmdlLmVuZE1zLFxyXG4gICAgICAgICAgICBmb290cHJpbnQxLnVuem9uZWRSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICBmb290cHJpbnQxLnVuem9uZWRSYW5nZS5lbmRNc1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgbXMuc29ydCh1dGlsXzEuY29tcGFyZU51bWJlcnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChtc1swXSwgbXNbM10pLCBmb290cHJpbnQwLmlzQWxsRGF5KTtcclxuICAgIH07XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmRhdGVQcm9maWxlLnZhbGlkVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkgJiZcclxuICAgICAgICAgICAgdGhpcy52aWV3LmNhbGVuZGFyLmNvbnN0cmFpbnRzLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRlU2VsZWN0aW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRlU2VsZWN0aW5nO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2NyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcclxudmFyIFRpbWVHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcclxudmFyIERheUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xyXG52YXIgQUdFTkRBX0FMTF9EQVlfRVZFTlRfTElNSVQgPSA1O1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgYWxsIGFnZW5kYS1yZWxhdGVkIHZpZXdzLiBEaXNwbGF5cyBvbmUgbW9yZSBjb2x1bW5zIHdpdGggdGltZSBzbG90cyBydW5uaW5nIHZlcnRpY2FsbHkuXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBJcyBhIG1hbmFnZXIgZm9yIHRoZSBUaW1lR3JpZCBzdWJjb21wb25lbnQgYW5kIHBvc3NpYmx5IHRoZSBEYXlHcmlkIHN1YmNvbXBvbmVudCAoaWYgYWxsRGF5U2xvdCBpcyBvbikuXHJcbi8vIFJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXHJcbnZhciBBZ2VuZGFWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQWdlbmRhVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFnZW5kYVZpZXcoY2FsZW5kYXIsIHZpZXdTcGVjKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY2FsZW5kYXIsIHZpZXdTcGVjKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnVzZXNNaW5NYXhUaW1lID0gdHJ1ZTsgLy8gaW5kaWNhdGVzIHRoYXQgbWluVGltZS9tYXhUaW1lIGFmZmVjdHMgcmVuZGVyaW5nXHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSBfdGhpcy5pbnN0YW50aWF0ZVRpbWVHcmlkKCk7XHJcbiAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMudGltZUdyaWQpO1xyXG4gICAgICAgIGlmIChfdGhpcy5vcHQoJ2FsbERheVNsb3QnKSkge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXlHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7IC8vIHRoZSBhbGwtZGF5IHN1YmNvbXBvbmVudCBvZiB0aGlzIHZpZXdcclxuICAgICAgICAgICAgX3RoaXMuYWRkQ2hpbGQoX3RoaXMuZGF5R3JpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXHJcbiAgICAgICAgICAgIG92ZXJmbG93WTogJ2F1dG8nXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBUaW1lR3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMudGltZUdyaWRDbGFzc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuaW5zdGFudGlhdGVUaW1lR3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgU3ViQ2xhc3MgPSBtYWtlVGltZUdyaWRTdWJjbGFzcyh0aGlzLnRpbWVHcmlkQ2xhc3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ViQ2xhc3ModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbWlnaHQgbmVlZC4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuaW5zdGFudGlhdGVEYXlHcmlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBTdWJDbGFzcyA9IG1ha2VEYXlHcmlkU3ViY2xhc3ModGhpcy5kYXlHcmlkQ2xhc3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ViQ2xhc3ModGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyogUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVHcmlkV3JhcEVsO1xyXG4gICAgICAgIHZhciB0aW1lR3JpZEVsO1xyXG4gICAgICAgIHRoaXMuZWwuYWRkQ2xhc3MoJ2ZjLWFnZW5kYS12aWV3JykuaHRtbCh0aGlzLnJlbmRlclNrZWxldG9uSHRtbCgpKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xyXG4gICAgICAgIHRpbWVHcmlkV3JhcEVsID0gdGhpcy5zY3JvbGxlci5lbC5hZGRDbGFzcygnZmMtdGltZS1ncmlkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRpbWVHcmlkRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtdGltZS1ncmlkXCIgLz4nKS5hcHBlbmRUbyh0aW1lR3JpZFdyYXBFbCk7XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQodGltZUdyaWRXcmFwRWwpO1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQuaGVhZENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCcuZmMtaGVhZC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLnNldEVsZW1lbnQodGltZUdyaWRFbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQuc2V0RWxlbWVudCh0aGlzLmVsLmZpbmQoJy5mYy1kYXktZ3JpZCcpKTtcclxuICAgICAgICAgICAgLy8gaGF2ZSB0aGUgZGF5LWdyaWQgZXh0ZW5kIGl0J3MgY29vcmRpbmF0ZSBhcmVhIG92ZXIgdGhlIDxocj4gZGl2aWRpbmcgdGhlIHR3byBncmlkc1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQuYm90dG9tQ29vcmRQYWRkaW5nID0gdGhpcy5kYXlHcmlkLmVsLm5leHQoJ2hyJykub3V0ZXJIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXHJcbiAgICAvLyBUaGUgZGF5LWdyaWQgYW5kIHRpbWUtZ3JpZCBjb21wb25lbnRzIHdpbGwgcmVuZGVyIGluc2lkZSBjb250YWluZXJzIGRlZmluZWQgYnkgdGhpcyBIVE1MLlxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLm9wdCgnY29sdW1uSGVhZGVyJykgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiPiZuYnNwOzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmRheUdyaWQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiLz4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiLz4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L3RkPicgK1xyXG4gICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgJzwvdGJvZHk+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIGFuIEhUTUwgYXR0cmlidXRlIHN0cmluZyBmb3Igc2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIGF4aXMsIGlmIGl0IGlzIGtub3duXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5heGlzU3R5bGVBdHRyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmF4aXNXaWR0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc3R5bGU9XCJ3aWR0aDonICsgdGhpcy5heGlzV2lkdGggKyAncHhcIic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICAvKiBOb3cgSW5kaWNhdG9yXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuZ2V0Tm93SW5kaWNhdG9yVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lR3JpZC5nZXROb3dJbmRpY2F0b3JVbml0KCk7XHJcbiAgICB9O1xyXG4gICAgLyogRGltZW5zaW9uc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEFkanVzdHMgdGhlIHZlcnRpY2FsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXcgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZXNcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICB2YXIgZXZlbnRMaW1pdDtcclxuICAgICAgICB2YXIgc2Nyb2xsZXJIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbGJhcldpZHRocztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgLy8gbWFrZSBhbGwgYXhpcyBjZWxscyBsaW5lIHVwLCBhbmQgcmVjb3JkIHRoZSB3aWR0aCBzbyBuZXdseSBjcmVhdGVkIGF4aXMgY2VsbHMgd2lsbCBoYXZlIGl0XHJcbiAgICAgICAgdGhpcy5heGlzV2lkdGggPSB1dGlsXzEubWF0Y2hDZWxsV2lkdGhzKHRoaXMuZWwuZmluZCgnLmZjLWF4aXMnKSk7XHJcbiAgICAgICAgLy8gaGFjayB0byBnaXZlIHRoZSB2aWV3IHNvbWUgaGVpZ2h0IHByaW9yIHRvIHRpbWVHcmlkJ3MgY29sdW1ucyBiZWluZyByZW5kZXJlZFxyXG4gICAgICAgIC8vIFRPRE86IHNlcGFyYXRlIHNldHRpbmcgaGVpZ2h0IGZyb20gc2Nyb2xsZXIgVlMgdGltZUdyaWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVHcmlkLmNvbEVscykge1xyXG4gICAgICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgb2YgZmFrZSByb3cgZWxlbWVudHMgdGhhdCBtdXN0IGNvbXBlbnNhdGUgd2hlbiBzY3JvbGxlciBoYXMgc2Nyb2xsYmFyc1xyXG4gICAgICAgIHZhciBub1Njcm9sbFJvd0VscyA9IHRoaXMuZWwuZmluZCgnLmZjLXJvdzpub3QoLmZjLXNjcm9sbGVyICopJyk7XHJcbiAgICAgICAgLy8gcmVzZXQgYWxsIGRpbWVuc2lvbnMgYmFjayB0byB0aGUgb3JpZ2luYWwgc3RhdGVcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmJvdHRvbVJ1bGVFbC5oaWRlKCk7IC8vIC5zaG93KCkgd2lsbCBiZSBjYWxsZWQgbGF0ZXIgaWYgdGhpcyA8aHI+IGlzIG5lY2Vzc2FyeVxyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuY2xlYXIoKTsgLy8gc2V0cyBoZWlnaHQgdG8gJ2F1dG8nIGFuZCBjbGVhcnMgb3ZlcmZsb3dcclxuICAgICAgICB1dGlsXzEudW5jb21wZW5zYXRlU2Nyb2xsKG5vU2Nyb2xsUm93RWxzKTtcclxuICAgICAgICAvLyBsaW1pdCBudW1iZXIgb2YgZXZlbnRzIGluIHRoZSBhbGwtZGF5IGFyZWFcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5yZW1vdmVTZWdQb3BvdmVyKCk7IC8vIGtpbGwgdGhlIFwibW9yZVwiIHBvcG92ZXIgaWYgZGlzcGxheWVkXHJcbiAgICAgICAgICAgIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TGltaXQgPSBBR0VOREFfQUxMX0RBWV9FVkVOVF9MSU1JVDsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudExpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRheUdyaWQubGltaXRSb3dzKGV2ZW50TGltaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIGFsbC1kYXkgYW5kIGhlYWRlciByb3dzIGxpbmVzIHVwXHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuY29tcGVuc2F0ZVNjcm9sbChub1Njcm9sbFJvd0Vscywgc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzY3JvbGxiYXIgY29tcGVuc2F0aW9uIG1pZ2h0IGhhdmUgY2hhbmdlZCB0ZXh0IGZsb3csIHdoaWNoIG1pZ2h0IGFmZmVjdCBoZWlnaHQsIHNvIHJlY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgcmVhcHBseSB0aGUgZGVzaXJlZCBoZWlnaHQgdG8gdGhlIHNjcm9sbGVyLlxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IHNwYWNlIGJlbG93IHRoZSBzbGF0cywgc2hvdyB0aGUgaG9yaXpvbnRhbCBydWxlLlxyXG4gICAgICAgICAgICAvLyB0aGlzIHdvbid0IGNhdXNlIGFueSBuZXcgb3ZlcmZsb3csIGJlY2F1c2UgbG9ja092ZXJmbG93IGFscmVhZHkgY2FsbGVkLlxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lR3JpZC5nZXRUb3RhbFNsYXRIZWlnaHQoKSA8IHNjcm9sbGVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVHcmlkLmJvdHRvbVJ1bGVFbC5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIENvbXB1dGVzIHRoZSBpbml0aWFsIHByZS1jb25maWd1cmVkIHNjcm9sbCBzdGF0ZSBwcmlvciB0byBhbGxvd2luZyB0aGUgdXNlciB0byBjaGFuZ2UgaXRcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnc2Nyb2xsVGltZScpKTtcclxuICAgICAgICB2YXIgdG9wID0gdGhpcy50aW1lR3JpZC5jb21wdXRlVGltZVRvcChzY3JvbGxUaW1lKTtcclxuICAgICAgICAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxyXG4gICAgICAgIHRvcCA9IE1hdGguY2VpbCh0b3ApO1xyXG4gICAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICAgICAgdG9wKys7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0b3A6IHRvcCB9O1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbC50b3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcChzY3JvbGwudG9wKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IEFyZWFzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gZm9yd2FyZCBhbGwgaGl0LXJlbGF0ZWQgbWV0aG9kIGNhbGxzIHRvIHRoZSBncmlkcyAoZGF5R3JpZCBtaWdodCBub3QgYmUgZGVmaW5lZClcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cclxuICAgICAgICByZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRGb290cHJpbnQoaGl0KTtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXRIaXRFbCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cclxuICAgICAgICByZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRFbChoaXQpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmV4ZWN1dGVFdmVudFJlbmRlciA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdmFyIGRheUV2ZW50c1BheWxvYWQgPSB7fTtcclxuICAgICAgICB2YXIgdGltZWRFdmVudHNQYXlsb2FkID0ge307XHJcbiAgICAgICAgdmFyIGlkLCBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgLy8gc2VwYXJhdGUgdGhlIGV2ZW50cyBpbnRvIGFsbC1kYXkgYW5kIHRpbWVkXHJcbiAgICAgICAgZm9yIChpZCBpbiBldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50c1BheWxvYWRbaWRdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCkuaXNBbGxEYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5RXZlbnRzUGF5bG9hZFtpZF0gPSBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lZEV2ZW50c1BheWxvYWRbaWRdID0gZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuZXhlY3V0ZUV2ZW50UmVuZGVyKHRpbWVkRXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQuZXhlY3V0ZUV2ZW50UmVuZGVyKGRheUV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBEcmFnZ2luZy9SZXNpemluZyBSb3V0aW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQSByZXR1cm5lZCB2YWx1ZSBvZiBgdHJ1ZWAgc2lnbmFscyB0aGF0IGEgbW9jayBcImhlbHBlclwiIGV2ZW50IGhhcyBiZWVuIHJlbmRlcmVkLlxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBncm91cHMgPSBncm91cEV2ZW50Rm9vdHByaW50c0J5QWxsRGF5KGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkSGVscGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmVuZGVyZWRIZWxwZXIgPSB0aGlzLnRpbWVHcmlkLnJlbmRlckRyYWcoZ3JvdXBzLnRpbWVkLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRIZWxwZXIgPSB0aGlzLmRheUdyaWQucmVuZGVyRHJhZyhncm91cHMuYWxsRGF5LCBzZWcsIGlzVG91Y2gpIHx8IHJlbmRlcmVkSGVscGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRIZWxwZXI7XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQucmVuZGVyRXZlbnRSZXNpemUoZ3JvdXBzLnRpbWVkLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbmRlckV2ZW50UmVzaXplKGdyb3Vwcy5hbGxEYXksIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICghY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUdyaWQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBZ2VuZGFWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFnZW5kYVZpZXc7XHJcbkFnZW5kYVZpZXcucHJvdG90eXBlLnRpbWVHcmlkQ2xhc3MgPSBUaW1lR3JpZF8xLmRlZmF1bHQ7XHJcbkFnZW5kYVZpZXcucHJvdG90eXBlLmRheUdyaWRDbGFzcyA9IERheUdyaWRfMS5kZWZhdWx0O1xyXG4vLyBXaWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgdGltZUdyaWRcclxuZnVuY3Rpb24gbWFrZVRpbWVHcmlkU3ViY2xhc3MoU3VwZXJDbGFzcykge1xyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCB3aWxsIGdvIGJlZm9yZSB0aGUgZGF5LW9mIHdlZWsgaGVhZGVyIGNlbGxzXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgICAgICB2YXIgd2Vla1N0YXJ0ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0aGlzLmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIHdlZWtUZXh0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHQoJ3dlZWtOdW1iZXJzJykpIHtcclxuICAgICAgICAgICAgICAgIHdlZWtUZXh0ID0gd2Vla1N0YXJ0LmZvcm1hdCh0aGlzLm9wdCgnc21hbGxXZWVrRm9ybWF0JykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiZmMtYXhpcyBmYy13ZWVrLW51bWJlciAnICsgY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5idWlsZEdvdG9BbmNob3JIdG1sKC8vIGFzaWRlIGZyb20gbGluaywgaW1wb3J0YW50IGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICB7IGRhdGU6IHdlZWtTdGFydCwgdHlwZTogJ3dlZWsnLCBmb3JjZU9mZjogdGhpcy5jb2xDbnQgPiAxIH0sIHV0aWxfMS5odG1sRXNjYXBlKHdlZWtUZXh0KSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGg+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRoIGNsYXNzPVwiZmMtYXhpcyAnICsgY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+PC90aD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYmcgb2YgdGhlIFRpbWVHcmlkIHNsb3QgYXJlYS4gTG9uZyB2ZXJ0aWNhbCBjb2x1bW4uXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzICcgKyB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgY2VsbHMuXHJcbiAgICAgICAgLy8gQWZmZWN0cyBjb250ZW50LXNrZWxldG9uLCBoZWxwZXItc2tlbGV0b24sIGhpZ2hsaWdodC1za2VsZXRvbiBmb3IgYm90aCB0aGUgdGltZS1ncmlkIGFuZCBkYXktZ3JpZC5cclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVySW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9KFN1cGVyQ2xhc3MpKTtcclxufVxyXG47XHJcbi8vIFdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyBkYXlHcmlkXHJcbmZ1bmN0aW9uIG1ha2VEYXlHcmlkU3ViY2xhc3MoU3VwZXJDbGFzcykge1xyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTdWJDbGFzcygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgYWxsLWRheSBjZWxsc1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJCZ0ludHJvSHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtYXhpcyAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiICcgKyB2aWV3LmF4aXNTdHlsZUF0dHIoKSArICc+JyArXHJcbiAgICAgICAgICAgICAgICAnPHNwYW4+JyArIC8vIG5lZWRlZCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICB2aWV3LmdldEFsbERheUh0bWwoKSArXHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGFsbCBvdGhlciB0eXBlcyBvZiBjZWxscy5cclxuICAgICAgICAvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIGhlbHBlci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXNcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBTdWJDbGFzcztcclxuICAgIH0oU3VwZXJDbGFzcykpO1xyXG59XHJcbjtcclxuZnVuY3Rpb24gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpIHtcclxuICAgIHZhciBhbGxEYXkgPSBbXTtcclxuICAgIHZhciB0aW1lZCA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgYWxsRGF5LnB1c2goZXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpbWVkLnB1c2goZXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBhbGxEYXk6IGFsbERheSwgdGltZWQ6IHRpbWVkIH07XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNjggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbnZhciBDb29yZENhY2hlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbnZhciBUaW1lR3JpZEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODMpO1xyXG52YXIgVGltZUdyaWRIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XHJcbnZhciBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XHJcbi8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBvbmUgb3IgbW9yZSBjb2x1bW5zIG9mIHZlcnRpY2FsIHRpbWUgc2xvdHNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFdlIG1peGluIERheVRhYmxlLCBldmVuIHRob3VnaCB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHJvdyBvZiBkYXlzXHJcbi8vIHBvdGVudGlhbCBuaWNlIHZhbHVlcyBmb3IgdGhlIHNsb3QtZHVyYXRpb24gYW5kIGludGVydmFsLWR1cmF0aW9uXHJcbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxyXG52YXIgQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlMgPSBbXHJcbiAgICB7IGhvdXJzOiAxIH0sXHJcbiAgICB7IG1pbnV0ZXM6IDMwIH0sXHJcbiAgICB7IG1pbnV0ZXM6IDE1IH0sXHJcbiAgICB7IHNlY29uZHM6IDMwIH0sXHJcbiAgICB7IHNlY29uZHM6IDE1IH1cclxuXTtcclxudmFyIFRpbWVHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZCh2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wcm9jZXNzT3B0aW9ucygpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIFNsaWNlcyB1cCB0aGUgZ2l2ZW4gc3BhbiAodW56b25lZCBzdGFydC9lbmQgd2l0aCBvdGhlciBtaXNjIGRhdGEpIGludG8gYW4gYXJyYXkgb2Ygc2VnbWVudHNcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2VCeVRpbWVzKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzW2ldLmNvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWdzW2ldLmRheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5jb2wgPSBzZWdzW2ldLmRheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8qIERhdGUgSGFuZGxpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuc2xpY2VSYW5nZUJ5VGltZXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgc2VnUmFuZ2U7XHJcbiAgICAgICAgdmFyIGRheUluZGV4O1xyXG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHRoaXMuZGF5c1BlclJvdzsgZGF5SW5kZXgrKykge1xyXG4gICAgICAgICAgICBzZWdSYW5nZSA9IHVuem9uZWRSYW5nZS5pbnRlcnNlY3QodGhpcy5kYXlSYW5nZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TXM6IHNlZ1JhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTXM6IHNlZ1JhbmdlLmVuZE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmlzRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4OiBkYXlJbmRleFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogT3B0aW9uc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFBhcnNlcyB2YXJpb3VzIG9wdGlvbnMgaW50byBwcm9wZXJ0aWVzIG9mIHRoaXMgb2JqZWN0XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNsb3REdXJhdGlvbiA9IHRoaXMub3B0KCdzbG90RHVyYXRpb24nKTtcclxuICAgICAgICB2YXIgc25hcER1cmF0aW9uID0gdGhpcy5vcHQoJ3NuYXBEdXJhdGlvbicpO1xyXG4gICAgICAgIHZhciBpbnB1dDtcclxuICAgICAgICBzbG90RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oc2xvdER1cmF0aW9uKTtcclxuICAgICAgICBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb24gPyBtb21lbnQuZHVyYXRpb24oc25hcER1cmF0aW9uKSA6IHNsb3REdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBzUGVyU2xvdCA9IHNsb3REdXJhdGlvbiAvIHNuYXBEdXJhdGlvbjsgLy8gVE9ETzogZW5zdXJlIGFuIGludGVnZXIgbXVsdGlwbGU/XHJcbiAgICAgICAgLy8gbWlnaHQgYmUgYW4gYXJyYXkgdmFsdWUgKGZvciBUaW1lbGluZVZpZXcpLlxyXG4gICAgICAgIC8vIGlmIHNvLCBnZXR0aW5nIHRoZSBtb3N0IGdyYW51bGFyIGVudHJ5ICh0aGUgbGFzdCBvbmUgcHJvYmFibHkpLlxyXG4gICAgICAgIGlucHV0ID0gdGhpcy5vcHQoJ3Nsb3RMYWJlbEZvcm1hdCcpO1xyXG4gICAgICAgIGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFiZWxGb3JtYXQgPSBpbnB1dCB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdCgnc21hbGxUaW1lRm9ybWF0Jyk7IC8vIHRoZSBjb21wdXRlZCBkZWZhdWx0XHJcbiAgICAgICAgaW5wdXQgPSB0aGlzLm9wdCgnc2xvdExhYmVsSW50ZXJ2YWwnKTtcclxuICAgICAgICB0aGlzLmxhYmVsSW50ZXJ2YWwgPSBpbnB1dCA/XHJcbiAgICAgICAgICAgIG1vbWVudC5kdXJhdGlvbihpbnB1dCkgOlxyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVMYWJlbEludGVydmFsKHNsb3REdXJhdGlvbik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVMYWJlbEludGVydmFsID0gZnVuY3Rpb24gKHNsb3REdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBsYWJlbEludGVydmFsO1xyXG4gICAgICAgIHZhciBzbG90c1BlckxhYmVsO1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIHNtYWxsZXN0IHN0b2NrIGxhYmVsIGludGVydmFsIHRoYXQgcmVzdWx0cyBpbiBtb3JlIHRoYW4gb25lIHNsb3RzLXBlci1sYWJlbFxyXG4gICAgICAgIGZvciAoaSA9IEFHRU5EQV9TVE9DS19TVUJfRFVSQVRJT05TLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxhYmVsSW50ZXJ2YWwgPSBtb21lbnQuZHVyYXRpb24oQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlNbaV0pO1xyXG4gICAgICAgICAgICBzbG90c1BlckxhYmVsID0gdXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbihsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodXRpbF8xLmlzSW50KHNsb3RzUGVyTGFiZWwpICYmIHNsb3RzUGVyTGFiZWwgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxJbnRlcnZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHNsb3REdXJhdGlvbik7IC8vIGZhbGwgYmFjay4gY2xvbmVcclxuICAgIH07XHJcbiAgICAvKiBEYXRlIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURheVRhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTbGF0cygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ29sdW1ucygpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vdGhpcy51bnJlbmRlclNsYXRzKCk7IC8vIGRvbid0IG5lZWQgdGhpcyBiZWNhdXNlIHJlcGVhdGVkIC5odG1sKCkgY2FsbHMgY2xlYXJcclxuICAgICAgICB0aGlzLnVucmVuZGVyQ29sdW1ucygpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5lbC5odG1sKCc8ZGl2IGNsYXNzPVwiZmMtYmdcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1zbGF0c1wiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiIHN0eWxlPVwiZGlzcGxheTpub25lXCIgLz4nKTtcclxuICAgICAgICB0aGlzLmJvdHRvbVJ1bGVFbCA9IHRoaXMuZWwuZmluZCgnaHInKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2xhdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHRoaXMuc2xhdENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCc+IC5mYy1zbGF0cycpXHJcbiAgICAgICAgICAgIC5odG1sKC8vIGF2b2lkcyBuZWVkaW5nIDo6dW5yZW5kZXJTbGF0cygpXHJcbiAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2xhdFJvd0h0bWwoKSArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicpO1xyXG4gICAgICAgIHRoaXMuc2xhdEVscyA9IHRoaXMuc2xhdENvbnRhaW5lckVsLmZpbmQoJ3RyJyk7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5zbGF0RWxzLFxyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgaG9yaXpvbnRhbCBcInNsYXRzXCIgdGhhdCBydW4gd2lkdGgtd2lzZS4gSGFzIGEgdGltZSBheGlzIG9uIGEgc2lkZS4gRGVwZW5kcyBvbiBSVEwuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2xhdFJvd0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdGhlbWUgPSBjYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgaXNSVEwgPSB0aGlzLmlzUlRMO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgc2xvdFRpbWUgPSBtb21lbnQuZHVyYXRpb24oK2RhdGVQcm9maWxlLm1pblRpbWUpOyAvLyB3aXNoIHRoZXJlIHdhcyAuY2xvbmUoKSBmb3IgZHVyYXRpb25zXHJcbiAgICAgICAgdmFyIHNsb3RJdGVyYXRvciA9IG1vbWVudC5kdXJhdGlvbigwKTtcclxuICAgICAgICB2YXIgc2xvdERhdGU7IC8vIHdpbGwgYmUgb24gdGhlIHZpZXcncyBmaXJzdCBkYXksIGJ1dCB3ZSBvbmx5IGNhcmUgYWJvdXQgaXRzIHRpbWVcclxuICAgICAgICB2YXIgaXNMYWJlbGVkO1xyXG4gICAgICAgIHZhciBheGlzSHRtbDtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRpbWUgZm9yIGVhY2ggc2xvdFxyXG4gICAgICAgIHdoaWxlIChzbG90VGltZSA8IGRhdGVQcm9maWxlLm1heFRpbWUpIHtcclxuICAgICAgICAgICAgc2xvdERhdGUgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KGRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zKS50aW1lKHNsb3RUaW1lKTtcclxuICAgICAgICAgICAgaXNMYWJlbGVkID0gdXRpbF8xLmlzSW50KHV0aWxfMS5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24oc2xvdEl0ZXJhdG9yLCB0aGlzLmxhYmVsSW50ZXJ2YWwpKTtcclxuICAgICAgICAgICAgYXhpc0h0bWwgPVxyXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWF4aXMgZmMtdGltZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpc0xhYmVsZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4+JyArIC8vIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHNsb3REYXRlLmZvcm1hdCh0aGlzLmxhYmVsRm9ybWF0KSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgICAgICBodG1sICs9XHJcbiAgICAgICAgICAgICAgICAnPHRyIGRhdGEtdGltZT1cIicgKyBzbG90RGF0ZS5mb3JtYXQoJ0hIOm1tOnNzJykgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAoaXNMYWJlbGVkID8gJycgOiAnIGNsYXNzPVwiZmMtbWlub3JcIicpICtcclxuICAgICAgICAgICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICghaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiLz4nICtcclxuICAgICAgICAgICAgICAgICAgICAoaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCI8L3RyPlwiO1xyXG4gICAgICAgICAgICBzbG90VGltZS5hZGQodGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBzbG90SXRlcmF0b3IuYWRkKHRoaXMuc2xvdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWw7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5kYXlSYW5nZXMgPSB0aGlzLmRheURhdGVzLm1hcChmdW5jdGlvbiAoZGF5RGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5RGF0ZS5jbG9uZSgpLmFkZChkYXRlUHJvZmlsZS5taW5UaW1lKSwgZGF5RGF0ZS5jbG9uZSgpLmFkZChkYXRlUHJvZmlsZS5tYXhUaW1lKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZENvbnRhaW5lckVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZENvbnRhaW5lckVsLmh0bWwodGhpcy5yZW5kZXJIZWFkSHRtbCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCc+IC5mYy1iZycpLmh0bWwoJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmdUckh0bWwoMCkgKyAvLyByb3c9MFxyXG4gICAgICAgICAgICAnPC90YWJsZT4nKTtcclxuICAgICAgICB0aGlzLmNvbEVscyA9IHRoaXMuZWwuZmluZCgnLmZjLWRheSwgLmZjLWRpc2FibGVkLWRheScpO1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5jb2xFbHMsXHJcbiAgICAgICAgICAgIGlzSG9yaXpvbnRhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVyQ29udGVudFNrZWxldG9uKCk7XHJcbiAgICB9O1xyXG4gICAgLyogQ29udGVudCBTa2VsZXRvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgdGhlIERPTSB0aGF0IHRoZSB2aWV3J3MgY29udGVudCB3aWxsIGxpdmUgaW5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJDb250ZW50U2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNlbGxIdG1sID0gJyc7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29sQ250OyBpKyspIHtcclxuICAgICAgICAgICAgY2VsbEh0bWwgKz1cclxuICAgICAgICAgICAgICAgICc8dGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LWNvbFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyIGZjLWhlbHBlci1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtaGlnaGxpZ2h0LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWJ1c2luZXNzLWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBza2VsZXRvbkVsID0gdGhpcy5jb250ZW50U2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGU+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArIGNlbGxIdG1sICsgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1jb250ZW50LWNvbCcpO1xyXG4gICAgICAgIHRoaXMuaGVscGVyQ29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGVscGVyLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1ldmVudC1jb250YWluZXI6bm90KC5mYy1oZWxwZXItY29udGFpbmVyKScpO1xyXG4gICAgICAgIHRoaXMuYmdDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1iZ2V2ZW50LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29udGFpbmVyRWxzID0gc2tlbGV0b25FbC5maW5kKCcuZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1idXNpbmVzcy1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmJvb2tlbmRDZWxscyhza2VsZXRvbkVsLmZpbmQoJ3RyJykpOyAvLyBUT0RPOiBkbyB0aGlzIG9uIHN0cmluZyBsZXZlbFxyXG4gICAgICAgIHRoaXMuZWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS51bnJlbmRlckNvbnRlbnRTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFNrZWxldG9uRWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29sQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mZ0NvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iZ0NvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYnVzaW5lc3NDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3MgY29sXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ3JvdXBTZWdzQnlDb2wgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBzZWdzQnlDb2wgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdzQnlDb2wucHVzaChbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3NCeUNvbFtzZWdzW2ldLmNvbF0ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeUNvbDtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBzZWdtZW50cyBncm91cGVkIGJ5IGNvbHVtbiwgaW5zZXJ0IHRoZSBzZWdtZW50cycgZWxlbWVudHMgaW50byBhIHBhcmFsbGVsIGFycmF5IG9mIGNvbnRhaW5lclxyXG4gICAgLy8gZWxlbWVudHMsIGVhY2ggbGl2aW5nIHdpdGhpbiBhIGNvbHVtbi5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5hdHRhY2hTZWdzQnlDb2wgPSBmdW5jdGlvbiAoc2Vnc0J5Q29sLCBjb250YWluZXJFbHMpIHtcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHZhciBzZWdzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3MgPSBzZWdzQnlDb2xbY29sXTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckVscy5lcShjb2wpLmFwcGVuZChzZWdzW2ldLmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBOb3cgSW5kaWNhdG9yXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldE5vd0luZGljYXRvclVuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtaW51dGUnOyAvLyB3aWxsIHJlZnJlc2ggb24gdGhlIG1pbnV0ZVxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIC8vIEhBQ0s6IGlmIGRhdGUgY29sdW1ucyBub3QgcmVhZHkgZm9yIHNvbWUgcmVhc29uIChzY2hlZHVsZXIpXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbENvbnRhaW5lckVscykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlZyBzeXN0ZW0gbWlnaHQgYmUgb3ZlcmtpbGwsIGJ1dCBpdCBoYW5kbGVzIHNjZW5hcmlvIHdoZXJlIGxpbmUgbmVlZHMgdG8gYmUgcmVuZGVyZWRcclxuICAgICAgICAvLyAgbW9yZSB0aGFuIG9uY2UgYmVjYXVzZSBvZiBjb2x1bW5zIHdpdGggdGhlIHNhbWUgZGF0ZSAocmVzb3VyY2VzIGNvbHVtbnMgZm9yIGV4YW1wbGUpXHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyhuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXRlLCBkYXRlLnZhbHVlT2YoKSArIDEpLCAvLyBwcm90ZWN0IGFnYWluc3QgbnVsbCByYW5nZVxyXG4gICAgICAgIGZhbHNlIC8vIGFsbC1kYXlcclxuICAgICAgICApKTtcclxuICAgICAgICB2YXIgdG9wID0gdGhpcy5jb21wdXRlRGF0ZVRvcChkYXRlLCBkYXRlKTtcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICAvLyByZW5kZXIgbGluZXMgd2l0aGluIHRoZSBjb2x1bW5zXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbm9kZXMucHVzaCgkKCc8ZGl2IGNsYXNzPVwiZmMtbm93LWluZGljYXRvciBmYy1ub3ctaW5kaWNhdG9yLWxpbmVcIj48L2Rpdj4nKVxyXG4gICAgICAgICAgICAgICAgLmNzcygndG9wJywgdG9wKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuY29sQ29udGFpbmVyRWxzLmVxKHNlZ3NbaV0uY29sKSlbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW5kZXIgYW4gYXJyb3cgb3ZlciB0aGUgYXhpc1xyXG4gICAgICAgIGlmIChzZWdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbm9kZXMucHVzaCgkKCc8ZGl2IGNsYXNzPVwiZmMtbm93LWluZGljYXRvciBmYy1ub3ctaW5kaWNhdG9yLWFycm93XCI+PC9kaXY+JylcclxuICAgICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIHRvcClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uJykpWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMgPSAkKG5vZGVzKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm93SW5kaWNhdG9yRWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIENvb3JkaW5hdGVzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIGlmIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2FscyhbXS5jb25jYXQodGhpcy5ldmVudFJlbmRlcmVyLmdldFNlZ3MoKSwgdGhpcy5idXNpbmVzc1NlZ3MgfHwgW10pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldFRvdGFsU2xhdEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zbGF0Q29udGFpbmVyRWwub3V0ZXJIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgLy8gYG1zYCBjYW4gYmUgYSBtaWxsaXNlY29uZCBVVEMgdGltZSBPUiBhIFVUQyBtb21lbnQuXHJcbiAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVEYXRlVG9wID0gZnVuY3Rpb24gKG1zLCBzdGFydE9mRGF5RGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKG1vbWVudC5kdXJhdGlvbihtcyAtIHN0YXJ0T2ZEYXlEYXRlLmNsb25lKCkuc3RyaXBUaW1lKCkpKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlVGltZVRvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuc2xhdEVscy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgc2xhdENvdmVyYWdlID0gKHRpbWUgLSBkYXRlUHJvZmlsZS5taW5UaW1lKSAvIHRoaXMuc2xvdER1cmF0aW9uOyAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcclxuICAgICAgICB2YXIgc2xhdEluZGV4O1xyXG4gICAgICAgIHZhciBzbGF0UmVtYWluZGVyO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9yIGhvdyBtYW55IHNsYXRzIHNob3VsZCBiZSBwcm9ncmVzc2VkIHRocm91Z2guXHJcbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxyXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2UgbWluVGltZS9tYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXHJcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICBzbGF0Q292ZXJhZ2UgPSBNYXRoLm1pbihsZW4sIHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxyXG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcclxuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLmZsb29yKHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcclxuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cclxuICAgICAgICAvLyBjb3VsZCBiZSAxLjAgaWYgc2xhdENvdmVyYWdlIGlzIGNvdmVyaW5nICphbGwqIHRoZSBzbG90c1xyXG4gICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0VG9wUG9zaXRpb24oc2xhdEluZGV4KSArXHJcbiAgICAgICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0SGVpZ2h0KHNsYXRJbmRleCkgKiBzbGF0UmVtYWluZGVyO1xyXG4gICAgfTtcclxuICAgIC8vIFJlZnJlc2hlcyB0aGUgQ1NTIHRvcC9ib3R0b20gY29vcmRpbmF0ZXMgZm9yIGVhY2ggc2VnbWVudCBlbGVtZW50LlxyXG4gICAgLy8gV29ya3Mgd2hlbiBjYWxsZWQgYWZ0ZXIgaW5pdGlhbCByZW5kZXIsIGFmdGVyIGEgd2luZG93IHJlc2l6ZS96b29tIGZvciBleGFtcGxlLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVwZGF0ZVNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQgaW4gYW4gYXJyYXksIGNvbXB1dGVzIGFuZCBhc3NpZ25zIGl0cyB0b3AgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWluSGVpZ2h0ID0gdGhpcy5vcHQoJ2FnZW5kYUV2ZW50TWluSGVpZ2h0Jyk7XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICB2YXIgZGF5RGF0ZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBkYXlEYXRlID0gdGhpcy5kYXlEYXRlc1tzZWcuZGF5SW5kZXhdO1xyXG4gICAgICAgICAgICBzZWcudG9wID0gdGhpcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnRNcywgZGF5RGF0ZSk7XHJcbiAgICAgICAgICAgIHNlZy5ib3R0b20gPSBNYXRoLm1heChzZWcudG9wICsgZXZlbnRNaW5IZWlnaHQsIHRoaXMuY29tcHV0ZURhdGVUb3Aoc2VnLmVuZE1zLCBkYXlEYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHNlZ21lbnRzIHRoYXQgYWxyZWFkeSBoYXZlIHRoZWlyIHRvcC9ib3R0b20gcHJvcGVydGllcyBjb21wdXRlZCwgYXBwbGllcyB0aG9zZSB2YWx1ZXMgdG9cclxuICAgIC8vIHRoZSBzZWdtZW50cycgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuYXNzaWduU2VnVmVydGljYWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgaSwgc2VnO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNlZy5lbC5jc3ModGhpcy5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMgZm9yIHRoZSB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIG9mIGEgc2VnbWVudCBlbGVtZW50XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3A6IHNlZy50b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogLXNlZy5ib3R0b20gLy8gZmxpcHBlZCBiZWNhdXNlIG5lZWRzIHRvIGJlIHNwYWNlIGJleW9uZCBib3R0b20gZWRnZSBvZiBldmVudCBjb250YWluZXJcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qIEhpdCBTeXN0ZW1cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICAvLyBOT1RFOiBkb24ndCBjbGVhciBzbGF0Q29vcmRDYWNoZSBiZWNhdXNlIHdlIHJlbHkgb24gaXQgZm9yIGNvbXB1dGVUaW1lVG9wXHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIHZhciBzbmFwc1BlclNsb3QgPSB0aGlzLnNuYXBzUGVyU2xvdDtcclxuICAgICAgICB2YXIgY29sQ29vcmRDYWNoZSA9IHRoaXMuY29sQ29vcmRDYWNoZTtcclxuICAgICAgICB2YXIgc2xhdENvb3JkQ2FjaGUgPSB0aGlzLnNsYXRDb29yZENhY2hlO1xyXG4gICAgICAgIGlmIChjb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHNsYXRDb29yZENhY2hlLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2YXIgY29sSW5kZXggPSBjb2xDb29yZENhY2hlLmdldEhvcml6b250YWxJbmRleChsZWZ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZENhY2hlLmdldFZlcnRpY2FsSW5kZXgodG9wT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbGF0VG9wID0gc2xhdENvb3JkQ2FjaGUuZ2V0VG9wT2Zmc2V0KHNsYXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xhdEhlaWdodCA9IHNsYXRDb29yZENhY2hlLmdldEhlaWdodChzbGF0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSAodG9wT2Zmc2V0IC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwVG9wID0gc2xhdFRvcCArIChsb2NhbFNuYXBJbmRleCAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBCb3R0b20gPSBzbGF0VG9wICsgKChsb2NhbFNuYXBJbmRleCArIDEpIC8gc25hcHNQZXJTbG90KSAqIHNsYXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcDogc25hcEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sSW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbEluZGV4KSxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNuYXBUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzbmFwQm90dG9tXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXRIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBoaXQuY29sKTsgLy8gcm93PTBcclxuICAgICAgICB2YXIgdGltZSA9IHRoaXMuY29tcHV0ZVNuYXBUaW1lKGhpdC5zbmFwKTsgLy8gcGFzcyBpbiB0aGUgc25hcC1pbmRleFxyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgc3RhcnQudGltZSh0aW1lKTtcclxuICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLnNuYXBEdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpLCBmYWxzZSAvLyBhbGwtZGF5P1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSByb3cgbnVtYmVyIG9mIHRoZSBncmlkLCByZXByZXNlbnRpbmcgYSBcInNuYXBcIiwgcmV0dXJucyBhIHRpbWUgKER1cmF0aW9uKSBmcm9tIGl0cyBzdGFydC1vZi1kYXlcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlU25hcFRpbWUgPSBmdW5jdGlvbiAoc25hcEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih0aGlzLmRhdGVQcm9maWxlLm1pblRpbWUgKyB0aGlzLnNuYXBEdXJhdGlvbiAqIHNuYXBJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbEVscy5lcShoaXQuY29sKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBEcmFnIFZpc3VhbGl6YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoZSBzcGVjaWZpZWQgZGF0ZShzKS5cclxuICAgIC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZykge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRGb290cHJpbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgICAgICAgICAvLyBzaWduYWwgdGhhdCBhIGhlbHBlciBoYXMgYmVlbiByZW5kZXJlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0KGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0LCB3aGljaCB3YXMgdG8gc2ltcGx5IHJlbmRlciBhIGhpZ2hsaWdodC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdzZWxlY3RIZWxwZXInKSkge1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlclJlbmRlcmVyLnJlbmRlckNvbXBvbmVudEZvb3RwcmludChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFueSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIudW5yZW5kZXIoKTtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRpbWVHcmlkO1xyXG59KEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5ldmVudFJlbmRlcmVyQ2xhc3MgPSBUaW1lR3JpZEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyA9IEJ1c2luZXNzSG91clJlbmRlcmVyXzEuZGVmYXVsdDtcclxuVGltZUdyaWQucHJvdG90eXBlLmhlbHBlclJlbmRlcmVyQ2xhc3MgPSBUaW1lR3JpZEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxuVGltZUdyaWQucHJvdG90eXBlLmZpbGxSZW5kZXJlckNsYXNzID0gVGltZUdyaWRGaWxsUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEuZGVmYXVsdC5taXhJbnRvKFRpbWVHcmlkKTtcclxuRGF5VGFibGVNaXhpbl8xLmRlZmF1bHQubWl4SW50byhUaW1lR3JpZCk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDY5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG52YXIgQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyVW56b25lZFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7IC8vIGFuIFVuem9uZWRSYW5nZVxyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMubXNUb1V0Y01vbWVudChyZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMubXNUb1V0Y01vbWVudChyZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXHJcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSkge1xyXG4gICAgICAgICAgICBzdGFydC5zdGFydE9mKCd3ZWVrJyk7XHJcbiAgICAgICAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcclxuICAgICAgICAgICAgaWYgKGVuZC53ZWVrZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5hZGQoMSwgJ3dlZWsnKS5zdGFydE9mKCd3ZWVrJyk7IC8vIGV4Y2x1c2l2ZWx5IG1vdmUgYmFja3dhcmRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufShEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBCYXNpY1ZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xyXG52YXIgQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xyXG4vKiBBIG1vbnRoIHZpZXcgd2l0aCBkYXkgY2VsbHMgcnVubmluZyBpbiByb3dzIChvbmUtcGVyLXdlZWspIGFuZCBjb2x1bW5zXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyVW56b25lZFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICAvLyBlbnN1cmUgNiB3ZWVrc1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnZml4ZWRXZWVrQ291bnQnKSkge1xyXG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xyXG4gICAgICAgICAgICBlbmQuZGlmZihzdGFydCwgJ3dlZWtzJywgdHJ1ZSkgLy8gZG9udFJvdW5kPXRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZW5kLmFkZCg2IC0gcm93Q250LCAnd2Vla3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufShCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQpKTtcclxudmFyIE1vbnRoVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1vbnRoVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vbnRoVmlldygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBPdmVycmlkZXMgdGhlIGRlZmF1bHQgQmFzaWNWaWV3IGJlaGF2aW9yIHRvIGhhdmUgc3BlY2lhbCBtdWx0aS13ZWVrIGF1dG8taGVpZ2h0IGxvZ2ljXHJcbiAgICBNb250aFZpZXcucHJvdG90eXBlLnNldEdyaWRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBpc0F1dG8pIHtcclxuICAgICAgICAvLyBpZiBhdXRvLCBtYWtlIHRoZSBoZWlnaHQgb2YgZWFjaCByb3cgdGhlIGhlaWdodCB0aGF0IGl0IHdvdWxkIGJlIGlmIHRoZXJlIHdlcmUgNiB3ZWVrc1xyXG4gICAgICAgIGlmIChpc0F1dG8pIHtcclxuICAgICAgICAgICAgaGVpZ2h0ICo9IHRoaXMuZGF5R3JpZC5yb3dDbnQgLyA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICB1dGlsXzEuZGlzdHJpYnV0ZUhlaWdodCh0aGlzLmRheUdyaWQucm93RWxzLCBoZWlnaHQsICFpc0F1dG8pOyAvLyBpZiBhdXRvLCBkb24ndCBjb21wZW5zYXRlIGZvciBoZWlnaHQtaG9nZ2luZyByb3dzXHJcbiAgICB9O1xyXG4gICAgTW9udGhWaWV3LnByb3RvdHlwZS5pc0RhdGVJbk90aGVyTW9udGggPSBmdW5jdGlvbiAoZGF0ZSwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICByZXR1cm4gZGF0ZS5tb250aCgpICE9PSBtb21lbnQudXRjKGRhdGVQcm9maWxlLmN1cnJlbnRVbnpvbmVkUmFuZ2Uuc3RhcnRNcykubW9udGgoKTsgLy8gVE9ETzogb3B0aW1pemVcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9udGhWaWV3O1xyXG59KEJhc2ljVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9udGhWaWV3O1xyXG5Nb250aFZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcclxudmFyIFNjcm9sbGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcclxudmFyIExpc3RFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKTtcclxudmFyIExpc3RFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKTtcclxuLypcclxuUmVzcG9uc2libGUgZm9yIHRoZSBzY3JvbGxlciwgYW5kIGZvcndhcmRpbmcgZXZlbnQtcmVsYXRlZCBhY3Rpb25zIGludG8gdGhlIFwiZ3JpZFwiLlxyXG4qL1xyXG52YXIgTGlzdFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMaXN0VmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zZWdTZWxlY3RvciA9ICcuZmMtbGlzdC1pdGVtJzsgLy8gd2hpY2ggZWxlbWVudHMgYWNjZXB0IGV2ZW50IGFjdGlvbnNcclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1saXN0LXZpZXcgJyArXHJcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ2xpc3RWaWV3JykpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5lbC5hcHBlbmRUbyh0aGlzLmVsKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbCA9IHRoaXMuc2Nyb2xsZXIuc2Nyb2xsRWw7IC8vIHNob3J0Y3V0XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnVucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7IC8vIHdpbGwgcmVtb3ZlIHRoZSBHcmlkIHRvb1xyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQodGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpKTtcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGRheVN0YXJ0ID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHZpZXdFbmQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KGRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRheURhdGVzID0gW107XHJcbiAgICAgICAgdmFyIGRheVJhbmdlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChkYXlTdGFydCA8IHZpZXdFbmQpIHtcclxuICAgICAgICAgICAgZGF5RGF0ZXMucHVzaChkYXlTdGFydC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZGF5UmFuZ2VzLnB1c2gobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF5U3RhcnQsIGRheVN0YXJ0LmNsb25lKCkuYWRkKDEsICdkYXknKSkpO1xyXG4gICAgICAgICAgICBkYXlTdGFydC5hZGQoMSwgJ2RheScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRheURhdGVzID0gZGF5RGF0ZXM7XHJcbiAgICAgICAgdGhpcy5kYXlSYW5nZXMgPSBkYXlSYW5nZXM7XHJcbiAgICAgICAgLy8gYWxsIHJlYWwgcmVuZGVyaW5nIGhhcHBlbnMgaW4gRXZlbnRSZW5kZXJlclxyXG4gICAgfTtcclxuICAgIC8vIHNsaWNlcyBieSBkYXlcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoZm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIGRheVJhbmdlcyA9IHRoaXMuZGF5UmFuZ2VzO1xyXG4gICAgICAgIHZhciBkYXlJbmRleDtcclxuICAgICAgICB2YXIgc2VnUmFuZ2U7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4KyspIHtcclxuICAgICAgICAgICAgc2VnUmFuZ2UgPSBmb290cHJpbnQudW56b25lZFJhbmdlLmludGVyc2VjdChkYXlSYW5nZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNczogc2VnUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgICAgICAgICBlbmRNczogc2VnUmFuZ2UuZW5kTXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2UuaXNTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXg6IGRheUluZGV4XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3Qgd2hlbiBmb290cHJpbnQgd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgbXV0YXRlIHRoZSBsYXRlc3Qgc2VnIHRvIHRoZSBiZSB0aGUgZW5kLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWZvb3RwcmludC5pc0FsbERheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICsgMSA8IGRheVJhbmdlcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICBmb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zIDwgZGF5UmFuZ2VzW2RheUluZGV4ICsgMV0uc3RhcnRNcyArIHRoaXMubmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbmRNcyA9IGZvb3RwcmludC51bnpvbmVkUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyRW1wdHlNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmh0bWwoJzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5LXdyYXAyXCI+JyArIC8vIFRPRE86IHRyeSBsZXNzIHdyYXBzXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMVwiPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHlcIj4nICtcclxuICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5vcHQoJ25vRXZlbnRzTWVzc2FnZScpKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPC9kaXY+Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gcmVuZGVyIHRoZSBldmVudCBzZWdtZW50cyBpbiB0aGUgdmlld1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlclNlZ0xpc3QgPSBmdW5jdGlvbiAoYWxsU2Vncykge1xyXG4gICAgICAgIHZhciBzZWdzQnlEYXkgPSB0aGlzLmdyb3VwU2Vnc0J5RGF5KGFsbFNlZ3MpOyAvLyBzcGFyc2UgYXJyYXlcclxuICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgdmFyIGRheVNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhYmxlRWwgPSAkKCc8dGFibGUgY2xhc3M9XCJmYy1saXN0LXRhYmxlICcgKyB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd0YWJsZUxpc3QnKSArICdcIj48dGJvZHkvPjwvdGFibGU+Jyk7XHJcbiAgICAgICAgdmFyIHRib2R5RWwgPSB0YWJsZUVsLmZpbmQoJ3Rib2R5Jyk7XHJcbiAgICAgICAgZm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgc2Vnc0J5RGF5Lmxlbmd0aDsgZGF5SW5kZXgrKykge1xyXG4gICAgICAgICAgICBkYXlTZWdzID0gc2Vnc0J5RGF5W2RheUluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGRheVNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcclxuICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kKHRoaXMuZGF5SGVhZGVySHRtbCh0aGlzLmRheURhdGVzW2RheUluZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnNvcnRFdmVudFNlZ3MoZGF5U2Vncyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGF5U2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRib2R5RWwuYXBwZW5kKGRheVNlZ3NbaV0uZWwpOyAvLyBhcHBlbmQgZXZlbnQgcm93XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKS5hcHBlbmQodGFibGVFbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmdyb3VwU2Vnc0J5RGF5ID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5RGF5ID0gW107IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgIHZhciBpLCBzZWc7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdIHx8IChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSA9IFtdKSlcclxuICAgICAgICAgICAgICAgIC5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzQnlEYXk7XHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgZGF5IGhlYWRlcnMgdGhhdCBsaXZlIGFtb25nc3QgdGhlIGV2ZW50IHJvd3NcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5kYXlIZWFkZXJIdG1sID0gZnVuY3Rpb24gKGRheURhdGUpIHtcclxuICAgICAgICB2YXIgbWFpbkZvcm1hdCA9IHRoaXMub3B0KCdsaXN0RGF5Rm9ybWF0Jyk7XHJcbiAgICAgICAgdmFyIGFsdEZvcm1hdCA9IHRoaXMub3B0KCdsaXN0RGF5QWx0Rm9ybWF0Jyk7XHJcbiAgICAgICAgcmV0dXJuICc8dHIgY2xhc3M9XCJmYy1saXN0LWhlYWRpbmdcIiBkYXRhLWRhdGU9XCInICsgZGF5RGF0ZS5mb3JtYXQoJ1lZWVktTU0tREQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiBjb2xzcGFuPVwiM1wiPicgK1xyXG4gICAgICAgICAgICAobWFpbkZvcm1hdCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkR290b0FuY2hvckh0bWwoZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLW1haW4nIH0sIHV0aWxfMS5odG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KG1haW5Gb3JtYXQpKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICApIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChhbHRGb3JtYXQgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEdvdG9BbmNob3JIdG1sKGRheURhdGUsIHsgJ2NsYXNzJzogJ2ZjLWxpc3QtaGVhZGluZy1hbHQnIH0sIHV0aWxfMS5odG1sRXNjYXBlKGRheURhdGUuZm9ybWF0KGFsdEZvcm1hdCkpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RWaWV3O1xyXG5MaXN0Vmlldy5wcm90b3R5cGUuZXZlbnRSZW5kZXJlckNsYXNzID0gTGlzdEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5MaXN0Vmlldy5wcm90b3R5cGUuZXZlbnRQb2ludGluZ0NsYXNzID0gTGlzdEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIG5hbWVzcGFjZV9ob29rc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIG5hbWVzcGFjZUV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBDYWxlbmRhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcbi8vIGZvciBpbnRlbnRpb25hbCBzaWRlLWVmZmVjdHNcclxuX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oOTIpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oOTYpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcclxuJC5mdWxsQ2FsZW5kYXIgPSAkLmV4dGVuZChuYW1lc3BhY2VfaG9va3NfMS5kZWZhdWx0LCBuYW1lc3BhY2VFeHBvcnRzKTsgLy8gZ3JhZnQgb3ZlciB0aGUgb3JpZ2luYWwgaG9va3Mgb2JqZWN0XHJcbiQuZm4uZnVsbENhbGVuZGFyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIGEgcG9zc2libGUgbWV0aG9kIGNhbGxcclxuICAgIHZhciByZXMgPSB0aGlzOyAvLyB3aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gKHRoaXMgalF1ZXJ5IG9iamVjdCBieSBkZWZhdWx0KVxyXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBfZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gJChfZWxlbWVudCk7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInKTsgLy8gZ2V0IHRoZSBleGlzdGluZyBjYWxlbmRhciBvYmplY3QgKGlmIGFueSlcclxuICAgICAgICB2YXIgc2luZ2xlUmVzOyAvLyB0aGUgcmV0dXJuZWQgdmFsdWUgb2YgdGhpcyBzaW5nbGUgbWV0aG9kIGNhbGxcclxuICAgICAgICAvLyBhIG1ldGhvZCBjYWxsXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gJ2dldENhbGVuZGFyJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gY2FsZW5kYXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gJ2Rlc3Ryb3knKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVEYXRhKCdmdWxsQ2FsZW5kYXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghY2FsZW5kYXIpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS53YXJuKFwiQXR0ZW1wdGluZyB0byBjYWxsIGEgRnVsbENhbGVuZGFyIG1ldGhvZCBvbiBhbiBlbGVtZW50IHdpdGggbm8gY2FsZW5kYXIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihjYWxlbmRhcltvcHRpb25zXSkpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZVJlcyA9IGNhbGVuZGFyW29wdGlvbnNdLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHNpbmdsZVJlczsgLy8gcmVjb3JkIHRoZSBmaXJzdCBtZXRob2QgY2FsbCByZXN1bHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oXCInXCIgKyBvcHRpb25zICsgXCInIGlzIGFuIHVua25vd24gRnVsbENhbGVuZGFyIG1ldGhvZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhbGVuZGFyKSB7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyID0gbmV3IENhbGVuZGFyXzEuZGVmYXVsdChlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgZWxlbWVudC5kYXRhKCdmdWxsQ2FsZW5kYXInLCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGNhbGVuZGFyLnJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLy8gVE9ETzogbGludGVyP1xyXG4vLyBhZnRlciBtZXJnZTogcHV0IE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yIGFmdGVyXHJcbi8vIFwiYWJzdHJhY3RcIiBpc3N1ZVxyXG4vLyBlbnN1cmUgJCBhbHdheXMgZ2V0cyBhIGxvY2FsIG1vZHVsZSByZWZlcmVuY2VcclxuLy8gYmV0dGVyIFVNRCBzb2x1dGlvblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBDYWxlbmRhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XHJcbmV4cG9ydHMuQ2FsZW5kYXIgPSBDYWxlbmRhcl8xLmRlZmF1bHQ7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuQ2FsZW5kYXJfMS5kZWZhdWx0LmRlZmF1bHRzID0gb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzO1xyXG5DYWxlbmRhcl8xLmRlZmF1bHQuZW5nbGlzaERlZmF1bHRzID0gb3B0aW9uc18xLmVuZ2xpc2hEZWZhdWx0cztcclxuQ2FsZW5kYXJfMS5kZWZhdWx0LnJ0bERlZmF1bHRzID0gb3B0aW9uc18xLnJ0bERlZmF1bHRzO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuZXhwb3J0cy5hcHBseUFsbCA9IHV0aWxfMS5hcHBseUFsbDtcclxuZXhwb3J0cy5kZWJvdW5jZSA9IHV0aWxfMS5kZWJvdW5jZTtcclxuZXhwb3J0cy5pc0ludCA9IHV0aWxfMS5pc0ludDtcclxuZXhwb3J0cy5odG1sRXNjYXBlID0gdXRpbF8xLmh0bWxFc2NhcGU7XHJcbmV4cG9ydHMuY3NzVG9TdHIgPSB1dGlsXzEuY3NzVG9TdHI7XHJcbmV4cG9ydHMucHJveHkgPSB1dGlsXzEucHJveHk7XHJcbmV4cG9ydHMuY2FwaXRhbGlzZUZpcnN0TGV0dGVyID0gdXRpbF8xLmNhcGl0YWxpc2VGaXJzdExldHRlcjtcclxuZXhwb3J0cy5nZXRPdXRlclJlY3QgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0O1xyXG5leHBvcnRzLmdldENsaWVudFJlY3QgPSB1dGlsXzEuZ2V0Q2xpZW50UmVjdDtcclxuZXhwb3J0cy5nZXRDb250ZW50UmVjdCA9IHV0aWxfMS5nZXRDb250ZW50UmVjdDtcclxuZXhwb3J0cy5nZXRTY3JvbGxiYXJXaWR0aHMgPSB1dGlsXzEuZ2V0U2Nyb2xsYmFyV2lkdGhzO1xyXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gdXRpbF8xLnByZXZlbnREZWZhdWx0O1xyXG5leHBvcnRzLnBhcnNlRmllbGRTcGVjcyA9IHV0aWxfMS5wYXJzZUZpZWxkU3BlY3M7XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IHV0aWxfMS5jb21wYXJlQnlGaWVsZFNwZWNzO1xyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlYyA9IHV0aWxfMS5jb21wYXJlQnlGaWVsZFNwZWM7XHJcbmV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gdXRpbF8xLmZsZXhpYmxlQ29tcGFyZTtcclxuZXhwb3J0cy5jb21wdXRlR3JlYXRlc3RVbml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQ7XHJcbmV4cG9ydHMuZGl2aWRlUmFuZ2VCeUR1cmF0aW9uID0gdXRpbF8xLmRpdmlkZVJhbmdlQnlEdXJhdGlvbjtcclxuZXhwb3J0cy5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24gPSB1dGlsXzEuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uO1xyXG5leHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSB1dGlsXzEubXVsdGlwbHlEdXJhdGlvbjtcclxuZXhwb3J0cy5kdXJhdGlvbkhhc1RpbWUgPSB1dGlsXzEuZHVyYXRpb25IYXNUaW1lO1xyXG5leHBvcnRzLmxvZyA9IHV0aWxfMS5sb2c7XHJcbmV4cG9ydHMud2FybiA9IHV0aWxfMS53YXJuO1xyXG5leHBvcnRzLnJlbW92ZUV4YWN0ID0gdXRpbF8xLnJlbW92ZUV4YWN0O1xyXG5leHBvcnRzLmludGVyc2VjdFJlY3RzID0gdXRpbF8xLmludGVyc2VjdFJlY3RzO1xyXG52YXIgZGF0ZV9mb3JtYXR0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZGF0ZV9mb3JtYXR0aW5nXzEuZm9ybWF0RGF0ZTtcclxuZXhwb3J0cy5mb3JtYXRSYW5nZSA9IGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdFJhbmdlO1xyXG5leHBvcnRzLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdCA9IGRhdGVfZm9ybWF0dGluZ18xLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdDtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbmV4cG9ydHMuZGF0ZXBpY2tlckxvY2FsZSA9IGxvY2FsZV8xLmRhdGVwaWNrZXJMb2NhbGU7XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlXzEubG9jYWxlO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuZXhwb3J0cy5tb21lbnQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdDtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuZXhwb3J0cy5FbWl0dGVyTWl4aW4gPSBFbWl0dGVyTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuZXhwb3J0cy5MaXN0ZW5lck1peGluID0gTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBNb2RlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbmV4cG9ydHMuTW9kZWwgPSBNb2RlbF8xLmRlZmF1bHQ7XHJcbnZhciBDb25zdHJhaW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbmV4cG9ydHMuQ29uc3RyYWludHMgPSBDb25zdHJhaW50c18xLmRlZmF1bHQ7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMuVW56b25lZFJhbmdlID0gVW56b25lZFJhbmdlXzEuZGVmYXVsdDtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbmV4cG9ydHMuQ29tcG9uZW50Rm9vdHByaW50ID0gQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdDtcclxudmFyIEJ1c2luZXNzSG91ckdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XHJcbmV4cG9ydHMuQnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuZXhwb3J0cy5FdmVudERlZiA9IEV2ZW50RGVmXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG5leHBvcnRzLkV2ZW50RGVmTXV0YXRpb24gPSBFdmVudERlZk11dGF0aW9uXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50U291cmNlUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuZXhwb3J0cy5FdmVudFNvdXJjZVBhcnNlciA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5leHBvcnRzLkV2ZW50U291cmNlID0gRXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgVGhlbWVSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcbmV4cG9ydHMuVGhlbWVSZWdpc3RyeSA9IFRoZW1lUmVnaXN0cnlfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxuZXhwb3J0cy5FdmVudEluc3RhbmNlR3JvdXAgPSBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0O1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbmV4cG9ydHMuQXJyYXlFdmVudFNvdXJjZSA9IEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgRnVuY0V2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxuZXhwb3J0cy5GdW5jRXZlbnRTb3VyY2UgPSBGdW5jRXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbmV4cG9ydHMuSnNvbkZlZWRFdmVudFNvdXJjZSA9IEpzb25GZWVkRXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5leHBvcnRzLkV2ZW50Rm9vdHByaW50ID0gRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0O1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG5leHBvcnRzLkNsYXNzID0gQ2xhc3NfMS5kZWZhdWx0O1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5leHBvcnRzLk1peGluID0gTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbmV4cG9ydHMuQ29vcmRDYWNoZSA9IENvb3JkQ2FjaGVfMS5kZWZhdWx0O1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuZXhwb3J0cy5EcmFnTGlzdGVuZXIgPSBEcmFnTGlzdGVuZXJfMS5kZWZhdWx0O1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2VfMS5kZWZhdWx0O1xyXG52YXIgVGFza1F1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxuZXhwb3J0cy5UYXNrUXVldWUgPSBUYXNrUXVldWVfMS5kZWZhdWx0O1xyXG52YXIgUmVuZGVyUXVldWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xyXG5leHBvcnRzLlJlbmRlclF1ZXVlID0gUmVuZGVyUXVldWVfMS5kZWZhdWx0O1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG5leHBvcnRzLlNjcm9sbGVyID0gU2Nyb2xsZXJfMS5kZWZhdWx0O1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG5leHBvcnRzLlRoZW1lID0gVGhlbWVfMS5kZWZhdWx0O1xyXG52YXIgRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSk7XHJcbmV4cG9ydHMuRGF0ZUNvbXBvbmVudCA9IERhdGVDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcclxuZXhwb3J0cy5JbnRlcmFjdGl2ZURhdGVDb21wb25lbnQgPSBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XHJcbmV4cG9ydHMuVmlldyA9IFZpZXdfMS5kZWZhdWx0O1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbmV4cG9ydHMuRGF5VGFibGVNaXhpbiA9IERheVRhYmxlTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQnVzaW5lc3NIb3VyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG5leHBvcnRzLkJ1c2luZXNzSG91clJlbmRlcmVyID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbmV4cG9ydHMuRXZlbnRSZW5kZXJlciA9IEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxuZXhwb3J0cy5GaWxsUmVuZGVyZXIgPSBGaWxsUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5leHBvcnRzLkhlbHBlclJlbmRlcmVyID0gSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRXh0ZXJuYWxEcm9wcGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcbmV4cG9ydHMuRXh0ZXJuYWxEcm9wcGluZyA9IEV4dGVybmFsRHJvcHBpbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRSZXNpemluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XHJcbmV4cG9ydHMuRXZlbnRSZXNpemluZyA9IEV2ZW50UmVzaXppbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XHJcbmV4cG9ydHMuRXZlbnRQb2ludGluZyA9IEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREcmFnZ2luZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XHJcbmV4cG9ydHMuRXZlbnREcmFnZ2luZyA9IEV2ZW50RHJhZ2dpbmdfMS5kZWZhdWx0O1xyXG52YXIgRGF0ZVNlbGVjdGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XHJcbmV4cG9ydHMuRGF0ZVNlbGVjdGluZyA9IERhdGVTZWxlY3RpbmdfMS5kZWZhdWx0O1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XHJcbmV4cG9ydHMuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbiA9IFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQWdlbmRhVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcbmV4cG9ydHMuQWdlbmRhVmlldyA9IEFnZW5kYVZpZXdfMS5kZWZhdWx0O1xyXG52YXIgVGltZUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xyXG5leHBvcnRzLlRpbWVHcmlkID0gVGltZUdyaWRfMS5kZWZhdWx0O1xyXG52YXIgRGF5R3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XHJcbmV4cG9ydHMuRGF5R3JpZCA9IERheUdyaWRfMS5kZWZhdWx0O1xyXG52YXIgQmFzaWNWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcclxuZXhwb3J0cy5CYXNpY1ZpZXcgPSBCYXNpY1ZpZXdfMS5kZWZhdWx0O1xyXG52YXIgTW9udGhWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcclxuZXhwb3J0cy5Nb250aFZpZXcgPSBNb250aFZpZXdfMS5kZWZhdWx0O1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG5leHBvcnRzLkxpc3RWaWV3ID0gTGlzdFZpZXdfMS5kZWZhdWx0O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBJdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yKGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zIHx8IFtdO1xyXG4gICAgfVxyXG4gICAgLyogQ2FsbHMgYSBtZXRob2Qgb24gZXZlcnkgaXRlbSBwYXNzaW5nIHRoZSBhcmd1bWVudHMgdGhyb3VnaCAqL1xyXG4gICAgSXRlcmF0b3IucHJvdG90eXBlLnByb3h5Q2FsbCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbVttZXRob2ROYW1lXS5hcHBseShpdGVtLCBhcmdzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEl0ZXJhdG9yO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJdGVyYXRvcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG4vKiBUb29sYmFyIHdpdGggYnV0dG9ucyBhbmQgdGl0bGVcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9vbGJhcihjYWxlbmRhciwgdG9vbGJhck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVsID0gbnVsbDsgLy8gbWlycm9ycyBsb2NhbCBgZWxgXHJcbiAgICAgICAgdGhpcy52aWV3c1dpdGhCdXR0b25zID0gW107XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSB0b29sYmFyT3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIG1ldGhvZCB0byB1cGRhdGUgdG9vbGJhci1zcGVjaWZpYyBvcHRpb25zLCBub3QgY2FsZW5kYXItd2lkZSBvcHRpb25zXHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5zZXRUb29sYmFyT3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdUb29sYmFyT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSBuZXdUb29sYmFyT3B0aW9ucztcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIHdpbGwgcmVyZW5kZXJcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VjdGlvbnMgPSB0aGlzLnRvb2xiYXJPcHRpb25zLmxheW91dDtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgIGlmIChzZWN0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdG9vbGJhciBcIiArIHRoaXMudG9vbGJhck9wdGlvbnMuZXh0cmFDbGFzc2VzICsgXCInLz5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbC5lbXB0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ2xlZnQnKSlcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5yZW5kZXJTZWN0aW9uKCdyaWdodCcpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCIvPicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIG9wdGlvbnNNYW5hZ2VyID0gY2FsZW5kYXIub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdmFyIHZpZXdTcGVjTWFuYWdlciA9IGNhbGVuZGFyLnZpZXdTcGVjTWFuYWdlcjtcclxuICAgICAgICB2YXIgc2VjdGlvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLScgKyBwb3NpdGlvbiArICdcIi8+Jyk7XHJcbiAgICAgICAgdmFyIGJ1dHRvblN0ciA9IHRoaXMudG9vbGJhck9wdGlvbnMubGF5b3V0W3Bvc2l0aW9uXTtcclxuICAgICAgICB2YXIgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gb3B0aW9uc01hbmFnZXIuZ2V0KCdjdXN0b21CdXR0b25zJykgfHwge307XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xyXG4gICAgICAgIHZhciBjYWxlbmRhckJ1dHRvblRleHQgPSBvcHRpb25zTWFuYWdlci5nZXQoJ2J1dHRvblRleHQnKSB8fCB7fTtcclxuICAgICAgICBpZiAoYnV0dG9uU3RyKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChidXR0b25TdHIuc3BsaXQoJyAnKSwgZnVuY3Rpb24gKGksIGJ1dHRvbkdyb3VwU3RyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBDaGlsZHJlbiA9ICQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cEVsO1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChqLCBidXR0b25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3U3BlYztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQ7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbklubmVySHRtbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoJCgnPGgyPiZuYnNwOzwvaDI+JykpOyAvLyB3ZSBhbHdheXMgd2FudCBpdCB0byB0YWtlIHVwIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChidXR0b25FbFswXSwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjdXN0b21CdXR0b25Qcm9wcy50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWMoYnV0dG9uTmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbGVuZGFyW2J1dHRvbk5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhcltidXR0b25OYW1lXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgXiBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbkNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzc2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGVmYXVsdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvblRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZShidXR0b25UZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJ1dHRvbkljb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25Jbm5lckh0bWwgPSBcIjxzcGFuIGNsYXNzPSdcIiArIGJ1dHRvbkljb24gKyBcIic+PC9zcGFuPlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwgPSAkKC8vIHR5cGU9XCJidXR0b25cIiBzbyB0aGF0IGl0IGRvZXNuJ3Qgc3VibWl0IGEgZm9ybVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJyArIGJ1dHRvbkNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbklubmVySHRtbCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvYnV0dG9uPicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHByb2Nlc3MgY2xpY2tzIGZvciBkaXNhYmxlZCBidXR0b25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidXR0b25FbC5oYXNDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayhldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBjbGljayBhY3Rpb24sIGlmIHRoZSBidXR0b24gYmVjb21lcyB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbmV2ZXIgaGF2ZSBhIGhvdmVyIGNsYXNzLCBzbyByZW1vdmUgaXQgbm93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uRWwuaGFzQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5oYXNDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tb3VzZWRvd24oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSAqZG93biogZWZmZWN0IChtb3VzZSBwcmVzc2VkIGluKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG9uIGJ1dHRvbnMgdGhhdCBhcmUgbm90IHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubm90KCcuJyArIHRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubm90KCcuJyArIHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVEb3duJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubW91c2V1cChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kbyB0aGUgKmRvd24qIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ob3ZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlICpob3ZlciogZWZmZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgb24gYnV0dG9ucyB0aGF0IGFyZSBub3QgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZUhvdmVyJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZG8gdGhlICpob3ZlciogZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZUhvdmVyJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVEb3duJykpOyAvLyBpZiBtb3VzZWxlYXZlIGhhcHBlbnMgYmVmb3JlIG1vdXNldXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBDaGlsZHJlbiA9IGdyb3VwQ2hpbGRyZW4uYWRkKGJ1dHRvbkVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT25seUJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maXJzdCgpLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdjb3JuZXJMZWZ0JykpLmVuZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5sYXN0KCkuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ2Nvcm5lclJpZ2h0JykpLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwQ2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRWwgPSAkKCc8ZGl2Lz4nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbmx5QnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cEVsLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbC5hcHBlbmQoZ3JvdXBDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbkVsLmFwcGVuZChncm91cEVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25FbC5hcHBlbmQoZ3JvdXBDaGlsZHJlbik7IC8vIDEgb3IgMCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlY3Rpb25FbDtcclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS51cGRhdGVUaXRsZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCdoMicpLnRleHQodGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmFjdGl2YXRlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdzdGF0ZUFjdGl2ZScpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZGVhY3RpdmF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmRpc2FibGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5lbmFibGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZ2V0Vmlld3NXaXRoQnV0dG9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3c1dpdGhCdXR0b25zO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUb29sYmFyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUb29sYmFyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIE1vZGVsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxudmFyIE9wdGlvbnNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3B0aW9uc01hbmFnZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBPcHRpb25zTWFuYWdlcihfY2FsZW5kYXIsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLm92ZXJyaWRlcyA9ICQuZXh0ZW5kKHt9LCBvdmVycmlkZXMpOyAvLyBtYWtlIGEgY29weVxyXG4gICAgICAgIF90aGlzLmR5bmFtaWNPdmVycmlkZXMgPSB7fTtcclxuICAgICAgICBfdGhpcy5jb21wdXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbkNudCA9IDA7XHJcbiAgICAgICAgdmFyIG9wdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRPdmVycmlkZXMobmV3T3B0aW9uSGFzaCk7IC8vIHdpbGwgdHJpZ2dlciB0aGlzIG1vZGVsJ3Mgd2F0Y2hlcnNcclxuICAgICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgICAgICBvcHRpb25DbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3BlY2lhbC1jYXNlIGhhbmRsaW5nIG9mIHNpbmdsZSBvcHRpb24gY2hhbmdlLlxyXG4gICAgICAgIC8vIGlmIG9ubHkgb25lIG9wdGlvbiBjaGFuZ2UsIGBvcHRpb25OYW1lYCB3aWxsIGJlIGl0cyBuYW1lLlxyXG4gICAgICAgIGlmIChvcHRpb25DbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbk5hbWUgPT09ICdoZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdjb250ZW50SGVpZ2h0JyB8fCBvcHRpb25OYW1lID09PSAnYXNwZWN0UmF0aW8nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxlbmRhci51cGRhdGVWaWV3U2l6ZSh0cnVlKTsgLy8gaXNSZXNpemU9dHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICdkZWZhdWx0RGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY2FuJ3QgY2hhbmdlIGRhdGUgdGhpcyB3YXkuIHVzZSBnb3RvRGF0ZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRoaXMgbW9kZWwgYWxyZWFkeSByZWFjdHMgdG8gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICd0aW1lem9uZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLnZpZXcuZmxhc2goJ2luaXRpYWxFdmVudHMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYXRjaC1hbGwuIHJlcmVuZGVyIHRoZSBoZWFkZXIgYW5kIGZvb3RlciBhbmQgcmVidWlsZC9yZXJlbmRlciB0aGUgY3VycmVudCB2aWV3XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVuZGVySGVhZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVuZGVyRm9vdGVyKCk7XHJcbiAgICAgICAgLy8gZXZlbiBub24tY3VycmVudCB2aWV3cyB3aWxsIGJlIGFmZmVjdGVkIGJ5IHRoaXMgb3B0aW9uIGNoYW5nZS4gZG8gYmVmb3JlIHJlcmVuZGVyXHJcbiAgICAgICAgLy8gVE9ETzogZGV0YW5nbGVcclxuICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3c0J5VHlwZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlaW5pdFZpZXcoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIG9wdGlvbnMgaGFzaCBmb3IgdGhlIGNhbGVuZGFyIGFuZCBhc3NpZ25zIHRvIGB0aGlzLm9wdGlvbnNgLlxyXG4gICAgLy8gQXNzdW1lcyB0aGlzLm92ZXJyaWRlcyBhbmQgdGhpcy5keW5hbWljT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsZSwgbG9jYWxlRGVmYXVsdHM7XHJcbiAgICAgICAgdmFyIGlzUlRMLCBkaXJEZWZhdWx0cztcclxuICAgICAgICB2YXIgcmF3T3B0aW9ucztcclxuICAgICAgICBsb2NhbGUgPSB1dGlsXzEuZmlyc3REZWZpbmVkKC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gZ2l2ZW4/XHJcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmxvY2FsZSwgdGhpcy5vdmVycmlkZXMubG9jYWxlKTtcclxuICAgICAgICBsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZV8xLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXTtcclxuICAgICAgICBpZiAoIWxvY2FsZURlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgIGxvY2FsZSA9IG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGU7XHJcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzID0gbG9jYWxlXzEubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVdIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1JUTCA9IHV0aWxfMS5maXJzdERlZmluZWQoLy8gYmFzZWQgb24gb3B0aW9ucyBjb21wdXRlZCBzbyBmYXIsIGlzIGRpcmVjdGlvbiBSVEw/XHJcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmlzUlRMLCB0aGlzLm92ZXJyaWRlcy5pc1JUTCwgbG9jYWxlRGVmYXVsdHMuaXNSVEwsIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5pc1JUTCk7XHJcbiAgICAgICAgZGlyRGVmYXVsdHMgPSBpc1JUTCA/IG9wdGlvbnNfMS5ydGxEZWZhdWx0cyA6IHt9O1xyXG4gICAgICAgIHRoaXMuZGlyRGVmYXVsdHMgPSBkaXJEZWZhdWx0cztcclxuICAgICAgICB0aGlzLmxvY2FsZURlZmF1bHRzID0gbG9jYWxlRGVmYXVsdHM7XHJcbiAgICAgICAgcmF3T3B0aW9ucyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW1xyXG4gICAgICAgICAgICBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIGRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgdGhpcy5vdmVycmlkZXMsXHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlc1xyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxvY2FsZV8xLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhyYXdPcHRpb25zKTsgLy8gZmlsbCBpbiBnYXBzIHdpdGggY29tcHV0ZWQgb3B0aW9uc1xyXG4gICAgICAgIHRoaXMucmVzZXQocmF3T3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLy8gc3RvcmVzIHRoZSBuZXcgb3B0aW9ucyBpbnRlcm5hbGx5LCBidXQgZG9lcyBub3QgcmVyZW5kZXIgYW55dGhpbmcuXHJcbiAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUucmVjb3JkT3ZlcnJpZGVzID0gZnVuY3Rpb24gKG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICB2YXIgb3B0aW9uTmFtZTtcclxuICAgICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXNbb3B0aW9uTmFtZV0gPSBuZXdPcHRpb25IYXNoW29wdGlvbk5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3U3BlY01hbmFnZXIuY2xlYXJDYWNoZSgpOyAvLyB0aGUgZHluYW1pYyBvdmVycmlkZSBpbnZhbGlkYXRlcyB0aGUgb3B0aW9ucyBpbiB0aGlzIGNhY2hlLCBzbyBqdXN0IGNsZWFyIGl0XHJcbiAgICAgICAgdGhpcy5jb21wdXRlKCk7IC8vIHRoaXMub3B0aW9ucyBuZWVkcyB0byBiZSByZWNvbXB1dGVkIGFmdGVyIHRoZSBkeW5hbWljIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9wdGlvbnNNYW5hZ2VyO1xyXG59KE1vZGVsXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPcHRpb25zTWFuYWdlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNzcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgbmFtZXNwYWNlX2hvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIG9wdGlvbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgbG9jYWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIFZpZXdTcGVjTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZpZXdTcGVjTWFuYWdlcihvcHRpb25zTWFuYWdlciwgX2NhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlciA9IG9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyID0gX2NhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xyXG4gICAgfVxyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmlld1NwZWNDYWNoZSA9IHt9O1xyXG4gICAgfTtcclxuICAgIC8vIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgaG93IHRvIGNyZWF0ZSBhIHZpZXcuIFdpbGwgdXNlIGEgY2FjaGUuXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmdldFZpZXdTcGVjID0gZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy52aWV3U3BlY0NhY2hlO1xyXG4gICAgICAgIHJldHVybiBjYWNoZVt2aWV3VHlwZV0gfHwgKGNhY2hlW3ZpZXdUeXBlXSA9IHRoaXMuYnVpbGRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cclxuICAgIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuZ2V0VW5pdFZpZXdTcGVjID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICB2YXIgdmlld1R5cGVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzcGVjO1xyXG4gICAgICAgIGlmICgkLmluQXJyYXkodW5pdCwgdXRpbF8xLnVuaXRzRGVzYykgIT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gcHV0IHZpZXdzIHRoYXQgaGF2ZSBidXR0b25zIGZpcnN0LiB0aGVyZSB3aWxsIGJlIGR1cGxpY2F0ZXMsIGJ1dCBvaCB3ZWxsXHJcbiAgICAgICAgICAgIHZpZXdUeXBlcyA9IHRoaXMuX2NhbGVuZGFyLmhlYWRlci5nZXRWaWV3c1dpdGhCdXR0b25zKCk7IC8vIFRPRE86IGluY2x1ZGUgZm9vdGVyIGFzIHdlbGw/XHJcbiAgICAgICAgICAgICQuZWFjaChuYW1lc3BhY2VfaG9va3NfMS5kZWZhdWx0LnZpZXdzLCBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHNwZWMgPSB0aGlzLmdldFZpZXdTcGVjKHZpZXdUeXBlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpbmdsZVVuaXQgPT0gdW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIG9uIGhvdyB0byBjcmVhdGUgYSBnaXZlbiB2aWV3XHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWMgPSBmdW5jdGlvbiAocmVxdWVzdGVkVmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgdmlld092ZXJyaWRlcyA9IHRoaXMub3B0aW9uc01hbmFnZXIub3ZlcnJpZGVzLnZpZXdzIHx8IHt9O1xyXG4gICAgICAgIHZhciBzcGVjQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciBkZWZhdWx0c0NoYWluID0gW107IC8vIGZvciB0aGUgdmlldy4gbG93ZXN0IHRvIGhpZ2hlc3QgcHJpb3JpdHlcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciB2aWV3VHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIHZhciBzcGVjOyAvLyBmb3IgdGhlIHZpZXdcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzOyAvLyBmb3IgdGhlIHZpZXdcclxuICAgICAgICB2YXIgZHVyYXRpb25JbnB1dDtcclxuICAgICAgICB2YXIgZHVyYXRpb247XHJcbiAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgLy8gaXRlcmF0ZSBmcm9tIHRoZSBzcGVjaWZpYyB2aWV3IGRlZmluaXRpb24gdG8gYSBtb3JlIGdlbmVyYWwgb25lIHVudGlsIHdlIGhpdCBhbiBhY3R1YWwgVmlldyBjbGFzc1xyXG4gICAgICAgIHdoaWxlICh2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICBzcGVjID0gbmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC52aWV3c1t2aWV3VHlwZV07XHJcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHZpZXdPdmVycmlkZXNbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICB2aWV3VHlwZSA9IG51bGw7IC8vIGNsZWFyLiBtaWdodCByZXBvcHVsYXRlIGZvciBhbm90aGVyIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNwZWMgPSB7ICdjbGFzcyc6IHNwZWMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgICAgICAgICAgc3BlY0NoYWluLnVuc2hpZnQoc3BlYyk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0c0NoYWluLnVuc2hpZnQoc3BlYy5kZWZhdWx0cyB8fCB7fSk7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fCBzcGVjLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCBzcGVjLnR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVzQ2hhaW4udW5zaGlmdChvdmVycmlkZXMpOyAvLyB2aWV3LXNwZWNpZmljIG9wdGlvbiBoYXNoZXMgaGF2ZSBvcHRpb25zIGF0IHplcm8tbGV2ZWxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8IG92ZXJyaWRlcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgb3ZlcnJpZGVzLnR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3BlYyA9IHV0aWxfMS5tZXJnZVByb3BzKHNwZWNDaGFpbik7XHJcbiAgICAgICAgc3BlYy50eXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XHJcbiAgICAgICAgaWYgKCFzcGVjWydjbGFzcyddKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRvcC1sZXZlbCBgZHVyYXRpb25gIG9wdGlvblxyXG4gICAgICAgIGR1cmF0aW9uSW5wdXQgPSBkdXJhdGlvbklucHV0IHx8XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcy5kdXJhdGlvbiB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5kdXJhdGlvbjtcclxuICAgICAgICBpZiAoZHVyYXRpb25JbnB1dCkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbklucHV0KTtcclxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9IHV0aWxfMS5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQoZHVyYXRpb24sIGR1cmF0aW9uSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgc3BlYy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgc3BlYy5kdXJhdGlvblVuaXQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgLy8gdmlldyBpcyBhIHNpbmdsZS11bml0IGR1cmF0aW9uLCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCJcclxuICAgICAgICAgICAgICAgIC8vIGluY29ycG9yYXRlIG9wdGlvbnMgZm9yIHRoaXMuIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uLmFzKHVuaXQpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlYy5zaW5nbGVVbml0ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXNDaGFpbi51bnNoaWZ0KHZpZXdPdmVycmlkZXNbdW5pdF0gfHwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNwZWMuZGVmYXVsdHMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKGRlZmF1bHRzQ2hhaW4pO1xyXG4gICAgICAgIHNwZWMub3ZlcnJpZGVzID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhvdmVycmlkZXNDaGFpbik7XHJcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjT3B0aW9ucyhzcGVjKTtcclxuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNCdXR0b25UZXh0KHNwZWMsIHJlcXVlc3RlZFZpZXdUeXBlKTtcclxuICAgICAgICByZXR1cm4gc3BlYztcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW5kIGFzc2lnbnMgYSB2aWV3IHNwZWMncyBvcHRpb25zIG9iamVjdCBmcm9tIGl0cyBhbHJlYWR5LWFzc2lnbmVkIGRlZmF1bHRzIGFuZCBvdmVycmlkZXNcclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuYnVpbGRWaWV3U3BlY09wdGlvbnMgPSBmdW5jdGlvbiAoc3BlYykge1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IHRoaXMub3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgc3BlYy5vcHRpb25zID0gb3B0aW9uc18xLm1lcmdlT3B0aW9ucyhbXHJcbiAgICAgICAgICAgIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cyxcclxuICAgICAgICAgICAgc3BlYy5kZWZhdWx0cyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIuZGlyRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLmxvY2FsZURlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5vdmVycmlkZXMsXHJcbiAgICAgICAgICAgIHNwZWMub3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5keW5hbWljT3ZlcnJpZGVzIC8vIGR5bmFtaWNhbGx5IHNldCB2aWEgc2V0dGVyLiBoaWdoZXN0IHByZWNlZGVuY2VcclxuICAgICAgICBdKTtcclxuICAgICAgICBsb2NhbGVfMS5wb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMoc3BlYy5vcHRpb25zKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbmQgYXNzaWducyBhIHZpZXcgc3BlYydzIGJ1dHRvblRleHQtcmVsYXRlZCBvcHRpb25zXHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmJ1aWxkVmlld1NwZWNCdXR0b25UZXh0ID0gZnVuY3Rpb24gKHNwZWMsIHJlcXVlc3RlZFZpZXdUeXBlKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnNNYW5hZ2VyID0gdGhpcy5vcHRpb25zTWFuYWdlcjtcclxuICAgICAgICAvLyBnaXZlbiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgcG9zc2libGUgYGJ1dHRvblRleHRgIGhhc2gsIGxvb2t1cCB0aGUgYnV0dG9uVGV4dCBmb3IgdGhlXHJcbiAgICAgICAgLy8gcmVxdWVzdGVkIHZpZXcsIGZhbGxpbmcgYmFjayB0byBhIGdlbmVyaWMgdW5pdCBlbnRyeSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCJcclxuICAgICAgICBmdW5jdGlvbiBxdWVyeUJ1dHRvblRleHQob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgYnV0dG9uVGV4dCA9IG9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRbcmVxdWVzdGVkVmlld1R5cGVdIHx8XHJcbiAgICAgICAgICAgICAgICAvLyB2aWV3IGNhbiBkZWNpZGUgdG8gbG9vayB1cCBhIGNlcnRhaW4ga2V5XHJcbiAgICAgICAgICAgICAgICAoc3BlYy5idXR0b25UZXh0S2V5ID8gYnV0dG9uVGV4dFtzcGVjLmJ1dHRvblRleHRLZXldIDogbnVsbCkgfHxcclxuICAgICAgICAgICAgICAgIC8vIGEga2V5IGxpa2UgXCJtb250aFwiXHJcbiAgICAgICAgICAgICAgICAoc3BlYy5zaW5nbGVVbml0ID8gYnV0dG9uVGV4dFtzcGVjLnNpbmdsZVVuaXRdIDogbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5XHJcbiAgICAgICAgc3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgPVxyXG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIuZHluYW1pY092ZXJyaWRlcykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5vdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgICAgIHNwZWMub3ZlcnJpZGVzLmJ1dHRvblRleHQ7IC8vIGBidXR0b25UZXh0YCBmb3Igdmlldy1zcGVjaWZpYyBvcHRpb25zIGlzIGEgc3RyaW5nXHJcbiAgICAgICAgLy8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHkuIG1pcnJvcnMgYnVpbGRWaWV3U3BlY09wdGlvbnNcclxuICAgICAgICBzcGVjLmJ1dHRvblRleHREZWZhdWx0ID1cclxuICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmxvY2FsZURlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLmRpckRlZmF1bHRzKSB8fFxyXG4gICAgICAgICAgICAgICAgc3BlYy5kZWZhdWx0cy5idXR0b25UZXh0IHx8IC8vIGEgc2luZ2xlIHN0cmluZy4gZnJvbSBWaWV3U3ViY2xhc3MuZGVmYXVsdHNcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICAoc3BlYy5kdXJhdGlvbiA/IHRoaXMuX2NhbGVuZGFyLmh1bWFuaXplRHVyYXRpb24oc3BlYy5kdXJhdGlvbikgOiBudWxsKSB8fCAvLyBsaWtlIFwiMyBkYXlzXCJcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZpZXdUeXBlOyAvLyBmYWxsIGJhY2sgdG8gZ2l2ZW4gdmlldyBuYW1lXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFZpZXdTcGVjTWFuYWdlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVmlld1NwZWNNYW5hZ2VyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3OCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBFdmVudFBlcmlvZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRXZlbnRTb3VyY2VQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBFdmVudE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIoY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy5zdGlja3lTb3VyY2UgPSBuZXcgQXJyYXlFdmVudFNvdXJjZV8xLmRlZmF1bHQoY2FsZW5kYXIpO1xyXG4gICAgICAgIHRoaXMub3RoZXJTb3VyY2VzID0gW107XHJcbiAgICB9XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlcXVlc3RFdmVudHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUsIGZvcmNlKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRQZXJpb2QgfHxcclxuICAgICAgICAgICAgIXRoaXMuY3VycmVudFBlcmlvZC5pc1dpdGhpblJhbmdlKHN0YXJ0LCBlbmQpIHx8XHJcbiAgICAgICAgICAgIHRpbWV6b25lICE9PSB0aGlzLmN1cnJlbnRQZXJpb2QudGltZXpvbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQZXJpb2QoLy8gd2lsbCBjaGFuZ2UgdGhpcy5jdXJyZW50UGVyaW9kXHJcbiAgICAgICAgICAgIG5ldyBFdmVudFBlcmlvZF8xLmRlZmF1bHQoc3RhcnQsIGVuZCwgdGltZXpvbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC53aGVuUmVsZWFzZWQoKTtcclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgQWRkaW5nL1JlbW92aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLm90aGVyU291cmNlcy5wdXNoKGV2ZW50U291cmNlKTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlKGV2ZW50U291cmNlKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChkb29tZWRTb3VyY2UpIHtcclxuICAgICAgICB1dGlsXzEucmVtb3ZlRXhhY3QodGhpcy5vdGhlclNvdXJjZXMsIGRvb21lZFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucHVyZ2VTb3VyY2UoZG9vbWVkU291cmNlKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclNvdXJjZXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5wdXJnZUFsbFNvdXJjZXMoKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgUmVmZXRjaGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVmZXRjaFNvdXJjZSA9IGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gdGhpcy5jdXJyZW50UGVyaW9kO1xyXG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucHVyZ2VTb3VyY2UoZXZlbnRTb3VyY2UpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlcXVlc3RTb3VyY2UoZXZlbnRTb3VyY2UpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnRoYXcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZWZldGNoQWxsU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnB1cmdlQWxsU291cmNlcygpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlcXVlc3RTb3VyY2VzKHRoaXMuZ2V0U291cmNlcygpKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFNvdXJjZSBRdWVyeWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuc3RpY2t5U291cmNlXS5jb25jYXQodGhpcy5vdGhlclNvdXJjZXMpO1xyXG4gICAgfTtcclxuICAgIC8vIGxpa2UgcXVlcnlTb3VyY2VzLCBidXQgYWNjZXB0cyBtdWx0cGxlIG1hdGNoIGNyaXRlcmlhIChsaWtlIG11bHRpcGxlIElEcylcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUubXVsdGlRdWVyeVNvdXJjZXMgPSBmdW5jdGlvbiAobWF0Y2hJbnB1dHMpIHtcclxuICAgICAgICAvLyBjb2VyY2UgaW50byBhbiBhcnJheVxyXG4gICAgICAgIGlmICghbWF0Y2hJbnB1dHMpIHtcclxuICAgICAgICAgICAgbWF0Y2hJbnB1dHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoISQuaXNBcnJheShtYXRjaElucHV0cykpIHtcclxuICAgICAgICAgICAgbWF0Y2hJbnB1dHMgPSBbbWF0Y2hJbnB1dHNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0Y2hpbmdTb3VyY2VzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gcmVzb2x2ZSByYXcgaW5wdXRzIHRvIHJlYWwgZXZlbnQgc291cmNlIG9iamVjdHNcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWF0Y2hJbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbWF0Y2hpbmdTb3VyY2VzLnB1c2guYXBwbHkoLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIG1hdGNoaW5nU291cmNlcywgdGhpcy5xdWVyeVNvdXJjZXMobWF0Y2hJbnB1dHNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nU291cmNlcztcclxuICAgIH07XHJcbiAgICAvLyBtYXRjaElucHV0IGNhbiBlaXRoZXIgYnkgYSByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3QsIGFuIElELCBvciB0aGUgZnVuY3Rpb24vVVJMIGZvciB0aGUgc291cmNlLlxyXG4gICAgLy8gcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBzb3VyY2Ugb2JqZWN0cy5cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucXVlcnlTb3VyY2VzID0gZnVuY3Rpb24gKG1hdGNoSW5wdXQpIHtcclxuICAgICAgICB2YXIgc291cmNlcyA9IHRoaXMub3RoZXJTb3VyY2VzO1xyXG4gICAgICAgIHZhciBpLCBzb3VyY2U7XHJcbiAgICAgICAgLy8gZ2l2ZW4gYSBwcm9wZXIgZXZlbnQgc291cmNlIG9iamVjdFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09IG1hdGNoSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc291cmNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiBJRCBtYXRjaFxyXG4gICAgICAgIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlQnlJZChFdmVudFNvdXJjZV8xLmRlZmF1bHQubm9ybWFsaXplSWQobWF0Y2hJbnB1dCkpO1xyXG4gICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtzb3VyY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXJzZSBhcyBhbiBldmVudCBzb3VyY2VcclxuICAgICAgICBtYXRjaElucHV0ID0gRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKG1hdGNoSW5wdXQsIHRoaXMuY2FsZW5kYXIpO1xyXG4gICAgICAgIGlmIChtYXRjaElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkLmdyZXAoc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU291cmNlc0VxdWl2YWxlbnQobWF0Y2hJbnB1dCwgc291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBJRCBhc3N1bWVkIHRvIGFscmVhZHkgYmUgbm9ybWFsaXplZFxyXG4gICAgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHJldHVybiAkLmdyZXAodGhpcy5vdGhlclNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5pZCAmJiBzb3VyY2UuaWQgPT09IGlkO1xyXG4gICAgICAgIH0pWzBdO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50LVBlcmlvZFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuc2V0UGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLnVuYmluZFBlcmlvZCh0aGlzLmN1cnJlbnRQZXJpb2QpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QgPSBldmVudFBlcmlvZDtcclxuICAgICAgICB0aGlzLmJpbmRQZXJpb2QoZXZlbnRQZXJpb2QpO1xyXG4gICAgICAgIGV2ZW50UGVyaW9kLnJlcXVlc3RTb3VyY2VzKHRoaXMuZ2V0U291cmNlcygpKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmJpbmRQZXJpb2QgPSBmdW5jdGlvbiAoZXZlbnRQZXJpb2QpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKGV2ZW50UGVyaW9kLCAncmVsZWFzZScsIGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVsZWFzZScsIGV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUudW5iaW5kUGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oZXZlbnRQZXJpb2QpO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEdldHRpbmcvQWRkaW5nL1JlbW92aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudERlZkJ5VWlkID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudERlZkJ5VWlkKHVpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYsIGlzU3RpY2t5KSB7XHJcbiAgICAgICAgaWYgKGlzU3RpY2t5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RpY2t5U291cmNlLmFkZEV2ZW50RGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QuYWRkRXZlbnREZWYoZXZlbnREZWYpOyAvLyBtaWdodCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudElkKSB7XHJcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UucmVtb3ZlRXZlbnREZWZzQnlJZChldmVudElkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZW1vdmVFdmVudERlZnNCeUlkKGV2ZW50SWQpOyAvLyBtaWdodCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlLnJlbW92ZUFsbEV2ZW50RGVmcygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLnJlbW92ZUFsbEV2ZW50RGVmcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBNdXRhdGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIGFuIHVuZG8gZnVuY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5tdXRhdGVFdmVudHNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCwgZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gdGhpcy5jdXJyZW50UGVyaW9kO1xyXG4gICAgICAgIHZhciBldmVudERlZnM7XHJcbiAgICAgICAgdmFyIHVuZG9GdW5jcyA9IFtdO1xyXG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmcyA9IGN1cnJlbnRQZXJpb2QuZ2V0RXZlbnREZWZzQnlJZChldmVudERlZklkKTtcclxuICAgICAgICAgICAgZXZlbnREZWZzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQvcmVtb3ZlIGVzcCBiZWNhdXNlIGlkIG1pZ2h0IGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZW1vdmVFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgICAgICAgICB1bmRvRnVuY3MucHVzaChldmVudERlZk11dGF0aW9uLm11dGF0ZVNpbmdsZShldmVudERlZikpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5hZGRFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnRoYXcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWYoZXZlbnREZWZzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB1bmRvRnVuY3NbaV0oKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLmFkZEV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLnRoYXcoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgY29waWVzIGFuZCB0aGVuIG11dGF0ZXNcclxuICAgICovXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCA9IGZ1bmN0aW9uIChldmVudERlZklkLCBldmVudERlZk11dGF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuZ2V0RXZlbnREZWZzQnlJZChldmVudERlZklkKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZGVmQ29weTtcclxuICAgICAgICB2YXIgYWxsSW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZWZDb3B5ID0gZXZlbnREZWZzW2ldLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGlmIChkZWZDb3B5IGluc3RhbmNlb2YgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZk11dGF0aW9uLm11dGF0ZVNpbmdsZShkZWZDb3B5KTtcclxuICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlcy5wdXNoLmFwcGx5KGFsbEluc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgICAgICBkZWZDb3B5LmJ1aWxkSW5zdGFuY2VzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdChhbGxJbnN0YW5jZXMpO1xyXG4gICAgfTtcclxuICAgIC8vIEZyZWV6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QuZnJlZXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUudGhhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIG1ldGhvZHMgdGhhdCBzaW1wbHkgZm9yd2FyZCB0byBFdmVudFBlcmlvZFxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGVyaW9kLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGVyaW9kLmdldEV2ZW50SW5zdGFuY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlc1dpdGhJZChldmVudERlZklkKTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGVyaW9kLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkKGV2ZW50RGVmSWQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudE1hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50TWFuYWdlcjtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50TWFuYWdlcik7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnRNYW5hZ2VyKTtcclxuZnVuY3Rpb24gaXNTb3VyY2VzRXF1aXZhbGVudChzb3VyY2UwLCBzb3VyY2UxKSB7XHJcbiAgICByZXR1cm4gc291cmNlMC5nZXRQcmltaXRpdmUoKSA9PSBzb3VyY2UxLmdldFByaW1pdGl2ZSgpO1xyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDc5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEV2ZW50UGVyaW9kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRQZXJpb2Qoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuZnJlZXplRGVwdGggPSAwO1xyXG4gICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMucmVsZWFzZUNudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMudGltZXpvbmUgPSB0aW1lem9uZTtcclxuICAgICAgICB0aGlzLnVuem9uZWRSYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LmNsb25lKCkuc3RyaXBab25lKCksIGVuZC5jbG9uZSgpLnN0cmlwWm9uZSgpKTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5VWlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeUlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHt9O1xyXG4gICAgfVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmlzV2l0aGluUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIC8vIFRPRE86IHVzZSBhIHJhbmdlIHV0aWwgZnVuY3Rpb24/XHJcbiAgICAgICAgcmV0dXJuICFzdGFydC5pc0JlZm9yZSh0aGlzLnN0YXJ0KSAmJiAhZW5kLmlzQWZ0ZXIodGhpcy5lbmQpO1xyXG4gICAgfTtcclxuICAgIC8vIFJlcXVlc3RpbmcgYW5kIFB1cmdpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVxdWVzdFNvdXJjZXMgPSBmdW5jdGlvbiAoc291cmNlcykge1xyXG4gICAgICAgIHRoaXMuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlcXVlc3RTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHsgc291cmNlOiBzb3VyY2UsIHN0YXR1czogJ3BlbmRpbmcnLCBldmVudERlZnM6IG51bGwgfTtcclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWRbc291cmNlLnVpZF0gPSByZXF1ZXN0O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NudCArPSAxO1xyXG4gICAgICAgIHNvdXJjZS5mZXRjaCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdGhpcy50aW1lem9uZSkudGhlbihmdW5jdGlvbiAoZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gJ2NhbmNlbGxlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2NvbXBsZXRlZCc7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmV2ZW50RGVmcyA9IGV2ZW50RGVmcztcclxuICAgICAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50RGVmcyhldmVudERlZnMpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdmYWlsZWQnO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnB1cmdlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RzQnlVaWRbc291cmNlLnVpZF07XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdjYW5jZWxsZWQnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ250LS07XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZXZlbnREZWZzLmZvckVhY2godGhpcy5yZW1vdmVFdmVudERlZi5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucHVyZ2VBbGxTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXF1ZXN0c0J5VWlkID0gdGhpcy5yZXF1ZXN0c0J5VWlkO1xyXG4gICAgICAgIHZhciB1aWQsIHJlcXVlc3Q7XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlZENudCA9IDA7XHJcbiAgICAgICAgZm9yICh1aWQgaW4gcmVxdWVzdHNCeVVpZCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdHNCeVVpZFt1aWRdO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZENudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVxdWVzdHNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NudCA9IDA7XHJcbiAgICAgICAgaWYgKGNvbXBsZXRlZENudCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50RGVmcygpOyAvLyBtaWdodCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERlZmluaXRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50RGVmQnlVaWQgPSBmdW5jdGlvbiAoZXZlbnREZWZVaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudERlZnNCeVVpZFtldmVudERlZlVpZF07XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBhID0gdGhpcy5ldmVudERlZnNCeUlkW2V2ZW50RGVmSWRdO1xyXG4gICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWNlKCk7IC8vIGNsb25lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUuYWRkRXZlbnREZWZzID0gZnVuY3Rpb24gKGV2ZW50RGVmcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnREZWYoZXZlbnREZWZzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmc0J5SWQgPSB0aGlzLmV2ZW50RGVmc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQgPSBldmVudERlZi5pZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gZXZlbnREZWZzQnlJZFtldmVudERlZklkXSB8fCAoZXZlbnREZWZzQnlJZFtldmVudERlZklkXSA9IFtdKTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSBldmVudERlZi5idWlsZEluc3RhbmNlcyh0aGlzLnVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWYudWlkXSA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50SW5zdGFuY2UoZXZlbnRJbnN0YW5jZXNbaV0sIGV2ZW50RGVmSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAgICAgX3RoaXMucmVtb3ZlRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlzRW1wdHkgPSAkLmlzRW1wdHlPYmplY3QodGhpcy5ldmVudERlZnNCeVVpZCk7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlJZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB7fTtcclxuICAgICAgICBpZiAoIWlzRW1wdHkpIHtcclxuICAgICAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZnNCeUlkID0gdGhpcy5ldmVudERlZnNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSBldmVudERlZnNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICBkZWxldGUgdGhpcy5ldmVudERlZnNCeVVpZFtldmVudERlZi51aWRdO1xyXG4gICAgICAgIGlmIChldmVudERlZnMpIHtcclxuICAgICAgICAgICAgdXRpbF8xLnJlbW92ZUV4YWN0KGV2ZW50RGVmcywgZXZlbnREZWYpO1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50RGVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudERlZnNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SW5zdGFuY2VzRm9yRGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgSW5zdGFuY2VzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gW107XHJcbiAgICAgICAgdmFyIGlkO1xyXG4gICAgICAgIGZvciAoaWQgaW4gZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZXMucHVzaC5hcHBseShldmVudEluc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2lkXS5ldmVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEluc3RhbmNlcztcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcy5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkO1xyXG4gICAgICAgIHZhciBtYXRjaGluZ0luc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCAhPT0gZXZlbnREZWZJZCkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdJbnN0YW5jZXMucHVzaC5hcHBseShtYXRjaGluZ0luc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXBzQnlJZFtpZF0uZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGluZ0luc3RhbmNlcztcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUuYWRkRXZlbnRJbnN0YW5jZSA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlLCBldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbZXZlbnREZWZJZF0gfHxcclxuICAgICAgICAgICAgKGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLnB1c2goZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlbW92ZUV2ZW50SW5zdGFuY2VzRm9yRGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbZXZlbnREZWYuaWRdO1xyXG4gICAgICAgIHZhciByZW1vdmVDbnQ7XHJcbiAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgICAgICByZW1vdmVDbnQgPSB1dGlsXzEucmVtb3ZlTWF0Y2hpbmcoZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLCBmdW5jdGlvbiAoY3VycmVudEV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RXZlbnRJbnN0YW5jZS5kZWYgPT09IGV2ZW50RGVmO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbZXZlbnREZWYuaWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZW1vdmVDbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbGVhc2luZyBhbmQgRnJlZXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUudHJ5UmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0NudCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZnJlZXplRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHVudGVkUmVsZWFzZUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucmVsZWFzZUNudCsrO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVsZWFzZScsIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS53aGVuUmVsZWFzZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5yZWxlYXNlQ250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5yZXNvbHZlKHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LmNvbnN0cnVjdChmdW5jdGlvbiAob25SZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmUoJ3JlbGVhc2UnLCBvblJlc29sdmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmZyZWV6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmZyZWV6ZURlcHRoKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUudGhhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISgtLXRoaXMuZnJlZXplRGVwdGgpICYmIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQgJiYgIXRoaXMucGVuZGluZ0NudCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UGVyaW9kO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFBlcmlvZDtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50UGVyaW9kKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogODAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBNb2RlbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMuYmluZEdsb2JhbEhhbmRsZXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJTa2VsZXRvbigpO1xyXG4gICAgICAgIHRoaXMuc2V0KCdpc0luRG9tJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2lzSW5Eb20nKTtcclxuICAgICAgICB0aGlzLnVucmVuZGVyU2tlbGV0b24oKTtcclxuICAgICAgICB0aGlzLnVuYmluZEdsb2JhbEhhbmRsZXJzKCk7XHJcbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAvLyBOT1RFOiBkb24ndCBudWxsLW91dCB0aGlzLmVsIGluIGNhc2UgdGhlIFZpZXcgd2FzIGRlc3Ryb3llZCB3aXRoaW4gYW4gQVBJIGNhbGxiYWNrLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IG51bGwtb3V0IHRoZSBWaWV3J3Mgb3RoZXIgalF1ZXJ5IGVsZW1lbnQgcmVmZXJlbmNlcyB1cG9uIGRlc3Ryb3ksXHJcbiAgICAgICAgLy8gIHNvIHdlIHNob3VsZG4ndCBraWxsIHRoaXMuZWwgZWl0aGVyLlxyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5PVEU6IENhbid0IGhhdmUgYSBgcmVuZGVyYCBtZXRob2QuIFJlYWQgdGhlIGRlcHJlY2F0aW9uIG5vdGljZSBpbiBWaWV3OjpleGVjdXRlRGF0ZVJlbmRlclxyXG4gICAgKi9cclxuICAgIC8vIFJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgdmlldyBiZWZvcmUgYW55IGNvbnRlbnQgaXMgcmVuZGVyZWRcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXdcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50O1xyXG59KE1vZGVsXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb25lbnQ7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDgxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbi8qIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBlbGVtZW50IGFuZCBsZXRzIGl0IHRyYWNrIHRoZSBtb3VzZSBhcyBpdCBtb3Zlc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIE1vdXNlRm9sbG93ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb3VzZUZvbGxvd2VyKHNvdXJjZUVsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0ZvbGxvd2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7IC8vIGRvaW5nIHRoZSByZXZlcnQgYW5pbWF0aW9uP1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbDtcclxuICAgICAgICB0aGlzLnBhcmVudEVsID0gb3B0aW9ucy5wYXJlbnRFbCA/ICQob3B0aW9ucy5wYXJlbnRFbCkgOiBzb3VyY2VFbC5wYXJlbnQoKTsgLy8gZGVmYXVsdCB0byBzb3VyY2VFbCdzIHBhcmVudFxyXG4gICAgfVxyXG4gICAgLy8gQ2F1c2VzIHRoZSBlbGVtZW50IHRvIHN0YXJ0IGZvbGxvd2luZyB0aGUgbW91c2VcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzRm9sbG93aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNGb2xsb3dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnkwID0gdXRpbF8xLmdldEV2WShldik7XHJcbiAgICAgICAgICAgIHRoaXMueDAgPSB1dGlsXzEuZ2V0RXZYKGV2KTtcclxuICAgICAgICAgICAgdGhpcy50b3BEZWx0YSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdERlbHRhID0gMDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxfMS5nZXRFdklzVG91Y2goZXYpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhdXNlcyB0aGUgZWxlbWVudCB0byBzdG9wIGZvbGxvd2luZyB0aGUgbW91c2UuIElmIHNob3VsZFJldmVydCBpcyB0cnVlLCB3aWxsIGFuaW1hdGUgYmFjayB0byBvcmlnaW5hbCBwb3NpdGlvbi5cclxuICAgIC8vIGBjYWxsYmFja2AgZ2V0cyBpbnZva2VkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS4gSWYgbm8gYW5pbWF0aW9uLCBpdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5LlxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChzaG91bGRSZXZlcnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmV2ZXJ0RHVyYXRpb24gPSB0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb247XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIF90aGlzLnRvcDAgPSBfdGhpcy5sZWZ0MCA9IG51bGw7IC8vIHJlc2V0IHN0YXRlIGZvciBmdXR1cmUgdXBkYXRlUG9zaXRpb24gY2FsbHNcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5pc0ZvbGxvd2luZyAmJiAhdGhpcy5pc0FuaW1hdGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRm9sbG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZFJldmVydCAmJiByZXZlcnREdXJhdGlvbiAmJiAhdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmFuaW1hdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy50b3AwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMubGVmdDBcclxuICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogcmV2ZXJ0RHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdHJhY2tpbmcgZWxlbWVudC4gQ3JlYXRlIGl0IGlmIG5lY2Vzc2FyeVxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuZ2V0RWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcclxuICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgIGVsID0gdGhpcy5lbCA9IHRoaXMuc291cmNlRWwuY2xvbmUoKVxyXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hZGRpdGlvbmFsQ2xhc3MgfHwgJycpXHJcbiAgICAgICAgICAgICAgICAuY3NzKHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiB0aGlzLmlzSGlkZGVuID8gJ25vbmUnIDogJycsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnYXV0bycsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5zb3VyY2VFbC53aWR0aCgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnNvdXJjZUVsLmhlaWdodCgpLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLm9wYWNpdHkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMub3B0aW9ucy56SW5kZXhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cclxuICAgICAgICAgICAgLy8gd291bGQgdXNlIHByZXZlbnRTZWxlY3Rpb24oKSwgYnV0IHRoYXQgcHJldmVudHMgc2VsZWN0c3RhcnQsIGNhdXNpbmcgcHJvYmxlbXMuXHJcbiAgICAgICAgICAgIGVsLmFkZENsYXNzKCdmYy11bnNlbGVjdGFibGUnKTtcclxuICAgICAgICAgICAgZWwuYXBwZW5kVG8odGhpcy5wYXJlbnRFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH07XHJcbiAgICAvLyBSZW1vdmVzIHRoZSB0cmFja2luZyBlbGVtZW50IGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZFxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlIHRoZSBDU1MgcG9zaXRpb24gb2YgdGhlIHRyYWNraW5nIGVsZW1lbnRcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzb3VyY2VPZmZzZXQ7XHJcbiAgICAgICAgdmFyIG9yaWdpbjtcclxuICAgICAgICB0aGlzLmdldEVsKCk7IC8vIGVuc3VyZSB0aGlzLmVsXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIG9yaWdpbiBpbmZvIHdhcyBjb21wdXRlZFxyXG4gICAgICAgIGlmICh0aGlzLnRvcDAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzb3VyY2VPZmZzZXQgPSB0aGlzLnNvdXJjZUVsLm9mZnNldCgpO1xyXG4gICAgICAgICAgICBvcmlnaW4gPSB0aGlzLmVsLm9mZnNldFBhcmVudCgpLm9mZnNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRvcDAgPSBzb3VyY2VPZmZzZXQudG9wIC0gb3JpZ2luLnRvcDtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0MCA9IHNvdXJjZU9mZnNldC5sZWZ0IC0gb3JpZ2luLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWwuY3NzKHtcclxuICAgICAgICAgICAgdG9wOiB0aGlzLnRvcDAgKyB0aGlzLnRvcERlbHRhLFxyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQwICsgdGhpcy5sZWZ0RGVsdGFcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBtb3VzZVxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMudG9wRGVsdGEgPSB1dGlsXzEuZ2V0RXZZKGV2KSAtIHRoaXMueTA7XHJcbiAgICAgICAgdGhpcy5sZWZ0RGVsdGEgPSB1dGlsXzEuZ2V0RXZYKGV2KSAtIHRoaXMueDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGVtcG9yYXJpbHkgbWFrZXMgdGhlIHRyYWNraW5nIGVsZW1lbnQgaW52aXNpYmxlLiBDYW4gYmUgY2FsbGVkIGJlZm9yZSBmb2xsb3dpbmcgc3RhcnRzXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFNob3cgdGhlIHRyYWNraW5nIGVsZW1lbnQgYWZ0ZXIgaXQgaGFzIGJlZW4gdGVtcG9yYXJpbHkgaGlkZGVuXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmdldEVsKCkuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTW91c2VGb2xsb3dlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW91c2VGb2xsb3dlcjtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhNb3VzZUZvbGxvd2VyKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogODIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBIaXREcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgRGF0ZUNsaWNraW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF0ZUNsaWNraW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBtdXN0IGltcGxlbWVudDpcclxuICAgICAgICAtIGJpbmREYXRlSGFuZGxlclRvRWxcclxuICAgICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICAgICAtIGdldEhpdEVsXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGF0ZUNsaWNraW5nKGNvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBfdGhpcy5idWlsZERyYWdMaXN0ZW5lcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERhdGVDbGlja2luZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyLmVuZEludGVyYWN0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNsaWNraW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXI7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmREYXRlSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmREYXRlSGFuZGxlclRvRWwoZWwsICd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LnNob3VsZElnbm9yZVRvdWNoKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYSBsaXN0ZW5lciB0aGF0IHRyYWNrcyB0aGUgdXNlcidzIGRyYWcgYWNyb3NzIGRheSBlbGVtZW50cywgZm9yIGRheSBjbGlja2luZy5cclxuICAgIERhdGVDbGlja2luZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGRheUNsaWNrSGl0OyAvLyBudWxsIGlmIGludmFsaWQgZGF5Q2xpY2tcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gbmV3IEhpdERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQoY29tcG9uZW50LCB7XHJcbiAgICAgICAgICAgIHNjcm9sbDogdGhpcy5vcHQoJ2RyYWdTY3JvbGwnKSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGF5Q2xpY2tIaXQgPSBkcmFnTGlzdGVuZXIub3JpZ0hpdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIGRyYWdnZWQgdG8gYW5vdGhlciBjZWxsIGF0IGFueSBwb2ludCwgaXQgY2FuIG5vIGxvbmdlciBiZSBhIGRheUNsaWNrXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT3JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheUNsaWNrSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBkYXlDbGlja0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbGxlZCAmJiBkYXlDbGlja0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZvb3RwcmludCA9IGNvbXBvbmVudC5nZXRTYWZlSGl0Rm9vdHByaW50KGRheUNsaWNrSGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXcudHJpZ2dlckRheUNsaWNrKGNvbXBvbmVudEZvb3RwcmludCwgY29tcG9uZW50LmdldEhpdEVsKGRheUNsaWNrSGl0KSwgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGJlY2F1c2UgZHJhZ0xpc3RlbmVyIHdvbid0IGJlIGNhbGxlZCB3aXRoIGFueSB0aW1lIGRlbGF5LCBcImRyYWdnaW5nXCIgd2lsbCBiZWdpbiBpbW1lZGlhdGVseSxcclxuICAgICAgICAvLyB3aGljaCB3aWxsIGtpbGwgYW55IHRvdWNobW92aW5nL3Njcm9sbGluZy4gUHJldmVudCB0aGlzLlxyXG4gICAgICAgIGRyYWdMaXN0ZW5lci5zaG91bGRDYW5jZWxUb3VjaFNjcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgIGRyYWdMaXN0ZW5lci5zY3JvbGxBbHdheXNLaWxscyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZUNsaWNraW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRlQ2xpY2tpbmc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDgzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xyXG4vKlxyXG5Pbmx5IGhhbmRsZXMgZm9yZWdyb3VuZCBzZWdzLlxyXG5Eb2VzIG5vdCBvd24gcmVuZGVyaW5nLiBVc2UgZm9yIGxvdy1sZXZlbCB1dGlsIG1ldGhvZHMgYnkgVGltZUdyaWQuXHJcbiovXHJcbnZhciBUaW1lR3JpZEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEV2ZW50UmVuZGVyZXIodGltZUdyaWQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRpbWVHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSB0aW1lR3JpZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLnRpbWVHcmlkLmZnQ29udGFpbmVyRWxzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBmb3JlZ3JvdW5kIHNlZ21lbnRzLCByZW5kZXIgYSBET00gZWxlbWVudCBmb3IgZWFjaCwgY29tcHV0ZXMgcG9zaXRpb24sXHJcbiAgICAvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzID0gZnVuY3Rpb24gKHNlZ3MsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBzZWdzQnlDb2w7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBzZWdzQnlDb2wgPSB0aGlzLnRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy50aW1lR3JpZC5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmdTZWdDb29yZHMoc2Vnc0J5Q29sW2NvbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmF0dGFjaFNlZ3NCeUNvbChzZWdzQnlDb2wsIGNvbnRhaW5lckVscyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5mZ1NlZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5mZ1NlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgdGltZUZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnbm9NZXJpZGllbVRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjY6MzBcIiAobm8gQU0vUE0pXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCBzZWdtZW50J3MgZGVmYXVsdCByZW5kZXJpbmdcclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZywgZGlzYWJsZVJlc2l6aW5nKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgY29tcG9uZW50Rm9vdHByaW50ID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGlzQWxsRGF5ID0gY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RGVmRHJhZ2dhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIHNlZy5pc1N0YXJ0ICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XHJcbiAgICAgICAgdmFyIHNraW5Dc3MgPSB1dGlsXzEuY3NzVG9TdHIodGhpcy5nZXRTa2luQ3NzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIHRpbWVUZXh0O1xyXG4gICAgICAgIHZhciBmdWxsVGltZVRleHQ7IC8vIG1vcmUgdmVyYm9zZSB0aW1lIHRleHQuIGZvciB0aGUgcHJpbnQgc3R5bGVzaGVldFxyXG4gICAgICAgIHZhciBzdGFydFRpbWVUZXh0OyAvLyBqdXN0IHRoZSBzdGFydCB0aW1lIHRleHRcclxuICAgICAgICBjbGFzc2VzLnVuc2hpZnQoJ2ZjLXRpbWUtZ3JpZC1ldmVudCcsICdmYy12LWV2ZW50Jyk7XHJcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGFwcGVhcnMgdG8gc3BhbiBtb3JlIHRoYW4gb25lIGRheS4uLlxyXG4gICAgICAgIGlmICh2aWV3LmlzTXVsdGlEYXlSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICAvLyBEb24ndCBkaXNwbGF5IHRpbWUgdGV4dCBvbiBzZWdtZW50cyB0aGF0IHJ1biBlbnRpcmVseSB0aHJvdWdoIGEgZGF5LlxyXG4gICAgICAgICAgICAvLyBUaGF0IHdvdWxkIGFwcGVhciBhcyBtaWRuaWdodC1taWRuaWdodCBhbmQgd291bGQgbG9vayBkdW1iLlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRpc3BsYXkgdGhlIHRpbWUgdGV4dCBmb3IgdGhlICpzZWdtZW50J3MqIHRpbWVzIChsaWtlIDZwbS1taWRuaWdodCBvciBtaWRuaWdodC0xMGFtKVxyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9uZWRTdGFydCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLnN0YXJ0TXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvbmVkRW5kID0gY2FsZW5kYXIubXNUb01vbWVudChzZWcuZW5kTXMpO1xyXG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXkpO1xyXG4gICAgICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5fZ2V0VGltZVRleHQoem9uZWRTdGFydCwgem9uZWRFbmQsIGlzQWxsRGF5LCAnTFQnKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXksIG51bGwsIGZhbHNlKTsgLy8gZGlzcGxheUVuZD1mYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgZnVsbFRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50LCAnTFQnKTtcclxuICAgICAgICAgICAgc3RhcnRUaW1lVGV4dCA9IHRoaXMuZ2V0VGltZVRleHQoc2VnLmZvb3RwcmludCwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRpbWVUZXh0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtdGltZVwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLXN0YXJ0PVwiJyArIHV0aWxfMS5odG1sRXNjYXBlKHN0YXJ0VGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBkYXRhLWZ1bGw9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZnVsbFRpbWVUZXh0KSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzcGFuPicgKyB1dGlsXzEuaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChldmVudERlZi50aXRsZSA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYmdcIi8+JyArXHJcbiAgICAgICAgICAgIC8qIFRPRE86IHdyaXRlIENTUyBmb3IgdGhpc1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICAgJydcclxuICAgICAgICAgICAgICAgICkgK1xyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tRW5kID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiIC8+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhcmUgYXNzdW1lZCB0byBhbGwgbGl2ZSBpbiB0aGUgKnNhbWUgY29sdW1uKixcclxuICAgIC8vIGNvbXB1dGUgdGhlaXIgdmVyaWNhbC9ob3Jpem9udGFsIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUZnU2VnQ29vcmRzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7IC8vIGhvcml6b250YWxzIHJlbGllcyBvbiB0aGlzXHJcbiAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdIb3Jpem9udGFscyhzZWdzKTsgLy8gY29tcHV0ZSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLCB6LWluZGV4J3MsIGFuZCByZW9yZGVyIHRoZSBhcnJheVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuYXNzaWduRmdTZWdIb3Jpem9udGFscyhzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGFyZSBhbGwgaW4gdGhlIHNhbWUgY29sdW1uLCBzZXRzIHRoZSBiYWNrd2FyZENvb3JkIGFuZCBmb3J3YXJkQ29vcmQgb24gZWFjaC5cclxuICAgIC8vIE5PVEU6IEFsc28gcmVvcmRlcnMgdGhlIGdpdmVuIGFycmF5IGJ5IGRhdGUhXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVGZ1NlZ0hvcml6b250YWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzO1xyXG4gICAgICAgIHZhciBsZXZlbDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpOyAvLyBvcmRlciBieSBjZXJ0YWluIGNyaXRlcmlhXHJcbiAgICAgICAgbGV2ZWxzID0gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpO1xyXG4gICAgICAgIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKTtcclxuICAgICAgICBpZiAoKGxldmVsMCA9IGxldmVsc1swXSkpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMobGV2ZWwwW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsY3VsYXRlIHNlZy5mb3J3YXJkQ29vcmQgYW5kIHNlZy5iYWNrd2FyZENvb3JkIGZvciB0aGUgc2VnbWVudCwgd2hlcmUgYm90aCB2YWx1ZXMgcmFuZ2VcclxuICAgIC8vIGZyb20gMCB0byAxLiBJZiB0aGUgY2FsZW5kYXIgaXMgbGVmdC10by1yaWdodCwgdGhlIHNlZy5iYWNrd2FyZENvb3JkIG1hcHMgdG8gXCJsZWZ0XCIgYW5kXHJcbiAgICAvLyBzZWcuZm9yd2FyZENvb3JkIG1hcHMgdG8gXCJyaWdodFwiICh2aWEgcGVyY2VudGFnZSkuIFZpY2UtdmVyc2EgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHNlZ21lbnQgbWlnaHQgYmUgcGFydCBvZiBhIFwic2VyaWVzXCIsIHdoaWNoIG1lYW5zIGNvbnNlY3V0aXZlIHNlZ21lbnRzIHdpdGggdGhlIHNhbWUgcHJlc3N1cmVcclxuICAgIC8vIHdobydzIHdpZHRoIGlzIHVua25vd24gdW50aWwgYW4gZWRnZSBoYXMgYmVlbiBoaXQuIGBzZXJpZXNCYWNrd2FyZFByZXNzdXJlYCBpcyB0aGUgbnVtYmVyIG9mXHJcbiAgICAvLyBzZWdtZW50cyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzLCBhbmQgYHNlcmllc0JhY2t3YXJkQ29vcmRgIGlzIHRoZSBzdGFydGluZ1xyXG4gICAgLy8gY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3Qgc2VnbWVudCBpbiB0aGUgc2VyaWVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayA9IGZ1bmN0aW9uIChzZWcsIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUsIHNlcmllc0JhY2t3YXJkQ29vcmQpIHtcclxuICAgICAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZy5mb3J3YXJkQ29vcmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoIWZvcndhcmRTZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaGlnaGVzdCBwcmVzc3VyZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Rm9yd2FyZFNlZ3MoZm9yd2FyZFNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzZWdtZW50J3MgZm9yd2FyZENvb3JkIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBiYWNrd2FyZENvb3JkIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gaGlnaGVzdC1wcmVzc3VyZSBmb3J3YXJkIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gZm9yd2FyZFNlZ3NbMF0uYmFja3dhcmRDb29yZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgIHNlZy5iYWNrd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZCAtXHJcbiAgICAgICAgICAgICAgICAoc2VnLmZvcndhcmRDb29yZCAtIHNlcmllc0JhY2t3YXJkQ29vcmQpIC8gLy8gYXZhaWxhYmxlIHdpZHRoIGZvciBzZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAoc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEpOyAvLyAjIG9mIHNlZ21lbnRzIGluIHRoZSBzZXJpZXNcclxuICAgICAgICAgICAgLy8gdXNlIHRoaXMgc2VnbWVudCdzIGNvb3JkaW5hdGVzIHRvIGNvbXB1dGVkIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGVzcy1wcmVzc3VyaXplZFxyXG4gICAgICAgICAgICAvLyBmb3J3YXJkIHNlZ21lbnRzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1tpXSwgMCwgc2VnLmZvcndhcmRDb29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0Rm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoZm9yd2FyZFNlZ3MpIHtcclxuICAgICAgICBmb3J3YXJkU2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUZvcndhcmRTZWdzJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBmb3J3YXJkIHNlZ21lbnQgdG8gcmVseSBvbiBtb3JlIHdoZW4gY29tcHV0aW5nIGNvb3JkaW5hdGVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xyXG4gICAgICAgIC8vIHB1dCBoaWdoZXItcHJlc3N1cmUgZmlyc3RcclxuICAgICAgICByZXR1cm4gc2VnMi5mb3J3YXJkUHJlc3N1cmUgLSBzZWcxLmZvcndhcmRQcmVzc3VyZSB8fFxyXG4gICAgICAgICAgICAvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxyXG4gICAgICAgICAgICAoc2VnMS5iYWNrd2FyZENvb3JkIHx8IDApIC0gKHNlZzIuYmFja3dhcmRDb29yZCB8fCAwKSB8fFxyXG4gICAgICAgICAgICAvLyBkbyBub3JtYWwgc29ydGluZy4uLlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVFdmVudFNlZ3Moc2VnMSwgc2VnMik7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBoYWQgdGhlaXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgY29tcHV0ZWQsXHJcbiAgICAvLyBhc3NpZ25zIHBvc2l0aW9uLXJlbGF0ZWQgQ1NTIHZhbHVlcyB0byB0aGVpciBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYXNzaWduRmdTZWdIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3Moc2VnKSk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoZWlnaHQgaXMgc2hvcnQsIGFkZCBhIGNsYXNzTmFtZSBmb3IgYWx0ZXJuYXRlIHN0eWxpbmdcclxuICAgICAgICAgICAgaWYgKHNlZy5ib3R0b20gLSBzZWcudG9wIDwgMzApIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtc2hvcnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMvdmFsdWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW4gZXZlbnQgc2VnbWVudCBlbGVtZW50LlxyXG4gICAgLy8gQ29udGFpbnMgaW1wb3J0YW50IHBvc2l0aW9uaW5nLXJlbGF0ZWQgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGFueSBldmVudCBlbGVtZW50LCBjdXN0b21pemVkIG9yIG5vdC5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3MgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIHNob3VsZE92ZXJsYXAgPSB0aGlzLm9wdCgnc2xvdEV2ZW50T3ZlcmxhcCcpO1xyXG4gICAgICAgIHZhciBiYWNrd2FyZENvb3JkID0gc2VnLmJhY2t3YXJkQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgdmFyIGZvcndhcmRDb29yZCA9IHNlZy5mb3J3YXJkQ29vcmQ7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy50aW1lR3JpZC5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZyk7IC8vIGdldCB0b3AvYm90dG9tIGZpcnN0XHJcbiAgICAgICAgdmFyIGlzUlRMID0gdGhpcy50aW1lR3JpZC5pc1JUTDtcclxuICAgICAgICB2YXIgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgIHZhciByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxyXG4gICAgICAgICAgICBmb3J3YXJkQ29vcmQgPSBNYXRoLm1pbigxLCBiYWNrd2FyZENvb3JkICsgKGZvcndhcmRDb29yZCAtIGJhY2t3YXJkQ29vcmQpICogMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JUTCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMSAtIGZvcndhcmRDb29yZDtcclxuICAgICAgICAgICAgcmlnaHQgPSBiYWNrd2FyZENvb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IGJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gMSAtIGZvcndhcmRDb29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHMuekluZGV4ID0gc2VnLmxldmVsICsgMTsgLy8gY29udmVydCBmcm9tIDAtYmFzZSB0byAxLWJhc2VkXHJcbiAgICAgICAgcHJvcHMubGVmdCA9IGxlZnQgKiAxMDAgKyAnJSc7XHJcbiAgICAgICAgcHJvcHMucmlnaHQgPSByaWdodCAqIDEwMCArICclJztcclxuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiBzZWcuZm9yd2FyZFByZXNzdXJlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cclxuICAgICAgICAgICAgcHJvcHNbaXNSVEwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luUmlnaHQnXSA9IDEwICogMjsgLy8gMTAgaXMgYSBndWVzc3RpbWF0ZSBvZiB0aGUgaWNvbidzIHdpZHRoXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRFdmVudFJlbmRlcmVyO1xyXG59KEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcjtcclxuLy8gQnVpbGRzIGFuIGFycmF5IG9mIHNlZ21lbnRzIFwibGV2ZWxzXCIuIFRoZSBmaXJzdCBsZXZlbCB3aWxsIGJlIHRoZSBsZWZ0bW9zdCB0aWVyIG9mIHNlZ21lbnRzIGlmIHRoZSBjYWxlbmRhciBpc1xyXG4vLyBsZWZ0LXRvLXJpZ2h0LCBvciB0aGUgcmlnaHRtb3N0IGlmIHRoZSBjYWxlbmRhciBpcyByaWdodC10by1sZWZ0LiBBc3N1bWVzIHRoZSBzZWdtZW50cyBhcmUgYWxyZWFkeSBvcmRlcmVkIGJ5IGRhdGUuXHJcbmZ1bmN0aW9uIGJ1aWxkU2xvdFNlZ0xldmVscyhzZWdzKSB7XHJcbiAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICB2YXIgaSwgc2VnO1xyXG4gICAgdmFyIGo7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgLy8gZ28gdGhyb3VnaCBhbGwgdGhlIGxldmVscyBhbmQgc3RvcCBvbiB0aGUgZmlyc3QgbGV2ZWwgd2hlcmUgdGhlcmUgYXJlIG5vIGNvbGxpc2lvbnNcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcHV0ZVNsb3RTZWdDb2xsaXNpb25zKHNlZywgbGV2ZWxzW2pdKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZy5sZXZlbCA9IGo7XHJcbiAgICAgICAgKGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGV2ZWxzO1xyXG59XHJcbi8vIEZvciBldmVyeSBzZWdtZW50LCBmaWd1cmUgb3V0IHRoZSBvdGhlciBzZWdtZW50cyB0aGF0IGFyZSBpbiBzdWJzZXF1ZW50XHJcbi8vIGxldmVscyB0aGF0IGFsc28gb2NjdXB5IHRoZSBzYW1lIHZlcnRpY2FsIHNwYWNlLiBBY2N1bXVsYXRlIGluIHNlZy5mb3J3YXJkU2Vnc1xyXG5mdW5jdGlvbiBjb21wdXRlRm9yd2FyZFNsb3RTZWdzKGxldmVscykge1xyXG4gICAgdmFyIGksIGxldmVsO1xyXG4gICAgdmFyIGosIHNlZztcclxuICAgIHZhciBrO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldmVsID0gbGV2ZWxzW2ldO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBzZWcgPSBsZXZlbFtqXTtcclxuICAgICAgICAgICAgc2VnLmZvcndhcmRTZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoayA9IGkgKyAxOyBrIDwgbGV2ZWxzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBsZXZlbHNba10sIHNlZy5mb3J3YXJkU2Vncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gRmlndXJlIG91dCB3aGljaCBwYXRoIGZvcndhcmQgKHZpYSBzZWcuZm9yd2FyZFNlZ3MpIHJlc3VsdHMgaW4gdGhlIGxvbmdlc3QgcGF0aCB1bnRpbFxyXG4vLyB0aGUgZnVydGhlc3QgZWRnZSBpcyByZWFjaGVkLiBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aCB3aWxsIGJlIHNlZy5mb3J3YXJkUHJlc3N1cmVcclxuZnVuY3Rpb24gY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoc2VnKSB7XHJcbiAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICB2YXIgZm9yd2FyZFByZXNzdXJlID0gMDtcclxuICAgIHZhciBpLCBmb3J3YXJkU2VnO1xyXG4gICAgaWYgKHNlZy5mb3J3YXJkUHJlc3N1cmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBmb3J3YXJkU2VnID0gZm9yd2FyZFNlZ3NbaV07XHJcbiAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIGNoaWxkJ3MgbWF4aW11bSBmb3J3YXJkIHBhdGhcclxuICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMoZm9yd2FyZFNlZyk7XHJcbiAgICAgICAgICAgIC8vIGVpdGhlciB1c2UgdGhlIGV4aXN0aW5nIG1heGltdW0sIG9yIHVzZSB0aGUgY2hpbGQncyBmb3J3YXJkIHByZXNzdXJlXHJcbiAgICAgICAgICAgIC8vIHBsdXMgb25lIChmb3IgdGhlIGZvcndhcmRTZWcgaXRzZWxmKVxyXG4gICAgICAgICAgICBmb3J3YXJkUHJlc3N1cmUgPSBNYXRoLm1heChmb3J3YXJkUHJlc3N1cmUsIDEgKyBmb3J3YXJkU2VnLmZvcndhcmRQcmVzc3VyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlZy5mb3J3YXJkUHJlc3N1cmUgPSBmb3J3YXJkUHJlc3N1cmU7XHJcbiAgICB9XHJcbn1cclxuLy8gRmluZCBhbGwgdGhlIHNlZ21lbnRzIGluIGBvdGhlclNlZ3NgIHRoYXQgdmVydGljYWxseSBjb2xsaWRlIHdpdGggYHNlZ2AuXHJcbi8vIEFwcGVuZCBpbnRvIGFuIG9wdGlvbmFsbHktc3VwcGxpZWQgYHJlc3VsdHNgIGFycmF5IGFuZCByZXR1cm4uXHJcbmZ1bmN0aW9uIGNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIG90aGVyU2VncywgcmVzdWx0cykge1xyXG4gICAgaWYgKHJlc3VsdHMgPT09IHZvaWQgMCkgeyByZXN1bHRzID0gW107IH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGlzU2xvdFNlZ0NvbGxpc2lvbihzZWcsIG90aGVyU2Vnc1tpXSkpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG90aGVyU2Vnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuLy8gRG8gdGhlc2Ugc2VnbWVudHMgb2NjdXB5IHRoZSBzYW1lIHZlcnRpY2FsIHNwYWNlP1xyXG5mdW5jdGlvbiBpc1Nsb3RTZWdDb2xsaXNpb24oc2VnMSwgc2VnMikge1xyXG4gICAgcmV0dXJuIHNlZzEuYm90dG9tID4gc2VnMi50b3AgJiYgc2VnMS50b3AgPCBzZWcyLmJvdHRvbTtcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG52YXIgVGltZUdyaWRIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFRpbWVHcmlkSGVscGVyUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEhlbHBlclJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICB2YXIgc291cmNlRWw7XHJcbiAgICAgICAgLy8gVE9ETzogbm90IGdvb2QgdG8gY2FsbCBldmVudFJlbmRlcmVyIHRoaXMgd2F5XHJcbiAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzKHNlZ3MsIHRoaXMuY29tcG9uZW50LmhlbHBlckNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgLy8gVHJ5IHRvIG1ha2UgdGhlIHNlZ21lbnQgdGhhdCBpcyBpbiB0aGUgc2FtZSByb3cgYXMgc291cmNlU2VnIGxvb2sgdGhlIHNhbWVcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlU2VnICYmIHNvdXJjZVNlZy5jb2wgPT09IHNlZy5jb2wpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUVsID0gc291cmNlU2VnLmVsO1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc291cmNlRWwuY3NzKCdsZWZ0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNvdXJjZUVsLmNzcygncmlnaHQnKSxcclxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLWxlZnQnOiBzb3VyY2VFbC5jc3MoJ21hcmdpbi1sZWZ0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLXJpZ2h0JylcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhlbHBlck5vZGVzLnB1c2goc2VnLmVsWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICQoaGVscGVyTm9kZXMpOyAvLyBtdXN0IHJldHVybiB0aGUgZWxlbWVudHMgcmVuZGVyZWRcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRIZWxwZXJSZW5kZXJlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogODUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG52YXIgVGltZUdyaWRGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEZpbGxSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkRmlsbFJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBjb250YWluZXJFbHM7XHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgbG9va3VwXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5iZ0NvbnRhaW5lckVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVscyA9IHRpbWVHcmlkLmJ1c2luZXNzQ29udGFpbmVyRWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaGlnaGxpZ2h0Jykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5oaWdobGlnaHRDb250YWluZXJFbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVHcmlkLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgICAgICB0aW1lR3JpZC5hdHRhY2hTZWdzQnlDb2wodGltZUdyaWQuZ3JvdXBTZWdzQnlDb2woc2VncyksIGNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZy5lbFswXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcbn0oRmlsbFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZEZpbGxSZW5kZXJlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogODYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLyogQSByZWN0YW5ndWxhciBwYW5lbCB0aGF0IGlzIGFic29sdXRlbHkgcG9zaXRpb25lZCBvdmVyIG90aGVyIGNvbnRlbnRcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbk9wdGlvbnM6XHJcbiAgICAtIGNsYXNzTmFtZSAoc3RyaW5nKVxyXG4gICAgLSBjb250ZW50IChIVE1MIHN0cmluZyBvciBqUXVlcnkgZWxlbWVudCBzZXQpXHJcbiAgICAtIHBhcmVudEVsXHJcbiAgICAtIHRvcFxyXG4gICAgLSBsZWZ0XHJcbiAgICAtIHJpZ2h0ICh0aGUgeCBjb29yZCBvZiB3aGVyZSB0aGUgcmlnaHQgZWRnZSBzaG91bGQgYmUuIG5vdCBhIFwiQ1NTXCIgcmlnaHQpXHJcbiAgICAtIGF1dG9IaWRlIChib29sZWFuKVxyXG4gICAgLSBzaG93IChjYWxsYmFjaylcclxuICAgIC0gaGlkZSAoY2FsbGJhY2spXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUG9wb3ZlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSAxMDsgLy8gdGhlIHNwYWNlIHJlcXVpcmVkIGJldHdlZW4gdGhlIHBvcG92ZXIgYW5kIHRoZSBlZGdlcyBvZiB0aGUgc2Nyb2xsIGNvbnRhaW5lclxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB9XHJcbiAgICAvLyBTaG93cyB0aGUgcG9wb3ZlciBvbiB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiBSZW5kZXJzIGl0IGlmIG5vdCBhbHJlYWR5XHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVsLnNob3coKTtcclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc2hvdycpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBIaWRlcyB0aGUgcG9wb3ZlciwgdGhyb3VnaCBDU1MsIGJ1dCBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgRE9NXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmhpZGUoKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaGlkZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGB0aGlzLmVsYCBhbmQgcmVuZGVycyBjb250ZW50IGluc2lkZSBvZiBpdFxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5lbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1wb3BvdmVyXCIvPicpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcyhvcHRpb25zLmNsYXNzTmFtZSB8fCAnJylcclxuICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIGluaXRpYWxseSB0byB0aGUgdG9wIGxlZnQgdG8gYXZvaWQgY3JlYXRpbmcgc2Nyb2xsYmFyc1xyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIGxlZnQ6IDBcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuYXBwZW5kKG9wdGlvbnMuY29udGVudClcclxuICAgICAgICAgICAgLmFwcGVuZFRvKG9wdGlvbnMucGFyZW50RWwpO1xyXG4gICAgICAgIC8vIHdoZW4gYSBjbGljayBoYXBwZW5zIG9uIGFueXRoaW5nIGluc2lkZSB3aXRoIGEgJ2ZjLWNsb3NlJyBjbGFzc05hbWUsIGhpZGUgdGhlIHBvcG92ZXJcclxuICAgICAgICB0aGlzLmVsLm9uKCdjbGljaycsICcuZmMtY2xvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvSGlkZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCAnbW91c2Vkb3duJywgdGhpcy5kb2N1bWVudE1vdXNlZG93bik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5kb2N1bWVudE1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIG9ubHkgaGlkZSB0aGUgcG9wb3ZlciBpZiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSB0aGUgcG9wb3ZlclxyXG4gICAgICAgIGlmICh0aGlzLmVsICYmICEkKGV2LnRhcmdldCkuY2xvc2VzdCh0aGlzLmVsKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEhpZGVzIGFuZCB1bnJlZ2lzdGVycyBhbnkgaGFuZGxlcnNcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKCQoZG9jdW1lbnQpLCAnbW91c2Vkb3duJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUG9zaXRpb25zIHRoZSBwb3BvdmVyIG9wdGltYWxseSwgdXNpbmcgdGhlIHRvcC9sZWZ0L3JpZ2h0IG9wdGlvbnNcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLmVsLm9mZnNldFBhcmVudCgpLm9mZnNldCgpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZWwub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmVsLm91dGVySGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIHdpbmRvd0VsID0gJCh3aW5kb3cpO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydEVsID0gdXRpbF8xLmdldFNjcm9sbFBhcmVudCh0aGlzLmVsKTtcclxuICAgICAgICB2YXIgdmlld3BvcnRUb3A7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0TGVmdDtcclxuICAgICAgICB2YXIgdmlld3BvcnRPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHRvcDsgLy8gdGhlIFwicG9zaXRpb25cIiAobm90IFwib2Zmc2V0XCIpIHZhbHVlcyBmb3IgdGhlIHBvcG92ZXJcclxuICAgICAgICB2YXIgbGVmdDsgLy9cclxuICAgICAgICAvLyBjb21wdXRlIHRvcCBhbmQgbGVmdFxyXG4gICAgICAgIHRvcCA9IG9wdGlvbnMudG9wIHx8IDA7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBvcHRpb25zLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5yaWdodCAtIHdpZHRoOyAvLyBkZXJpdmUgdGhlIGxlZnQgdmFsdWUgZnJvbSB0aGUgcmlnaHQgdmFsdWVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmlld3BvcnRFbC5pcyh3aW5kb3cpIHx8IHZpZXdwb3J0RWwuaXMoZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0RWwgPSB3aW5kb3dFbDtcclxuICAgICAgICAgICAgdmlld3BvcnRUb3AgPSAwOyAvLyB0aGUgd2luZG93IGlzIGFsd2F5cyBhdCB0aGUgdG9wIGxlZnRcclxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gMDsgLy8gKGFuZCAub2Zmc2V0KCkgd29uJ3Qgd29yayBpZiBjYWxsZWQgaGVyZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0T2Zmc2V0ID0gdmlld3BvcnRFbC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdmlld3BvcnRUb3AgPSB2aWV3cG9ydE9mZnNldC50b3A7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSB3aW5kb3cgaXMgc2Nyb2xsZWQsIGl0IGNhdXNlcyB0aGUgdmlzaWJsZSBhcmVhIHRvIGJlIGZ1cnRoZXIgZG93blxyXG4gICAgICAgIHZpZXdwb3J0VG9wICs9IHdpbmRvd0VsLnNjcm9sbFRvcCgpO1xyXG4gICAgICAgIHZpZXdwb3J0TGVmdCArPSB3aW5kb3dFbC5zY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgLy8gY29uc3RyYWluIHRvIHRoZSB2aWV3IHBvcnQuIGlmIGNvbnN0cmFpbmVkIGJ5IHR3byBlZGdlcywgZ2l2ZSBwcmVjZWRlbmNlIHRvIHRvcC9sZWZ0XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlld3BvcnRDb25zdHJhaW4gIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgdmlld3BvcnRUb3AgKyB2aWV3cG9ydEVsLm91dGVySGVpZ2h0KCkgLSBoZWlnaHQgLSB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgdmlld3BvcnRUb3AgKyB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCB2aWV3cG9ydExlZnQgKyB2aWV3cG9ydEVsLm91dGVyV2lkdGgoKSAtIHdpZHRoIC0gdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgdmlld3BvcnRMZWZ0ICsgdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmNzcyh7XHJcbiAgICAgICAgICAgIHRvcDogdG9wIC0gb3JpZ2luLnRvcCxcclxuICAgICAgICAgICAgbGVmdDogbGVmdCAtIG9yaWdpbi5sZWZ0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjay4gQ2FsbHMgYSBmdW5jdGlvbiBpbiB0aGUgb3B0aW9uIGhhc2ggb2YgdGhlIHNhbWUgbmFtZS5cclxuICAgIC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxyXG4gICAgLy8gVE9ETzogYmV0dGVyIGNvZGUgcmV1c2UgZm9yIHRoaXMuIFJlcGVhdCBjb2RlXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvcG92ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBvcG92ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oUG9wb3Zlcik7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbi8qIEV2ZW50LXJlbmRlcmluZyBtZXRob2RzIGZvciB0aGUgRGF5R3JpZCBjbGFzc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkRXZlbnRSZW5kZXJlcihkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IGRheUdyaWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHRpbWVkIGJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgZXZlbnRSYW5nZXMgPSAkLmdyZXAoZXZlbnRSYW5nZXMsIGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFJhbmdlLmV2ZW50RGVmLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJCZ1Jhbmdlcy5jYWxsKHRoaXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBnaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzID0gdGhpcy5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cclxuICAgICAgICB0aGlzLmRheUdyaWQucm93RWxzLmVhY2goZnVuY3Rpb24gKGksIHJvd05vZGUpIHtcclxuICAgICAgICAgICAgJChyb3dOb2RlKS5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiA+IHRhYmxlJykuYXBwZW5kKHJvd1N0cnVjdHNbaV0udGJvZHlFbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50c1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3Q7XHJcbiAgICAgICAgd2hpbGUgKChyb3dTdHJ1Y3QgPSByb3dTdHJ1Y3RzLnBvcCgpKSkge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QudGJvZHlFbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3dTdHJ1Y3RzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBVc2VzIHRoZSBnaXZlbiBldmVudHMgYXJyYXkgdG8gZ2VuZXJhdGUgPHRib2R5PiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b24uXHJcbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd1N0cnVjdCBvYmplY3RzIChzZWUgdGhlIGJvdHRvbSBvZiBgcmVuZGVyU2VnUm93YCkuXHJcbiAgICAvLyBQUkVDT05ESVRJT046IGVhY2ggc2VnbWVudCBzaG91ZCBhbHJlYWR5IGhhdmUgYSByZW5kZXJlZCBhbmQgYXNzaWduZWQgYC5lbGBcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWdSb3dzO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgc2VnUm93cyA9IHRoaXMuZ3JvdXBTZWdSb3dzKHNlZ3MpOyAvLyBncm91cCBpbnRvIG5lc3RlZCBhcnJheXNcclxuICAgICAgICAvLyBpdGVyYXRlIGVhY2ggcm93IG9mIHNlZ21lbnQgZ3JvdXBpbmdzXHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBzZWdSb3dzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93U3RydWN0cy5wdXNoKHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3dTdHJ1Y3RzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgcm93ICMgYW5kIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFsbCBpbiB0aGUgc2FtZSByb3csIHJlbmRlciBhIDx0Ym9keT4gZWxlbWVudCwgYSBza2VsZXRvbiB0aGF0IGNvbnRhaW5zXHJcbiAgICAvLyB0aGUgc2VnbWVudHMuIFJldHVybnMgb2JqZWN0IHdpdGggYSBidW5jaCBvZiBpbnRlcm5hbCBkYXRhIGFib3V0IGhvdyB0aGUgcmVuZGVyIHdhcyBjYWxjdWxhdGVkLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1JvdyA9IGZ1bmN0aW9uIChyb3csIHJvd1NlZ3MpIHtcclxuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5kYXlHcmlkLmNvbENudDtcclxuICAgICAgICB2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xyXG4gICAgICAgIHZhciBsZXZlbENudCA9IE1hdGgubWF4KDEsIHNlZ0xldmVscy5sZW5ndGgpOyAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxldmVsXHJcbiAgICAgICAgdmFyIHRib2R5ID0gJCgnPHRib2R5Lz4nKTtcclxuICAgICAgICB2YXIgc2VnTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3Igd2hpY2ggc2VnbWVudHMgYXJlIHJlbmRlcmVkIGludG8gd2hpY2ggbGV2ZWwrY29sIGNlbGxzXHJcbiAgICAgICAgdmFyIGNlbGxNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciBhbGwgPHRkPiBlbGVtZW50cyBvZiB0aGUgbGV2ZWwrY29sIG1hdHJpeFxyXG4gICAgICAgIHZhciBsb25lQ2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIDx0ZD4gZWxlbWVudHMgdGhhdCBvbmx5IHRha2UgdXAgYSBzaW5nbGUgY29sdW1uXHJcbiAgICAgICAgdmFyIGksIGxldmVsU2VncztcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHZhciB0cjtcclxuICAgICAgICB2YXIgaiwgc2VnO1xyXG4gICAgICAgIHZhciB0ZDtcclxuICAgICAgICAvLyBwb3B1bGF0ZXMgZW1wdHkgY2VsbHMgZnJvbSB0aGUgY3VycmVudCBjb2x1bW4gKGBjb2xgKSB0byBgZW5kQ29sYFxyXG4gICAgICAgIGZ1bmN0aW9uIGVtcHR5Q2VsbHNVbnRpbChlbmRDb2wpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdyYWIgYSBjZWxsIGZyb20gdGhlIGxldmVsIGFib3ZlIGFuZCBleHRlbmQgaXRzIHJvd3NwYW4uIG90aGVyd2lzZSwgY3JlYXRlIGEgZnJlc2ggY2VsbFxyXG4gICAgICAgICAgICAgICAgdGQgPSAobG9uZUNlbGxNYXRyaXhbaSAtIDFdIHx8IFtdKVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQuYXR0cigncm93c3BhbicsIHBhcnNlSW50KHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxLCAxMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRkID0gJCgnPHRkLz4nKTtcclxuICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmQodGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICBsb25lQ2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXZlbFNlZ3MgPSBzZWdMZXZlbHNbaV07XHJcbiAgICAgICAgICAgIGNvbCA9IDA7XHJcbiAgICAgICAgICAgIHRyID0gJCgnPHRyLz4nKTtcclxuICAgICAgICAgICAgc2VnTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBsb25lQ2VsbE1hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgLy8gbGV2ZWxDbnQgbWlnaHQgYmUgMSBldmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gYWN0dWFsIGxldmVscy4gcHJvdGVjdCBhZ2FpbnN0IHRoaXMuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXHJcbiAgICAgICAgICAgIGlmIChsZXZlbFNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbFNlZ3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3Nbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlDZWxsc1VudGlsKHNlZy5sZWZ0Q29sKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjb250YWluZXIgdGhhdCBvY2N1cGllcyBvciBtb3JlIGNvbHVtbnMuIGFwcGVuZCB0aGUgZXZlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICB0ZCA9ICQoJzx0ZCBjbGFzcz1cImZjLWV2ZW50LWNvbnRhaW5lclwiLz4nKS5hcHBlbmQoc2VnLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnLmxlZnRDb2wgIT0gc2VnLnJpZ2h0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRkLmF0dHIoJ2NvbHNwYW4nLCBzZWcucmlnaHRDb2wgLSBzZWcubGVmdENvbCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29sIDw9IHNlZy5yaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWF0cml4W2ldW2NvbF0gPSBzZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmQodGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVtcHR5Q2VsbHNVbnRpbChjb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSByb3dcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmJvb2tlbmRDZWxscyh0cik7XHJcbiAgICAgICAgICAgIHRib2R5LmFwcGVuZCh0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICB0Ym9keUVsOiB0Ym9keSxcclxuICAgICAgICAgICAgY2VsbE1hdHJpeDogY2VsbE1hdHJpeCxcclxuICAgICAgICAgICAgc2VnTWF0cml4OiBzZWdNYXRyaXgsXHJcbiAgICAgICAgICAgIHNlZ0xldmVsczogc2VnTGV2ZWxzLFxyXG4gICAgICAgICAgICBzZWdzOiByb3dTZWdzXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBTdGFja3MgYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCB3aGljaCBhcmUgYWxsIGFzc3VtZWQgdG8gYmUgaW4gdGhlIHNhbWUgcm93LCBpbnRvIHN1YmFycmF5cyBvZiB2ZXJ0aWNhbCBsZXZlbHMuXHJcbiAgICAvLyBOT1RFOiBtb2RpZmllcyBzZWdzXHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRTZWdMZXZlbHMgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBsZXZlbHMgPSBbXTtcclxuICAgICAgICB2YXIgaSwgc2VnO1xyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIC8vIEdpdmUgcHJlZmVyZW5jZSB0byBlbGVtZW50cyB3aXRoIGNlcnRhaW4gY3JpdGVyaWEsIHNvIHRoZXkgaGF2ZVxyXG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIGJlIGNsb3NlciB0byB0aGUgdG9wLlxyXG4gICAgICAgIHRoaXMuc29ydEV2ZW50U2VncyhzZWdzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZSB0b3Btb3N0LCB1bnRpbCB0aGUgc2VnbWVudCBkb2Vzbid0IGNvbGxpZGUgd2l0aCBvdGhlciBzZWdtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGF5U2VnQ29sbGlzaW9uKHNlZywgbGV2ZWxzW2pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGBqYCBub3cgaG9sZHMgdGhlIGRlc2lyZWQgc3Vicm93IGluZGV4XHJcbiAgICAgICAgICAgIHNlZy5sZXZlbCA9IGo7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbGV2ZWwgYXJyYXkgaWYgbmVlZGVkIGFuZCBhcHBlbmQgc2VnbWVudFxyXG4gICAgICAgICAgICAobGV2ZWxzW2pdIHx8IChsZXZlbHNbal0gPSBbXSkpLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb3JkZXIgc2VnbWVudHMgbGVmdC10by1yaWdodC4gdmVyeSBpbXBvcnRhbnQgaWYgY2FsZW5kYXIgaXMgUlRMXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBsZXZlbHNbal0uc29ydChjb21wYXJlRGF5U2VnQ29scyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZXZlbHM7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyByb3dcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5ncm91cFNlZ1Jvd3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBzZWdSb3dzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF5R3JpZC5yb3dDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdSb3dzLnB1c2goW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWdSb3dzW3NlZ3NbaV0ucm93XS5wdXNoKHNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VnUm93cztcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgZXZlbnQgdGltZSBmb3JtYXR0aW5nIHN0cmluZyBpZiBgdGltZUZvcm1hdGAgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdleHRyYVNtYWxsVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNnBcIiBvciBcIjY6MzBwXCJcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgYGRpc3BsYXlFdmVudEVuZGAgdmFsdWUgaWYgb25lIGlzIG5vdCBleHBsaWNsdHkgZGVmaW5lZFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVEaXNwbGF5RXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5R3JpZC5jb2xDbnQgPT09IDE7IC8vIHdlJ2xsIGxpa2VseSBoYXZlIHNwYWNlIGlmIHRoZXJlJ3Mgb25seSBvbmUgZGF5XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHRvIGJlIHVzZWQgZm9yIHRoZSBkZWZhdWx0IGVsZW1lbnQgZm9yIGFuIGluZGl2aWR1YWwgc2VnbWVudFxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHNlZy5mb290cHJpbnQuZXZlbnREZWY7XHJcbiAgICAgICAgdmFyIGlzQWxsRGF5ID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXk7XHJcbiAgICAgICAgdmFyIGlzRHJhZ2dhYmxlID0gdmlldy5pc0V2ZW50RGVmRHJhZ2dhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tU3RhcnQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5pc1N0YXJ0ICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21TdGFydChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbUVuZCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgaXNBbGxEYXkgJiZcclxuICAgICAgICAgICAgc2VnLmlzRW5kICYmIHZpZXcuaXNFdmVudERlZlJlc2l6YWJsZUZyb21FbmQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5nZXRTZWdDbGFzc2VzKHNlZywgaXNEcmFnZ2FibGUsIGlzUmVzaXphYmxlRnJvbVN0YXJ0IHx8IGlzUmVzaXphYmxlRnJvbUVuZCk7XHJcbiAgICAgICAgdmFyIHNraW5Dc3MgPSB1dGlsXzEuY3NzVG9TdHIodGhpcy5nZXRTa2luQ3NzKGV2ZW50RGVmKSk7XHJcbiAgICAgICAgdmFyIHRpbWVIdG1sID0gJyc7XHJcbiAgICAgICAgdmFyIHRpbWVUZXh0O1xyXG4gICAgICAgIHZhciB0aXRsZUh0bWw7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktZ3JpZC1ldmVudCcsICdmYy1oLWV2ZW50Jyk7XHJcbiAgICAgICAgLy8gT25seSBkaXNwbGF5IGEgdGltZWQgZXZlbnRzIHRpbWUgaWYgaXQgaXMgdGhlIHN0YXJ0aW5nIHNlZ21lbnRcclxuICAgICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICBpZiAodGltZVRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gJzxzcGFuIGNsYXNzPVwiZmMtdGltZVwiPicgKyB1dGlsXzEuaHRtbEVzY2FwZSh0aW1lVGV4dCkgKyAnPC9zcGFuPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGl0bGVIdG1sID1cclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcclxuICAgICAgICAgICAgICAgICh1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSB8fCAnJykgfHwgJyZuYnNwOycpICsgLy8gd2UgYWx3YXlzIHdhbnQgb25lIGxpbmUgb2YgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAnPC9zcGFuPic7XHJcbiAgICAgICAgcmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoZXZlbnREZWYudXJsID9cclxuICAgICAgICAgICAgICAgICcgaHJlZj1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi51cmwpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoc2tpbkNzcyA/XHJcbiAgICAgICAgICAgICAgICAnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5kYXlHcmlkLmlzUlRMID9cclxuICAgICAgICAgICAgICAgIHRpdGxlSHRtbCArICcgJyArIHRpbWVIdG1sIDogLy8gcHV0IGEgbmF0dXJhbCBzcGFjZSBpbiBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCArICcgJyArIHRpdGxlSHRtbCAvL1xyXG4gICAgICAgICAgICApICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLXN0YXJ0LXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbUVuZCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtZW5kLXJlc2l6ZXJcIiAvPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvYT4nO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlHcmlkRXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkRXZlbnRSZW5kZXJlcjtcclxuLy8gQ29tcHV0ZXMgd2hldGhlciB0d28gc2VnbWVudHMnIGNvbHVtbnMgY29sbGlkZS4gVGhleSBhcmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3cuXHJcbmZ1bmN0aW9uIGlzRGF5U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzKSB7XHJcbiAgICB2YXIgaSwgb3RoZXJTZWc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgb3RoZXJTZWcgPSBvdGhlclNlZ3NbaV07XHJcbiAgICAgICAgaWYgKG90aGVyU2VnLmxlZnRDb2wgPD0gc2VnLnJpZ2h0Q29sICYmXHJcbiAgICAgICAgICAgIG90aGVyU2VnLnJpZ2h0Q29sID49IHNlZy5sZWZ0Q29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vLyBBIGNtcCBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIGxlZnRtb3N0IGV2ZW50XHJcbmZ1bmN0aW9uIGNvbXBhcmVEYXlTZWdDb2xzKGEsIGIpIHtcclxuICAgIHJldHVybiBhLmxlZnRDb2wgLSBiLmxlZnRDb2w7XHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogODggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxudmFyIEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcclxudmFyIERheUdyaWRIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWRIZWxwZXJSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRIZWxwZXJSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgYXNzb2NpYXRlZCBpbnRlcm5hbCBzZWdtZW50IG9iamVjdC4gSXQgY2FuIGJlIG51bGwuXHJcbiAgICBEYXlHcmlkSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHM7XHJcbiAgICAgICAgLy8gVE9ETzogbm90IGdvb2QgdG8gY2FsbCBldmVudFJlbmRlcmVyIHRoaXMgd2F5XHJcbiAgICAgICAgcm93U3RydWN0cyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGluamVjdCBlYWNoIG5ldyBldmVudCBza2VsZXRvbiBpbnRvIGVhY2ggYXNzb2NpYXRlZCByb3dcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yb3dFbHMuZWFjaChmdW5jdGlvbiAocm93LCByb3dOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dFbCA9ICQocm93Tm9kZSk7IC8vIHRoZSAuZmMtcm93XHJcbiAgICAgICAgICAgIHZhciBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlbHBlci1za2VsZXRvblwiPjx0YWJsZS8+PC9kaXY+Jyk7IC8vIHdpbGwgYmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkXHJcbiAgICAgICAgICAgIHZhciBza2VsZXRvblRvcEVsO1xyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3A7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIG9yaWdpbmFsIHNlZ21lbnQsIG1hdGNoIHRoZSB0b3AgcG9zaXRpb24uIE90aGVyd2lzZSwgcHV0IGl0IGF0IHRoZSByb3cncyB0b3AgbGV2ZWxcclxuICAgICAgICAgICAgaWYgKHNvdXJjZVNlZyAmJiBzb3VyY2VTZWcucm93ID09PSByb3cpIHtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wID0gc291cmNlU2VnLmVsLnBvc2l0aW9uKCkudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3BFbCA9IHJvd0VsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNrZWxldG9uVG9wRWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tlbGV0b25Ub3BFbCA9IHJvd0VsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uIHRhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvblRvcCA9IHNrZWxldG9uVG9wRWwucG9zaXRpb24oKS50b3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2tlbGV0b25FbC5jc3MoJ3RvcCcsIHNrZWxldG9uVG9wKVxyXG4gICAgICAgICAgICAgICAgLmZpbmQoJ3RhYmxlJylcclxuICAgICAgICAgICAgICAgIC5hcHBlbmQocm93U3RydWN0c1tyb3ddLnRib2R5RWwpO1xyXG4gICAgICAgICAgICByb3dFbC5hcHBlbmQoc2tlbGV0b25FbCk7XHJcbiAgICAgICAgICAgIGhlbHBlck5vZGVzLnB1c2goc2tlbGV0b25FbFswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICQoaGVscGVyTm9kZXMpOyAvLyBtdXN0IHJldHVybiB0aGUgZWxlbWVudHMgcmVuZGVyZWRcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZEhlbHBlclJlbmRlcmVyO1xyXG59KEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkSGVscGVyUmVuZGVyZXI7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDg5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbnZhciBGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG52YXIgRGF5R3JpZEZpbGxSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWRGaWxsUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkRmlsbFJlbmRlcmVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmZpbGxTZWdUYWcgPSAndGQnOyAvLyBvdmVycmlkZSB0aGUgZGVmYXVsdCB0YWcgbmFtZVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIERheUdyaWRGaWxsUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ0VscyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XHJcbiAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGksIHNlZztcclxuICAgICAgICB2YXIgc2tlbGV0b25FbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBza2VsZXRvbkVsID0gdGhpcy5yZW5kZXJGaWxsUm93KHR5cGUsIHNlZyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJvd0Vscy5lcShzZWcucm93KS5hcHBlbmQoc2tlbGV0b25FbCk7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2goc2tlbGV0b25FbFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgbmVlZGVkIGZvciBvbmUgcm93IG9mIGEgZmlsbC4gUmVxdWlyZXMgdGhlIHNlZydzIGVsIHRvIGJlIHJlbmRlcmVkLlxyXG4gICAgRGF5R3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmlsbFJvdyA9IGZ1bmN0aW9uICh0eXBlLCBzZWcpIHtcclxuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5jb21wb25lbnQuY29sQ250O1xyXG4gICAgICAgIHZhciBzdGFydENvbCA9IHNlZy5sZWZ0Q29sO1xyXG4gICAgICAgIHZhciBlbmRDb2wgPSBzZWcucmlnaHRDb2wgKyAxO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWU7XHJcbiAgICAgICAgdmFyIHNrZWxldG9uRWw7XHJcbiAgICAgICAgdmFyIHRyRWw7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSAnYmdldmVudCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNrZWxldG9uRWwgPSAkKCc8ZGl2IGNsYXNzPVwiZmMtJyArIGNsYXNzTmFtZSArICctc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZT48dHIvPjwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgICAgICB0ckVsID0gc2tlbGV0b25FbC5maW5kKCd0cicpO1xyXG4gICAgICAgIGlmIChzdGFydENvbCA+IDApIHtcclxuICAgICAgICAgICAgdHJFbC5hcHBlbmQoJzx0ZCBjb2xzcGFuPVwiJyArIHN0YXJ0Q29sICsgJ1wiLz4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJFbC5hcHBlbmQoc2VnLmVsLmF0dHIoJ2NvbHNwYW4nLCBlbmRDb2wgLSBzdGFydENvbCkpO1xyXG4gICAgICAgIGlmIChlbmRDb2wgPCBjb2xDbnQpIHtcclxuICAgICAgICAgICAgdHJFbC5hcHBlbmQoJzx0ZCBjb2xzcGFuPVwiJyArIChjb2xDbnQgLSBlbmRDb2wpICsgJ1wiLz4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQuYm9va2VuZENlbGxzKHRyRWwpO1xyXG4gICAgICAgIHJldHVybiBza2VsZXRvbkVsO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlHcmlkRmlsbFJlbmRlcmVyO1xyXG59KEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEZpbGxSZW5kZXJlcjtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XHJcbnZhciBMaXN0RXZlbnRSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKExpc3RFdmVudFJlbmRlcmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdEV2ZW50UmVuZGVyZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgaWYgKCFzZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZW5kZXJFbXB0eU1lc3NhZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlbmRlclNlZ0xpc3Qoc2Vncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgZXZlbnQgcm93XHJcbiAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50ID0gc2VnLmZvb3RwcmludDtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBldmVudEZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgY29tcG9uZW50Rm9vdHByaW50ID0gZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHZhciB1cmwgPSBldmVudERlZi51cmw7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2ZjLWxpc3QtaXRlbSddLmNvbmNhdCh0aGlzLmdldENsYXNzZXMoZXZlbnREZWYpKTtcclxuICAgICAgICB2YXIgYmdDb2xvciA9IHRoaXMuZ2V0QmdDb2xvcihldmVudERlZik7XHJcbiAgICAgICAgdmFyIHRpbWVIdG1sO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgdGltZUh0bWwgPSB2aWV3LmdldEFsbERheUh0bWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmlldy5pc011bHRpRGF5UmFuZ2UoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgaWYgKHNlZy5pc1N0YXJ0IHx8IHNlZy5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLl9nZXRUaW1lVGV4dChjYWxlbmRhci5tc1RvTW9tZW50KHNlZy5zdGFydE1zKSwgY2FsZW5kYXIubXNUb01vbWVudChzZWcuZW5kTXMpLCBjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gdmlldy5nZXRBbGxEYXlIdG1sKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcclxuICAgICAgICAgICAgdGltZUh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZSh0aGlzLmdldFRpbWVUZXh0KGV2ZW50Rm9vdHByaW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cmwpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1oYXMtdXJsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnPHRyIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAodGhpcy5kaXNwbGF5RXZlbnRUaW1lID9cclxuICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tdGltZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAodGltZUh0bWwgfHwgJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1saXN0LWl0ZW0tbWFya2VyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy1ldmVudC1kb3RcIicgK1xyXG4gICAgICAgICAgICAoYmdDb2xvciA/XHJcbiAgICAgICAgICAgICAgICAnIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgYmdDb2xvciArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz48L3NwYW4+JyArXHJcbiAgICAgICAgICAgICc8L3RkPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLXRpdGxlICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPGEnICsgKHVybCA/ICcgaHJlZj1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZSh1cmwpICsgJ1wiJyA6ICcnKSArICc+JyArXHJcbiAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKGV2ZW50RGVmLnRpdGxlIHx8ICcnKSArXHJcbiAgICAgICAgICAgICc8L2E+JyArXHJcbiAgICAgICAgICAgICc8L3RkPicgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIC8vIGxpa2UgXCI0OjAwYW1cIlxyXG4gICAgTGlzdEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdtZWRpdW1UaW1lRm9ybWF0Jyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RFdmVudFJlbmRlcmVyO1xyXG59KEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RFdmVudFJlbmRlcmVyO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XHJcbnZhciBMaXN0RXZlbnRQb2ludGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKExpc3RFdmVudFBvaW50aW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTGlzdEV2ZW50UG9pbnRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yIGV2ZW50cyB3aXRoIGEgdXJsLCB0aGUgd2hvbGUgPHRyPiBzaG91bGQgYmUgY2xpY2thYmxlLFxyXG4gICAgLy8gYnV0IGl0J3MgaW1wb3NzaWJsZSB0byB3cmFwIHdpdGggYW4gPGE+IHRhZy4gc2ltdWxhdGUgdGhpcy5cclxuICAgIExpc3RFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIHVybDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcywgc2VnLCBldik7IC8vIG1pZ2h0IHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uXHJcbiAgICAgICAgLy8gbm90IGNsaWNraW5nIG9uIG9yIHdpdGhpbiBhbiA8YT4gd2l0aCBhbiBocmVmXHJcbiAgICAgICAgaWYgKCEkKGV2LnRhcmdldCkuY2xvc2VzdCgnYVtocmVmXScpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB1cmwgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmLnVybDtcclxuICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsOyAvLyBzaW11bGF0ZSBsaW5rIGNsaWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExpc3RFdmVudFBvaW50aW5nO1xyXG59KEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IExpc3RFdmVudFBvaW50aW5nO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nyk7XHJcbnZhciBKc29uRmVlZEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoQXJyYXlFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhGdW5jRXZlbnRTb3VyY2VfMS5kZWZhdWx0KTtcclxuRXZlbnRTb3VyY2VQYXJzZXJfMS5kZWZhdWx0LnJlZ2lzdGVyQ2xhc3MoSnNvbkZlZWRFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxudmFyIFN0YW5kYXJkVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbnZhciBCb290c3RyYXBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZhdWx0LnJlZ2lzdGVyKCdzdGFuZGFyZCcsIFN0YW5kYXJkVGhlbWVfMS5kZWZhdWx0KTtcclxuVGhlbWVSZWdpc3RyeV8xLmRlZmF1bHQucmVnaXN0ZXIoJ2pxdWVyeS11aScsIEpxdWVyeVVpVGhlbWVfMS5kZWZhdWx0KTtcclxuVGhlbWVSZWdpc3RyeV8xLmRlZmF1bHQucmVnaXN0ZXIoJ2Jvb3RzdHJhcDMnLCBCb290c3RyYXBUaGVtZV8xLmRlZmF1bHQpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5NCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxudmFyIEJvb3RzdHJhcFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQm9vdHN0cmFwVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBCb290c3RyYXBUaGVtZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm9vdHN0cmFwVGhlbWU7XHJcbn0oVGhlbWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJvb3RzdHJhcFRoZW1lO1xyXG5Cb290c3RyYXBUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgIHdpZGdldDogJ2ZjLWJvb3RzdHJhcDMnLFxyXG4gICAgdGFibGVHcmlkOiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgdGFibGVMaXN0OiAndGFibGUgdGFibGUtc3RyaXBlZCcsXHJcbiAgICBidXR0b25Hcm91cDogJ2J0bi1ncm91cCcsXHJcbiAgICBidXR0b246ICdidG4gYnRuLWRlZmF1bHQnLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdhY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICAgIHRvZGF5OiAnYWxlcnQgYWxlcnQtaW5mbycsXHJcbiAgICBwb3BvdmVyOiAncGFuZWwgcGFuZWwtZGVmYXVsdCcsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAncGFuZWwtaGVhZGluZycsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ3BhbmVsLWJvZHknLFxyXG4gICAgLy8gZGF5IGdyaWRcclxuICAgIGhlYWRlclJvdzogJ3BhbmVsLWRlZmF1bHQnLFxyXG4gICAgZGF5Um93OiAncGFuZWwtZGVmYXVsdCcsXHJcbiAgICAvLyBsaXN0IHZpZXdcclxuICAgIGxpc3RWaWV3OiAncGFuZWwgcGFuZWwtZGVmYXVsdCdcclxufTtcclxuQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZ2x5cGhpY29uJztcclxuQm9vdHN0cmFwVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICdnbHlwaGljb24tcmVtb3ZlJyxcclxuICAgIHByZXY6ICdnbHlwaGljb24tY2hldnJvbi1sZWZ0JyxcclxuICAgIG5leHQ6ICdnbHlwaGljb24tY2hldnJvbi1yaWdodCcsXHJcbiAgICBwcmV2WWVhcjogJ2dseXBoaWNvbi1iYWNrd2FyZCcsXHJcbiAgICBuZXh0WWVhcjogJ2dseXBoaWNvbi1mb3J3YXJkJ1xyXG59O1xyXG5Cb290c3RyYXBUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2Jvb3RzdHJhcEdseXBoaWNvbnMnO1xyXG5Cb290c3RyYXBUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2Jvb3RzdHJhcEdseXBoaWNvbic7XHJcbkJvb3RzdHJhcFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZ2x5cGhpY29uLSc7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDk1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG5hbWVzcGFjZV9ob29rc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XHJcbnZhciBNb250aFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xyXG52YXIgdmlld3MgPSBuYW1lc3BhY2VfaG9va3NfMS5kZWZhdWx0LnZpZXdzO1xyXG52aWV3cy5iYXNpYyA9IHtcclxuICAgICdjbGFzcyc6IEJhc2ljVmlld18xLmRlZmF1bHRcclxufTtcclxudmlld3MuYmFzaWNEYXkgPSB7XHJcbiAgICB0eXBlOiAnYmFzaWMnLFxyXG4gICAgZHVyYXRpb246IHsgZGF5czogMSB9XHJcbn07XHJcbnZpZXdzLmJhc2ljV2VlayA9IHtcclxuICAgIHR5cGU6ICdiYXNpYycsXHJcbiAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9XHJcbn07XHJcbnZpZXdzLm1vbnRoID0ge1xyXG4gICAgJ2NsYXNzJzogTW9udGhWaWV3XzEuZGVmYXVsdCxcclxuICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5NiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBuYW1lc3BhY2VfaG9va3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBBZ2VuZGFWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcclxudmFyIHZpZXdzID0gbmFtZXNwYWNlX2hvb2tzXzEuZGVmYXVsdC52aWV3cztcclxudmlld3MuYWdlbmRhID0ge1xyXG4gICAgJ2NsYXNzJzogQWdlbmRhVmlld18xLmRlZmF1bHQsXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGFsbERheVNsb3Q6IHRydWUsXHJcbiAgICAgICAgc2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxyXG4gICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IHRydWUgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXHJcbiAgICB9XHJcbn07XHJcbnZpZXdzLmFnZW5kYURheSA9IHtcclxuICAgIHR5cGU6ICdhZ2VuZGEnLFxyXG4gICAgZHVyYXRpb246IHsgZGF5czogMSB9XHJcbn07XHJcbnZpZXdzLmFnZW5kYVdlZWsgPSB7XHJcbiAgICB0eXBlOiAnYWdlbmRhJyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cclxufTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbmFtZXNwYWNlX2hvb2tzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xyXG52YXIgdmlld3MgPSBuYW1lc3BhY2VfaG9va3NfMS5kZWZhdWx0LnZpZXdzO1xyXG52aWV3cy5saXN0ID0ge1xyXG4gICAgJ2NsYXNzJzogTGlzdFZpZXdfMS5kZWZhdWx0LFxyXG4gICAgYnV0dG9uVGV4dEtleTogJ2xpc3QnLFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBidXR0b25UZXh0OiAnbGlzdCcsXHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ0xMJyxcclxuICAgICAgICBub0V2ZW50c01lc3NhZ2U6ICdObyBldmVudHMgdG8gZGlzcGxheSdcclxuICAgIH1cclxufTtcclxudmlld3MubGlzdERheSA9IHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyXHJcbiAgICB9XHJcbn07XHJcbnZpZXdzLmxpc3RXZWVrID0ge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ2RkZGQnLFxyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdMTCdcclxuICAgIH1cclxufTtcclxudmlld3MubGlzdE1vbnRoID0ge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgbW9udGg6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUFsdEZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgfVxyXG59O1xyXG52aWV3cy5saXN0WWVhciA9IHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUFsdEZvcm1hdDogJ2RkZGQnIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8qKiovIH0pXHJcbi8qKioqKiovIF0pO1xyXG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9mdWxsY2FsZW5kYXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2Z1bGxjYWxlbmRhci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBtYXAgPSB7XG5cdFwiLi9hZlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYWYuanNcIixcblx0XCIuL2FmLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hZi5qc1wiLFxuXHRcIi4vYXJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLmpzXCIsXG5cdFwiLi9hci1kelwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItZHouanNcIixcblx0XCIuL2FyLWR6LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1kei5qc1wiLFxuXHRcIi4vYXIta3dcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWt3LmpzXCIsXG5cdFwiLi9hci1rdy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIta3cuanNcIixcblx0XCIuL2FyLWx5XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1seS5qc1wiLFxuXHRcIi4vYXItbHkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzXCIsXG5cdFwiLi9hci1tYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItbWEuanNcIixcblx0XCIuL2FyLW1hLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1tYS5qc1wiLFxuXHRcIi4vYXItc2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXNhLmpzXCIsXG5cdFwiLi9hci1zYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItc2EuanNcIixcblx0XCIuL2FyLXRuXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci10bi5qc1wiLFxuXHRcIi4vYXItdG4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXRuLmpzXCIsXG5cdFwiLi9hci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXIuanNcIixcblx0XCIuL2F6XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hei5qc1wiLFxuXHRcIi4vYXouanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2F6LmpzXCIsXG5cdFwiLi9iZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmUuanNcIixcblx0XCIuL2JlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9iZS5qc1wiLFxuXHRcIi4vYmdcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JnLmpzXCIsXG5cdFwiLi9iZy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmcuanNcIixcblx0XCIuL2JtXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibS5qc1wiLFxuXHRcIi4vYm0uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JtLmpzXCIsXG5cdFwiLi9iblwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm4uanNcIixcblx0XCIuL2JuLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibi5qc1wiLFxuXHRcIi4vYm9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzXCIsXG5cdFwiLi9iby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYm8uanNcIixcblx0XCIuL2JyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ici5qc1wiLFxuXHRcIi4vYnIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JyLmpzXCIsXG5cdFwiLi9ic1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnMuanNcIixcblx0XCIuL2JzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9icy5qc1wiLFxuXHRcIi4vY2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzXCIsXG5cdFwiLi9jYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY2EuanNcIixcblx0XCIuL2NzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qc1wiLFxuXHRcIi4vY3MuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NzLmpzXCIsXG5cdFwiLi9jdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3YuanNcIixcblx0XCIuL2N2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jdi5qc1wiLFxuXHRcIi4vY3lcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2N5LmpzXCIsXG5cdFwiLi9jeS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3kuanNcIixcblx0XCIuL2RhXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kYS5qc1wiLFxuXHRcIi4vZGEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzXCIsXG5cdFwiLi9kZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUuanNcIixcblx0XCIuL2RlLWF0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1hdC5qc1wiLFxuXHRcIi4vZGUtYXQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLWF0LmpzXCIsXG5cdFwiLi9kZS1jaFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtY2guanNcIixcblx0XCIuL2RlLWNoLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1jaC5qc1wiLFxuXHRcIi4vZGUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RlLmpzXCIsXG5cdFwiLi9kdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZHYuanNcIixcblx0XCIuL2R2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kdi5qc1wiLFxuXHRcIi4vZWxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzXCIsXG5cdFwiLi9lbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZWwuanNcIixcblx0XCIuL2VuLWF1XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1hdS5qc1wiLFxuXHRcIi4vZW4tYXUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzXCIsXG5cdFwiLi9lbi1jYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tY2EuanNcIixcblx0XCIuL2VuLWNhLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1jYS5qc1wiLFxuXHRcIi4vZW4tZ2JcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWdiLmpzXCIsXG5cdFwiLi9lbi1nYi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tZ2IuanNcIixcblx0XCIuL2VuLWllXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1pZS5qc1wiLFxuXHRcIi4vZW4taWUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWllLmpzXCIsXG5cdFwiLi9lbi1uelwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tbnouanNcIixcblx0XCIuL2VuLW56LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lbi1uei5qc1wiLFxuXHRcIi4vZW9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VvLmpzXCIsXG5cdFwiLi9lby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW8uanNcIixcblx0XCIuL2VzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy5qc1wiLFxuXHRcIi4vZXMtZG9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLWRvLmpzXCIsXG5cdFwiLi9lcy1kby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtZG8uanNcIixcblx0XCIuL2VzLXVzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lcy11cy5qc1wiLFxuXHRcIi4vZXMtdXMuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLXVzLmpzXCIsXG5cdFwiLi9lcy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMuanNcIixcblx0XCIuL2V0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qc1wiLFxuXHRcIi4vZXQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V0LmpzXCIsXG5cdFwiLi9ldVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXUuanNcIixcblx0XCIuL2V1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldS5qc1wiLFxuXHRcIi4vZmFcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZhLmpzXCIsXG5cdFwiLi9mYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmEuanNcIixcblx0XCIuL2ZpXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9maS5qc1wiLFxuXHRcIi4vZmkuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZpLmpzXCIsXG5cdFwiLi9mb1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZm8uanNcIixcblx0XCIuL2ZvLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mby5qc1wiLFxuXHRcIi4vZnJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLmpzXCIsXG5cdFwiLi9mci1jYVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2EuanNcIixcblx0XCIuL2ZyLWNhLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci1jYS5qc1wiLFxuXHRcIi4vZnItY2hcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNoLmpzXCIsXG5cdFwiLi9mci1jaC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2guanNcIixcblx0XCIuL2ZyLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qc1wiLFxuXHRcIi4vZnlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2Z5LmpzXCIsXG5cdFwiLi9meS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnkuanNcIixcblx0XCIuL2dkXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nZC5qc1wiLFxuXHRcIi4vZ2QuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dkLmpzXCIsXG5cdFwiLi9nbFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2wuanNcIixcblx0XCIuL2dsLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nbC5qc1wiLFxuXHRcIi4vZ29tLWxhdG5cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2dvbS1sYXRuLmpzXCIsXG5cdFwiLi9nb20tbGF0bi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ29tLWxhdG4uanNcIixcblx0XCIuL2d1XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qc1wiLFxuXHRcIi4vZ3UuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2d1LmpzXCIsXG5cdFwiLi9oZVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGUuanNcIixcblx0XCIuL2hlLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oZS5qc1wiLFxuXHRcIi4vaGlcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hpLmpzXCIsXG5cdFwiLi9oaS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGkuanNcIixcblx0XCIuL2hyXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9oci5qc1wiLFxuXHRcIi4vaHIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hyLmpzXCIsXG5cdFwiLi9odVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHUuanNcIixcblx0XCIuL2h1LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9odS5qc1wiLFxuXHRcIi4vaHktYW1cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2h5LWFtLmpzXCIsXG5cdFwiLi9oeS1hbS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHktYW0uanNcIixcblx0XCIuL2lkXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pZC5qc1wiLFxuXHRcIi4vaWQuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2lkLmpzXCIsXG5cdFwiLi9pc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXMuanNcIixcblx0XCIuL2lzLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pcy5qc1wiLFxuXHRcIi4vaXRcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzXCIsXG5cdFwiLi9pdC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaXQuanNcIixcblx0XCIuL2phXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qYS5qc1wiLFxuXHRcIi4vamEuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2phLmpzXCIsXG5cdFwiLi9qdlwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvanYuanNcIixcblx0XCIuL2p2LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9qdi5qc1wiLFxuXHRcIi4va2FcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2thLmpzXCIsXG5cdFwiLi9rYS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva2EuanNcIixcblx0XCIuL2trXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ray5qc1wiLFxuXHRcIi4va2suanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2trLmpzXCIsXG5cdFwiLi9rbVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva20uanNcIixcblx0XCIuL2ttLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbS5qc1wiLFxuXHRcIi4va25cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tuLmpzXCIsXG5cdFwiLi9rbi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva24uanNcIixcblx0XCIuL2tvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rby5qc1wiLFxuXHRcIi4va28uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tvLmpzXCIsXG5cdFwiLi9reVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUva3kuanNcIixcblx0XCIuL2t5LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9reS5qc1wiLFxuXHRcIi4vbGJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xiLmpzXCIsXG5cdFwiLi9sYi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbGIuanNcIixcblx0XCIuL2xvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sby5qc1wiLFxuXHRcIi4vbG8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xvLmpzXCIsXG5cdFwiLi9sdFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHQuanNcIixcblx0XCIuL2x0LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdC5qc1wiLFxuXHRcIi4vbHZcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2x2LmpzXCIsXG5cdFwiLi9sdi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHYuanNcIixcblx0XCIuL21lXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tZS5qc1wiLFxuXHRcIi4vbWUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21lLmpzXCIsXG5cdFwiLi9taVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWkuanNcIixcblx0XCIuL21pLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9taS5qc1wiLFxuXHRcIi4vbWtcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21rLmpzXCIsXG5cdFwiLi9tay5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWsuanNcIixcblx0XCIuL21sXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tbC5qc1wiLFxuXHRcIi4vbWwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21sLmpzXCIsXG5cdFwiLi9tclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXIuanNcIixcblx0XCIuL21yLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tci5qc1wiLFxuXHRcIi4vbXNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzXCIsXG5cdFwiLi9tcy1teVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXMtbXkuanNcIixcblx0XCIuL21zLW15LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tcy1teS5qc1wiLFxuXHRcIi4vbXMuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzXCIsXG5cdFwiLi9teVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXkuanNcIixcblx0XCIuL215LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9teS5qc1wiLFxuXHRcIi4vbmJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzXCIsXG5cdFwiLi9uYi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmIuanNcIixcblx0XCIuL25lXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9uZS5qc1wiLFxuXHRcIi4vbmUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25lLmpzXCIsXG5cdFwiLi9ubFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwuanNcIixcblx0XCIuL25sLWJlXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qc1wiLFxuXHRcIi4vbmwtYmUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25sLWJlLmpzXCIsXG5cdFwiLi9ubC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmwuanNcIixcblx0XCIuL25uXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubi5qc1wiLFxuXHRcIi4vbm4uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25uLmpzXCIsXG5cdFwiLi9wYS1pblwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGEtaW4uanNcIixcblx0XCIuL3BhLWluLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wYS1pbi5qc1wiLFxuXHRcIi4vcGxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3BsLmpzXCIsXG5cdFwiLi9wbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGwuanNcIixcblx0XCIuL3B0XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC5qc1wiLFxuXHRcIi4vcHQtYnJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzXCIsXG5cdFwiLi9wdC1ici5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcHQtYnIuanNcIixcblx0XCIuL3B0LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC5qc1wiLFxuXHRcIi4vcm9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3JvLmpzXCIsXG5cdFwiLi9yby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcm8uanNcIixcblx0XCIuL3J1XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ydS5qc1wiLFxuXHRcIi4vcnUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3J1LmpzXCIsXG5cdFwiLi9zZFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2QuanNcIixcblx0XCIuL3NkLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zZC5qc1wiLFxuXHRcIi4vc2VcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzXCIsXG5cdFwiLi9zZS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2UuanNcIixcblx0XCIuL3NpXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zaS5qc1wiLFxuXHRcIi4vc2kuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NpLmpzXCIsXG5cdFwiLi9za1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2suanNcIixcblx0XCIuL3NrLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zay5qc1wiLFxuXHRcIi4vc2xcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NsLmpzXCIsXG5cdFwiLi9zbC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2wuanNcIixcblx0XCIuL3NxXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zcS5qc1wiLFxuXHRcIi4vc3EuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NxLmpzXCIsXG5cdFwiLi9zclwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3IuanNcIixcblx0XCIuL3NyLWN5cmxcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanNcIixcblx0XCIuL3NyLWN5cmwuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanNcIixcblx0XCIuL3NyLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zci5qc1wiLFxuXHRcIi4vc3NcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NzLmpzXCIsXG5cdFwiLi9zcy5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3MuanNcIixcblx0XCIuL3N2XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdi5qc1wiLFxuXHRcIi4vc3YuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3N2LmpzXCIsXG5cdFwiLi9zd1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3cuanNcIixcblx0XCIuL3N3LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdy5qc1wiLFxuXHRcIi4vdGFcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RhLmpzXCIsXG5cdFwiLi90YS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGEuanNcIixcblx0XCIuL3RlXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZS5qc1wiLFxuXHRcIi4vdGUuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RlLmpzXCIsXG5cdFwiLi90ZXRcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RldC5qc1wiLFxuXHRcIi4vdGV0LmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZXQuanNcIixcblx0XCIuL3RoXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90aC5qc1wiLFxuXHRcIi4vdGguanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RoLmpzXCIsXG5cdFwiLi90bC1waFwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGwtcGguanNcIixcblx0XCIuL3RsLXBoLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bC1waC5qc1wiLFxuXHRcIi4vdGxoXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bGguanNcIixcblx0XCIuL3RsaC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGxoLmpzXCIsXG5cdFwiLi90clwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHIuanNcIixcblx0XCIuL3RyLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ci5qc1wiLFxuXHRcIi4vdHpsXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanNcIixcblx0XCIuL3R6bC5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHpsLmpzXCIsXG5cdFwiLi90em1cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bS5qc1wiLFxuXHRcIi4vdHptLWxhdG5cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bS1sYXRuLmpzXCIsXG5cdFwiLi90em0tbGF0bi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLWxhdG4uanNcIixcblx0XCIuL3R6bS5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLmpzXCIsXG5cdFwiLi91a1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdWsuanNcIixcblx0XCIuL3VrLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ay5qc1wiLFxuXHRcIi4vdXJcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzXCIsXG5cdFwiLi91ci5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXIuanNcIixcblx0XCIuL3V6XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS91ei5qc1wiLFxuXHRcIi4vdXotbGF0blwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXotbGF0bi5qc1wiLFxuXHRcIi4vdXotbGF0bi5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXotbGF0bi5qc1wiLFxuXHRcIi4vdXouanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LmpzXCIsXG5cdFwiLi92aVwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanNcIixcblx0XCIuL3ZpLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS92aS5qc1wiLFxuXHRcIi4veC1wc2V1ZG9cIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3gtcHNldWRvLmpzXCIsXG5cdFwiLi94LXBzZXVkby5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUveC1wc2V1ZG8uanNcIixcblx0XCIuL3lvXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS95by5qc1wiLFxuXHRcIi4veW8uanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3lvLmpzXCIsXG5cdFwiLi96aC1jblwiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtY24uanNcIixcblx0XCIuL3poLWNuLmpzXCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC1jbi5qc1wiLFxuXHRcIi4vemgtaGtcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWhrLmpzXCIsXG5cdFwiLi96aC1oay5qc1wiOiBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanNcIixcblx0XCIuL3poLXR3XCI6IFwiLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS96aC10dy5qc1wiLFxuXHRcIi4vemgtdHcuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLXR3LmpzXCJcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18od2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkpO1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0dmFyIGlkID0gbWFwW3JlcV07XG5cdGlmKCEoaWQgKyAxKSkgLy8gY2hlY2sgZm9yIG51bWJlciBvciBzdHJpbmdcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKTtcblx0cmV0dXJuIGlkO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSBcIi4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUgcmVjdXJzaXZlIF5cXFxcLlxcXFwvLiokXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZSBeXFwuXFwvLiokXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlIHJlY3Vyc2l2ZSBeXFwuXFwvLiokXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQWZyaWthYW5zIFthZl1cclxuLy8hIGF1dGhvciA6IFdlcm5lciBNb2xsZW50emUgOiBodHRwczovL2dpdGh1Yi5jb20vd2VybmVybVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGFmID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYWYnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyaWVfRmVicnVhcmllX01hYXJ0X0FwcmlsX01laV9KdW5pZV9KdWxpZV9BdWd1c3R1c19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTXJ0X0Fwcl9NZWlfSnVuX0p1bF9BdWdfU2VwX09rdF9Ob3ZfRGVzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnU29uZGFnX01hYW5kYWdfRGluc2RhZ19Xb2Vuc2RhZ19Eb25kZXJkYWdfVnJ5ZGFnX1NhdGVyZGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTb25fTWFhX0Rpbl9Xb2VfRG9uX1ZyeV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTb19NYV9EaV9Xb19Eb19Wcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC92bXxubS9pLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAvXm5tJC9pLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAndm0nIDogJ1ZNJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdubScgOiAnTk0nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbVmFuZGFnIG9tXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbTcO0cmUgb21dIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtvbV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0dpc3RlciBvbV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYWFzXSBkZGRkIFtvbV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdvb3IgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgZ2VsZWRlJyxcclxuICAgICAgICBzIDogJ1xcJ24gcGFhciBzZWtvbmRlcycsXHJcbiAgICAgICAgbSA6ICdcXCduIG1pbnV1dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlJyxcclxuICAgICAgICBoIDogJ1xcJ24gdXVyJyxcclxuICAgICAgICBoaCA6ICclZCB1cmUnLFxyXG4gICAgICAgIGQgOiAnXFwnbiBkYWcnLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZScsXHJcbiAgICAgICAgTSA6ICdcXCduIG1hYW5kJyxcclxuICAgICAgICBNTSA6ICclZCBtYWFuZGUnLFxyXG4gICAgICAgIHkgOiAnXFwnbiBqYWFyJyxcclxuICAgICAgICB5eSA6ICclZCBqYWFyJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdGV8ZGUpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICgobnVtYmVyID09PSAxIHx8IG51bWJlciA9PT0gOCB8fCBudW1iZXIgPj0gMjApID8gJ3N0ZScgOiAnZGUnKTsgLy8gVGhhbmtzIHRvIEpvcmlzIFLDtmxpbmcgOiBodHRwczovL2dpdGh1Yi5jb20vamp1cGl0ZXJcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1hYW5kYWcgaXMgZGllIGVlcnN0ZSBkYWcgdmFuIGRpZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIERpZSB3ZWVrIHdhdCBkaWUgNGRlIEphbnVhcmllIGJldmF0IGlzIGRpZSBlZXJzdGUgd2VlayB2YW4gZGllIGphYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGFmO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hZi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hZi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFyYWJpYyAoQWxnZXJpYSkgW2FyLWR6XVxyXG4vLyEgYXV0aG9yIDogTm91cmVkZGluZSBMT1VBSEVESiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub3VyZWRkaW5lbWVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBhckR6ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItZHonLCB7XHJcbiAgICBtb250aHMgOiAn2KzYp9mG2YHZil/ZgdmK2YHYsdmKX9mF2KfYsdizX9ij2YHYsdmK2YRf2YXYp9mKX9is2YjYp9mGX9is2YjZitmE2YrYqV/Yo9mI2Kpf2LPYqNiq2YXYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YHZhdio2LFf2K/Zitiz2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn2KzYp9mG2YHZil/ZgdmK2YHYsdmKX9mF2KfYsdizX9ij2YHYsdmK2YRf2YXYp9mKX9is2YjYp9mGX9is2YjZitmE2YrYqV/Yo9mI2Kpf2LPYqNiq2YXYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YHZhdio2LFf2K/Zitiz2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn2KfZhNij2K3Yr1/Yp9mE2KXYq9mG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfYp9it2K9f2KfYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KfYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9ij2K1f2KXYq1/Yq9mE2Kdf2KPYsV/YrtmFX9is2YVf2LPYqCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb2LrYr9inINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW9ij2YXYsyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn2YHZiiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfZhdmG2LAgJXMnLFxyXG4gICAgICAgIHMgOiAn2KvZiNin2YYnLFxyXG4gICAgICAgIG0gOiAn2K/ZgtmK2YLYqScsXHJcbiAgICAgICAgbW0gOiAnJWQg2K/Zgtin2KbZgicsXHJcbiAgICAgICAgaCA6ICfYs9in2LnYqScsXHJcbiAgICAgICAgaGggOiAnJWQg2LPYp9i52KfYqicsXHJcbiAgICAgICAgZCA6ICfZitmI2YUnLFxyXG4gICAgICAgIGRkIDogJyVkINij2YrYp9mFJyxcclxuICAgICAgICBNIDogJ9i02YfYsScsXHJcbiAgICAgICAgTU0gOiAnJWQg2KPYtNmH2LEnLFxyXG4gICAgICAgIHkgOiAn2LPZhtipJyxcclxuICAgICAgICB5eSA6ICclZCDYs9mG2YjYp9iqJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhckR6O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1kei5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1kei5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFyYWJpYyAoS3V3YWl0KSBbYXIta3ddXHJcbi8vISBhdXRob3IgOiBOdXNyZXQgUGFybGFrOiBodHRwczovL2dpdGh1Yi5jb20vbnVzcmV0cGFybGFrXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgYXJLdyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyLWt3Jywge1xyXG4gICAgbW9udGhzIDogJ9mK2YbYp9mK2LFf2YHYqNix2KfZitixX9mF2KfYsdizX9ij2KjYsdmK2YRf2YXYp9mKX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiNiyX9i62LTYql/YtNiq2YbYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YbYqNixX9iv2KzZhtio2LEnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZil/ZitmI2YbZitmIX9mK2YjZhNmK2YjYsl/Yuti02Kpf2LTYqtmG2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmG2KjYsV/Yr9is2YbYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn2KfZhNij2K3Yr1/Yp9mE2KXYqtmG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfYp9it2K9f2KfYqtmG2YrZhl/Yq9mE2KfYq9in2KFf2KfYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb2KfZhNmK2YjZhSDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfZgdmKICVzJyxcclxuICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXHJcbiAgICAgICAgcyA6ICfYq9mI2KfZhicsXHJcbiAgICAgICAgbSA6ICfYr9mC2YrZgtipJyxcclxuICAgICAgICBtbSA6ICclZCDYr9mC2KfYptmCJyxcclxuICAgICAgICBoIDogJ9iz2KfYudipJyxcclxuICAgICAgICBoaCA6ICclZCDYs9in2LnYp9iqJyxcclxuICAgICAgICBkIDogJ9mK2YjZhScsXHJcbiAgICAgICAgZGQgOiAnJWQg2KPZitin2YUnLFxyXG4gICAgICAgIE0gOiAn2LTZh9ixJyxcclxuICAgICAgICBNTSA6ICclZCDYo9i02YfYsScsXHJcbiAgICAgICAgeSA6ICfYs9mG2KknLFxyXG4gICAgICAgIHl5IDogJyVkINiz2YbZiNin2KonXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhckt3O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1rdy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1rdy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFyYWJpYyAoTHliaWEpIFthci1seV1cclxuLy8hIGF1dGhvciA6IEFsaSBIbWVyOiBodHRwczovL2dpdGh1Yi5jb20va2lrb2FuaXNcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICcxJyxcclxuICAgICcyJzogJzInLFxyXG4gICAgJzMnOiAnMycsXHJcbiAgICAnNCc6ICc0JyxcclxuICAgICc1JzogJzUnLFxyXG4gICAgJzYnOiAnNicsXHJcbiAgICAnNyc6ICc3JyxcclxuICAgICc4JzogJzgnLFxyXG4gICAgJzknOiAnOScsXHJcbiAgICAnMCc6ICcwJ1xyXG59O1xyXG52YXIgcGx1cmFsRm9ybSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiBuID09PSAxID8gMSA6IG4gPT09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1O1xyXG59O1xyXG52YXIgcGx1cmFscyA9IHtcclxuICAgIHMgOiBbJ9ij2YLZhCDZhdmGINir2KfZhtmK2KknLCAn2KvYp9mG2YrYqSDZiNin2K3Yr9ipJywgWyfYq9in2YbZitiq2KfZhicsICfYq9in2YbZitiq2YrZhiddLCAnJWQg2KvZiNin2YYnLCAnJWQg2KvYp9mG2YrYqScsICclZCDYq9in2YbZitipJ10sXHJcbiAgICBtIDogWyfYo9mC2YQg2YXZhiDYr9mC2YrZgtipJywgJ9iv2YLZitmC2Kkg2YjYp9it2K/YqScsIFsn2K/ZgtmK2YLYqtin2YYnLCAn2K/ZgtmK2YLYqtmK2YYnXSwgJyVkINiv2YLYp9im2YInLCAnJWQg2K/ZgtmK2YLYqScsICclZCDYr9mC2YrZgtipJ10sXHJcbiAgICBoIDogWyfYo9mC2YQg2YXZhiDYs9in2LnYqScsICfYs9in2LnYqSDZiNin2K3Yr9ipJywgWyfYs9in2LnYqtin2YYnLCAn2LPYp9i52KrZitmGJ10sICclZCDYs9in2LnYp9iqJywgJyVkINiz2KfYudipJywgJyVkINiz2KfYudipJ10sXHJcbiAgICBkIDogWyfYo9mC2YQg2YXZhiDZitmI2YUnLCAn2YrZiNmFINmI2KfYrdivJywgWyfZitmI2YXYp9mGJywgJ9mK2YjZhdmK2YYnXSwgJyVkINij2YrYp9mFJywgJyVkINmK2YjZhdmL2KcnLCAnJWQg2YrZiNmFJ10sXHJcbiAgICBNIDogWyfYo9mC2YQg2YXZhiDYtNmH2LEnLCAn2LTZh9ixINmI2KfYrdivJywgWyfYtNmH2LHYp9mGJywgJ9i02YfYsdmK2YYnXSwgJyVkINij2LTZh9ixJywgJyVkINi02YfYsdinJywgJyVkINi02YfYsSddLFxyXG4gICAgeSA6IFsn2KPZgtmEINmF2YYg2LnYp9mFJywgJ9i52KfZhSDZiNin2K3YrycsIFsn2LnYp9mF2KfZhicsICfYudin2YXZitmGJ10sICclZCDYo9i52YjYp9mFJywgJyVkINi52KfZhdmL2KcnLCAnJWQg2LnYp9mFJ11cclxufTtcclxudmFyIHBsdXJhbGl6ZSA9IGZ1bmN0aW9uICh1KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xyXG4gICAgICAgIHZhciBmID0gcGx1cmFsRm9ybShudW1iZXIpLFxyXG4gICAgICAgICAgICBzdHIgPSBwbHVyYWxzW3VdW3BsdXJhbEZvcm0obnVtYmVyKV07XHJcbiAgICAgICAgaWYgKGYgPT09IDIpIHtcclxuICAgICAgICAgICAgc3RyID0gc3RyW3dpdGhvdXRTdWZmaXggPyAwIDogMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcclxuICAgIH07XHJcbn07XHJcbnZhciBtb250aHMgPSBbXHJcbiAgICAn2YrZhtin2YrYsScsXHJcbiAgICAn2YHYqNix2KfZitixJyxcclxuICAgICfZhdin2LHYsycsXHJcbiAgICAn2KPYqNix2YrZhCcsXHJcbiAgICAn2YXYp9mK2YgnLFxyXG4gICAgJ9mK2YjZhtmK2YgnLFxyXG4gICAgJ9mK2YjZhNmK2YgnLFxyXG4gICAgJ9ij2LrYs9i32LMnLFxyXG4gICAgJ9iz2KjYqtmF2KjYsScsXHJcbiAgICAn2KPZg9iq2YjYqNixJyxcclxuICAgICfZhtmI2YHZhdio2LEnLFxyXG4gICAgJ9iv2YrYs9mF2KjYsSdcclxuXTtcclxuXHJcbnZhciBhckx5ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItbHknLCB7XHJcbiAgICBtb250aHMgOiBtb250aHMsXHJcbiAgICBtb250aHNTaG9ydCA6IG1vbnRocyxcclxuICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfYrV/Zhl/Yq1/YsV/Yrl/YrF/Ysycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0QvXFx1MjAwRk0vXFx1MjAwRllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAn2YUnID09PSBpbnB1dDtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2LUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2YUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb2LrYr9mL2Kcg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfYqNi52K8gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcclxuICAgICAgICBzIDogcGx1cmFsaXplKCdzJyksXHJcbiAgICAgICAgbSA6IHBsdXJhbGl6ZSgnbScpLFxyXG4gICAgICAgIG1tIDogcGx1cmFsaXplKCdtJyksXHJcbiAgICAgICAgaCA6IHBsdXJhbGl6ZSgnaCcpLFxyXG4gICAgICAgIGhoIDogcGx1cmFsaXplKCdoJyksXHJcbiAgICAgICAgZCA6IHBsdXJhbGl6ZSgnZCcpLFxyXG4gICAgICAgIGRkIDogcGx1cmFsaXplKCdkJyksXHJcbiAgICAgICAgTSA6IHBsdXJhbGl6ZSgnTScpLFxyXG4gICAgICAgIE1NIDogcGx1cmFsaXplKCdNJyksXHJcbiAgICAgICAgeSA6IHBsdXJhbGl6ZSgneScpLFxyXG4gICAgICAgIHl5IDogcGx1cmFsaXplKCd5JylcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgv2IwvZywgJywnKTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pLnJlcGxhY2UoLywvZywgJ9iMJyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGFyTHk7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLWx5LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQXJhYmljIChNb3JvY2NvKSBbYXItbWFdXHJcbi8vISBhdXRob3IgOiBFbEZhZGlsaSBZYXNzaW5lIDogaHR0cHM6Ly9naXRodWIuY29tL0VsRmFkaWxpWVxyXG4vLyEgYXV0aG9yIDogQWJkZWwgU2FpZCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hYmRlbHNhaWRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBhck1hID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXItbWEnLCB7XHJcbiAgICBtb250aHMgOiAn2YrZhtin2YrYsV/Zgdio2LHYp9mK2LFf2YXYp9ix2LNf2KPYqNix2YrZhF/Zhdin2Ypf2YrZiNmG2YrZiF/ZitmI2YTZitmI2LJf2LrYtNiqX9i02KrZhtio2LFf2KPZg9iq2YjYqNixX9mG2YjZhtio2LFf2K/YrNmG2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9mK2YbYp9mK2LFf2YHYqNix2KfZitixX9mF2KfYsdizX9ij2KjYsdmK2YRf2YXYp9mKX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiNiyX9i62LTYql/YtNiq2YbYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YbYqNixX9iv2KzZhtio2LEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfYp9mE2KPYrdivX9in2YTYpdiq2YbZitmGX9in2YTYq9mE2KfYq9in2KFf2KfZhNij2LHYqNi52KfYoV/Yp9mE2K7ZhdmK2LNf2KfZhNis2YXYudipX9in2YTYs9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9in2K3Yr1/Yp9iq2YbZitmGX9ir2YTYp9ir2KfYoV/Yp9ix2KjYudin2KFf2K7ZhdmK2LNf2KzZhdi52Klf2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vYp9mE2YrZiNmFINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9i62K/YpyDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1vYo9mF2LMg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9mB2YogJXMnLFxyXG4gICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcclxuICAgICAgICBzIDogJ9ir2YjYp9mGJyxcclxuICAgICAgICBtIDogJ9iv2YLZitmC2KknLFxyXG4gICAgICAgIG1tIDogJyVkINiv2YLYp9im2YInLFxyXG4gICAgICAgIGggOiAn2LPYp9i52KknLFxyXG4gICAgICAgIGhoIDogJyVkINiz2KfYudin2KonLFxyXG4gICAgICAgIGQgOiAn2YrZiNmFJyxcclxuICAgICAgICBkZCA6ICclZCDYo9mK2KfZhScsXHJcbiAgICAgICAgTSA6ICfYtNmH2LEnLFxyXG4gICAgICAgIE1NIDogJyVkINij2LTZh9ixJyxcclxuICAgICAgICB5IDogJ9iz2YbYqScsXHJcbiAgICAgICAgeXkgOiAnJWQg2LPZhtmI2KfYqidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogMTIgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYXJNYTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItbWEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYXItbWEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBcmFiaWMgKFNhdWRpIEFyYWJpYSkgW2FyLXNhXVxyXG4vLyEgYXV0aG9yIDogU3VoYWlsIEFsa293YWlsZWV0IDogaHR0cHM6Ly9naXRodWIuY29tL3hzb2hcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfZoScsXHJcbiAgICAnMic6ICfZoicsXHJcbiAgICAnMyc6ICfZoycsXHJcbiAgICAnNCc6ICfZpCcsXHJcbiAgICAnNSc6ICfZpScsXHJcbiAgICAnNic6ICfZpicsXHJcbiAgICAnNyc6ICfZpycsXHJcbiAgICAnOCc6ICfZqCcsXHJcbiAgICAnOSc6ICfZqScsXHJcbiAgICAnMCc6ICfZoCdcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfZoSc6ICcxJyxcclxuICAgICfZoic6ICcyJyxcclxuICAgICfZoyc6ICczJyxcclxuICAgICfZpCc6ICc0JyxcclxuICAgICfZpSc6ICc1JyxcclxuICAgICfZpic6ICc2JyxcclxuICAgICfZpyc6ICc3JyxcclxuICAgICfZqCc6ICc4JyxcclxuICAgICfZqSc6ICc5JyxcclxuICAgICfZoCc6ICcwJ1xyXG59O1xyXG5cclxudmFyIGFyU2EgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdhci1zYScsIHtcclxuICAgIG1vbnRocyA6ICfZitmG2KfZitixX9mB2KjYsdin2YrYsV/Zhdin2LHYs1/Yo9io2LHZitmEX9mF2KfZitmIX9mK2YjZhtmK2Yhf2YrZiNmE2YrZiF/Yo9i62LPYt9izX9iz2KjYqtmF2KjYsV/Yo9mD2KrZiNio2LFf2YbZiNmB2YXYqNixX9iv2YrYs9mF2KjYsScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9mK2YbYp9mK2LFf2YHYqNix2KfZitixX9mF2KfYsdizX9ij2KjYsdmK2YRf2YXYp9mK2Yhf2YrZiNmG2YrZiF/ZitmI2YTZitmIX9ij2LrYs9i32LNf2LPYqNiq2YXYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YHZhdio2LFf2K/Zitiz2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn2KfZhNij2K3Yr1/Yp9mE2KXYq9mG2YrZhl/Yp9mE2KvZhNin2KvYp9ihX9in2YTYo9ix2KjYudin2KFf2KfZhNiu2YXZitizX9in2YTYrNmF2LnYqV/Yp9mE2LPYqNiqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfYo9it2K9f2KXYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KPYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9itX9mGX9irX9ixX9iuX9isX9izJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/YtXzZhS8sXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICfZhScgPT09IGlucHV0O1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfYtSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfZhSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb2KfZhNmK2YjZhSDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfZgdmKICVzJyxcclxuICAgICAgICBwYXN0IDogJ9mF2YbYsCAlcycsXHJcbiAgICAgICAgcyA6ICfYq9mI2KfZhicsXHJcbiAgICAgICAgbSA6ICfYr9mC2YrZgtipJyxcclxuICAgICAgICBtbSA6ICclZCDYr9mC2KfYptmCJyxcclxuICAgICAgICBoIDogJ9iz2KfYudipJyxcclxuICAgICAgICBoaCA6ICclZCDYs9in2LnYp9iqJyxcclxuICAgICAgICBkIDogJ9mK2YjZhScsXHJcbiAgICAgICAgZGQgOiAnJWQg2KPZitin2YUnLFxyXG4gICAgICAgIE0gOiAn2LTZh9ixJyxcclxuICAgICAgICBNTSA6ICclZCDYo9i02YfYsScsXHJcbiAgICAgICAgeSA6ICfYs9mG2KknLFxyXG4gICAgICAgIHl5IDogJyVkINiz2YbZiNin2KonXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vZodmi2aPZpNml2abZp9mo2anZoF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KS5yZXBsYWNlKC8sL2csICfYjCcpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBhclNhO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1zYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci1zYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSAgOiAgQXJhYmljIChUdW5pc2lhKSBbYXItdG5dXHJcbi8vISBhdXRob3IgOiBOYWRlciBUb3VrYWJyaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYWRlcmlvXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgYXJUbiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2FyLXRuJywge1xyXG4gICAgbW9udGhzOiAn2KzYp9mG2YHZil/ZgdmK2YHYsdmKX9mF2KfYsdizX9ij2YHYsdmK2YRf2YXYp9mKX9is2YjYp9mGX9is2YjZitmE2YrYqV/Yo9mI2Kpf2LPYqNiq2YXYqNixX9ij2YPYqtmI2KjYsV/ZhtmI2YHZhdio2LFf2K/Zitiz2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICfYrNin2YbZgdmKX9mB2YrZgdix2Ypf2YXYp9ix2LNf2KPZgdix2YrZhF/Zhdin2Ypf2KzZiNin2YZf2KzZiNmK2YTZitipX9ij2YjYql/Ys9io2KrZhdio2LFf2KPZg9iq2YjYqNixX9mG2YjZgdmF2KjYsV/Yr9mK2LPZhdio2LEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5czogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICfYo9it2K9f2KXYq9mG2YrZhl/Yq9mE2KfYq9in2KFf2KPYsdio2LnYp9ihX9iu2YXZitizX9is2YXYudipX9iz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluOiAn2K1f2YZf2Ktf2LFf2K5f2Kxf2LMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0hIOm1tJyxcclxuICAgICAgICBMVFM6ICdISDptbTpzcycsXHJcbiAgICAgICAgTDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb2KfZhNmK2YjZhSDYudmE2Ykg2KfZhNiz2KfYudipXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vYutiv2Kcg2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhNmJINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YTZiSDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lOiB7XHJcbiAgICAgICAgZnV0dXJlOiAn2YHZiiAlcycsXHJcbiAgICAgICAgcGFzdDogJ9mF2YbYsCAlcycsXHJcbiAgICAgICAgczogJ9ir2YjYp9mGJyxcclxuICAgICAgICBtOiAn2K/ZgtmK2YLYqScsXHJcbiAgICAgICAgbW06ICclZCDYr9mC2KfYptmCJyxcclxuICAgICAgICBoOiAn2LPYp9i52KknLFxyXG4gICAgICAgIGhoOiAnJWQg2LPYp9i52KfYqicsXHJcbiAgICAgICAgZDogJ9mK2YjZhScsXHJcbiAgICAgICAgZGQ6ICclZCDYo9mK2KfZhScsXHJcbiAgICAgICAgTTogJ9i02YfYsScsXHJcbiAgICAgICAgTU06ICclZCDYo9i02YfYsScsXHJcbiAgICAgICAgeTogJ9iz2YbYqScsXHJcbiAgICAgICAgeXk6ICclZCDYs9mG2YjYp9iqJ1xyXG4gICAgfSxcclxuICAgIHdlZWs6IHtcclxuICAgICAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveTogNCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGFyVG47XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXRuLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2FyLXRuLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQXJhYmljIFthcl1cclxuLy8hIGF1dGhvciA6IEFiZGVsIFNhaWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hYmRlbHNhaWRcclxuLy8hIGF1dGhvciA6IEFobWVkIEVsa2hhdGliXHJcbi8vISBhdXRob3IgOiBmb3JhYmkgaHR0cHM6Ly9naXRodWIuY29tL2ZvcmFiaVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ9mhJyxcclxuICAgICcyJzogJ9miJyxcclxuICAgICczJzogJ9mjJyxcclxuICAgICc0JzogJ9mkJyxcclxuICAgICc1JzogJ9mlJyxcclxuICAgICc2JzogJ9mmJyxcclxuICAgICc3JzogJ9mnJyxcclxuICAgICc4JzogJ9moJyxcclxuICAgICc5JzogJ9mpJyxcclxuICAgICcwJzogJ9mgJ1xyXG59O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgJ9mhJzogJzEnLFxyXG4gICAgJ9miJzogJzInLFxyXG4gICAgJ9mjJzogJzMnLFxyXG4gICAgJ9mkJzogJzQnLFxyXG4gICAgJ9mlJzogJzUnLFxyXG4gICAgJ9mmJzogJzYnLFxyXG4gICAgJ9mnJzogJzcnLFxyXG4gICAgJ9moJzogJzgnLFxyXG4gICAgJ9mpJzogJzknLFxyXG4gICAgJ9mgJzogJzAnXHJcbn07XHJcbnZhciBwbHVyYWxGb3JtID0gZnVuY3Rpb24gKG4pIHtcclxuICAgIHJldHVybiBuID09PSAwID8gMCA6IG4gPT09IDEgPyAxIDogbiA9PT0gMiA/IDIgOiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCA/IDMgOiBuICUgMTAwID49IDExID8gNCA6IDU7XHJcbn07XHJcbnZhciBwbHVyYWxzID0ge1xyXG4gICAgcyA6IFsn2KPZgtmEINmF2YYg2KvYp9mG2YrYqScsICfYq9in2YbZitipINmI2KfYrdiv2KknLCBbJ9ir2KfZhtmK2KrYp9mGJywgJ9ir2KfZhtmK2KrZitmGJ10sICclZCDYq9mI2KfZhicsICclZCDYq9in2YbZitipJywgJyVkINir2KfZhtmK2KknXSxcclxuICAgIG0gOiBbJ9ij2YLZhCDZhdmGINiv2YLZitmC2KknLCAn2K/ZgtmK2YLYqSDZiNin2K3Yr9ipJywgWyfYr9mC2YrZgtiq2KfZhicsICfYr9mC2YrZgtiq2YrZhiddLCAnJWQg2K/Zgtin2KbZgicsICclZCDYr9mC2YrZgtipJywgJyVkINiv2YLZitmC2KknXSxcclxuICAgIGggOiBbJ9ij2YLZhCDZhdmGINiz2KfYudipJywgJ9iz2KfYudipINmI2KfYrdiv2KknLCBbJ9iz2KfYudiq2KfZhicsICfYs9in2LnYqtmK2YYnXSwgJyVkINiz2KfYudin2KonLCAnJWQg2LPYp9i52KknLCAnJWQg2LPYp9i52KknXSxcclxuICAgIGQgOiBbJ9ij2YLZhCDZhdmGINmK2YjZhScsICfZitmI2YUg2YjYp9it2K8nLCBbJ9mK2YjZhdin2YYnLCAn2YrZiNmF2YrZhiddLCAnJWQg2KPZitin2YUnLCAnJWQg2YrZiNmF2YvYpycsICclZCDZitmI2YUnXSxcclxuICAgIE0gOiBbJ9ij2YLZhCDZhdmGINi02YfYsScsICfYtNmH2LEg2YjYp9it2K8nLCBbJ9i02YfYsdin2YYnLCAn2LTZh9ix2YrZhiddLCAnJWQg2KPYtNmH2LEnLCAnJWQg2LTZh9ix2KcnLCAnJWQg2LTZh9ixJ10sXHJcbiAgICB5IDogWyfYo9mC2YQg2YXZhiDYudin2YUnLCAn2LnYp9mFINmI2KfYrdivJywgWyfYudin2YXYp9mGJywgJ9i52KfZhdmK2YYnXSwgJyVkINij2LnZiNin2YUnLCAnJWQg2LnYp9mF2YvYpycsICclZCDYudin2YUnXVxyXG59O1xyXG52YXIgcGx1cmFsaXplID0gZnVuY3Rpb24gKHUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XHJcbiAgICAgICAgdmFyIGYgPSBwbHVyYWxGb3JtKG51bWJlciksXHJcbiAgICAgICAgICAgIHN0ciA9IHBsdXJhbHNbdV1bcGx1cmFsRm9ybShudW1iZXIpXTtcclxuICAgICAgICBpZiAoZiA9PT0gMikge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHJbd2l0aG91dFN1ZmZpeCA/IDAgOiAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xyXG4gICAgfTtcclxufTtcclxudmFyIG1vbnRocyA9IFtcclxuICAgICfZg9in2YbZiNmGINin2YTYq9in2YbZiiDZitmG2KfZitixJyxcclxuICAgICfYtNio2KfYtyDZgdio2LHYp9mK2LEnLFxyXG4gICAgJ9ii2LDYp9ixINmF2KfYsdizJyxcclxuICAgICfZhtmK2LPYp9mGINij2KjYsdmK2YQnLFxyXG4gICAgJ9ij2YrYp9ixINmF2KfZitmIJyxcclxuICAgICfYrdiy2YrYsdin2YYg2YrZiNmG2YrZiCcsXHJcbiAgICAn2KrZhdmI2LIg2YrZiNmE2YrZiCcsXHJcbiAgICAn2KLYqCDYo9i62LPYt9izJyxcclxuICAgICfYo9mK2YTZiNmEINiz2KjYqtmF2KjYsScsXHJcbiAgICAn2KrYtNix2YrZhiDYp9mE2KPZiNmEINij2YPYqtmI2KjYsScsXHJcbiAgICAn2KrYtNix2YrZhiDYp9mE2KvYp9mG2Yog2YbZiNmB2YXYqNixJyxcclxuICAgICfZg9in2YbZiNmGINin2YTYo9mI2YQg2K/Zitiz2YXYqNixJ1xyXG5dO1xyXG5cclxudmFyIGFyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYXInLCB7XHJcbiAgICBtb250aHMgOiBtb250aHMsXHJcbiAgICBtb250aHNTaG9ydCA6IG1vbnRocyxcclxuICAgIHdlZWtkYXlzIDogJ9in2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfYrV/Zhl/Yq1/YsV/Yrl/YrF/Ysycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0QvXFx1MjAwRk0vXFx1MjAwRllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv2LV82YUvLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAn2YUnID09PSBpbnB1dDtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2LUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2YUnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9in2YTZitmI2YUg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb2LrYr9mL2Kcg2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb2LnZhtivINin2YTYs9in2LnYqV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb2KPZhdizINi52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW9i52YbYryDYp9mE2LPYp9i52KldIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfYqNi52K8gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAn2YXZhtiwICVzJyxcclxuICAgICAgICBzIDogcGx1cmFsaXplKCdzJyksXHJcbiAgICAgICAgbSA6IHBsdXJhbGl6ZSgnbScpLFxyXG4gICAgICAgIG1tIDogcGx1cmFsaXplKCdtJyksXHJcbiAgICAgICAgaCA6IHBsdXJhbGl6ZSgnaCcpLFxyXG4gICAgICAgIGhoIDogcGx1cmFsaXplKCdoJyksXHJcbiAgICAgICAgZCA6IHBsdXJhbGl6ZSgnZCcpLFxyXG4gICAgICAgIGRkIDogcGx1cmFsaXplKCdkJyksXHJcbiAgICAgICAgTSA6IHBsdXJhbGl6ZSgnTScpLFxyXG4gICAgICAgIE1NIDogcGx1cmFsaXplKCdNJyksXHJcbiAgICAgICAgeSA6IHBsdXJhbGl6ZSgneScpLFxyXG4gICAgICAgIHl5IDogcGx1cmFsaXplKCd5JylcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW9mh2aLZo9mk2aXZptmn2ajZqdmgXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XHJcbiAgICAgICAgfSkucmVwbGFjZSgv2IwvZywgJywnKTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pLnJlcGxhY2UoLywvZywgJ9iMJyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGFyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9hci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEF6ZXJiYWlqYW5pIFthel1cclxuLy8hIGF1dGhvciA6IHRvcGNoaXlldiA6IGh0dHBzOi8vZ2l0aHViLmNvbS90b3BjaGl5ZXZcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzdWZmaXhlcyA9IHtcclxuICAgIDE6ICctaW5jaScsXHJcbiAgICA1OiAnLWluY2knLFxyXG4gICAgODogJy1pbmNpJyxcclxuICAgIDcwOiAnLWluY2knLFxyXG4gICAgODA6ICctaW5jaScsXHJcbiAgICAyOiAnLW5jaScsXHJcbiAgICA3OiAnLW5jaScsXHJcbiAgICAyMDogJy1uY2knLFxyXG4gICAgNTA6ICctbmNpJyxcclxuICAgIDM6ICctw7xuY8O8JyxcclxuICAgIDQ6ICctw7xuY8O8JyxcclxuICAgIDEwMDogJy3DvG5jw7wnLFxyXG4gICAgNjogJy1uY8SxJyxcclxuICAgIDk6ICctdW5jdScsXHJcbiAgICAxMDogJy11bmN1JyxcclxuICAgIDMwOiAnLXVuY3UnLFxyXG4gICAgNjA6ICctxLFuY8SxJyxcclxuICAgIDkwOiAnLcSxbmPEsSdcclxufTtcclxuXHJcbnZhciBheiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2F6Jywge1xyXG4gICAgbW9udGhzIDogJ3lhbnZhcl9mZXZyYWxfbWFydF9hcHJlbF9tYXlfaXl1bl9peXVsX2F2cXVzdF9zZW50eWFicl9va3R5YWJyX25veWFicl9kZWthYnInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICd5YW5fZmV2X21hcl9hcHJfbWF5X2l5bl9peWxfYXZxX3Nlbl9va3Rfbm95X2Rlaycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ0JhemFyX0JhemFyIGVydMmZc2lfw4fJmXLFn8mZbmLJmSBheMWfYW3EsV/Dh8mZcsWfyZluYsmZX0PDvG3JmSBheMWfYW3EsV9Dw7xtyZlfxZ7JmW5iyZknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0Jhel9CekVfw4dBeF/Dh8mZcl9DQXhfQ8O8bV/FnsmZbicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0J6X0JFX8OHQV/Dh8mZX0NBX0PDvF/FnsmZJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tidWfDvG4gc2FhdF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW3NhYmFoIHNhYXRdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdbZ8mZbMmZbiBoyZlmdMmZXSBkZGRkIFtzYWF0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbZMO8bsmZbl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1trZcOnyZluIGjJmWZ0yZldIGRkZGQgW3NhYXRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMgc29ucmEnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgyZl2dsmZbCcsXHJcbiAgICAgICAgcyA6ICdiaXJuZcOnyZkgc2FuaXl5yZknLFxyXG4gICAgICAgIG0gOiAnYmlyIGTJmXFpccmZJyxcclxuICAgICAgICBtbSA6ICclZCBkyZlxaXHJmScsXHJcbiAgICAgICAgaCA6ICdiaXIgc2FhdCcsXHJcbiAgICAgICAgaGggOiAnJWQgc2FhdCcsXHJcbiAgICAgICAgZCA6ICdiaXIgZ8O8bicsXHJcbiAgICAgICAgZGQgOiAnJWQgZ8O8bicsXHJcbiAgICAgICAgTSA6ICdiaXIgYXknLFxyXG4gICAgICAgIE1NIDogJyVkIGF5JyxcclxuICAgICAgICB5IDogJ2JpciBpbCcsXHJcbiAgICAgICAgeXkgOiAnJWQgaWwnXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL2dlY8mZfHPJmWjJmXJ8Z8O8bmTDvHp8YXjFn2FtLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL14oZ8O8bmTDvHp8YXjFn2FtKSQvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2dlY8mZJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3PJmWjJmXInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZ8O8bmTDvHonO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnYXjFn2FtJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjEsW5jxLF8aW5jaXxuY2l8w7xuY8O8fG5jxLF8dW5jdSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7ICAvLyBzcGVjaWFsIGNhc2UgZm9yIHplcm9cclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICctxLFuY8SxJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgYiA9IG51bWJlciAlIDEwMCAtIGEsXHJcbiAgICAgICAgICAgIGMgPSBudW1iZXIgPj0gMTAwID8gMTAwIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgKHN1ZmZpeGVzW2FdIHx8IHN1ZmZpeGVzW2JdIHx8IHN1ZmZpeGVzW2NdKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYXo7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2F6LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2F6LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQmVsYXJ1c2lhbiBbYmVdXHJcbi8vISBhdXRob3IgOiBEbWl0cnkgRGVtaWRvdiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9kZW1pZG92OTFcclxuLy8hIGF1dGhvcjogUHJhbGVza2E6IGh0dHA6Ly9wcmFsZXNrYS5wcm8vXHJcbi8vISBBdXRob3IgOiBNZW5lbGlvbiBFbGVuc8O6bGUgOiBodHRwczovL2dpdGh1Yi5jb20vT2lyZVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcGx1cmFsKHdvcmQsIG51bSkge1xyXG4gICAgdmFyIGZvcm1zID0gd29yZC5zcGxpdCgnXycpO1xyXG4gICAgcmV0dXJuIG51bSAlIDEwID09PSAxICYmIG51bSAlIDEwMCAhPT0gMTEgPyBmb3Jtc1swXSA6IChudW0gJSAxMCA+PSAyICYmIG51bSAlIDEwIDw9IDQgJiYgKG51bSAlIDEwMCA8IDEwIHx8IG51bSAlIDEwMCA+PSAyMCkgPyBmb3Jtc1sxXSA6IGZvcm1zWzJdKTtcclxufVxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdtbSc6IHdpdGhvdXRTdWZmaXggPyAn0YXQstGW0LvRltC90LBf0YXQstGW0LvRltC90Ytf0YXQstGW0LvRltC9JyA6ICfRhdCy0ZbQu9GW0L3Rg1/RhdCy0ZbQu9GW0L3Ri1/RhdCy0ZbQu9GW0L0nLFxyXG4gICAgICAgICdoaCc6IHdpdGhvdXRTdWZmaXggPyAn0LPQsNC00LfRltC90LBf0LPQsNC00LfRltC90Ytf0LPQsNC00LfRltC9JyA6ICfQs9Cw0LTQt9GW0L3Rg1/Qs9Cw0LTQt9GW0L3Ri1/Qs9Cw0LTQt9GW0L0nLFxyXG4gICAgICAgICdkZCc6ICfQtNC30LXQvdGMX9C00L3Rll/QtNC30ZHQvScsXHJcbiAgICAgICAgJ01NJzogJ9C80LXRgdGP0YZf0LzQtdGB0Y/RhtGLX9C80LXRgdGP0YbQsNGeJyxcclxuICAgICAgICAneXknOiAn0LPQvtC0X9Cz0LDQtNGLX9Cz0LDQtNC+0Z4nXHJcbiAgICB9O1xyXG4gICAgaWYgKGtleSA9PT0gJ20nKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0YXQstGW0LvRltC90LAnIDogJ9GF0LLRltC70ZbQvdGDJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ2gnKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAn0LPQsNC00LfRltC90LAnIDogJ9Cz0LDQtNC30ZbQvdGDJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBwbHVyYWwoZm9ybWF0W2tleV0sICtudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYmUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdiZScsIHtcclxuICAgIG1vbnRocyA6IHtcclxuICAgICAgICBmb3JtYXQ6ICfRgdGC0YPQtNC30LXQvdGPX9C70Y7RgtCw0LPQsF/RgdCw0LrQsNCy0ZbQutCwX9C60YDQsNGB0LDQstGW0LrQsF/RgtGA0LDRntC90Y9f0YfRjdGA0LLQtdC90Y9f0LvRltC/0LXQvdGPX9C20L3RltGe0L3Rj1/QstC10YDQsNGB0L3Rj1/QutCw0YHRgtGA0YvRh9C90ZbQutCwX9C70ZbRgdGC0LDQv9Cw0LTQsF/RgdC90LXQttC90Y8nLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ9GB0YLRg9C00LfQtdC90Yxf0LvRjtGC0Ytf0YHQsNC60LDQstGW0Lpf0LrRgNCw0YHQsNCy0ZbQul/RgtGA0LDQstC10L3RjF/Rh9GN0YDQstC10L3RjF/Qu9GW0L/QtdC90Yxf0LbQvdGW0LLQtdC90Yxf0LLQtdGA0LDRgdC10L3RjF/QutCw0YHRgtGA0YvRh9C90ZbQul/Qu9GW0YHRgtCw0L/QsNC0X9GB0L3QtdC20LDQvdGMJy5zcGxpdCgnXycpXHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiAn0YHRgtGD0LRf0LvRjtGCX9GB0LDQul/QutGA0LDRgV/RgtGA0LDQsl/Rh9GN0YDQsl/Qu9GW0L9f0LbQvdGW0LJf0LLQtdGAX9C60LDRgdGCX9C70ZbRgdGCX9GB0L3QtdC2Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiB7XHJcbiAgICAgICAgZm9ybWF0OiAn0L3Rj9C00LfQtdC70Y5f0L/QsNC90Y/QtNC30LXQu9Cw0Lpf0LDRntGC0L7RgNCw0Lpf0YHQtdGA0LDQtNGDX9GH0LDRhtCy0LXRgF/Qv9GP0YLQvdGW0YbRg1/RgdGD0LHQvtGC0YMnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ9C90Y/QtNC30LXQu9GPX9C/0LDQvdGP0LTQt9C10LvQsNC6X9Cw0Z7RgtC+0YDQsNC6X9GB0LXRgNCw0LTQsF/Rh9Cw0YbQstC10YBf0L/Rj9GC0L3RltGG0LBf0YHRg9Cx0L7RgtCwJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIGlzRm9ybWF0OiAvXFxbID9b0JLQsl0gPyg/OtC80ZbQvdGD0LvRg9GOfNC90LDRgdGC0YPQv9C90YPRjik/ID9cXF0gP2RkZGQvXHJcbiAgICB9LFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQvdC0X9C/0L1f0LDRgl/RgdGAX9GH0YZf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn0L3QtF/Qv9C9X9Cw0YJf0YHRgF/Rh9GGX9C/0YJf0YHQsScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVkg0LMuJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkg0LMuLCBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSDQsy4sIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb0KHRkdC90L3RjyDRnl0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb0JfQsNGe0YLRgNCwINGeXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1vQo9GH0L7RgNCwINGeXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdb0KNdIGRkZGQgW9GeXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQoyDQvNGW0L3Rg9C70YPRjl0gZGRkZCBb0Z5dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQoyDQvNGW0L3Rg9C70YtdIGRkZGQgW9GeXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9C/0YDQsNC3ICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzINGC0LDQvNGDJyxcclxuICAgICAgICBzIDogJ9C90LXQutCw0LvRjNC60ZYg0YHQtdC60YPQvdC0JyxcclxuICAgICAgICBtIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgaGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGQgOiAn0LTQt9C10L3RjCcsXHJcbiAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIE0gOiAn0LzQtdGB0Y/RhicsXHJcbiAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIHkgOiAn0LPQvtC0JyxcclxuICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0Yt80YDQsNC90ZbRhtGLfNC00L3Rj3zQstC10YfQsNGA0LAvLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAvXijQtNC90Y980LLQtdGH0LDRgNCwKSQvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9GLJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9GA0LDQvdGW0YbRiyc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQtNC90Y8nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn0LLQtdGH0LDRgNCwJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjRlnzRi3zQs9CwKS8sXHJcbiAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAobnVtYmVyICUgMTAgPT09IDIgfHwgbnVtYmVyICUgMTAgPT09IDMpICYmIChudW1iZXIgJSAxMDAgIT09IDEyICYmIG51bWJlciAlIDEwMCAhPT0gMTMpID8gbnVtYmVyICsgJy3RlicgOiBudW1iZXIgKyAnLdGLJztcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Qs9CwJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBiZTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBCdWxnYXJpYW4gW2JnXVxyXG4vLyEgYXV0aG9yIDogS3Jhc2VuIEJvcmlzb3YgOiBodHRwczovL2dpdGh1Yi5jb20va3JhelxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGJnID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYmcnLCB7XHJcbiAgICBtb250aHMgOiAn0Y/QvdGD0LDRgNC4X9GE0LXQstGA0YPQsNGA0Lhf0LzQsNGA0YJf0LDQv9GA0LjQu1/QvNCw0Llf0Y7QvdC4X9GO0LvQuF/QsNCy0LPRg9GB0YJf0YHQtdC/0YLQtdC80LLRgNC4X9C+0LrRgtC+0LzQstGA0Lhf0L3QvtC10LzQstGA0Lhf0LTQtdC60LXQvNCy0YDQuCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9GP0L3RgF/RhNC10LJf0LzQsNGAX9Cw0L/RgF/QvNCw0Llf0Y7QvdC4X9GO0LvQuF/QsNCy0LNf0YHQtdC/X9C+0LrRgl/QvdC+0LVf0LTQtdC6Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn0L3QtdC00LXQu9GPX9C/0L7QvdC10LTQtdC70L3QuNC6X9Cy0YLQvtGA0L3QuNC6X9GB0YDRj9C00LBf0YfQtdGC0LLRitGA0YLRitC6X9C/0LXRgtGK0Lpf0YHRitCx0L7RgtCwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQvdC10LRf0L/QvtC9X9Cy0YLQvl/RgdGA0Y9f0YfQtdGCX9C/0LXRgl/RgdGK0LEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnRC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vQlNC90LXRgSDQsl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9Cj0YLRgNC1INCyXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0LJdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vQktGH0LXRgNCwINCyXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC40LfQvNC40L3QsNC70LDRgtCwXSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC40LfQvNC40L3QsNC70LjRj10gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9GB0LvQtdC0ICVzJyxcclxuICAgICAgICBwYXN0IDogJ9C/0YDQtdC00LggJXMnLFxyXG4gICAgICAgIHMgOiAn0L3Rj9C60L7Qu9C60L4g0YHQtdC60YPQvdC00LgnLFxyXG4gICAgICAgIG0gOiAn0LzQuNC90YPRgtCwJyxcclxuICAgICAgICBtbSA6ICclZCDQvNC40L3Rg9GC0LgnLFxyXG4gICAgICAgIGggOiAn0YfQsNGBJyxcclxuICAgICAgICBoaCA6ICclZCDRh9Cw0YHQsCcsXHJcbiAgICAgICAgZCA6ICfQtNC10L0nLFxyXG4gICAgICAgIGRkIDogJyVkINC00L3QuCcsXHJcbiAgICAgICAgTSA6ICfQvNC10YHQtdGGJyxcclxuICAgICAgICBNTSA6ICclZCDQvNC10YHQtdGG0LAnLFxyXG4gICAgICAgIHkgOiAn0LPQvtC00LjQvdCwJyxcclxuICAgICAgICB5eSA6ICclZCDQs9C+0LTQuNC90LgnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjQtdCyfNC10L180YLQuHzQstC4fNGA0Lh80LzQuCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgbGFzdERpZ2l0ID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIGxhc3QyRGlnaXRzID0gbnVtYmVyICUgMTAwO1xyXG4gICAgICAgIGlmIChudW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQsic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0MkRpZ2l0cyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QtdC9JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3QyRGlnaXRzID4gMTAgJiYgbGFzdDJEaWdpdHMgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgtC4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QstC4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgNC4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNyB8fCBsYXN0RGlnaXQgPT09IDgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LzQuCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBiZztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYmcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBCYW1iYXJhIFtibV1cclxuLy8hIGF1dGhvciA6IEVzdGVsbGUgQ29tbWVudCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RlbGxlY29tbWVudFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG4vLyBMYW5ndWFnZSBjb250YWN0IHBlcnNvbiA6IEFiZG91ZmF0YSBLYW5lIDogaHR0cHM6Ly9naXRodWIuY29tL2FiZG91ZmF0YVxyXG5cclxudmFyIGJtID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYm0nLCB7XHJcbiAgICBtb250aHMgOiAnWmFud3V5ZWthbG9fRmV3dXJ1eWVrYWxvX01hcmlzaWthbG9fQXdpcmlsaWthbG9fTcmba2Fsb19adXfJm25rYWxvX1p1bHV5ZWthbG9fVXRpa2Fsb19TyZt0YW5idXJ1a2Fsb1/JlGt1dMmUYnVydWthbG9fTm93YW5idXJ1a2Fsb19EZXNhbmJ1cnVrYWxvJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnWmFuX0Zld19NYXJfQXdpX03Jm19adXdfWnVsX1V0aV9TyZt0X8mUa3VfTm93X0Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ0thcmlfTnTJm27Jm25fVGFyYXRhX0FyYWJhX0FsYW1pc2FfSnVtYV9TaWJpcmknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0thcl9OdMmbX1Rhcl9BcmFfQWxhX0p1bV9TaWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdLYV9OdF9UYV9Bcl9BbF9KdV9TaScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnTU1NTSBbdGlsZV0gRCBbc2FuXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnTU1NTSBbdGlsZV0gRCBbc2FuXSBZWVlZIFtsyZtyyZtdIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgTU1NTSBbdGlsZV0gRCBbc2FuXSBZWVlZIFtsyZtyyZtdIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0JpIGzJm3LJm10gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1NpbmkgbMmbcsmbXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbZG9uIGzJm3LJm10gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0t1bnUgbMmbcsmbXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbdMmbbcmbbmVuIGzJm3LJm10gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyBryZRuyZQnLFxyXG4gICAgICAgIHBhc3QgOiAnYSBiyZsgJXMgYsmUJyxcclxuICAgICAgICBzIDogJ3NhbmdhIGRhbWEgZGFtYScsXHJcbiAgICAgICAgbSA6ICdtaW5pdGkga2VsZW4nLFxyXG4gICAgICAgIG1tIDogJ21pbml0aSAlZCcsXHJcbiAgICAgICAgaCA6ICdsyZtyyZsga2VsZW4nLFxyXG4gICAgICAgIGhoIDogJ2zJm3LJmyAlZCcsXHJcbiAgICAgICAgZCA6ICd0aWxlIGtlbGVuJyxcclxuICAgICAgICBkZCA6ICd0aWxlICVkJyxcclxuICAgICAgICBNIDogJ2thbG8ga2VsZW4nLFxyXG4gICAgICAgIE1NIDogJ2thbG8gJWQnLFxyXG4gICAgICAgIHkgOiAnc2FuIGtlbGVuJyxcclxuICAgICAgICB5eSA6ICdzYW4gJWQnXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGJtO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEJlbmdhbGkgW2JuXVxyXG4vLyEgYXV0aG9yIDogS2F1c2hpayBHYW5kaGkgOiBodHRwczovL2dpdGh1Yi5jb20va2F1c2hpa2dhbmRoaVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+CnpycsXHJcbiAgICAnMic6ICfgp6gnLFxyXG4gICAgJzMnOiAn4KepJyxcclxuICAgICc0JzogJ+CnqicsXHJcbiAgICAnNSc6ICfgp6snLFxyXG4gICAgJzYnOiAn4KesJyxcclxuICAgICc3JzogJ+CnrScsXHJcbiAgICAnOCc6ICfgp64nLFxyXG4gICAgJzknOiAn4KevJyxcclxuICAgICcwJzogJ+CnpidcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfgp6cnOiAnMScsXHJcbiAgICAn4KeoJzogJzInLFxyXG4gICAgJ+CnqSc6ICczJyxcclxuICAgICfgp6onOiAnNCcsXHJcbiAgICAn4KerJzogJzUnLFxyXG4gICAgJ+CnrCc6ICc2JyxcclxuICAgICfgp60nOiAnNycsXHJcbiAgICAn4KeuJzogJzgnLFxyXG4gICAgJ+Cnryc6ICc5JyxcclxuICAgICfgp6YnOiAnMCdcclxufTtcclxuXHJcbnZhciBibiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2JuJywge1xyXG4gICAgbW9udGhzIDogJ+CmnOCmvuCmqOCngeCnn+CmvuCmsOCngF/gpqvgp4fgpqzgp43gprDgp4Hgp5/gpr7gprDgpr9f4Kau4Ka+4Kaw4KeN4KaaX+Cmj+CmquCnjeCmsOCmv+Cmsl/gpq7gp4df4Kac4KeB4KaoX+CmnOCngeCmsuCmvuCmh1/gpobgppfgprjgp43gpp9f4Ka44KeH4Kaq4KeN4Kaf4KeH4Kau4KeN4Kas4KawX+CmheCmleCnjeCmn+Cni+CmrOCmsF/gpqjgpq3gp4fgpq7gp43gpqzgprBf4Kah4Ka/4Ka44KeH4Kau4KeN4Kas4KawJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4Kac4Ka+4Kao4KeBX+Cmq+Cnh+CmrF/gpq7gpr7gprDgp43gpppf4KaP4Kaq4KeN4KawX+CmruCnh1/gppzgp4Hgpqhf4Kac4KeB4KayX+CmhuCml1/gprjgp4fgpqrgp43gpp9f4KaF4KaV4KeN4Kaf4KeLX+CmqOCmreCnh1/gpqHgpr/gprjgp4cnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfgprDgpqzgpr/gpqzgpr7gprBf4Ka44KeL4Kau4Kas4Ka+4KawX+CmruCmmeCnjeCml+CmsuCmrOCmvuCmsF/gpqzgp4Hgpqfgpqzgpr7gprBf4Kas4KeD4Ka54Ka44KeN4Kaq4Kak4Ka/4Kas4Ka+4KawX+CmtuCngeCmleCnjeCmsOCmrOCmvuCmsF/gprbgpqjgpr/gpqzgpr7gprAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+CmsOCmrOCmv1/gprjgp4vgpq5f4Kau4KaZ4KeN4KaX4KayX+CmrOCngeCmp1/gpqzgp4Pgprngprjgp43gpqrgpqTgpr9f4Ka24KeB4KaV4KeN4KawX+CmtuCmqOCmvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+CmsOCmrOCmv1/gprjgp4vgpq5f4Kau4KaZ4KeN4KaXX+CmrOCngeCmp1/gpqzgp4PgprngpoNf4Ka24KeB4KaV4KeN4KawX+CmtuCmqOCmvycuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbSDgprjgpq7gp58nLFxyXG4gICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4Ka44Kau4KefJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgprjgpq7gp58nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSDgprjgpq7gp58nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4KaG4KacXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4KaG4KaX4Ka+4Kau4KeA4KaV4Ka+4KayXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+Cml+CmpOCmleCmvuCmsl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgppfgpqRdIGRkZGQsIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg4Kaq4Kaw4KeHJyxcclxuICAgICAgICBwYXN0IDogJyVzIOCmhuCml+CnhycsXHJcbiAgICAgICAgcyA6ICfgppXgp5/gp4fgppUg4Ka44KeH4KaV4KeH4Kao4KeN4KahJyxcclxuICAgICAgICBtIDogJ+Cmj+CmlSDgpq7gpr/gpqjgpr/gpp8nLFxyXG4gICAgICAgIG1tIDogJyVkIOCmruCmv+CmqOCmv+CmnycsXHJcbiAgICAgICAgaCA6ICfgpo/gppUg4KaY4Kao4KeN4Kaf4Ka+JyxcclxuICAgICAgICBoaCA6ICclZCDgppjgpqjgp43gpp/gpr4nLFxyXG4gICAgICAgIGQgOiAn4KaP4KaVIOCmpuCmv+CmqCcsXHJcbiAgICAgICAgZGQgOiAnJWQg4Kam4Ka/4KaoJyxcclxuICAgICAgICBNIDogJ+Cmj+CmlSDgpq7gpr7gprgnLFxyXG4gICAgICAgIE1NIDogJyVkIOCmruCmvuCmuCcsXHJcbiAgICAgICAgeSA6ICfgpo/gppUg4Kas4Kab4KawJyxcclxuICAgICAgICB5eSA6ICclZCDgpqzgppvgprAnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vgp6fgp6jgp6ngp6rgp6vgp6zgp63gp67gp6/gp6ZdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXGQvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gprDgpr7gpqR84Ka44KaV4Ka+4KayfOCmpuCngeCmquCngeCmsHzgpqzgpr/gppXgpr7gprJ84Kaw4Ka+4KakLyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChtZXJpZGllbSA9PT0gJ+CmsOCmvuCmpCcgJiYgaG91ciA+PSA0KSB8fFxyXG4gICAgICAgICAgICAgICAgKG1lcmlkaWVtID09PSAn4Kam4KeB4Kaq4KeB4KawJyAmJiBob3VyIDwgNSkgfHxcclxuICAgICAgICAgICAgICAgIG1lcmlkaWVtID09PSAn4Kas4Ka/4KaV4Ka+4KayJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgprDgpr7gpqQnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Ka44KaV4Ka+4KayJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CmpuCngeCmquCngeCmsCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpqzgpr/gppXgpr7gprInO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kaw4Ka+4KakJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGJuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ibi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFRpYmV0YW4gW2JvXVxyXG4vLyEgYXV0aG9yIDogVGh1cHRlbiBOLiBDaGFrcmlzaGFyIDogaHR0cHM6Ly9naXRodWIuY29tL3ZhanJhZG9nXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAn4LyhJyxcclxuICAgICcyJzogJ+C8oicsXHJcbiAgICAnMyc6ICfgvKMnLFxyXG4gICAgJzQnOiAn4LykJyxcclxuICAgICc1JzogJ+C8pScsXHJcbiAgICAnNic6ICfgvKYnLFxyXG4gICAgJzcnOiAn4LynJyxcclxuICAgICc4JzogJ+C8qCcsXHJcbiAgICAnOSc6ICfgvKknLFxyXG4gICAgJzAnOiAn4LygJ1xyXG59O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgJ+C8oSc6ICcxJyxcclxuICAgICfgvKInOiAnMicsXHJcbiAgICAn4LyjJzogJzMnLFxyXG4gICAgJ+C8pCc6ICc0JyxcclxuICAgICfgvKUnOiAnNScsXHJcbiAgICAn4LymJzogJzYnLFxyXG4gICAgJ+C8pyc6ICc3JyxcclxuICAgICfgvKgnOiAnOCcsXHJcbiAgICAn4LypJzogJzknLFxyXG4gICAgJ+C8oCc6ICcwJ1xyXG59O1xyXG5cclxudmFyIGJvID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYm8nLCB7XHJcbiAgICBtb250aHMgOiAn4L2f4L6z4LyL4L2W4LyL4L2R4L2E4LyL4L2U4L28X+C9n+C+s+C8i+C9luC8i+C9guC9ieC9suC9puC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvYLgvabgvbTgvZjgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2e4L2y4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9o+C+lOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZHgvrLgvbTgvYLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2R4L204L2T4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9ouC+kuC+seC9keC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZHgvYLgvbTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9guC9heC9suC9guC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvYLgvYngvbLgvabgvIvgvZQnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfgvZ/gvrPgvIvgvZbgvIvgvZHgvYTgvIvgvZTgvbxf4L2f4L6z4LyL4L2W4LyL4L2C4L2J4L2y4L2m4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9guC9puC9tOC9mOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvZ7gvbLgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2j4L6U4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9keC+suC9tOC9guC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvZHgvbTgvZPgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2i4L6S4L6x4L2R4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9keC9guC9tOC8i+C9lF/gvZ/gvrPgvIvgvZbgvIvgvZbgvYXgvbTgvIvgvZRf4L2f4L6z4LyL4L2W4LyL4L2W4L2F4L204LyL4L2C4L2F4L2y4L2C4LyL4L2UX+C9n+C+s+C8i+C9luC8i+C9luC9heC9tOC8i+C9guC9ieC9suC9puC8i+C9lCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ+C9guC9n+C9oOC8i+C9ieC9suC8i+C9mOC8i1/gvYLgvZ/gvaDgvIvgvZ/gvrPgvIvgvZbgvItf4L2C4L2f4L2g4LyL4L2Y4L2y4L2C4LyL4L2R4L2Y4L2i4LyLX+C9guC9n+C9oOC8i+C9o+C+t+C9guC8i+C9lOC8i1/gvYLgvZ/gvaDgvIvgvZXgvbTgvaLgvIvgvZbgvbRf4L2C4L2f4L2g4LyL4L2U4LyL4L2m4L2E4L2m4LyLX+C9guC9n+C9oOC8i+C9puC+pOC9uuC9k+C8i+C9lOC8iycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4L2J4L2y4LyL4L2Y4LyLX+C9n+C+s+C8i+C9luC8i1/gvZjgvbLgvYLgvIvgvZHgvZjgvaLgvItf4L2j4L634L2C4LyL4L2U4LyLX+C9leC9tOC9ouC8i+C9luC9tF/gvZTgvIvgvabgvYTgvabgvItf4L2m4L6k4L264L2T4LyL4L2U4LyLJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn4L2J4L2y4LyL4L2Y4LyLX+C9n+C+s+C8i+C9luC8i1/gvZjgvbLgvYLgvIvgvZHgvZjgvaLgvItf4L2j4L634L2C4LyL4L2U4LyLX+C9leC9tOC9ouC8i+C9luC9tF/gvZTgvIvgvabgvYTgvabgvItf4L2m4L6k4L264L2T4LyL4L2U4LyLJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnQSBoOm1tJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+C9keC9suC8i+C9ouC9suC9hF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+C9puC9hOC8i+C9ieC9suC9k10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vgvZbgvZHgvbTgvZPgvIvgvZXgvrLgvYLgvIvgvaLgvpfgvbrgvabgvIvgvZhdLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4L2B4LyL4L2m4L2EXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+C9luC9keC9tOC9k+C8i+C9leC+suC9guC8i+C9mOC9kOC9oOC8i+C9mF0gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDgvaPgvIsnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4L2m4L6U4L2T4LyL4L2jJyxcclxuICAgICAgICBzIDogJ+C9o+C9mOC8i+C9puC9hCcsXHJcbiAgICAgICAgbSA6ICfgvabgvpDgvaLgvIvgvZjgvIvgvYLgvYXgvbLgvYInLFxyXG4gICAgICAgIG1tIDogJyVkIOC9puC+kOC9ouC8i+C9mCcsXHJcbiAgICAgICAgaCA6ICfgvYbgvbTgvIvgvZrgvbzgvZHgvIvgvYLgvYXgvbLgvYInLFxyXG4gICAgICAgIGhoIDogJyVkIOC9huC9tOC8i+C9muC9vOC9kScsXHJcbiAgICAgICAgZCA6ICfgvYngvbLgvZPgvIvgvYLgvYXgvbLgvYInLFxyXG4gICAgICAgIGRkIDogJyVkIOC9ieC9suC9k+C8iycsXHJcbiAgICAgICAgTSA6ICfgvZ/gvrPgvIvgvZbgvIvgvYLgvYXgvbLgvYInLFxyXG4gICAgICAgIE1NIDogJyVkIOC9n+C+s+C8i+C9licsXHJcbiAgICAgICAgeSA6ICfgvaPgvbzgvIvgvYLgvYXgvbLgvYInLFxyXG4gICAgICAgIHl5IDogJyVkIOC9o+C9vCdcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+C8oeC8ouC8o+C8pOC8peC8puC8p+C8qOC8qeC8oF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+C9mOC9muC9k+C8i+C9mOC9vHzgvZ7gvbzgvYLgvabgvIvgvYDgvaZ84L2J4L2y4L2T4LyL4L2C4L204L2EfOC9keC9guC9vOC9hOC8i+C9keC9gnzgvZjgvZrgvZPgvIvgvZjgvbwvLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKG1lcmlkaWVtID09PSAn4L2Y4L2a4L2T4LyL4L2Y4L28JyAmJiBob3VyID49IDQpIHx8XHJcbiAgICAgICAgICAgICAgICAobWVyaWRpZW0gPT09ICfgvYngvbLgvZPgvIvgvYLgvbTgvYQnICYmIGhvdXIgPCA1KSB8fFxyXG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfgvZHgvYLgvbzgvYTgvIvgvZHgvYInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C9mOC9muC9k+C8i+C9mOC9vCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgvZ7gvbzgvYLgvabgvIvgvYDgvaYnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4L2J4L2y4L2T4LyL4L2C4L204L2EJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C9keC9guC9vOC9hOC8i+C9keC9gic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgvZjgvZrgvZPgvIvgvZjgvbwnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYm87XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JvLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQnJldG9uIFticl1cclxuLy8hIGF1dGhvciA6IEplYW4tQmFwdGlzdGUgTGUgRHVpZ291IDogaHR0cHM6Ly9naXRodWIuY29tL2pibGVkdWlnb3VcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhNdXRhdGlvbihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAnbW0nOiAnbXVudXRlbm4nLFxyXG4gICAgICAgICdNTSc6ICdtaXonLFxyXG4gICAgICAgICdkZCc6ICdkZXZlemgnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG51bWJlciArICcgJyArIG11dGF0aW9uKGZvcm1hdFtrZXldLCBudW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIHNwZWNpYWxNdXRhdGlvbkZvclllYXJzKG51bWJlcikge1xyXG4gICAgc3dpdGNoIChsYXN0TnVtYmVyKG51bWJlcikpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyBibG9heic7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgdmxvYXonO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxhc3ROdW1iZXIobnVtYmVyKSB7XHJcbiAgICBpZiAobnVtYmVyID4gOSkge1xyXG4gICAgICAgIHJldHVybiBsYXN0TnVtYmVyKG51bWJlciAlIDEwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudW1iZXI7XHJcbn1cclxuZnVuY3Rpb24gbXV0YXRpb24odGV4dCwgbnVtYmVyKSB7XHJcbiAgICBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvZnRNdXRhdGlvbih0ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHNvZnRNdXRhdGlvbih0ZXh0KSB7XHJcbiAgICB2YXIgbXV0YXRpb25UYWJsZSA9IHtcclxuICAgICAgICAnbSc6ICd2JyxcclxuICAgICAgICAnYic6ICd2JyxcclxuICAgICAgICAnZCc6ICd6J1xyXG4gICAgfTtcclxuICAgIGlmIChtdXRhdGlvblRhYmxlW3RleHQuY2hhckF0KDApXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbXV0YXRpb25UYWJsZVt0ZXh0LmNoYXJBdCgwKV0gKyB0ZXh0LnN1YnN0cmluZygxKTtcclxufVxyXG5cclxudmFyIGJyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnYnInLCB7XHJcbiAgICBtb250aHMgOiAnR2VudmVyX0NcXCdod2V2cmVyX01ldXJ6aF9FYnJlbF9NYWVfTWV6aGV2ZW5fR291ZXJlX0Vvc3RfR3dlbmdvbG9fSGVyZV9EdV9LZXJ6dScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0dlbl9DXFwnaHdlX01ldV9FYnJfTWFlX0V2ZV9Hb3VfRW9zX0d3ZV9IZXJfRHVfS2VyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnU3VsX0x1bl9NZXVyemhfTWVyY1xcJ2hlcl9ZYW91X0d3ZW5lcl9TYWRvcm4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bF9MdW5fTWV1X01lcl9ZYW9fR3dlX1NhZCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1N1X0x1X01lX01lcl9ZYV9Hd19TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoW2VdbW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2hbZV1tbTpzcyBBJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgW2Egdml6XSBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIFthIHZpel0gTU1NTSBZWVlZIGhbZV1tbSBBJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2Egdml6XSBNTU1NIFlZWVkgaFtlXW1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbSGl6aXYgZGFdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tXYXJjXFwnaG9hemggZGFdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtkYV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0RlY1xcJ2ggZGFdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtwYXNldCBkYV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdhLWJlbm4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgXFwnem8nLFxyXG4gICAgICAgIHMgOiAndW4gbmViZXVkIHNlZ29uZGVubm/DuScsXHJcbiAgICAgICAgbSA6ICd1ciB2dW51dGVubicsXHJcbiAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoTXV0YXRpb24sXHJcbiAgICAgICAgaCA6ICd1biBldXInLFxyXG4gICAgICAgIGhoIDogJyVkIGV1cicsXHJcbiAgICAgICAgZCA6ICd1biBkZXZlemgnLFxyXG4gICAgICAgIGRkIDogcmVsYXRpdmVUaW1lV2l0aE11dGF0aW9uLFxyXG4gICAgICAgIE0gOiAndXIgbWl6JyxcclxuICAgICAgICBNTSA6IHJlbGF0aXZlVGltZVdpdGhNdXRhdGlvbixcclxuICAgICAgICB5IDogJ3VyIGJsb2F6JyxcclxuICAgICAgICB5eSA6IHNwZWNpYWxNdXRhdGlvbkZvclllYXJzXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGHDsXx2ZXQpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IChudW1iZXIgPT09IDEpID8gJ2HDsScgOiAndmV0JztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBicjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvYnIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBCb3NuaWFuIFtic11cclxuLy8hIGF1dGhvciA6IE5lZGltIENob2xpY2ggOiBodHRwczovL2dpdGh1Yi5jb20vZnJvbnR5YXJkXHJcbi8vISBiYXNlZCBvbiAoaHIpIHRyYW5zbGF0aW9uIGJ5IEJvamFuIE1hcmtvdmnEh1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnamVkbmEgbWludXRhJyA6ICdqZWRuZSBtaW51dGUnO1xyXG4gICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtaW51dGEnO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMiB8fCBudW1iZXIgPT09IDMgfHwgbnVtYmVyID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0ZSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0YSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnamVkYW4gc2F0JyA6ICdqZWRub2cgc2F0YSc7XHJcbiAgICAgICAgY2FzZSAnaGgnOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0YSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3NhdGknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnZGQnOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2Rhbic7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2RhbmEnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnTU0nOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlYyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWplc2VjYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21qZXNlY2knO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2dvZGluYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5lJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5hJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgYnMgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdicycsIHtcclxuICAgIG1vbnRocyA6ICdqYW51YXJfZmVicnVhcl9tYXJ0X2FwcmlsX21hal9qdW5pX2p1bGlfYXVndXN0X3NlcHRlbWJhcl9va3RvYmFyX25vdmVtYmFyX2RlY2VtYmFyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuLl9mZWIuX21hci5fYXByLl9tYWouX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnbmVkamVsamFfcG9uZWRqZWxqYWtfdXRvcmFrX3NyaWplZGFfxI1ldHZydGFrX3BldGFrX3N1Ym90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVkLl9wb24uX3V0by5fc3JpLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICduZV9wb191dF9zcl/EjWVfcGVfc3UnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSAgOiAnW2RhbmFzIHVdIExUJyxcclxuICAgICAgICBuZXh0RGF5ICA6ICdbc3V0cmEgdV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbbmVkamVsanVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3NyaWplZHVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3N1Ym90dV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBkZGRkIFt1XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgIDogJ1tqdcSNZXIgdV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcm/FoWx1XSBkZGRkIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcm/FoWxpXSBkZGRkIFt1XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCAgIDogJ3ByaWplICVzJyxcclxuICAgICAgICBzICAgICAgOiAncGFyIHNla3VuZGknLFxyXG4gICAgICAgIG0gICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtbSAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCAgICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGhoICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkICAgICAgOiAnZGFuJyxcclxuICAgICAgICBkZCAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSAgICAgIDogJ21qZXNlYycsXHJcbiAgICAgICAgTU0gICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxyXG4gICAgICAgIHl5ICAgICA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gYnM7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2JzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ2F0YWxhbiBbY2FdXHJcbi8vISBhdXRob3IgOiBKdWFuIEcuIEh1cnRhZG8gOiBodHRwczovL2dpdGh1Yi5jb20vanVhbmdodXJ0YWRvXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgY2EgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdjYScsIHtcclxuICAgIG1vbnRocyA6IHtcclxuICAgICAgICBzdGFuZGFsb25lOiAnZ2VuZXJfZmVicmVyX21hcsOnX2FicmlsX21haWdfanVueV9qdWxpb2xfYWdvc3Rfc2V0ZW1icmVfb2N0dWJyZV9ub3ZlbWJyZV9kZXNlbWJyZScuc3BsaXQoJ18nKSxcclxuICAgICAgICBmb3JtYXQ6ICdkZSBnZW5lcl9kZSBmZWJyZXJfZGUgbWFyw6dfZFxcJ2FicmlsX2RlIG1haWdfZGUganVueV9kZSBqdWxpb2xfZFxcJ2Fnb3N0X2RlIHNldGVtYnJlX2RcXCdvY3R1YnJlX2RlIG5vdmVtYnJlX2RlIGRlc2VtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIGlzRm9ybWF0OiAvRFtvRF0/KFxccykrTU1NTS9cclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6ICdnZW4uX2ZlYnIuX21hcsOnX2Fici5fbWFpZ19qdW55X2p1bC5fYWcuX3NldC5fb2N0Ll9ub3YuX2Rlcy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2RpdW1lbmdlX2RpbGx1bnNfZGltYXJ0c19kaW1lY3Jlc19kaWpvdXNfZGl2ZW5kcmVzX2Rpc3NhYnRlJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkZy5fZGwuX2R0Ll9kYy5fZGouX2R2Ll9kcy4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdkZ19kbF9kdF9kY19kal9kdl9kcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gW2RlXSBZWVlZJyxcclxuICAgICAgICBsbCA6ICdEIE1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFtkZV0gWVlZWSBbYSBsZXNdIEg6bW0nLFxyXG4gICAgICAgIGxsbCA6ICdEIE1NTSBZWVlZLCBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFtkZV0gWVlZWSBbYSBsZXNdIEg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnZGRkIEQgTU1NIFlZWVksIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbYXZ1aSBhICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnbGVzJyA6ICdsYScpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbZGVtw6AgYSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ2xlcycgOiAnbGEnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQgW2EgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1thaGlyIGEgJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdsZXMnIDogJ2xhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbZWxdIGRkZGQgW3Bhc3NhdCBhICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnbGVzJyA6ICdsYScpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RcXCdhcXXDrSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdmYSAlcycsXHJcbiAgICAgICAgcyA6ICd1bnMgc2Vnb25zJyxcclxuICAgICAgICBtIDogJ3VuIG1pbnV0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dHMnLFxyXG4gICAgICAgIGggOiAndW5hIGhvcmEnLFxyXG4gICAgICAgIGhoIDogJyVkIGhvcmVzJyxcclxuICAgICAgICBkIDogJ3VuIGRpYScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGllcycsXHJcbiAgICAgICAgTSA6ICd1biBtZXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc29zJyxcclxuICAgICAgICB5IDogJ3VuIGFueScsXHJcbiAgICAgICAgeXkgOiAnJWQgYW55cydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0ocnxufHR8w6h8YSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSAobnVtYmVyID09PSAxKSA/ICdyJyA6XHJcbiAgICAgICAgICAgIChudW1iZXIgPT09IDIpID8gJ24nIDpcclxuICAgICAgICAgICAgKG51bWJlciA9PT0gMykgPyAncicgOlxyXG4gICAgICAgICAgICAobnVtYmVyID09PSA0KSA/ICd0JyA6ICfDqCc7XHJcbiAgICAgICAgaWYgKHBlcmlvZCA9PT0gJ3cnIHx8IHBlcmlvZCA9PT0gJ1cnKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9ICdhJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gY2E7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2NhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ3plY2ggW2NzXVxyXG4vLyEgYXV0aG9yIDogcGV0cmJlbGEgOiBodHRwczovL2dpdGh1Yi5jb20vcGV0cmJlbGFcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHMgPSAnbGVkZW5fw7pub3JfYsWZZXplbl9kdWJlbl9rdsSbdGVuX8SNZXJ2ZW5fxI1lcnZlbmVjX3NycGVuX3rDocWZw61fxZnDrWplbl9saXN0b3BhZF9wcm9zaW5lYycuc3BsaXQoJ18nKTtcclxudmFyIG1vbnRoc1Nob3J0ID0gJ2xlZF/Dum5vX2LFmWVfZHViX2t2xJtfxI12bl/EjXZjX3NycF96w6HFmV/FmcOtal9saXNfcHJvJy5zcGxpdCgnXycpO1xyXG5mdW5jdGlvbiBwbHVyYWwobikge1xyXG4gICAgcmV0dXJuIChuID4gMSkgJiYgKG4gPCA1KSAmJiAofn4obiAvIDEwKSAhPT0gMSk7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgY2FzZSAncyc6ICAvLyBhIGZldyBzZWNvbmRzIC8gaW4gYSBmZXcgc2Vjb25kcyAvIGEgZmV3IHNlY29uZHMgYWdvXHJcbiAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAncMOhciBzZWt1bmQnIDogJ3DDoXIgc2VrdW5kYW1pJztcclxuICAgICAgICBjYXNlICdtJzogIC8vIGEgbWludXRlIC8gaW4gYSBtaW51dGUgLyBhIG1pbnV0ZSBhZ29cclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyAnbWludXRhJyA6IChpc0Z1dHVyZSA/ICdtaW51dHUnIDogJ21pbnV0b3UnKTtcclxuICAgICAgICBjYXNlICdtbSc6IC8vIDkgbWludXRlcyAvIGluIDkgbWludXRlcyAvIDkgbWludXRlcyBhZ29cclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbWludXR5JyA6ICdtaW51dCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtaW51dGFtaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaCc6ICAvLyBhbiBob3VyIC8gaW4gYW4gaG91ciAvIGFuIGhvdXIgYWdvXHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2hvZGluYScgOiAoaXNGdXR1cmUgPyAnaG9kaW51JyA6ICdob2Rpbm91Jyk7XHJcbiAgICAgICAgY2FzZSAnaGgnOiAvLyA5IGhvdXJzIC8gaW4gOSBob3VycyAvIDkgaG91cnMgYWdvXHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ2hvZGlueScgOiAnaG9kaW4nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnaG9kaW5hbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2QnOiAgLy8gYSBkYXkgLyBpbiBhIGRheSAvIGEgZGF5IGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ2RlbicgOiAnZG5lbSc7XHJcbiAgICAgICAgY2FzZSAnZGQnOiAvLyA5IGRheXMgLyBpbiA5IGRheXMgLyA5IGRheXMgYWdvXHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ2RueScgOiAnZG7DrScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdkbnknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ00nOiAgLy8gYSBtb250aCAvIGluIGEgbW9udGggLyBhIG1vbnRoIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ23Em3PDrWMnIDogJ23Em3PDrWNlbSc7XHJcbiAgICAgICAgY2FzZSAnTU0nOiAvLyA5IG1vbnRocyAvIGluIDkgbW9udGhzIC8gOSBtb250aHMgYWdvXHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ23Em3PDrWNlJyA6ICdtxJtzw61jxa8nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbcSbc8OtY2knO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3knOiAgLy8gYSB5ZWFyIC8gaW4gYSB5ZWFyIC8gYSB5ZWFyIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3JvaycgOiAncm9rZW0nO1xyXG4gICAgICAgIGNhc2UgJ3l5JzogLy8gOSB5ZWFycyAvIGluIDkgeWVhcnMgLyA5IHllYXJzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdyb2t5JyA6ICdsZXQnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbGV0eSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBjcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2NzJywge1xyXG4gICAgbW9udGhzIDogbW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcclxuICAgIG1vbnRoc1BhcnNlIDogKGZ1bmN0aW9uIChtb250aHMsIG1vbnRoc1Nob3J0KSB7XHJcbiAgICAgICAgdmFyIGksIF9tb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gcGFyc2VyIHRvIHNvbHZlIHByb2JsZW0gd2l0aCBKdWx5ICjEjWVydmVuZWMpXHJcbiAgICAgICAgICAgIF9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgbW9udGhzW2ldICsgJyR8XicgKyBtb250aHNTaG9ydFtpXSArICckJywgJ2knKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9tb250aHNQYXJzZTtcclxuICAgIH0obW9udGhzLCBtb250aHNTaG9ydCkpLFxyXG4gICAgc2hvcnRNb250aHNQYXJzZSA6IChmdW5jdGlvbiAobW9udGhzU2hvcnQpIHtcclxuICAgICAgICB2YXIgaSwgX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBfc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgbW9udGhzU2hvcnRbaV0gKyAnJCcsICdpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfc2hvcnRNb250aHNQYXJzZTtcclxuICAgIH0obW9udGhzU2hvcnQpKSxcclxuICAgIGxvbmdNb250aHNQYXJzZSA6IChmdW5jdGlvbiAobW9udGhzKSB7XHJcbiAgICAgICAgdmFyIGksIF9sb25nTW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBfbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyBtb250aHNbaV0gKyAnJCcsICdpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfbG9uZ01vbnRoc1BhcnNlO1xyXG4gICAgfShtb250aHMpKSxcclxuICAgIHdlZWtkYXlzIDogJ25lZMSbbGVfcG9uZMSbbMOtX8O6dGVyw71fc3TFmWVkYV/EjXR2cnRla19ww6F0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICduZV9wb1/DunRfc3RfxI10X3DDoV9zbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ25lX3BvX8O6dF9zdF/EjXRfcMOhX3NvJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQ6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBsIDogJ0QuIE0uIFlZWVknXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tkbmVzIHZdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW3rDrXRyYSB2XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBuZWTEm2xpIHZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBkZGRkIFt2XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdmUgc3TFmWVkdSB2XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdmUgxI10dnJ0ZWsgdl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3YgcMOhdGVrIHZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2IHNvYm90dSB2XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXk6ICdbdsSNZXJhIHZdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bG91IG5lZMSbbGkgdl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw6ldIGRkZGQgW3ZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bG91IHN0xZllZHUgdl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw71dIGRkZGQgW3ZdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bG91IHNvYm90dSB2XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcclxuICAgICAgICBwYXN0IDogJ3DFmWVkICVzJyxcclxuICAgICAgICBzIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGRkIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTU0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGNzO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IENodXZhc2ggW2N2XVxyXG4vLyEgYXV0aG9yIDogQW5hdG9seSBNaXJvbm92IDogaHR0cHM6Ly9naXRodWIuY29tL21pcm9udG9saVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGN2ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnY3YnLCB7XHJcbiAgICBtb250aHMgOiAn0LrTkdGA0LvQsNGHX9C90LDRgNOR0YFf0L/Rg9GIX9Cw0LrQsF/QvNCw0Llf0qvTl9GA0YLQvNC1X9GD0YLTkV/Sq9GD0YDQu9CwX9Cw0LLTkdC9X9GO0L/QsF/Rh9Oz0Lpf0YDQsNGI0YLQsNCyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn0LrTkdGAX9C90LDRgF/Qv9GD0Yhf0LDQutCwX9C80LDQuV/Sq9OX0YBf0YPRgtORX9Kr0YPRgF/QsNCy0L1f0Y7Qv9CwX9GH07PQul/RgNCw0YgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfQstGL0YDRgdCw0YDQvdC40LrRg9C9X9GC0YPQvdGC0LjQutGD0L1f0YvRgtC70LDRgNC40LrRg9C9X9GO0L3QutGD0L1f0LrTl9Kr0L3QtdGA0L3QuNC60YPQvV/RjdGA0L3QtdC60YPQvV/RiNOR0LzQsNGC0LrRg9C9Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQstGL0YBf0YLRg9C9X9GL0YLQu1/RjtC9X9C605fSq1/RjdGA0L1f0YjTkdC8Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn0LLRgF/RgtC9X9GL0YJf0Y7QvV/QutKrX9GN0YBf0YjQvCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQtTU0tWVlZWScsXHJcbiAgICAgICAgTEwgOiAnWVlZWSBb0qvRg9C70YXQuF0gTU1NTSBb0YPQudOR0YXTl9C9XSBEWy3QvNOX0YjTl10nLFxyXG4gICAgICAgIExMTCA6ICdZWVlZIFvSq9GD0LvRhdC4XSBNTU1NIFvRg9C505HRhdOX0L1dIERbLdC805fRiNOXXSwgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgWVlZWSBb0qvRg9C70YXQuF0gTU1NTSBb0YPQudOR0YXTl9C9XSBEWy3QvNOX0YjTl10sIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb0J/QsNGP0L1dIExUIFvRgdC10YXQtdGC0YDQtV0nLFxyXG4gICAgICAgIG5leHREYXk6ICdb0KvRgNCw0L1dIExUIFvRgdC10YXQtdGC0YDQtV0nLFxyXG4gICAgICAgIGxhc3REYXk6ICdb05bQvdC10YBdIExUIFvRgdC10YXQtdGC0YDQtV0nLFxyXG4gICAgICAgIG5leHRXZWVrOiAnW9Kq0LjRgtC10YFdIGRkZGQgTFQgW9GB0LXRhdC10YLRgNC1XScsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdb0JjRgNGC0L3Tl10gZGRkZCBMVCBb0YHQtdGF0LXRgtGA0LVdJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIGFmZml4ID0gL9GB0LXRhdC10YIkL2kuZXhlYyhvdXRwdXQpID8gJ9GA0LXQvScgOiAv0qvRg9C7JC9pLmV4ZWMob3V0cHV0KSA/ICfRgtCw0L0nIDogJ9GA0LDQvSc7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQgKyBhZmZpeDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhc3QgOiAnJXMg0LrQsNGP0LvQu9CwJyxcclxuICAgICAgICBzIDogJ9C/05fRgC3QuNC6INKr0LXQutC60YPQvdGCJyxcclxuICAgICAgICBtIDogJ9C/05fRgCDQvNC40L3Rg9GCJyxcclxuICAgICAgICBtbSA6ICclZCDQvNC40L3Rg9GCJyxcclxuICAgICAgICBoIDogJ9C/05fRgCDRgdC10YXQtdGCJyxcclxuICAgICAgICBoaCA6ICclZCDRgdC10YXQtdGCJyxcclxuICAgICAgICBkIDogJ9C/05fRgCDQutGD0L0nLFxyXG4gICAgICAgIGRkIDogJyVkINC60YPQvScsXHJcbiAgICAgICAgTSA6ICfQv9OX0YAg0YPQudOR0YUnLFxyXG4gICAgICAgIE1NIDogJyVkINGD0LnTkdGFJyxcclxuICAgICAgICB5IDogJ9C/05fRgCDSq9GD0LsnLFxyXG4gICAgICAgIHl5IDogJyVkINKr0YPQuydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0t0LzTl9GILyxcclxuICAgIG9yZGluYWwgOiAnJWQt0LzTl9GIJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBjdjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3YuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvY3YuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBXZWxzaCBbY3ldXHJcbi8vISBhdXRob3IgOiBSb2JlcnQgQWxsZW4gOiBodHRwczovL2dpdGh1Yi5jb20vcm9iZ2FsbGVuXHJcbi8vISBhdXRob3IgOiBodHRwczovL2dpdGh1Yi5jb20vcnlhbmdyZWF2ZXNcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBjeSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2N5Jywge1xyXG4gICAgbW9udGhzOiAnSW9uYXdyX0Nod2Vmcm9yX01hd3J0aF9FYnJpbGxfTWFpX01laGVmaW5fR29yZmZlbm5hZl9Bd3N0X01lZGlfSHlkcmVmX1RhY2h3ZWRkX1JoYWdmeXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ0lvbl9DaHdlX01hd19FYnJfTWFpX01laF9Hb3JfQXdzX01lZF9IeWRfVGFjaF9SaGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXM6ICdEeWRkIFN1bF9EeWRkIExsdW5fRHlkZCBNYXdydGhfRHlkZCBNZXJjaGVyX0R5ZGQgSWF1X0R5ZGQgR3dlbmVyX0R5ZGQgU2Fkd3JuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ1N1bF9MbHVuX01hd19NZXJfSWF1X0d3ZV9TYWQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ1N1X0xsX01hX01lX0lhX0d3X1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIC8vIHRpbWUgZm9ybWF0cyBhcmUgdGhlIHNhbWUgYXMgZW4tZ2JcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbSGVkZGl3IGFtXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tZZm9yeSBhbV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbYW1dIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW0Rkb2UgYW1dIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW2Rpd2V0aGFmIGFtXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZToge1xyXG4gICAgICAgIGZ1dHVyZTogJ21ld24gJXMnLFxyXG4gICAgICAgIHBhc3Q6ICclcyB5biDDtGwnLFxyXG4gICAgICAgIHM6ICd5Y2h5ZGlnIGVpbGlhZGF1JyxcclxuICAgICAgICBtOiAnbXVudWQnLFxyXG4gICAgICAgIG1tOiAnJWQgbXVudWQnLFxyXG4gICAgICAgIGg6ICdhd3InLFxyXG4gICAgICAgIGhoOiAnJWQgYXdyJyxcclxuICAgICAgICBkOiAnZGl3cm5vZCcsXHJcbiAgICAgICAgZGQ6ICclZCBkaXdybm9kJyxcclxuICAgICAgICBNOiAnbWlzJyxcclxuICAgICAgICBNTTogJyVkIG1pcycsXHJcbiAgICAgICAgeTogJ2Jsd3lkZHluJyxcclxuICAgICAgICB5eTogJyVkIGZseW5lZGQnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGZlZHxhaW58YWZ8aWx8eWRkfGVkfGVnKS8sXHJcbiAgICAvLyB0cmFkaXRpb25hbCBvcmRpbmFsIG51bWJlcnMgYWJvdmUgMzEgYXJlIG5vdCBjb21tb25seSB1c2VkIGluIGNvbGxvcXVpYWwgV2Vsc2hcclxuICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlcixcclxuICAgICAgICAgICAgb3V0cHV0ID0gJycsXHJcbiAgICAgICAgICAgIGxvb2t1cCA9IFtcclxuICAgICAgICAgICAgICAgICcnLCAnYWYnLCAnaWwnLCAneWRkJywgJ3lkZCcsICdlZCcsICdlZCcsICdlZCcsICdmZWQnLCAnZmVkJywgJ2ZlZCcsIC8vIDFhZiB0byAxMGZlZFxyXG4gICAgICAgICAgICAgICAgJ2VnJywgJ2ZlZCcsICdlZycsICdlZycsICdmZWQnLCAnZWcnLCAnZWcnLCAnZmVkJywgJ2VnJywgJ2ZlZCcgLy8gMTFlZyB0byAyMGZlZFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIGlmIChiID4gMjApIHtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDQwIHx8IGIgPT09IDUwIHx8IGIgPT09IDYwIHx8IGIgPT09IDgwIHx8IGIgPT09IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gJ2ZlZCc7IC8vIG5vdCAzMGFpbiwgNzBhaW4gb3IgOTBhaW5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICdhaW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID4gMCkge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSBsb29rdXBbYl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGN5O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jeS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9jeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IERhbmlzaCBbZGFdXHJcbi8vISBhdXRob3IgOiBVbHJpayBOaWVsc2VuIDogaHR0cHM6Ly9naXRodWIuY29tL21yYmFzZVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGRhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZGEnLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFydHNfYXByaWxfbWFqX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFqX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3PDuG5kYWdfbWFuZGFnX3RpcnNkYWdfb25zZGFnX3RvcnNkYWdfZnJlZGFnX2zDuHJkYWcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3PDuG5fbWFuX3Rpcl9vbnNfdG9yX2ZyZV9sw7hyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnc8O4X21hX3RpX29uX3RvX2ZyX2zDuCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgW2QuXSBELiBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbaSBkYWcga2wuXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbaSBtb3JnZW4ga2wuXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAncMOlIGRkZGQgW2tsLl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW2kgZ8OlciBrbC5dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbaV0gZGRkZFtzIGtsLl0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdvbSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBzaWRlbicsXHJcbiAgICAgICAgcyA6ICdmw6Ugc2VrdW5kZXInLFxyXG4gICAgICAgIG0gOiAnZXQgbWludXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0dGVyJyxcclxuICAgICAgICBoIDogJ2VuIHRpbWUnLFxyXG4gICAgICAgIGhoIDogJyVkIHRpbWVyJyxcclxuICAgICAgICBkIDogJ2VuIGRhZycsXHJcbiAgICAgICAgZGQgOiAnJWQgZGFnZScsXHJcbiAgICAgICAgTSA6ICdlbiBtw6VuZWQnLFxyXG4gICAgICAgIE1NIDogJyVkIG3DpW5lZGVyJyxcclxuICAgICAgICB5IDogJ2V0IMOlcicsXHJcbiAgICAgICAgeXkgOiAnJWQgw6VyJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZGE7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2RhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogR2VybWFuIChBdXN0cmlhKSBbZGUtYXRdXHJcbi8vISBhdXRob3IgOiBsbHVjaHMgOiBodHRwczovL2dpdGh1Yi5jb20vbGx1Y2hzXHJcbi8vISBhdXRob3I6IE1lbmVsaW9uIEVsZW5zw7psZTogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcclxuLy8hIGF1dGhvciA6IE1hcnRpbiBHcm9sbGVyIDogaHR0cHM6Ly9naXRodWIuY29tL01hZE1HXHJcbi8vISBhdXRob3IgOiBNaWtvbGFqIERhZGVsYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWswMWFqXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAnbSc6IFsnZWluZSBNaW51dGUnLCAnZWluZXIgTWludXRlJ10sXHJcbiAgICAgICAgJ2gnOiBbJ2VpbmUgU3R1bmRlJywgJ2VpbmVyIFN0dW5kZSddLFxyXG4gICAgICAgICdkJzogWydlaW4gVGFnJywgJ2VpbmVtIFRhZyddLFxyXG4gICAgICAgICdkZCc6IFtudW1iZXIgKyAnIFRhZ2UnLCBudW1iZXIgKyAnIFRhZ2VuJ10sXHJcbiAgICAgICAgJ00nOiBbJ2VpbiBNb25hdCcsICdlaW5lbSBNb25hdCddLFxyXG4gICAgICAgICdNTSc6IFtudW1iZXIgKyAnIE1vbmF0ZScsIG51bWJlciArICcgTW9uYXRlbiddLFxyXG4gICAgICAgICd5JzogWydlaW4gSmFocicsICdlaW5lbSBKYWhyJ10sXHJcbiAgICAgICAgJ3l5JzogW251bWJlciArICcgSmFocmUnLCBudW1iZXIgKyAnIEphaHJlbiddXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xyXG59XHJcblxyXG52YXIgZGVBdCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RlLWF0Jywge1xyXG4gICAgbW9udGhzIDogJ0rDpG5uZXJfRmVicnVhcl9Nw6Ryel9BcHJpbF9NYWlfSnVuaV9KdWxpX0F1Z3VzdF9TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXplbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0rDpG4uX0ZlYi5fTcOkcnpfQXByLl9NYWlfSnVuaV9KdWxpX0F1Zy5fU2VwLl9Pa3QuX05vdi5fRGV6Licuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnU29ubnRhZ19Nb250YWdfRGllbnN0YWdfTWl0dHdvY2hfRG9ubmVyc3RhZ19GcmVpdGFnX1NhbXN0YWcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1NvLl9Nby5fRGkuX01pLl9Eby5fRnIuX1NhLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUzogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBELiBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1toZXV0ZSB1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXHJcbiAgICAgICAgbmV4dERheTogJ1ttb3JnZW4gdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3VtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgbGFzdERheTogJ1tnZXN0ZXJuIHVtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbbGV0enRlbl0gZGRkZCBbdW1dIExUIFtVaHJdJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAndm9yICVzJyxcclxuICAgICAgICBzIDogJ2VpbiBwYWFyIFNla3VuZGVuJyxcclxuICAgICAgICBtIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtbSA6ICclZCBNaW51dGVuJyxcclxuICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoaCA6ICclZCBTdHVuZGVuJyxcclxuICAgICAgICBkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTU0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHl5IDogcHJvY2Vzc1JlbGF0aXZlVGltZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZGVBdDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtYXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZGUtYXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBHZXJtYW4gKFN3aXR6ZXJsYW5kKSBbZGUtY2hdXHJcbi8vISBhdXRob3IgOiBzc2NodWVsbGVyIDogaHR0cHM6Ly9naXRodWIuY29tL3NzY2h1ZWxsZXJcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbi8vIGJhc2VkIG9uOiBodHRwczovL3d3dy5iay5hZG1pbi5jaC9kb2t1bWVudGF0aW9uL3NwcmFjaGVuLzA0OTE1LzA1MDE2L2luZGV4Lmh0bWw/bGFuZz1kZSNcclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdtJzogWydlaW5lIE1pbnV0ZScsICdlaW5lciBNaW51dGUnXSxcclxuICAgICAgICAnaCc6IFsnZWluZSBTdHVuZGUnLCAnZWluZXIgU3R1bmRlJ10sXHJcbiAgICAgICAgJ2QnOiBbJ2VpbiBUYWcnLCAnZWluZW0gVGFnJ10sXHJcbiAgICAgICAgJ2RkJzogW251bWJlciArICcgVGFnZScsIG51bWJlciArICcgVGFnZW4nXSxcclxuICAgICAgICAnTSc6IFsnZWluIE1vbmF0JywgJ2VpbmVtIE1vbmF0J10sXHJcbiAgICAgICAgJ01NJzogW251bWJlciArICcgTW9uYXRlJywgbnVtYmVyICsgJyBNb25hdGVuJ10sXHJcbiAgICAgICAgJ3knOiBbJ2VpbiBKYWhyJywgJ2VpbmVtIEphaHInXSxcclxuICAgICAgICAneXknOiBbbnVtYmVyICsgJyBKYWhyZScsIG51bWJlciArICcgSmFocmVuJ11cclxuICAgIH07XHJcbiAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XHJcbn1cclxuXHJcbnZhciBkZUNoID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZGUtY2gnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyX0ZlYnJ1YXJfTcOkcnpfQXByaWxfTWFpX0p1bmlfSnVsaV9BdWd1c3RfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGV6ZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW4uX0ZlYi5fTcOkcnpfQXByLl9NYWlfSnVuaV9KdWxpX0F1Zy5fU2VwLl9Pa3QuX05vdi5fRGV6Licuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnU29ubnRhZ19Nb250YWdfRGllbnN0YWdfTWl0dHdvY2hfRG9ubmVyc3RhZ19GcmVpdGFnX1NhbXN0YWcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1NvX01vX0RpX01pX0RvX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU29fTW9fRGlfTWlfRG9fRnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQ6ICdISC5tbScsXHJcbiAgICAgICAgTFRTOiAnSEgubW0uc3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEhILm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW2hldXRlIHVtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJyxcclxuICAgICAgICBuZXh0RGF5OiAnW21vcmdlbiB1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBsYXN0RGF5OiAnW2dlc3Rlcm4gdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBsYXN0V2VlazogJ1tsZXR6dGVuXSBkZGRkIFt1bV0gTFQgW1Vocl0nXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICAgICAgcGFzdCA6ICd2b3IgJXMnLFxyXG4gICAgICAgIHMgOiAnZWluIHBhYXIgU2VrdW5kZW4nLFxyXG4gICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG1tIDogJyVkIE1pbnV0ZW4nLFxyXG4gICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGhoIDogJyVkIFN0dW5kZW4nLFxyXG4gICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGRkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBkZUNoO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1jaC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS1jaC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEdlcm1hbiBbZGVdXHJcbi8vISBhdXRob3IgOiBsbHVjaHMgOiBodHRwczovL2dpdGh1Yi5jb20vbGx1Y2hzXHJcbi8vISBhdXRob3I6IE1lbmVsaW9uIEVsZW5zw7psZTogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcclxuLy8hIGF1dGhvciA6IE1pa29sYWogRGFkZWxhIDogaHR0cHM6Ly9naXRodWIuY29tL21pazAxYWpcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdtJzogWydlaW5lIE1pbnV0ZScsICdlaW5lciBNaW51dGUnXSxcclxuICAgICAgICAnaCc6IFsnZWluZSBTdHVuZGUnLCAnZWluZXIgU3R1bmRlJ10sXHJcbiAgICAgICAgJ2QnOiBbJ2VpbiBUYWcnLCAnZWluZW0gVGFnJ10sXHJcbiAgICAgICAgJ2RkJzogW251bWJlciArICcgVGFnZScsIG51bWJlciArICcgVGFnZW4nXSxcclxuICAgICAgICAnTSc6IFsnZWluIE1vbmF0JywgJ2VpbmVtIE1vbmF0J10sXHJcbiAgICAgICAgJ01NJzogW251bWJlciArICcgTW9uYXRlJywgbnVtYmVyICsgJyBNb25hdGVuJ10sXHJcbiAgICAgICAgJ3knOiBbJ2VpbiBKYWhyJywgJ2VpbmVtIEphaHInXSxcclxuICAgICAgICAneXknOiBbbnVtYmVyICsgJyBKYWhyZScsIG51bWJlciArICcgSmFocmVuJ11cclxuICAgIH07XHJcbiAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XHJcbn1cclxuXHJcbnZhciBkZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2RlJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcl9GZWJydWFyX03DpHJ6X0FwcmlsX01haV9KdW5pX0p1bGlfQXVndXN0X1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0RlemVtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuLl9GZWIuX03DpHJ6X0Fwci5fTWFpX0p1bmlfSnVsaV9BdWcuX1NlcC5fT2t0Ll9Ob3YuX0Rlei4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ1Nvbm50YWdfTW9udGFnX0RpZW5zdGFnX01pdHR3b2NoX0Rvbm5lcnN0YWdfRnJlaXRhZ19TYW1zdGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTby5fTW8uX0RpLl9NaS5fRG8uX0ZyLl9TYS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTb19Nb19EaV9NaV9Eb19Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVDogJ0hIOm1tJyxcclxuICAgICAgICBMVFM6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbaGV1dGUgdW1dIExUIFtVaHJdJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxyXG4gICAgICAgIG5leHREYXk6ICdbbW9yZ2VuIHVtXSBMVCBbVWhyXScsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFt1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIGxhc3REYXk6ICdbZ2VzdGVybiB1bV0gTFQgW1Vocl0nLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW2xldHp0ZW5dIGRkZGQgW3VtXSBMVCBbVWhyXSdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJ3ZvciAlcycsXHJcbiAgICAgICAgcyA6ICdlaW4gcGFhciBTZWt1bmRlbicsXHJcbiAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbW0gOiAnJWQgTWludXRlbicsXHJcbiAgICAgICAgaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaGggOiAnJWQgU3R1bmRlbicsXHJcbiAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5eSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGRlO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9kZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE1hbGRpdmlhbiBbZHZdXHJcbi8vISBhdXRob3IgOiBKYXdpc2ggSGFtZWVkIDogaHR0cHM6Ly9naXRodWIuY29tL2phd2lzaFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRocyA9IFtcclxuICAgICfelt6s3oLeqt6H3qbeg96pJyxcclxuICAgICfeit6s3oTesN6D3qreh96m3oPeqScsXHJcbiAgICAn3onep96D3qjel96qJyxcclxuICAgICfeh96t3pXesN6D3qnejd6qJyxcclxuICAgICfeid6tJyxcclxuICAgICfelt6r3oLesCcsXHJcbiAgICAn3pbeqt6N3qbeh96oJyxcclxuICAgICfeh96v3o7ept6Q3rDek96qJyxcclxuICAgICfekN6s3pXesN6T3qzeid6w3oTept6D3qonLFxyXG4gICAgJ96H3q7eht6w3pPer96E3qbeg96qJyxcclxuICAgICfegt6u3ojerN6J3rDehN6m3oPeqicsXHJcbiAgICAn3pHeqN6Q3qzeid6w3oTept6D3qonXHJcbl07XHJcbnZhciB3ZWVrZGF5cyA9IFtcclxuICAgICfeh96n3oveqN6H3rDejN6mJyxcclxuICAgICfegN6v3onepicsXHJcbiAgICAn3ofept6C3rDejt6n3oPepicsXHJcbiAgICAn3oTeqt6L3qYnLFxyXG4gICAgJ96E3qreg96n3pDesN6K3qbejN6oJyxcclxuICAgICfegN6q3obeqt6D3qonLFxyXG4gICAgJ96A3q7egt6o3oDeqN6D3qonXHJcbl07XHJcblxyXG52YXIgZHYgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdkdicsIHtcclxuICAgIG1vbnRocyA6IG1vbnRocyxcclxuICAgIG1vbnRoc1Nob3J0IDogbW9udGhzLFxyXG4gICAgd2Vla2RheXMgOiB3ZWVrZGF5cyxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiB3ZWVrZGF5cyxcclxuICAgIHdlZWtkYXlzTWluIDogJ96H3qfei96oX96A3q/eid6mX96H3qbegt6wX96E3qrei96mX96E3qreg96nX96A3qreht6qX96A3q7egt6oJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcblxyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnRC9NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv3onehnzeid6KLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJ96J3oonID09PSBpbnB1dDtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn3onehic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfeid6KJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb3oneqN6H3qbei96qXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb3onep96L3qbeid6nXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb3ofeqN6H3rDelN6sXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW96K3qfeh96o3ozeqt6I3qhdIGRkZGQgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfejN6s3oPerd6O3qbeh96oICVzJyxcclxuICAgICAgICBwYXN0IDogJ96G3qreg96o3oLesCAlcycsXHJcbiAgICAgICAgcyA6ICfekN6o3obeqt6C3rDejN6q3obert6F3qzeh96wJyxcclxuICAgICAgICBtIDogJ96J3qjegt6o3pPerN6H3rAnLFxyXG4gICAgICAgIG1tIDogJ96J3qjegt6o3pPeqiAlZCcsXHJcbiAgICAgICAgaCA6ICfejt6m3pHeqN6H3qjeg96s3ofesCcsXHJcbiAgICAgICAgaGggOiAn3o7ept6R3qjeh96o3oPeqiAlZCcsXHJcbiAgICAgICAgZCA6ICfei96q3ojept6A3qzeh96wJyxcclxuICAgICAgICBkZCA6ICfei96q3ojept6Q3rAgJWQnLFxyXG4gICAgICAgIE0gOiAn3onept6A3qzeh96wJyxcclxuICAgICAgICBNTSA6ICfeid6m3pDesCAlZCcsXHJcbiAgICAgICAgeSA6ICfeh96m3oDept6D3qzeh96wJyxcclxuICAgICAgICB5eSA6ICfeh96m3oDept6D3qogJWQnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLC9nLCAn2IwnKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDcsICAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBkdjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZHYuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZHYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBHcmVlayBbZWxdXHJcbi8vISBhdXRob3IgOiBBZ2dlbG9zIEthcmFsaWFzIDogaHR0cHM6Ly9naXRodWIuY29tL21laGllbFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG59XHJcblxyXG5cclxudmFyIGVsID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZWwnLCB7XHJcbiAgICBtb250aHNOb21pbmF0aXZlRWwgOiAnzpnOsc69zr/Phc6sz4HOuc6/z4JfzqbOtc6yz4HOv8+FzqzPgc65zr/Pgl/OnM6sz4HPhM65zr/Pgl/Okc+Az4HOr867zrnOv8+CX86czqzOuc6/z4JfzpnOv8+Nzr3Ouc6/z4JfzpnOv8+NzrvOuc6/z4JfzpHPjc6zzr/Phc+Dz4TOv8+CX86jzrXPgM+Ezq3OvM6yz4HOuc6/z4Jfzp/Ous+Ez47Oss+BzrnOv8+CX86dzr/Orc68zrLPgc65zr/Pgl/OlM61zrrOrc68zrLPgc65zr/Pgicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc0dlbml0aXZlRWwgOiAnzpnOsc69zr/Phc6xz4HOr86/z4VfzqbOtc6yz4HOv8+FzrHPgc6vzr/PhV/OnM6xz4HPhM6vzr/PhV/Okc+Az4HOuc67zq/Ov8+FX86czrHOkM6/z4VfzpnOv8+Fzr3Or86/z4VfzpnOv8+FzrvOr86/z4VfzpHPhc6zzr/Pjc+Dz4TOv8+FX86jzrXPgM+EzrXOvM6yz4HOr86/z4Vfzp/Ous+Ez4nOss+Bzq/Ov8+FX86dzr/Otc68zrLPgc6vzr/PhV/OlM61zrrOtc68zrLPgc6vzr/PhScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtb21lbnRUb0Zvcm1hdCwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtb21lbnRUb0Zvcm1hdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzTm9taW5hdGl2ZUVsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycgJiYgL0QvLnRlc3QoZm9ybWF0LnN1YnN0cmluZygwLCBmb3JtYXQuaW5kZXhPZignTU1NTScpKSkpIHsgLy8gaWYgdGhlcmUgaXMgYSBkYXkgbnVtYmVyIGJlZm9yZSAnTU1NTSdcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc0dlbml0aXZlRWxbbW9tZW50VG9Gb3JtYXQubW9udGgoKV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc05vbWluYXRpdmVFbFttb21lbnRUb0Zvcm1hdC5tb250aCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiAnzpnOsc69X86mzrXOsl/OnM6xz4FfzpHPgM+BX86czrHPil/Omc6/z4XOvV/Omc6/z4XOu1/Okc+FzrNfzqPOtc+AX86fzrrPhF/Onc6/zrVfzpTOtc66Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnzprPhc+BzrnOsc66zq5fzpTOtc+Fz4TOrc+BzrFfzqTPgc6vz4TOt1/OpM61z4TOrM+Bz4TOt1/OoM6tzrzPgM+EzrdfzqDOsc+BzrHPg866zrXPhc6uX86jzqzOss6yzrHPhM6/Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfOms+Fz4FfzpTOtc+FX86kz4HOuV/OpM61z4RfzqDOtc68X86gzrHPgV/Oo86xzrInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfOms+FX86UzrVfzqTPgV/OpM61X86gzrVfzqDOsV/Oo86xJy5zcGxpdCgnXycpLFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICfOvM68JyA6ICfOnM6cJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICfPgM68JyA6ICfOoM6cJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKClbMF0gPT09ICfOvCcpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2UgOiAvW86gzpxdXFwuP86cP1xcLj8vaSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIGg6bW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXJFbCA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vOo86uzrzOtc+BzrEge31dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vOkc+Nz4HOuc6/IHt9XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbe31dIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vOp864zrXPgiB7fV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vPhM6/IM+Az4HOv863zrPOv8+NzrzOtc69zr9dIGRkZGQgW3t9XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW8+EzrfOvSDPgM+Bzr/Ot86zzr/Pjc68zrXOvc63XSBkZGRkIFt7fV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDogZnVuY3Rpb24gKGtleSwgbW9tKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyRWxba2V5XSxcclxuICAgICAgICAgICAgaG91cnMgPSBtb20gJiYgbW9tLmhvdXJzKCk7XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3V0cHV0KSkge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuYXBwbHkobW9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5yZXBsYWNlKCd7fScsIChob3VycyAlIDEyID09PSAxID8gJ8+Dz4TOtycgOiAnz4PPhM65z4InKSk7XHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfPg861ICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIM+Az4HOuc69JyxcclxuICAgICAgICBzIDogJ867zq/Os86xIM60zrXPhc+EzrXPgc+MzrvOtc+Az4TOsScsXHJcbiAgICAgICAgbSA6ICfOrc69zrEgzrvOtc+Az4TPjCcsXHJcbiAgICAgICAgbW0gOiAnJWQgzrvOtc+Az4TOrCcsXHJcbiAgICAgICAgaCA6ICfOvM6vzrEgz47Pgc6xJyxcclxuICAgICAgICBoaCA6ICclZCDPjs+BzrXPgicsXHJcbiAgICAgICAgZCA6ICfOvM6vzrEgzrzOrc+BzrEnLFxyXG4gICAgICAgIGRkIDogJyVkIM68zq3Pgc61z4InLFxyXG4gICAgICAgIE0gOiAnzq3Ovc6xz4IgzrzOrs69zrHPgicsXHJcbiAgICAgICAgTU0gOiAnJWQgzrzOrs69zrXPgicsXHJcbiAgICAgICAgeSA6ICfOrc69zrHPgiDPh8+Bz4zOvc6/z4InLFxyXG4gICAgICAgIHl5IDogJyVkIM+Hz4HPjM69zrnOsSdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn3Oty8sXHJcbiAgICBvcmRpbmFsOiAnJWTOtycsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDRzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZWw7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRW5nbGlzaCAoQXVzdHJhbGlhKSBbZW4tYXVdXHJcbi8vISBhdXRob3IgOiBKYXJlZCBNb3JzZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXJjb2FsXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZW5BdSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWF1Jywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIGg6bW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGFnbycsXHJcbiAgICAgICAgcyA6ICdhIGZldyBzZWNvbmRzJyxcclxuICAgICAgICBtIDogJ2EgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ2FuIGhvdXInLFxyXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkIDogJ2EgZGF5JyxcclxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcclxuICAgICAgICBNIDogJ2EgbW9udGgnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXHJcbiAgICAgICAgeSA6ICdhIHllYXInLFxyXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcclxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVuQXU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWF1LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRW5nbGlzaCAoQ2FuYWRhKSBbZW4tY2FdXHJcbi8vISBhdXRob3IgOiBKb25hdGhhbiBBYm91cmJpaCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb25iY2FcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBlbkNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZW4tY2EnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnaDptbSBBJyxcclxuICAgICAgICBMVFMgOiAnaDptbTpzcyBBJyxcclxuICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxyXG4gICAgICAgIExMIDogJ01NTU0gRCwgWVlZWScsXHJcbiAgICAgICAgTExMIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcclxuICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxyXG4gICAgICAgIG0gOiAnYSBtaW51dGUnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGggOiAnYW4gaG91cicsXHJcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxyXG4gICAgICAgIGQgOiAnYSBkYXknLFxyXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxyXG4gICAgICAgIE0gOiAnYSBtb250aCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcclxuICAgICAgICB5IDogJ2EgeWVhcicsXHJcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0fG5kfHJkfHRoKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XHJcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcclxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZW5DYTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tY2EuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tY2EuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBFbmdsaXNoIChVbml0ZWQgS2luZ2RvbSkgW2VuLWdiXVxyXG4vLyEgYXV0aG9yIDogQ2hyaXMgR2VkcmltIDogaHR0cHM6Ly9naXRodWIuY29tL2NocmlzZ2VkcmltXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZW5HYiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLWdiJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcclxuICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxyXG4gICAgICAgIG0gOiAnYSBtaW51dGUnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGggOiAnYW4gaG91cicsXHJcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxyXG4gICAgICAgIGQgOiAnYSBkYXknLFxyXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxyXG4gICAgICAgIE0gOiAnYSBtb250aCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcclxuICAgICAgICB5IDogJ2EgeWVhcicsXHJcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0fG5kfHJkfHRoKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIG91dHB1dCA9ICh+fihudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XHJcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcclxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZW5HYjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tZ2IuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZW4tZ2IuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBFbmdsaXNoIChJcmVsYW5kKSBbZW4taWVdXHJcbi8vISBhdXRob3IgOiBDaHJpcyBDYXJ0bGlkZ2UgOiBodHRwczovL2dpdGh1Yi5jb20vY2hyaXNjYXJ0bGlkZ2VcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBlbkllID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZW4taWUnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC1NTS1ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGFnbycsXHJcbiAgICAgICAgcyA6ICdhIGZldyBzZWNvbmRzJyxcclxuICAgICAgICBtIDogJ2EgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ2FuIGhvdXInLFxyXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkIDogJ2EgZGF5JyxcclxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcclxuICAgICAgICBNIDogJ2EgbW9udGgnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXHJcbiAgICAgICAgeSA6ICdhIHllYXInLFxyXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcclxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVuSWU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWllLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLWllLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRW5nbGlzaCAoTmV3IFplYWxhbmQpIFtlbi1uel1cclxuLy8hIGF1dGhvciA6IEx1a2UgTWNHcmVnb3IgOiBodHRwczovL2dpdGh1Yi5jb20vbHVrZW1jZ3JlZ29yXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZW5OeiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VuLW56Jywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIGg6bW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGFnbycsXHJcbiAgICAgICAgcyA6ICdhIGZldyBzZWNvbmRzJyxcclxuICAgICAgICBtIDogJ2EgbWludXRlJyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgICAgICBoIDogJ2FuIGhvdXInLFxyXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICBkIDogJ2EgZGF5JyxcclxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcclxuICAgICAgICBNIDogJ2EgbW9udGgnLFxyXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXHJcbiAgICAgICAgeSA6ICdhIHllYXInLFxyXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShzdHxuZHxyZHx0aCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcclxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVuTno7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VuLW56LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRXNwZXJhbnRvIFtlb11cclxuLy8hIGF1dGhvciA6IENvbGluIERlYW4gOiBodHRwczovL2dpdGh1Yi5jb20vY29saW5kZWFuXHJcbi8vISBhdXRob3IgOiBNaWEgTm9yZGVudG9mdCBJbXBlcmF0b3JpIDogaHR0cHM6Ly9naXRodWIuY29tL21pZXN0YXNtaWFcclxuLy8hIGNvbW1lbnQgOiBtaWVzdGFzbWlhIGNvcnJlY3RlZCB0aGUgdHJhbnNsYXRpb24gYnkgY29saW5kZWFuXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZW8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlbycsIHtcclxuICAgIG1vbnRocyA6ICdqYW51YXJvX2ZlYnJ1YXJvX21hcnRvX2Fwcmlsb19tYWpvX2p1bmlvX2p1bGlvX2HFrWd1c3RvX3NlcHRlbWJyb19va3RvYnJvX25vdmVtYnJvX2RlY2VtYnJvJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2HFrWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnZGltYW7EiW9fbHVuZG9fbWFyZG9fbWVya3JlZG9fxLVhxa1kb192ZW5kcmVkb19zYWJhdG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2RpbV9sdW5fbWFyZF9tZXJrX8S1YcWtX3Zlbl9zYWInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdkaV9sdV9tYV9tZV/EtWFfdmVfc2EnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ1lZWVktTU0tREQnLFxyXG4gICAgICAgIExMIDogJ0RbLWEgZGVdIE1NTU0sIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEWy1hIGRlXSBNTU1NLCBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIFtsYV0gRFstYSBkZV0gTU1NTSwgWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvW2FwXVxcLnRcXC5tL2ksXHJcbiAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgPT09ICdwJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3AudC5tLicgOiAnUC5ULk0uJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhLnQubS4nIDogJ0EuVC5NLic7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0hvZGlhxa0gamVdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tNb3JnYcWtIGplXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbamVdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tIaWVyYcWtIGplXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW3Bhc2ludGFdIGRkZGQgW2plXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3Bvc3QgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnYW50YcWtICVzJyxcclxuICAgICAgICBzIDogJ3Nla3VuZG9qJyxcclxuICAgICAgICBtIDogJ21pbnV0bycsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRvaicsXHJcbiAgICAgICAgaCA6ICdob3JvJyxcclxuICAgICAgICBoaCA6ICclZCBob3JvaicsXHJcbiAgICAgICAgZCA6ICd0YWdvJywvL25lICdkaXVybm8nLCDEiWFyIGVzdGFzIHV6aXRhIHBvciBwcm9rc2ltdW1vXHJcbiAgICAgICAgZGQgOiAnJWQgdGFnb2onLFxyXG4gICAgICAgIE0gOiAnbW9uYXRvJyxcclxuICAgICAgICBNTSA6ICclZCBtb25hdG9qJyxcclxuICAgICAgICB5IDogJ2phcm8nLFxyXG4gICAgICAgIHl5IDogJyVkIGphcm9qJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfWEvLFxyXG4gICAgb3JkaW5hbCA6ICclZGEnLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGVvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lby5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9lby5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFNwYW5pc2ggKERvbWluaWNhbiBSZXB1YmxpYykgW2VzLWRvXVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRoc1Nob3J0RG90ID0gJ2VuZS5fZmViLl9tYXIuX2Fici5fbWF5Ll9qdW4uX2p1bC5fYWdvLl9zZXAuX29jdC5fbm92Ll9kaWMuJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnQgPSAnZW5lX2ZlYl9tYXJfYWJyX21heV9qdW5fanVsX2Fnb19zZXBfb2N0X25vdl9kaWMnLnNwbGl0KCdfJyk7XHJcblxyXG52YXIgbW9udGhzUGFyc2UgPSBbL15lbmUvaSwgL15mZWIvaSwgL15tYXIvaSwgL15hYnIvaSwgL15tYXkvaSwgL15qdW4vaSwgL15qdWwvaSwgL15hZ28vaSwgL15zZXAvaSwgL15vY3QvaSwgL15ub3YvaSwgL15kaWMvaV07XHJcbnZhciBtb250aHNSZWdleCA9IC9eKGVuZXJvfGZlYnJlcm98bWFyem98YWJyaWx8bWF5b3xqdW5pb3xqdWxpb3xhZ29zdG98c2VwdGllbWJyZXxvY3R1YnJlfG5vdmllbWJyZXxkaWNpZW1icmV8ZW5lXFwuP3xmZWJcXC4/fG1hclxcLj98YWJyXFwuP3xtYXlcXC4/fGp1blxcLj98anVsXFwuP3xhZ29cXC4/fHNlcFxcLj98b2N0XFwuP3xub3ZcXC4/fGRpY1xcLj8pL2k7XHJcblxyXG52YXIgZXNEbyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VzLWRvJywge1xyXG4gICAgbW9udGhzIDogJ2VuZXJvX2ZlYnJlcm9fbWFyem9fYWJyaWxfbWF5b19qdW5pb19qdWxpb19hZ29zdG9fc2VwdGllbWJyZV9vY3R1YnJlX25vdmllbWJyZV9kaWNpZW1icmUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoLy1NTU0tLy50ZXN0KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0W20ubW9udGgoKV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90W20ubW9udGgoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1JlZ2V4OiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1Nob3J0UmVnZXg6IG1vbnRoc1JlZ2V4LFxyXG4gICAgbW9udGhzU3RyaWN0UmVnZXg6IC9eKGVuZXJvfGZlYnJlcm98bWFyem98YWJyaWx8bWF5b3xqdW5pb3xqdWxpb3xhZ29zdG98c2VwdGllbWJyZXxvY3R1YnJlfG5vdmllbWJyZXxkaWNpZW1icmUpL2ksXHJcbiAgICBtb250aHNTaG9ydFN0cmljdFJlZ2V4OiAvXihlbmVcXC4/fGZlYlxcLj98bWFyXFwuP3xhYnJcXC4/fG1heVxcLj98anVuXFwuP3xqdWxcXC4/fGFnb1xcLj98c2VwXFwuP3xvY3RcXC4/fG5vdlxcLj98ZGljXFwuPykvaSxcclxuICAgIG1vbnRoc1BhcnNlOiBtb250aHNQYXJzZSxcclxuICAgIGxvbmdNb250aHNQYXJzZTogbW9udGhzUGFyc2UsXHJcbiAgICBzaG9ydE1vbnRoc1BhcnNlOiBtb250aHNQYXJzZSxcclxuICAgIHdlZWtkYXlzIDogJ2RvbWluZ29fbHVuZXNfbWFydGVzX21pw6lyY29sZXNfanVldmVzX3ZpZXJuZXNfc8OhYmFkbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZG9tLl9sdW4uX21hci5fbWnDqS5fanVlLl92aWUuX3PDoWIuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnZG9fbHVfbWFfbWlfanVfdmlfc8OhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVkgaDptbSBBJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbaG95IGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbbWHDsWFuYSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQgW2EgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbYXllciBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzYWRvIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2VuICVzJyxcclxuICAgICAgICBwYXN0IDogJ2hhY2UgJXMnLFxyXG4gICAgICAgIHMgOiAndW5vcyBzZWd1bmRvcycsXHJcbiAgICAgICAgbSA6ICd1biBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxyXG4gICAgICAgIGggOiAndW5hIGhvcmEnLFxyXG4gICAgICAgIGhoIDogJyVkIGhvcmFzJyxcclxuICAgICAgICBkIDogJ3VuIGTDrWEnLFxyXG4gICAgICAgIGRkIDogJyVkIGTDrWFzJyxcclxuICAgICAgICBNIDogJ3VuIG1lcycsXHJcbiAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxyXG4gICAgICAgIHkgOiAndW4gYcOxbycsXHJcbiAgICAgICAgeXkgOiAnJWQgYcOxb3MnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcclxuICAgIG9yZGluYWwgOiAnJWTCuicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZXNEbztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtZG8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtZG8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTcGFuaXNoKFVuaXRlZCBTdGF0ZSkgW2VzLXVzXVxyXG4vLyEgYXV0aG9yIDogYnVzdHRhIDogaHR0cHM6Ly9naXRodWIuY29tL2J1c3R0YVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRoc1Nob3J0RG90ID0gJ2VuZS5fZmViLl9tYXIuX2Fici5fbWF5Ll9qdW4uX2p1bC5fYWdvLl9zZXAuX29jdC5fbm92Ll9kaWMuJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnQgPSAnZW5lX2ZlYl9tYXJfYWJyX21heV9qdW5fanVsX2Fnb19zZXBfb2N0X25vdl9kaWMnLnNwbGl0KCdfJyk7XHJcblxyXG52YXIgZXNVcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2VzLXVzJywge1xyXG4gICAgbW9udGhzIDogJ2VuZXJvX2ZlYnJlcm9fbWFyem9fYWJyaWxfbWF5b19qdW5pb19qdWxpb19hZ29zdG9fc2VwdGllbWJyZV9vY3R1YnJlX25vdmllbWJyZV9kaWNpZW1icmUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoLy1NTU0tLy50ZXN0KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0W20ubW9udGgoKV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0RG90W20ubW9udGgoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnZG9taW5nb19sdW5lc19tYXJ0ZXNfbWnDqXJjb2xlc19qdWV2ZXNfdmllcm5lc19zw6FiYWRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkb20uX2x1bi5fbWFyLl9tacOpLl9qdWUuX3ZpZS5fc8OhYi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdkb19sdV9tYV9taV9qdV92aV9zw6EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnTU0vREQvWVlZWScsXHJcbiAgICAgICAgTEwgOiAnTU1NTSBbZGVdIEQgW2RlXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnTU1NTSBbZGVdIEQgW2RlXSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBbZGVdIEQgW2RlXSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbaG95IGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbbWHDsWFuYSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQgW2EgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbYXllciBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzYWRvIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2VuICVzJyxcclxuICAgICAgICBwYXN0IDogJ2hhY2UgJXMnLFxyXG4gICAgICAgIHMgOiAndW5vcyBzZWd1bmRvcycsXHJcbiAgICAgICAgbSA6ICd1biBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxyXG4gICAgICAgIGggOiAndW5hIGhvcmEnLFxyXG4gICAgICAgIGhoIDogJyVkIGhvcmFzJyxcclxuICAgICAgICBkIDogJ3VuIGTDrWEnLFxyXG4gICAgICAgIGRkIDogJyVkIGTDrWFzJyxcclxuICAgICAgICBNIDogJ3VuIG1lcycsXHJcbiAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxyXG4gICAgICAgIHkgOiAndW4gYcOxbycsXHJcbiAgICAgICAgeXkgOiAnJWQgYcOxb3MnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcclxuICAgIG9yZGluYWwgOiAnJWTCuicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZXNVcztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtdXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZXMtdXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTcGFuaXNoIFtlc11cclxuLy8hIGF1dGhvciA6IEp1bGlvIE5hcHVyw60gOiBodHRwczovL2dpdGh1Yi5jb20vanVsaW9uY1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRoc1Nob3J0RG90ID0gJ2VuZS5fZmViLl9tYXIuX2Fici5fbWF5Ll9qdW4uX2p1bC5fYWdvLl9zZXAuX29jdC5fbm92Ll9kaWMuJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnQgPSAnZW5lX2ZlYl9tYXJfYWJyX21heV9qdW5fanVsX2Fnb19zZXBfb2N0X25vdl9kaWMnLnNwbGl0KCdfJyk7XHJcblxyXG52YXIgbW9udGhzUGFyc2UgPSBbL15lbmUvaSwgL15mZWIvaSwgL15tYXIvaSwgL15hYnIvaSwgL15tYXkvaSwgL15qdW4vaSwgL15qdWwvaSwgL15hZ28vaSwgL15zZXAvaSwgL15vY3QvaSwgL15ub3YvaSwgL15kaWMvaV07XHJcbnZhciBtb250aHNSZWdleCA9IC9eKGVuZXJvfGZlYnJlcm98bWFyem98YWJyaWx8bWF5b3xqdW5pb3xqdWxpb3xhZ29zdG98c2VwdGllbWJyZXxvY3R1YnJlfG5vdmllbWJyZXxkaWNpZW1icmV8ZW5lXFwuP3xmZWJcXC4/fG1hclxcLj98YWJyXFwuP3xtYXlcXC4/fGp1blxcLj98anVsXFwuP3xhZ29cXC4/fHNlcFxcLj98b2N0XFwuP3xub3ZcXC4/fGRpY1xcLj8pL2k7XHJcblxyXG52YXIgZXMgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdlcycsIHtcclxuICAgIG1vbnRocyA6ICdlbmVyb19mZWJyZXJvX21hcnpvX2FicmlsX21heW9fanVuaW9fanVsaW9fYWdvc3RvX3NlcHRpZW1icmVfb2N0dWJyZV9ub3ZpZW1icmVfZGljaWVtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSwgZm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdDtcclxuICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFttLm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydERvdFttLm1vbnRoKCldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb250aHNSZWdleCA6IG1vbnRoc1JlZ2V4LFxyXG4gICAgbW9udGhzU2hvcnRSZWdleCA6IG1vbnRoc1JlZ2V4LFxyXG4gICAgbW9udGhzU3RyaWN0UmVnZXggOiAvXihlbmVyb3xmZWJyZXJvfG1hcnpvfGFicmlsfG1heW98anVuaW98anVsaW98YWdvc3RvfHNlcHRpZW1icmV8b2N0dWJyZXxub3ZpZW1icmV8ZGljaWVtYnJlKS9pLFxyXG4gICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IC9eKGVuZVxcLj98ZmViXFwuP3xtYXJcXC4/fGFiclxcLj98bWF5XFwuP3xqdW5cXC4/fGp1bFxcLj98YWdvXFwuP3xzZXBcXC4/fG9jdFxcLj98bm92XFwuP3xkaWNcXC4/KS9pLFxyXG4gICAgbW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIGxvbmdNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG4gICAgc2hvcnRNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG4gICAgd2Vla2RheXMgOiAnZG9taW5nb19sdW5lc19tYXJ0ZXNfbWnDqXJjb2xlc19qdWV2ZXNfdmllcm5lc19zw6FiYWRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkb20uX2x1bi5fbWFyLl9tacOpLl9qdWUuX3ZpZS5fc8OhYi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdkb19sdV9tYV9taV9qdV92aV9zw6EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbaG95IGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbbWHDsWFuYSBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQgW2EgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdERheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbYXllciBhIGxhJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICdzJyA6ICcnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1tlbF0gZGRkZCBbcGFzYWRvIGEgbGEnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ3MnIDogJycpICsgJ10gTFQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2VuICVzJyxcclxuICAgICAgICBwYXN0IDogJ2hhY2UgJXMnLFxyXG4gICAgICAgIHMgOiAndW5vcyBzZWd1bmRvcycsXHJcbiAgICAgICAgbSA6ICd1biBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxyXG4gICAgICAgIGggOiAndW5hIGhvcmEnLFxyXG4gICAgICAgIGhoIDogJyVkIGhvcmFzJyxcclxuICAgICAgICBkIDogJ3VuIGTDrWEnLFxyXG4gICAgICAgIGRkIDogJyVkIGTDrWFzJyxcclxuICAgICAgICBNIDogJ3VuIG1lcycsXHJcbiAgICAgICAgTU0gOiAnJWQgbWVzZXMnLFxyXG4gICAgICAgIHkgOiAndW4gYcOxbycsXHJcbiAgICAgICAgeXkgOiAnJWQgYcOxb3MnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfcK6LyxcclxuICAgIG9yZGluYWwgOiAnJWTCuicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZXM7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2VzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRXN0b25pYW4gW2V0XVxyXG4vLyEgYXV0aG9yIDogSGVucnkgS2VobG1hbm4gOiBodHRwczovL2dpdGh1Yi5jb20vbWFkaGVucnlcclxuLy8hIGltcHJvdmVtZW50cyA6IElsbGltYXIgVGFtYmVrIDogaHR0cHM6Ly9naXRodWIuY29tL3JhZ3Vsa2FcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgZm9ybWF0ID0ge1xyXG4gICAgICAgICdzJyA6IFsnbcO1bmUgc2VrdW5kaScsICdtw7VuaSBzZWt1bmQnLCAncGFhciBzZWt1bmRpdCddLFxyXG4gICAgICAgICdtJyA6IFsnw7xoZSBtaW51dGknLCAnw7xrcyBtaW51dCddLFxyXG4gICAgICAgICdtbSc6IFtudW1iZXIgKyAnIG1pbnV0aScsIG51bWJlciArICcgbWludXRpdCddLFxyXG4gICAgICAgICdoJyA6IFsnw7xoZSB0dW5uaScsICd0dW5kIGFlZ2EnLCAnw7xrcyB0dW5kJ10sXHJcbiAgICAgICAgJ2hoJzogW251bWJlciArICcgdHVubmknLCBudW1iZXIgKyAnIHR1bmRpJ10sXHJcbiAgICAgICAgJ2QnIDogWyfDvGhlIHDDpGV2YScsICfDvGtzIHDDpGV2J10sXHJcbiAgICAgICAgJ00nIDogWydrdXUgYWphJywgJ2t1dSBhZWdhJywgJ8O8a3Mga3V1J10sXHJcbiAgICAgICAgJ01NJzogW251bWJlciArICcga3V1JywgbnVtYmVyICsgJyBrdXVkJ10sXHJcbiAgICAgICAgJ3knIDogWyfDvGhlIGFhc3RhJywgJ2Fhc3RhJywgJ8O8a3MgYWFzdGEnXSxcclxuICAgICAgICAneXknOiBbbnVtYmVyICsgJyBhYXN0YScsIG51bWJlciArICcgYWFzdGF0J11cclxuICAgIH07XHJcbiAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRba2V5XVsyXSA/IGZvcm1hdFtrZXldWzJdIDogZm9ybWF0W2tleV1bMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNGdXR1cmUgPyBmb3JtYXRba2V5XVswXSA6IGZvcm1hdFtrZXldWzFdO1xyXG59XHJcblxyXG52YXIgZXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdldCcsIHtcclxuICAgIG1vbnRocyAgICAgICAgOiAnamFhbnVhcl92ZWVicnVhcl9tw6RydHNfYXByaWxsX21haV9qdXVuaV9qdXVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9vYmVyX25vdmVtYmVyX2RldHNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0ICAgOiAnamFhbl92ZWVicl9tw6RydHNfYXByX21haV9qdXVuaV9qdXVsaV9hdWdfc2VwdF9va3Rfbm92X2RldHMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyAgICAgIDogJ3DDvGhhcMOkZXZfZXNtYXNww6Rldl90ZWlzaXDDpGV2X2tvbG1hcMOkZXZfbmVsamFww6Rldl9yZWVkZV9sYXVww6Rldicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnUF9FX1RfS19OX1JfTCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluICAgOiAnUF9FX1RfS19OX1JfTCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUICAgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgICAgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgICA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCAgOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSAgOiAnW1TDpG5hLF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgIDogJ1tIb21tZSxdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdbSsOkcmdtaW5lXSBkZGRkIExUJyxcclxuICAgICAgICBsYXN0RGF5ICA6ICdbRWlsZSxdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbRWVsbWluZV0gZGRkZCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIHDDpHJhc3QnLFxyXG4gICAgICAgIHBhc3QgICA6ICclcyB0YWdhc2knLFxyXG4gICAgICAgIHMgICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbSAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtbSAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGggICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaGggICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGRkICAgICA6ICclZCBww6RldmEnLFxyXG4gICAgICAgIE0gICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTU0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5ICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHl5ICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGV0O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ldC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEJhc3F1ZSBbZXVdXHJcbi8vISBhdXRob3IgOiBFbmVrbyBJbGxhcnJhbWVuZGkgOiBodHRwczovL2dpdGh1Yi5jb20vZWlsbGFycmFcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBldSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2V1Jywge1xyXG4gICAgbW9udGhzIDogJ3VydGFycmlsYV9vdHNhaWxhX21hcnR4b2FfYXBpcmlsYV9tYWlhdHphX2VrYWluYV91enRhaWxhX2FidXp0dWFfaXJhaWxhX3VycmlhX2F6YXJvYV9hYmVuZHVhJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAndXJ0Ll9vdHMuX21hci5fYXBpLl9tYWkuX2VrYS5fdXp0Ll9hYnUuX2lyYS5fdXJyLl9hemEuX2FiZS4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2lnYW5kZWFfYXN0ZWxlaGVuYV9hc3RlYXJ0ZWFfYXN0ZWF6a2VuYV9vc3RlZ3VuYV9vc3RpcmFsYV9sYXJ1bmJhdGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2lnLl9hbC5fYXIuX2F6Ll9vZy5fb2wuX2xyLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ2lnX2FsX2FyX2F6X29nX29sX2xyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXHJcbiAgICAgICAgTEwgOiAnWVlZWVtrb10gTU1NTVtyZW5dIERbYV0nLFxyXG4gICAgICAgIExMTCA6ICdZWVlZW2tvXSBNTU1NW3Jlbl0gRFthXSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBZWVlZW2tvXSBNTU1NW3Jlbl0gRFthXSBISDptbScsXHJcbiAgICAgICAgbCA6ICdZWVlZLU0tRCcsXHJcbiAgICAgICAgbGwgOiAnWVlZWVtrb10gTU1NIERbYV0nLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZW2tvXSBNTU0gRFthXSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdkZGQsIFlZWVlba29dIE1NTSBEW2FdIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW2dhdXJdIExUW2V0YW5dJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tiaWhhcl0gTFRbZXRhbl0nLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgTFRbZXRhbl0nLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW2F0em9dIExUW2V0YW5dJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbYXVycmVrb10gZGRkZCBMVFtldGFuXScsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIGJhcnJ1JyxcclxuICAgICAgICBwYXN0IDogJ2R1ZWxhICVzJyxcclxuICAgICAgICBzIDogJ3NlZ3VuZG8gYmF0enVrJyxcclxuICAgICAgICBtIDogJ21pbnV0dSBiYXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0dScsXHJcbiAgICAgICAgaCA6ICdvcmR1IGJhdCcsXHJcbiAgICAgICAgaGggOiAnJWQgb3JkdScsXHJcbiAgICAgICAgZCA6ICdlZ3VuIGJhdCcsXHJcbiAgICAgICAgZGQgOiAnJWQgZWd1bicsXHJcbiAgICAgICAgTSA6ICdoaWxhYmV0ZSBiYXQnLFxyXG4gICAgICAgIE1NIDogJyVkIGhpbGFiZXRlJyxcclxuICAgICAgICB5IDogJ3VydGUgYmF0JyxcclxuICAgICAgICB5eSA6ICclZCB1cnRlJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZXU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V1LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2V1LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUGVyc2lhbiBbZmFdXHJcbi8vISBhdXRob3IgOiBFYnJhaGltIEJ5YWdvd2kgOiBodHRwczovL2dpdGh1Yi5jb20vZWJyYW1pbmlvXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAn27EnLFxyXG4gICAgJzInOiAn27InLFxyXG4gICAgJzMnOiAn27MnLFxyXG4gICAgJzQnOiAn27QnLFxyXG4gICAgJzUnOiAn27UnLFxyXG4gICAgJzYnOiAn27YnLFxyXG4gICAgJzcnOiAn27cnLFxyXG4gICAgJzgnOiAn27gnLFxyXG4gICAgJzknOiAn27knLFxyXG4gICAgJzAnOiAn27AnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn27EnOiAnMScsXHJcbiAgICAn27InOiAnMicsXHJcbiAgICAn27MnOiAnMycsXHJcbiAgICAn27QnOiAnNCcsXHJcbiAgICAn27UnOiAnNScsXHJcbiAgICAn27YnOiAnNicsXHJcbiAgICAn27cnOiAnNycsXHJcbiAgICAn27gnOiAnOCcsXHJcbiAgICAn27knOiAnOScsXHJcbiAgICAn27AnOiAnMCdcclxufTtcclxuXHJcbnZhciBmYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2ZhJywge1xyXG4gICAgbW9udGhzIDogJ9qY2KfZhtmI24zZh1/ZgdmI2LHbjNmHX9mF2KfYsdizX9ii2YjYsduM2YRf2YXZh1/amNmI2KbZhl/amNmI2KbbjNmHX9in2YjYql/Ys9m+2KrYp9mF2KjYsV/Yp9qp2KrYqNixX9mG2YjYp9mF2KjYsV/Yr9iz2KfZhdio2LEnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfamNin2YbZiNuM2Ydf2YHZiNix24zZh1/Zhdin2LHYs1/YotmI2LHbjNmEX9mF2Ydf2pjZiNim2YZf2pjZiNim24zZh1/Yp9mI2Kpf2LPZvtiq2KfZhdio2LFf2Kfaqdiq2KjYsV/ZhtmI2KfZhdio2LFf2K/Ys9in2YXYqNixJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn24zaqVxcdTIwMGPYtNmG2KjZh1/Yr9mI2LTZhtio2Ydf2LPZh1xcdTIwMGPYtNmG2KjZh1/ahtmH2KfYsdi02YbYqNmHX9m+2YbYrFxcdTIwMGPYtNmG2KjZh1/YrNmF2LnZh1/YtNmG2KjZhycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn24zaqVxcdTIwMGPYtNmG2KjZh1/Yr9mI2LTZhtio2Ydf2LPZh1xcdTIwMGPYtNmG2KjZh1/ahtmH2KfYsdi02YbYqNmHX9m+2YbYrFxcdTIwMGPYtNmG2KjZh1/YrNmF2LnZh1/YtNmG2KjZhycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9uMX9ivX9izX9qGX9m+X9isX9i0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv2YLYqNmEINin2LIg2LjZh9ixfNio2LnYryDYp9iyINi42YfYsS8sXHJcbiAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL9io2LnYryDYp9iyINi42YfYsS8udGVzdChpbnB1dCk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9mC2KjZhCDYp9iyINi42YfYsSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfYqNi52K8g2KfYsiDYuNmH2LEnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vYp9mF2LHZiNiyINiz2KfYudiqXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb2YHYsdiv2Kcg2LPYp9i52KpdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvYs9in2LnYql0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9iv24zYsdmI2LIg2LPYp9i52KpdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFvZvtuM2LRdIFvYs9in2LnYql0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfYr9ixICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzINm+24zYtCcsXHJcbiAgICAgICAgcyA6ICfahtmG2K8g2KvYp9mG24zZhycsXHJcbiAgICAgICAgbSA6ICfbjNqpINiv2YLbjNmC2YcnLFxyXG4gICAgICAgIG1tIDogJyVkINiv2YLbjNmC2YcnLFxyXG4gICAgICAgIGggOiAn24zaqSDYs9in2LnYqicsXHJcbiAgICAgICAgaGggOiAnJWQg2LPYp9i52KonLFxyXG4gICAgICAgIGQgOiAn24zaqSDYsdmI2LInLFxyXG4gICAgICAgIGRkIDogJyVkINix2YjYsicsXHJcbiAgICAgICAgTSA6ICfbjNqpINmF2KfZhycsXHJcbiAgICAgICAgTU0gOiAnJWQg2YXYp9mHJyxcclxuICAgICAgICB5IDogJ9uM2qkg2LPYp9mEJyxcclxuICAgICAgICB5eSA6ICclZCDYs9in2YQnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1vbsC3buV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KS5yZXBsYWNlKC8sL2csICfYjCcpO1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfdmFLyxcclxuICAgIG9yZGluYWwgOiAnJWTZhScsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogMTIgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBmYTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBGaW5uaXNoIFtmaV1cclxuLy8hIGF1dGhvciA6IFRhcm1vIEFpZGFudGF1c3RhIDogaHR0cHM6Ly9naXRodWIuY29tL2JsZWFkb2ZcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBudW1iZXJzUGFzdCA9ICdub2xsYSB5a3NpIGtha3NpIGtvbG1lIG5lbGrDpCB2aWlzaSBrdXVzaSBzZWl0c2Vtw6RuIGthaGRla3NhbiB5aGRla3PDpG4nLnNwbGl0KCcgJyk7XHJcbnZhciBudW1iZXJzRnV0dXJlID0gW1xyXG4gICAgICAgICdub2xsYScsICd5aGRlbicsICdrYWhkZW4nLCAna29sbWVuJywgJ25lbGrDpG4nLCAndmlpZGVuJywgJ2t1dWRlbicsXHJcbiAgICAgICAgbnVtYmVyc1Bhc3RbN10sIG51bWJlcnNQYXN0WzhdLCBudW1iZXJzUGFzdFs5XVxyXG4gICAgXTtcclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ211dXRhbWFuIHNla3VubmluJyA6ICdtdXV0YW1hIHNla3VudGknO1xyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICByZXR1cm4gaXNGdXR1cmUgPyAnbWludXV0aW4nIDogJ21pbnV1dHRpJztcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ21pbnV1dGluJyA6ICdtaW51dXR0aWEnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ3R1bm5pbicgOiAndHVudGknO1xyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAndHVubmluJyA6ICd0dW50aWEnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ3DDpGl2w6RuJyA6ICdww6RpdsOkJztcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGlzRnV0dXJlID8gJ3DDpGl2w6RuJyA6ICdww6RpdsOkw6QnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ2t1dWthdWRlbicgOiAna3V1a2F1c2knO1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAna3V1a2F1ZGVuJyA6ICdrdXVrYXV0dGEnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICd5JzpcclxuICAgICAgICAgICAgcmV0dXJuIGlzRnV0dXJlID8gJ3Z1b2RlbicgOiAndnVvc2knO1xyXG4gICAgICAgIGNhc2UgJ3l5JzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gaXNGdXR1cmUgPyAndnVvZGVuJyA6ICd2dW90dGEnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJlc3VsdCA9IHZlcmJhbE51bWJlcihudW1iZXIsIGlzRnV0dXJlKSArICcgJyArIHJlc3VsdDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gdmVyYmFsTnVtYmVyKG51bWJlciwgaXNGdXR1cmUpIHtcclxuICAgIHJldHVybiBudW1iZXIgPCAxMCA/IChpc0Z1dHVyZSA/IG51bWJlcnNGdXR1cmVbbnVtYmVyXSA6IG51bWJlcnNQYXN0W251bWJlcl0pIDogbnVtYmVyO1xyXG59XHJcblxyXG52YXIgZmkgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmaScsIHtcclxuICAgIG1vbnRocyA6ICd0YW1taWt1dV9oZWxtaWt1dV9tYWFsaXNrdXVfaHVodGlrdXVfdG91a29rdXVfa2Vzw6RrdXVfaGVpbsOka3V1X2Vsb2t1dV9zeXlza3V1X2xva2FrdXVfbWFycmFza3V1X2pvdWx1a3V1Jy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAndGFtbWlfaGVsbWlfbWFhbGlzX2h1aHRpX3RvdWtvX2tlc8OkX2hlaW7DpF9lbG9fc3l5c19sb2thX21hcnJhc19qb3VsdScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3N1bm51bnRhaV9tYWFuYW50YWlfdGlpc3RhaV9rZXNraXZpaWtrb190b3JzdGFpX3BlcmphbnRhaV9sYXVhbnRhaScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc3VfbWFfdGlfa2VfdG9fcGVfbGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdzdV9tYV90aV9rZV90b19wZV9sYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hILm1tJyxcclxuICAgICAgICBMVFMgOiAnSEgubW0uc3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRG8gTU1NTVt0YV0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0RvIE1NTU1bdGFdIFlZWVksIFtrbG9dIEhILm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIERvIE1NTU1bdGFdIFlZWVksIFtrbG9dIEhILm1tJyxcclxuICAgICAgICBsIDogJ0QuTS5ZWVlZJyxcclxuICAgICAgICBsbCA6ICdEbyBNTU0gWVlZWScsXHJcbiAgICAgICAgbGxsIDogJ0RvIE1NTSBZWVlZLCBba2xvXSBISC5tbScsXHJcbiAgICAgICAgbGxsbCA6ICdkZGQsIERvIE1NTSBZWVlZLCBba2xvXSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1t0w6Ruw6TDpG5dIFtrbG9dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1todW9tZW5uYV0gW2tsb10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2tsb10gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW2VpbGVuXSBba2xvXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW3ZpaW1lXSBkZGRkW25hXSBba2xvXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIHDDpMOkc3TDpCcsXHJcbiAgICAgICAgcGFzdCA6ICclcyBzaXR0ZW4nLFxyXG4gICAgICAgIHMgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGhoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5IDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHl5IDogdHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBmaTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZmkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBGYXJvZXNlIFtmb11cclxuLy8hIGF1dGhvciA6IFJhZ25hciBKb2hhbm5lc2VuIDogaHR0cHM6Ly9naXRodWIuY29tL3JhZ25hcjEyM1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGZvID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZm8nLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFyc19hcHLDrWxfbWFpX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ3N1bm51ZGFndXJfbcOhbmFkYWd1cl90w71zZGFndXJfbWlrdWRhZ3VyX2jDs3NkYWd1cl9mcsOtZ2dqYWRhZ3VyX2xleWdhcmRhZ3VyJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdzdW5fbcOhbl90w71zX21pa19ow7NzX2Zyw61fbGV5Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnc3VfbcOhX3TDvV9taV9ow7NfZnJfbGUnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NLCBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW8ONIGRhZyBrbC5dIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vDjSBtb3JnaW4ga2wuXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBba2wuXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbw40gZ2rDoXIga2wuXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW3PDrcOwc3R1XSBkZGRkIFtrbF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd1bSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBzw63DsGFuaScsXHJcbiAgICAgICAgcyA6ICdmw6Egc2VrdW5kJyxcclxuICAgICAgICBtIDogJ2VpbiBtaW51dHQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0dGlyJyxcclxuICAgICAgICBoIDogJ2VpbiB0w61taScsXHJcbiAgICAgICAgaGggOiAnJWQgdMOtbWFyJyxcclxuICAgICAgICBkIDogJ2VpbiBkYWd1cicsXHJcbiAgICAgICAgZGQgOiAnJWQgZGFnYXInLFxyXG4gICAgICAgIE0gOiAnZWluIG3DoW5hw7BpJyxcclxuICAgICAgICBNTSA6ICclZCBtw6FuYcOwaXInLFxyXG4gICAgICAgIHkgOiAnZWl0dCDDoXInLFxyXG4gICAgICAgIHl5IDogJyVkIMOhcidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGZvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mby5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mby5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEZyZW5jaCAoQ2FuYWRhKSBbZnItY2FdXHJcbi8vISBhdXRob3IgOiBKb25hdGhhbiBBYm91cmJpaCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb25iY2FcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBmckNhID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnItY2EnLCB7XHJcbiAgICBtb250aHMgOiAnamFudmllcl9mw6l2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW/Du3Rfc2VwdGVtYnJlX29jdG9icmVfbm92ZW1icmVfZMOpY2VtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFudi5fZsOpdnIuX21hcnNfYXZyLl9tYWlfanVpbl9qdWlsLl9hb8O7dF9zZXB0Ll9vY3QuX25vdi5fZMOpYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2RpbWFuY2hlX2x1bmRpX21hcmRpX21lcmNyZWRpX2pldWRpX3ZlbmRyZWRpX3NhbWVkaScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZGltLl9sdW4uX21hci5fbWVyLl9qZXUuX3Zlbi5fc2FtLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0RpX0x1X01hX01lX0plX1ZlX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0F1am91cmTigJlodWkgw6BdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tEZW1haW4gw6BdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvDoF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0hpZXIgw6BdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtkZXJuaWVyIMOgXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhbnMgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnaWwgeSBhICVzJyxcclxuICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcclxuICAgICAgICBtIDogJ3VuZSBtaW51dGUnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGggOiAndW5lIGhldXJlJyxcclxuICAgICAgICBoaCA6ICclZCBoZXVyZXMnLFxyXG4gICAgICAgIGQgOiAndW4gam91cicsXHJcbiAgICAgICAgZGQgOiAnJWQgam91cnMnLFxyXG4gICAgICAgIE0gOiAndW4gbW9pcycsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9pcycsXHJcbiAgICAgICAgeSA6ICd1biBhbicsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5zJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShlcnxlKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBtYXNjdWxpbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBtb2lzLCB0cmltZXN0cmUsIGpvdXJcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdlcicgOiAnZScpO1xyXG5cclxuICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBmZW1pbmluZSBncmFtbWF0aWNhbCBnZW5kZXI6IHNlbWFpbmVcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAncmUnIDogJ2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGZyQ2E7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ZyLWNhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogRnJlbmNoIChTd2l0emVybGFuZCkgW2ZyLWNoXVxyXG4vLyEgYXV0aG9yIDogR2FzcGFyZCBCdWNoZXIgOiBodHRwczovL2dpdGh1Yi5jb20vZ2FzcGFyZFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGZyQ2ggPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdmci1jaCcsIHtcclxuICAgIG1vbnRocyA6ICdqYW52aWVyX2bDqXZyaWVyX21hcnNfYXZyaWxfbWFpX2p1aW5fanVpbGxldF9hb8O7dF9zZXB0ZW1icmVfb2N0b2JyZV9ub3ZlbWJyZV9kw6ljZW1icmUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW52Ll9mw6l2ci5fbWFyc19hdnIuX21haV9qdWluX2p1aWwuX2Fvw7t0X3NlcHQuX29jdC5fbm92Ll9kw6ljLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnZGltYW5jaGVfbHVuZGlfbWFyZGlfbWVyY3JlZGlfamV1ZGlfdmVuZHJlZGlfc2FtZWRpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkaW0uX2x1bi5fbWFyLl9tZXIuX2pldS5fdmVuLl9zYW0uJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnRGlfTHVfTWFfTWVfSmVfVmVfU2EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbQXVqb3VyZOKAmWh1aSDDoF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW0RlbWFpbiDDoF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW8OgXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbSGllciDDoF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2Rlcm5pZXIgw6BdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnZGFucyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdpbCB5IGEgJXMnLFxyXG4gICAgICAgIHMgOiAncXVlbHF1ZXMgc2Vjb25kZXMnLFxyXG4gICAgICAgIG0gOiAndW5lIG1pbnV0ZScsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXHJcbiAgICAgICAgaCA6ICd1bmUgaGV1cmUnLFxyXG4gICAgICAgIGhoIDogJyVkIGhldXJlcycsXHJcbiAgICAgICAgZCA6ICd1biBqb3VyJyxcclxuICAgICAgICBkZCA6ICclZCBqb3VycycsXHJcbiAgICAgICAgTSA6ICd1biBtb2lzJyxcclxuICAgICAgICBNTSA6ICclZCBtb2lzJyxcclxuICAgICAgICB5IDogJ3VuIGFuJyxcclxuICAgICAgICB5eSA6ICclZCBhbnMnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGVyfGUpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICAvLyBXb3JkcyB3aXRoIG1hc2N1bGluZSBncmFtbWF0aWNhbCBnZW5kZXI6IG1vaXMsIHRyaW1lc3RyZSwgam91clxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ2VyJyA6ICdlJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBXb3JkcyB3aXRoIGZlbWluaW5lIGdyYW1tYXRpY2FsIGdlbmRlcjogc2VtYWluZVxyXG4gICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgY2FzZSAnVyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdyZScgOiAnZScpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gZnJDaDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2guanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZnItY2guanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBGcmVuY2ggW2ZyXVxyXG4vLyEgYXV0aG9yIDogSm9obiBGaXNjaGVyIDogaHR0cHM6Ly9naXRodWIuY29tL2pmcm9mZmljZVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGZyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnInLCB7XHJcbiAgICBtb250aHMgOiAnamFudmllcl9mw6l2cmllcl9tYXJzX2F2cmlsX21haV9qdWluX2p1aWxsZXRfYW/Du3Rfc2VwdGVtYnJlX29jdG9icmVfbm92ZW1icmVfZMOpY2VtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFudi5fZsOpdnIuX21hcnNfYXZyLl9tYWlfanVpbl9qdWlsLl9hb8O7dF9zZXB0Ll9vY3QuX25vdi5fZMOpYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2RpbWFuY2hlX2x1bmRpX21hcmRpX21lcmNyZWRpX2pldWRpX3ZlbmRyZWRpX3NhbWVkaScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnZGltLl9sdW4uX21hci5fbWVyLl9qZXUuX3Zlbi5fc2FtLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0RpX0x1X01hX01lX0plX1ZlX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0F1am91cmTigJlodWkgw6BdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tEZW1haW4gw6BdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvDoF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW0hpZXIgw6BdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtkZXJuaWVyIMOgXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhbnMgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnaWwgeSBhICVzJyxcclxuICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcclxuICAgICAgICBtIDogJ3VuZSBtaW51dGUnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxyXG4gICAgICAgIGggOiAndW5lIGhldXJlJyxcclxuICAgICAgICBoaCA6ICclZCBoZXVyZXMnLFxyXG4gICAgICAgIGQgOiAndW4gam91cicsXHJcbiAgICAgICAgZGQgOiAnJWQgam91cnMnLFxyXG4gICAgICAgIE0gOiAndW4gbW9pcycsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9pcycsXHJcbiAgICAgICAgeSA6ICd1biBhbicsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5zJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfShlcnwpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBSZXR1cm4gJ2UnIHdoZW4gZGF5IG9mIG1vbnRoID4gMS4gTW92ZSB0aGlzIGNhc2UgaW5zaWRlXHJcbiAgICAgICAgICAgIC8vIGJsb2NrIGZvciBtYXNjdWxpbmUgd29yZHMgYmVsb3cuXHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMzM3NVxyXG4gICAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ2VyJyA6ICcnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggbWFzY3VsaW5lIGdyYW1tYXRpY2FsIGdlbmRlcjogbW9pcywgdHJpbWVzdHJlLCBqb3VyXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICBjYXNlICdRJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgKG51bWJlciA9PT0gMSA/ICdlcicgOiAnZScpO1xyXG5cclxuICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBmZW1pbmluZSBncmFtbWF0aWNhbCBnZW5kZXI6IHNlbWFpbmVcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIChudW1iZXIgPT09IDEgPyAncmUnIDogJ2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGZyO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEZyaXNpYW4gW2Z5XVxyXG4vLyEgYXV0aG9yIDogUm9iaW4gdmFuIGRlciBWbGlldCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yb2JpbjB2YW4wZGVyMHZcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHNTaG9ydFdpdGhEb3RzID0gJ2phbi5fZmViLl9tcnQuX2Fwci5fbWFpX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2Rlcy4nLnNwbGl0KCdfJyk7XHJcbnZhciBtb250aHNTaG9ydFdpdGhvdXREb3RzID0gJ2phbl9mZWJfbXJ0X2Fwcl9tYWlfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVzJy5zcGxpdCgnXycpO1xyXG5cclxudmFyIGZ5ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnknLCB7XHJcbiAgICBtb250aHMgOiAnamFubmV3YXJpc19mZWJyZXdhcmlzX21hYXJ0X2FwcmlsX21hYWllX2p1bnlfanVseV9hdWd1c3R1c19zZXB0aW1iZXJfb2t0b2Jlcl9ub3ZpbWJlcl9kZXNpbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0sIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRoRG90cztcclxuICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhvdXREb3RzW20ubW9udGgoKV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHNbbS5tb250aCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdzbmVpbl9tb2FuZGVpX3RpaXNkZWlfd29hbnNkZWlfdG9uZ2Vyc2RlaV9mcmVlZF9zbmVvbicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc2kuX21vLl90aS5fd28uX3RvLl9mci5fc28uJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU2lfTW9fVGlfV29fVG9fRnJfU28nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC1NTS1ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1toam9lZCBvbV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbbW9hcm4gb21dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW29tXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tqdXN0ZXIgb21dIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1vDtGZyw7tuZV0gZGRkZCBbb21dIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdvZXIgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgbHluJyxcclxuICAgICAgICBzIDogJ2luIHBlYXIgc2Vrb25kZW4nLFxyXG4gICAgICAgIG0gOiAnaWVuIG1pbsO6dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlbicsXHJcbiAgICAgICAgaCA6ICdpZW4gb2VyZScsXHJcbiAgICAgICAgaGggOiAnJWQgb2VyZW4nLFxyXG4gICAgICAgIGQgOiAnaWVuIGRlaScsXHJcbiAgICAgICAgZGQgOiAnJWQgZGFnZW4nLFxyXG4gICAgICAgIE0gOiAnaWVuIG1vYW5uZScsXHJcbiAgICAgICAgTU0gOiAnJWQgbW9hbm5lbicsXHJcbiAgICAgICAgeSA6ICdpZW4gamllcicsXHJcbiAgICAgICAgeXkgOiAnJWQgamllcnJlbidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3RlfGRlKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAoKG51bWJlciA9PT0gMSB8fCBudW1iZXIgPT09IDggfHwgbnVtYmVyID49IDIwKSA/ICdzdGUnIDogJ2RlJyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGZ5O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9meS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9meS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFNjb3R0aXNoIEdhZWxpYyBbZ2RdXHJcbi8vISBhdXRob3IgOiBKb24gQXNoZG93biA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb25hc2hkb3duXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzID0gW1xyXG4gICAgJ0FtIEZhb2lsbGVhY2gnLCAnQW4gR2VhcnJhbicsICdBbSBNw6BydCcsICdBbiBHaWJsZWFuJywgJ0FuIEPDqGl0ZWFuJywgJ0FuIHQtw5JnbWhpb3MnLCAnQW4gdC1JdWNoYXInLCAnQW4gTMO5bmFzdGFsJywgJ0FuIHQtU3VsdGFpbicsICdBbiBEw6BtaGFpcicsICdBbiB0LVNhbWhhaW4nLCAnQW4gRMO5YmhsYWNoZCdcclxuXTtcclxuXHJcbnZhciBtb250aHNTaG9ydCA9IFsnRmFvaScsICdHZWFyJywgJ03DoHJ0JywgJ0dpYmwnLCAnQ8OoaXQnLCAnw5JnbWgnLCAnSXVjaCcsICdMw7luJywgJ1N1bHQnLCAnRMOgbWgnLCAnU2FtaCcsICdEw7liaCddO1xyXG5cclxudmFyIHdlZWtkYXlzID0gWydEaWTDsm1obmFpY2gnLCAnRGlsdWFpbicsICdEaW3DoGlydCcsICdEaWNpYWRhaW4nLCAnRGlhcmRhb2luJywgJ0RpaGFvaW5lJywgJ0Rpc2F0aGFpcm5lJ107XHJcblxyXG52YXIgd2Vla2RheXNTaG9ydCA9IFsnRGlkJywgJ0RpbCcsICdEaW0nLCAnRGljJywgJ0RpYScsICdEaWgnLCAnRGlzJ107XHJcblxyXG52YXIgd2Vla2RheXNNaW4gPSBbJ0TDsicsICdMdScsICdNw6AnLCAnQ2knLCAnQXInLCAnSGEnLCAnU2EnXTtcclxuXHJcbnZhciBnZCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2dkJywge1xyXG4gICAgbW9udGhzIDogbW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiB3ZWVrZGF5cyxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiB3ZWVrZGF5c1Nob3J0LFxyXG4gICAgd2Vla2RheXNNaW4gOiB3ZWVrZGF5c01pbixcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tBbi1kaXVnaCBhaWddIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tBLW3DoGlyZWFjaCBhaWddIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthaWddIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tBbi1kw6ggYWlnXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbc2VvIGNoYWlkaF0gW2FpZ10gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdhbm4gYW4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnYmhvIGNoaW9ubiAlcycsXHJcbiAgICAgICAgcyA6ICdiZWFnYW4gZGlvZ2FuJyxcclxuICAgICAgICBtIDogJ21pb25haWQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pb25haWRlYW4nLFxyXG4gICAgICAgIGggOiAndWFpcicsXHJcbiAgICAgICAgaGggOiAnJWQgdWFpcmVhbicsXHJcbiAgICAgICAgZCA6ICdsYXRoYScsXHJcbiAgICAgICAgZGQgOiAnJWQgbGF0aGEnLFxyXG4gICAgICAgIE0gOiAnbcOsb3MnLFxyXG4gICAgICAgIE1NIDogJyVkIG3DrG9zYW4nLFxyXG4gICAgICAgIHkgOiAnYmxpYWRobmEnLFxyXG4gICAgICAgIHl5IDogJyVkIGJsaWFkaG5hJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn0oZHxuYXxtaCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgb3V0cHV0ID0gbnVtYmVyID09PSAxID8gJ2QnIDogbnVtYmVyICUgMTAgPT09IDIgPyAnbmEnIDogJ21oJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBnZDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBHYWxpY2lhbiBbZ2xdXHJcbi8vISBhdXRob3IgOiBKdWFuIEcuIEh1cnRhZG8gOiBodHRwczovL2dpdGh1Yi5jb20vanVhbmdodXJ0YWRvXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgZ2wgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdnbCcsIHtcclxuICAgIG1vbnRocyA6ICd4YW5laXJvX2ZlYnJlaXJvX21hcnpvX2FicmlsX21haW9feHXDsW9feHVsbG9fYWdvc3RvX3NldGVtYnJvX291dHVicm9fbm92ZW1icm9fZGVjZW1icm8nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICd4YW4uX2ZlYi5fbWFyLl9hYnIuX21haS5feHXDsS5feHVsLl9hZ28uX3NldC5fb3V0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnZG9taW5nb19sdW5zX21hcnRlc19tw6lyY29yZXNfeG92ZXNfdmVucmVzX3PDoWJhZG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2RvbS5fbHVuLl9tYXIuX23DqXIuX3hvdi5fdmVuLl9zw6FiLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ2RvX2x1X21hX23DqV94b192ZV9zw6EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdbaG94ZSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhcycgOiAnw6EnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHREYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnW21hw7HDoSAnICsgKCh0aGlzLmhvdXJzKCkgIT09IDEpID8gJ8OhcycgOiAnw6EnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2RkZGQgWycgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6FzJyA6ICdhJykgKyAnXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1tvbnRlICcgKyAoKHRoaXMuaG91cnMoKSAhPT0gMSkgPyAnw6EnIDogJ2EnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1tvXSBkZGRkIFtwYXNhZG8gJyArICgodGhpcy5ob3VycygpICE9PSAxKSA/ICfDoXMnIDogJ2EnKSArICddIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCd1bicpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ24nICsgc3RyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnZW4gJyArIHN0cjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhc3QgOiAnaGFpICVzJyxcclxuICAgICAgICBzIDogJ3VucyBzZWd1bmRvcycsXHJcbiAgICAgICAgbSA6ICd1biBtaW51dG8nLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnV0b3MnLFxyXG4gICAgICAgIGggOiAndW5oYSBob3JhJyxcclxuICAgICAgICBoaCA6ICclZCBob3JhcycsXHJcbiAgICAgICAgZCA6ICd1biBkw61hJyxcclxuICAgICAgICBkZCA6ICclZCBkw61hcycsXHJcbiAgICAgICAgTSA6ICd1biBtZXMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2VzJyxcclxuICAgICAgICB5IDogJ3VuIGFubycsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5vcydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ9wrovLFxyXG4gICAgb3JkaW5hbCA6ICclZMK6JyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBnbDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2wuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvZ2wuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBLb25rYW5pIExhdGluIHNjcmlwdCBbZ29tLWxhdG5dXHJcbi8vISBhdXRob3IgOiBUaGUgRGlzY292ZXJlciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9XaWtpRGlzY292ZXJlclxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ3MnOiBbJ3Rob2RkZSBzZWNvbmRhbmltJywgJ3Rob2RkZSBzZWNvbmQnXSxcclxuICAgICAgICAnbSc6IFsnZWthIG1pbnRhbicsICdlayBtaW51dGUnXSxcclxuICAgICAgICAnbW0nOiBbbnVtYmVyICsgJyBtaW50YW5pbScsIG51bWJlciArICcgbWludGFtJ10sXHJcbiAgICAgICAgJ2gnOiBbJ2VrYSBob3JhbicsICdlayBob3InXSxcclxuICAgICAgICAnaGgnOiBbbnVtYmVyICsgJyBob3JhbmltJywgbnVtYmVyICsgJyBob3InXSxcclxuICAgICAgICAnZCc6IFsnZWthIGRpc2FuJywgJ2VrIGRpcyddLFxyXG4gICAgICAgICdkZCc6IFtudW1iZXIgKyAnIGRpc2FuaW0nLCBudW1iZXIgKyAnIGRpcyddLFxyXG4gICAgICAgICdNJzogWydla2EgbWhvaW5lYW4nLCAnZWsgbWhvaW5vJ10sXHJcbiAgICAgICAgJ01NJzogW251bWJlciArICcgbWhvaW5lYW5pbScsIG51bWJlciArICcgbWhvaW5lJ10sXHJcbiAgICAgICAgJ3knOiBbJ2VrYSB2b3JzYW4nLCAnZWsgdm9yb3MnXSxcclxuICAgICAgICAneXknOiBbbnVtYmVyICsgJyB2b3JzYW5pbScsIG51bWJlciArICcgdm9yc2FtJ11cclxuICAgIH07XHJcbiAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1hdFtrZXldWzBdIDogZm9ybWF0W2tleV1bMV07XHJcbn1cclxuXHJcbnZhciBnb21MYXRuID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZ29tLWxhdG4nLCB7XHJcbiAgICBtb250aHMgOiAnSmFuZXJfRmVicmVyX01hcnNfQWJyaWxfTWFpX0p1bl9KdWxhaV9BZ29zdF9TZXRlbWJyX090dWJyX05vdmVtYnJfRGV6ZW1icicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbi5fRmViLl9NYXJzX0Fici5fTWFpX0p1bl9KdWwuX0Fnby5fU2V0Ll9PdHUuX05vdi5fRGV6Licuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnQWl0YXJfU29tYXJfTW9uZ2xsYXJfQnVkdmFyX0JyZXN0YXJfU3VrcmFyX1NvblxcJ3Zhcicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnQWl0Ll9Tb20uX01vbi5fQnVkLl9CcmUuX1N1ay5fU29uLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0FpX1NtX01vX0J1X0JyX1N1X1NuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbSBbdmF6dGFdJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIFt2YXp0YV0nLFxyXG4gICAgICAgIEwgOiAnREQtTU0tWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBBIGg6bW0gW3ZhenRhXScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NW2FjaGVhXSBEbywgWVlZWSwgQSBoOm1tIFt2YXp0YV0nLFxyXG4gICAgICAgIGxsbGw6ICdkZGQsIEQgTU1NIFlZWVksIEEgaDptbSBbdmF6dGFdJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbQWl6XSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tGYWxlYW1dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ1tJZXRhIHRvXSBkZGRkWyxdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW0thbF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW0ZhdGxvXSBkZGRkWyxdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBhZGltJyxcclxuICAgICAgICBzIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBtbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgaGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGRkIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBNTSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeXkgOiBwcm9jZXNzUmVsYXRpdmVUaW1lXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfShlcikvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBvcmRpbmFsICdlcicgb25seSBhcHBsaWVzIHRvIGRheSBvZiB0aGUgbW9udGhcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ2VyJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL3JhdGl8c29rYWxsaXxkb25wYXJhbXxzYW5qZS8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ3JhdGknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3Nva2FsbGknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdkb25wYXJhbScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPiAxMiA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3NhbmplJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdyYXRpJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3Nva2FsbGknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZG9ucGFyYW0nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnc2FuamUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncmF0aSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBnb21MYXRuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nb20tbGF0bi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9nb20tbGF0bi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEd1amFyYXRpIFtndV1cclxuLy8hIGF1dGhvciA6IEthdXNoaWsgVGhhbmtpIDogaHR0cHM6Ly9naXRodWIuY29tL0thdXNoaWsxOTg3XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgICAgICcxJzogJ+CrpycsXHJcbiAgICAgICAgJzInOiAn4KuoJyxcclxuICAgICAgICAnMyc6ICfgq6knLFxyXG4gICAgICAgICc0JzogJ+CrqicsXHJcbiAgICAgICAgJzUnOiAn4KurJyxcclxuICAgICAgICAnNic6ICfgq6wnLFxyXG4gICAgICAgICc3JzogJ+CrrScsXHJcbiAgICAgICAgJzgnOiAn4KuuJyxcclxuICAgICAgICAnOSc6ICfgq68nLFxyXG4gICAgICAgICcwJzogJ+CrpidcclxuICAgIH07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAgICAgJ+Crpyc6ICcxJyxcclxuICAgICAgICAn4KuoJzogJzInLFxyXG4gICAgICAgICfgq6knOiAnMycsXHJcbiAgICAgICAgJ+Crqic6ICc0JyxcclxuICAgICAgICAn4KurJzogJzUnLFxyXG4gICAgICAgICfgq6wnOiAnNicsXHJcbiAgICAgICAgJ+CrrSc6ICc3JyxcclxuICAgICAgICAn4KuuJzogJzgnLFxyXG4gICAgICAgICfgq68nOiAnOScsXHJcbiAgICAgICAgJ+Crpic6ICcwJ1xyXG4gICAgfTtcclxuXHJcbnZhciBndSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2d1Jywge1xyXG4gICAgbW9udGhzOiAn4Kqc4Kq+4Kqo4KuN4Kqv4KuB4KqG4Kqw4KuAX+Cqq+Crh+CqrOCrjeCqsOCrgeCqhuCqsOCrgF/gqq7gqr7gqrDgq43gqppf4KqP4Kqq4KuN4Kqw4Kq/4KqyX+CqruCrh1/gqpzgq4Lgqqhf4Kqc4KuB4Kqy4Kq+4KqIX+CqkeCql+CquOCrjeCqn1/gqrjgqqrgq43gqp/gq4fgqq7gq43gqqzgqrBf4KqR4KqV4KuN4Kqf4KuN4Kqs4KqwX+CqqOCqteCrh+CqruCrjeCqrOCqsF/gqqHgqr/gqrjgq4fgqq7gq43gqqzgqrAnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ+CqnOCqvuCqqOCrjeCqr+CrgS5f4Kqr4KuH4Kqs4KuN4Kqw4KuBLl/gqq7gqr7gqrDgq43gqppf4KqP4Kqq4KuN4Kqw4Kq/Ll/gqq7gq4df4Kqc4KuC4KqoX+CqnOCrgeCqsuCqvi5f4KqR4KqXLl/gqrjgqqrgq43gqp/gq4cuX+CqkeCqleCrjeCqn+CrjS5f4Kqo4Kq14KuHLl/gqqHgqr/gqrjgq4cuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzOiAn4Kqw4Kq14Kq/4Kq14Kq+4KqwX+CquOCri+CqruCqteCqvuCqsF/gqq7gqoLgqpfgqrPgqrXgqr7gqrBf4Kqs4KuB4Kqn4KuN4Kq14Kq+4KqwX+Cql+CrgeCqsOCrgeCqteCqvuCqsF/gqrbgq4HgqpXgq43gqrDgqrXgqr7gqrBf4Kq24Kqo4Kq/4Kq14Kq+4KqwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ+CqsOCqteCqv1/gqrjgq4vgqq5f4Kqu4KqC4KqX4KqzX+CqrOCrgeCqp+CrjV/gqpfgq4HgqrDgq4Ff4Kq24KuB4KqV4KuN4KqwX+CqtuCqqOCqvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluOiAn4KqwX+CquOCri1/gqq7gqoJf4Kqs4KuBX+Cql+CrgV/gqrbgq4Ff4Kq2Jy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0EgaDptbSDgqrXgqr7gqpfgq43gqq/gq4cnLFxyXG4gICAgICAgIExUUzogJ0EgaDptbTpzcyDgqrXgqr7gqpfgq43gqq/gq4cnLFxyXG4gICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEw6ICdEIE1NTU0gWVlZWSwgQSBoOm1tIOCqteCqvuCql+CrjeCqr+CrhycsXHJcbiAgICAgICAgTExMTDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0g4Kq14Kq+4KqX4KuN4Kqv4KuHJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vgqobgqpxdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW+CqleCqvuCqsuCrh10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCwgTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb4KqX4KqH4KqV4Kq+4Kqy4KuHXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdb4Kqq4Kq+4Kqb4Kqy4Kq+XSBkZGRkLCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZToge1xyXG4gICAgICAgIGZ1dHVyZTogJyVzIOCqruCqvicsXHJcbiAgICAgICAgcGFzdDogJyVzIOCqquCrh+CqueCqsuCqvicsXHJcbiAgICAgICAgczogJ+CqheCqruCrgeCqlSDgqqrgqrPgq4snLFxyXG4gICAgICAgIG06ICfgqo/gqpUg4Kqu4Kq/4Kqo4Kq/4KqfJyxcclxuICAgICAgICBtbTogJyVkIOCqruCqv+CqqOCqv+CqnycsXHJcbiAgICAgICAgaDogJ+Cqj+CqlSDgqpXgqrLgqr7gqpUnLFxyXG4gICAgICAgIGhoOiAnJWQg4KqV4Kqy4Kq+4KqVJyxcclxuICAgICAgICBkOiAn4KqP4KqVIOCqpuCqv+CqteCquCcsXHJcbiAgICAgICAgZGQ6ICclZCDgqqbgqr/gqrXgqrgnLFxyXG4gICAgICAgIE06ICfgqo/gqpUg4Kqu4Kq54Kq/4Kqo4KuLJyxcclxuICAgICAgICBNTTogJyVkIOCqruCqueCqv+CqqOCriycsXHJcbiAgICAgICAgeTogJ+Cqj+CqlSDgqrXgqrDgq43gqrcnLFxyXG4gICAgICAgIHl5OiAnJWQg4Kq14Kqw4KuN4Kq3J1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4Kun4Kuo4Kup4Kuq4Kur4Kus4Kut4Kuu4Kuv4KumXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyBHdWphcmF0aSBub3RhdGlvbiBmb3IgbWVyaWRpZW1zIGFyZSBxdWl0ZSBmdXp6eSBpbiBwcmFjdGljZS4gV2hpbGUgdGhlcmUgZXhpc3RzXHJcbiAgICAvLyBhIHJpZ2lkIG5vdGlvbiBvZiBhICdQYWhhcicgaXQgaXMgbm90IHVzZWQgYXMgcmlnaWRseSBpbiBtb2Rlcm4gR3VqYXJhdGkuXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4Kqw4Kq+4KqkfOCqrOCqquCri+CqsHzgqrjgqrXgqr7gqrB84Kq44Kq+4KqC4KqcLyxcclxuICAgIG1lcmlkaWVtSG91cjogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgqrDgqr7gqqQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CquOCqteCqvuCqsCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CqrOCqquCri+CqsCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqrjgqr7gqoLgqpwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kqw4Kq+4KqkJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CquOCqteCqvuCqsCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqqzgqqrgq4vgqrAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kq44Kq+4KqC4KqcJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CqsOCqvuCqpCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWs6IHtcclxuICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveTogNiAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGd1O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ndS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEhlYnJldyBbaGVdXHJcbi8vISBhdXRob3IgOiBUb21lciBDb2hlbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS90b21lclxyXG4vLyEgYXV0aG9yIDogTW9zaGUgU2ltYW50b3YgOiBodHRwczovL2dpdGh1Yi5jb20vRGV2ZWxvcG1lbnRJTFxyXG4vLyEgYXV0aG9yIDogVGFsIEF0ZXIgOiBodHRwczovL2dpdGh1Yi5jb20vVGFsQXRlclxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGhlID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaGUnLCB7XHJcbiAgICBtb250aHMgOiAn15nXoNeV15DXqF/XpNeR16jXldeQ16hf157XqNelX9eQ16TXqNeZ15xf157XkNeZX9eZ15XXoNeZX9eZ15XXnNeZX9eQ15XXkteV16HXmF/Xodek15jXnteR16hf15DXlden15jXldeR16hf16DXldeR157XkdeoX9eT16bXnteR16gnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfXmdeg15XXs1/XpNeR16jXs1/Xnteo16Vf15DXpNeo17Nf157XkNeZX9eZ15XXoNeZX9eZ15XXnNeZX9eQ15XXktezX9eh16TXmNezX9eQ15XXp9ezX9eg15XXkdezX9eT16bXntezJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn16jXkNep15XXn1/Xqdeg15lf16nXnNeZ16nXmV/XqNeR15nXoteZX9eX157Xmdep15lf16nXmdep15lf16nXkdeqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfXkNezX9eR17Nf15LXs1/Xk9ezX9eU17Nf15XXs1/XqdezJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn15Bf15Ff15Jf15Nf15Rf15Vf16knLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgW9eRXU1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgW9eRXU1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIFvXkV1NTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIGwgOiAnRC9NL1lZWVknLFxyXG4gICAgICAgIGxsIDogJ0QgTU1NIFlZWVknLFxyXG4gICAgICAgIGxsbCA6ICdEIE1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBsbGxsIDogJ2RkZCwgRCBNTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vXlNeZ15XXnSDXkda+XUxUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vXnteX16gg15HWvl1MVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb15HXqdei15RdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vXkNeq157XldecINeR1r5dTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vXkdeZ15XXnV0gZGRkZCBb15TXkNeX16jXldefINeR16nXoteUXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ9eR16LXldeTICVzJyxcclxuICAgICAgICBwYXN0IDogJ9ec16TXoNeZICVzJyxcclxuICAgICAgICBzIDogJ9ee16HXpNeoINep16DXmdeV16onLFxyXG4gICAgICAgIG0gOiAn15PXp9eUJyxcclxuICAgICAgICBtbSA6ICclZCDXk9en15XXqicsXHJcbiAgICAgICAgaCA6ICfXqdei15QnLFxyXG4gICAgICAgIGhoIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9ep16LXqteZ15nXnSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg16nXoteV16onO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZCA6ICfXmdeV150nLFxyXG4gICAgICAgIGRkIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ9eZ15XXnteZ15nXnSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcg15nXnteZ150nO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgTSA6ICfXl9eV15PXqScsXHJcbiAgICAgICAgTU0gOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAn15fXldeT16nXmdeZ150nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnINeX15XXk9ep15nXnSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB5IDogJ9ep16DXlCcsXHJcbiAgICAgICAgeXkgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAn16nXoNeq15nXmdedJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgJSAxMCA9PT0gMCAmJiBudW1iZXIgIT09IDEwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDXqdeg15QnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnINep16DXmdedJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL9eQ15fXlFwi16Z815zXpNeg15RcItemfNeQ15fXqNeZINeU16bXlNeo15nXmdedfNec16TXoNeZINeU16bXlNeo15nXmdedfNec16TXoNeV16og15HXlden16h815HXkdeV16fXqHzXkdei16jXkS9pLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAvXijXkNeX15RcItemfNeQ15fXqNeZINeU16bXlNeo15nXmdedfNeR16LXqNeRKSQvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9ec16TXoNeV16og15HXlden16gnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn15HXkdeV16fXqCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAn15zXpNeg15RcItemJyA6ICfXnNek16DXmSDXlNem15TXqNeZ15nXnSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAn15DXl9eUXCLXpicgOiAn15DXl9eo15kg15TXpteU16jXmdeZ150nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn15HXoteo15EnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaGU7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogSGluZGkgW2hpXVxyXG4vLyEgYXV0aG9yIDogTWF5YW5rIFNpbmdoYWwgOiBodHRwczovL2dpdGh1Yi5jb20vbWF5YW5rc2luZ2hhbFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+ClpycsXHJcbiAgICAnMic6ICfgpagnLFxyXG4gICAgJzMnOiAn4KWpJyxcclxuICAgICc0JzogJ+ClqicsXHJcbiAgICAnNSc6ICfgpasnLFxyXG4gICAgJzYnOiAn4KWsJyxcclxuICAgICc3JzogJ+ClrScsXHJcbiAgICAnOCc6ICfgpa4nLFxyXG4gICAgJzknOiAn4KWvJyxcclxuICAgICcwJzogJ+ClpidcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfgpacnOiAnMScsXHJcbiAgICAn4KWoJzogJzInLFxyXG4gICAgJ+ClqSc6ICczJyxcclxuICAgICfgpaonOiAnNCcsXHJcbiAgICAn4KWrJzogJzUnLFxyXG4gICAgJ+ClrCc6ICc2JyxcclxuICAgICfgpa0nOiAnNycsXHJcbiAgICAn4KWuJzogJzgnLFxyXG4gICAgJ+Clryc6ICc5JyxcclxuICAgICfgpaYnOiAnMCdcclxufTtcclxuXHJcbnZhciBoaSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2hpJywge1xyXG4gICAgbW9udGhzIDogJ+CknOCkqOCkteCksOClgF/gpKvgpLzgpLDgpLXgpLDgpYBf4KSu4KS+4KSw4KWN4KSaX+CkheCkquCljeCksOCliOCksl/gpK7gpIhf4KSc4KWC4KSoX+CknOClgeCksuCkvuCkiF/gpIXgpJfgpLjgpY3gpKRf4KS44KS/4KSk4KSu4KWN4KSs4KSwX+CkheCkleCljeCkn+ClguCkrOCksF/gpKjgpLXgpK7gpY3gpKzgpLBf4KSm4KS/4KS44KSu4KWN4KSs4KSwJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4KSc4KSoLl/gpKvgpLzgpLAuX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpYguX+CkruCkiF/gpJzgpYLgpKhf4KSc4KWB4KSyLl/gpIXgpJcuX+CkuOCkv+CkpC5f4KSF4KSV4KWN4KSf4KWCLl/gpKjgpLUuX+CkpuCkv+CkuC4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAn4KSw4KS14KS/4KS14KS+4KSwX+CkuOCli+CkruCkteCkvuCksF/gpK7gpILgpJfgpLLgpLXgpL7gpLBf4KSs4KWB4KSn4KS14KS+4KSwX+Ckl+ClgeCksOClguCkteCkvuCksF/gpLbgpYHgpJXgpY3gpLDgpLXgpL7gpLBf4KS24KSo4KS/4KS14KS+4KSwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgpLDgpLXgpL9f4KS44KWL4KSuX+CkruCkguCkl+Cksl/gpKzgpYHgpKdf4KSX4KWB4KSw4KWCX+CktuClgeCkleCljeCksF/gpLbgpKjgpL8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgpLBf4KS44KWLX+CkruCkgl/gpKzgpYFf4KSX4KWBX+CktuClgV/gpLYnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0g4KSs4KSc4KWHJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIOCkrOCknOClhycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0g4KSs4KSc4KWHJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBBIGg6bW0g4KSs4KSc4KWHJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+CkhuCknF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+CkleCksl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgpJXgpLJdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4KSq4KS/4KSb4KSy4KWHXSBkZGRkLCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIOCkruClh+CkgicsXHJcbiAgICAgICAgcGFzdCA6ICclcyDgpKrgpLngpLLgpYcnLFxyXG4gICAgICAgIHMgOiAn4KSV4KWB4KSbIOCkueClgCDgpJXgpY3gpLfgpKMnLFxyXG4gICAgICAgIG0gOiAn4KSP4KSVIOCkruCkv+CkqOCknycsXHJcbiAgICAgICAgbW0gOiAnJWQg4KSu4KS/4KSo4KSfJyxcclxuICAgICAgICBoIDogJ+Ckj+CklSDgpJjgpILgpJ/gpL4nLFxyXG4gICAgICAgIGhoIDogJyVkIOCkmOCkguCkn+ClhycsXHJcbiAgICAgICAgZCA6ICfgpI/gpJUg4KSm4KS/4KSoJyxcclxuICAgICAgICBkZCA6ICclZCDgpKbgpL/gpKgnLFxyXG4gICAgICAgIE0gOiAn4KSP4KSVIOCkruCkueClgOCkqOClhycsXHJcbiAgICAgICAgTU0gOiAnJWQg4KSu4KS54KWA4KSo4KWHJyxcclxuICAgICAgICB5IDogJ+Ckj+CklSDgpLXgpLDgpY3gpLcnLFxyXG4gICAgICAgIHl5IDogJyVkIOCkteCksOCljeCktydcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Clp+ClqOClqeClquClq+ClrOClreClruClr+Clpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gSGluZGkgbm90YXRpb24gZm9yIG1lcmlkaWVtcyBhcmUgcXVpdGUgZnV6enkgaW4gcHJhY3RpY2UuIFdoaWxlIHRoZXJlIGV4aXN0c1xyXG4gICAgLy8gYSByaWdpZCBub3Rpb24gb2YgYSAnUGFoYXInIGl0IGlzIG5vdCB1c2VkIGFzIHJpZ2lkbHkgaW4gbW9kZXJuIEhpbmRpLlxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+CksOCkvuCkpHzgpLjgpYHgpKzgpLl84KSm4KWL4KSq4KS54KSwfOCktuCkvuCkri8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CksOCkvuCkpCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KS44KWB4KSs4KS5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSm4KWL4KSq4KS54KSwJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CktuCkvuCkricpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSkJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CkuOClgeCkrOCkuSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpKbgpYvgpKrgpLngpLAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KS24KS+4KSuJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBoaTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaGkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBDcm9hdGlhbiBbaHJdXHJcbi8vISBhdXRob3IgOiBCb2phbiBNYXJrb3ZpxIcgOiBodHRwczovL2dpdGh1Yi5jb20vYm1hcmtvdmljXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdqZWRuYSBtaW51dGEnIDogJ2plZG5lIG1pbnV0ZSc7XHJcbiAgICAgICAgY2FzZSAnbW0nOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21pbnV0YSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyIHx8IG51bWJlciA9PT0gMyB8fCBudW1iZXIgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRlJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWludXRhJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdqZWRhbiBzYXQnIDogJ2plZG5vZyBzYXRhJztcclxuICAgICAgICBjYXNlICdoaCc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0JztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdzYXRhJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnc2F0aSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZGFuJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZGFuYSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjYXNlICdNTSc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWplc2VjJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtamVzZWNhJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWplc2VjaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjYXNlICd5eSc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnZ29kaW5hJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIgfHwgbnVtYmVyID09PSAzIHx8IG51bWJlciA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmUnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdnb2RpbmEnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBociA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2hyJywge1xyXG4gICAgbW9udGhzIDoge1xyXG4gICAgICAgIGZvcm1hdDogJ3NpamXEjW5qYV92ZWxqYcSNZV9vxb51amthX3RyYXZuamFfc3ZpYm5qYV9saXBuamFfc3JwbmphX2tvbG92b3phX3J1am5hX2xpc3RvcGFkYV9zdHVkZW5vZ2FfcHJvc2luY2EnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ3NpamXEjWFual92ZWxqYcSNYV9vxb51amFrX3RyYXZhbmpfc3ZpYmFual9saXBhbmpfc3JwYW5qX2tvbG92b3pfcnVqYW5fbGlzdG9wYWRfc3R1ZGVuaV9wcm9zaW5hYycuc3BsaXQoJ18nKVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ3Npai5fdmVsai5fb8W+dS5fdHJhLl9zdmkuX2xpcC5fc3JwLl9rb2wuX3J1ai5fbGlzLl9zdHUuX3Byby4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0OiB0cnVlLFxyXG4gICAgd2Vla2RheXMgOiAnbmVkamVsamFfcG9uZWRqZWxqYWtfdXRvcmFrX3NyaWplZGFfxI1ldHZydGFrX3BldGFrX3N1Ym90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnbmVkLl9wb24uX3V0by5fc3JpLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICduZV9wb191dF9zcl/EjWVfcGVfc3UnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSAgOiAnW2RhbmFzIHVdIExUJyxcclxuICAgICAgICBuZXh0RGF5ICA6ICdbc3V0cmEgdV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBbbmVkamVsanVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3NyaWplZHVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3N1Ym90dV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t1XSBkZGRkIFt1XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgIDogJ1tqdcSNZXIgdV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcm/FoWx1XSBkZGRkIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcm/FoWxpXSBkZGRkIFt1XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCAgIDogJ3ByaWplICVzJyxcclxuICAgICAgICBzICAgICAgOiAncGFyIHNla3VuZGknLFxyXG4gICAgICAgIG0gICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtbSAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCAgICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGhoICAgICA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkICAgICAgOiAnZGFuJyxcclxuICAgICAgICBkZCAgICAgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSAgICAgIDogJ21qZXNlYycsXHJcbiAgICAgICAgTU0gICAgIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgICAgICA6ICdnb2RpbnUnLFxyXG4gICAgICAgIHl5ICAgICA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaHI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2hyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogSHVuZ2FyaWFuIFtodV1cclxuLy8hIGF1dGhvciA6IEFkYW0gQnJ1bm5lciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZGFtYnJ1bm5lclxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHdlZWtFbmRpbmdzID0gJ3Zhc8Ohcm5hcCBow6l0ZsWRbiBrZWRkZW4gc3plcmTDoW4gY3PDvHTDtnJ0w7Zrw7ZuIHDDqW50ZWtlbiBzem9tYmF0b24nLnNwbGl0KCcgJyk7XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciBudW0gPSBudW1iZXIsXHJcbiAgICAgICAgc3VmZml4O1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgcmV0dXJuIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4KSA/ICduw6low6FueSBtw6Fzb2RwZXJjJyA6ICduw6low6FueSBtw6Fzb2RwZXJjZSc7XHJcbiAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnZWd5JyArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyBwZXJjJyA6ICcgcGVyY2UnKTtcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgcGVyYycgOiAnIHBlcmNlJyk7XHJcbiAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgIHJldHVybiAnZWd5JyArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyDDs3JhJyA6ICcgw7Nyw6FqYScpO1xyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bSArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyDDs3JhJyA6ICcgw7Nyw6FqYScpO1xyXG4gICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICByZXR1cm4gJ2VneScgKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgbmFwJyA6ICcgbmFwamEnKTtcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBudW0gKyAoaXNGdXR1cmUgfHwgd2l0aG91dFN1ZmZpeCA/ICcgbmFwJyA6ICcgbmFwamEnKTtcclxuICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgcmV0dXJuICdlZ3knICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIGjDs25hcCcgOiAnIGjDs25hcGphJyk7XHJcbiAgICAgICAgY2FzZSAnTU0nOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIGjDs25hcCcgOiAnIGjDs25hcGphJyk7XHJcbiAgICAgICAgY2FzZSAneSc6XHJcbiAgICAgICAgICAgIHJldHVybiAnZWd5JyArIChpc0Z1dHVyZSB8fCB3aXRob3V0U3VmZml4ID8gJyDDqXYnIDogJyDDqXZlJyk7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtICsgKGlzRnV0dXJlIHx8IHdpdGhvdXRTdWZmaXggPyAnIMOpdicgOiAnIMOpdmUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiAnJztcclxufVxyXG5mdW5jdGlvbiB3ZWVrKGlzRnV0dXJlKSB7XHJcbiAgICByZXR1cm4gKGlzRnV0dXJlID8gJycgOiAnW23Dumx0XSAnKSArICdbJyArIHdlZWtFbmRpbmdzW3RoaXMuZGF5KCldICsgJ10gTFRbLWtvcl0nO1xyXG59XHJcblxyXG52YXIgaHUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdodScsIHtcclxuICAgIG1vbnRocyA6ICdqYW51w6FyX2ZlYnJ1w6FyX23DoXJjaXVzX8OhcHJpbGlzX23DoWp1c19qw7puaXVzX2rDumxpdXNfYXVndXN6dHVzX3N6ZXB0ZW1iZXJfb2t0w7NiZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX23DoXJjX8OhcHJfbcOhal9qw7puX2rDumxfYXVnX3N6ZXB0X29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAndmFzw6FybmFwX2jDqXRmxZFfa2VkZF9zemVyZGFfY3PDvHTDtnJ0w7ZrX3DDqW50ZWtfc3pvbWJhdCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAndmFzX2jDqXRfa2VkZF9zemVfY3PDvHRfcMOpbl9zem8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICd2X2hfa19zemVfY3NfcF9zem8nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdZWVlZLk1NLkRELicsXHJcbiAgICAgICAgTEwgOiAnWVlZWS4gTU1NTSBELicsXHJcbiAgICAgICAgTExMIDogJ1lZWVkuIE1NTU0gRC4gSDptbScsXHJcbiAgICAgICAgTExMTCA6ICdZWVlZLiBNTU1NIEQuLCBkZGRkIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL2RlfGR1L2ksXHJcbiAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd1JztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID09PSB0cnVlID8gJ2RlJyA6ICdERSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPT09IHRydWUgPyAnZHUnIDogJ0RVJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbbWFdIExUWy1rb3JdJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tob2xuYXBdIExUWy1rb3JdJyxcclxuICAgICAgICBuZXh0V2VlayA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdlZWsuY2FsbCh0aGlzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgOiAnW3RlZ25hcF0gTFRbLWtvcl0nLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2Vlay5jYWxsKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyBtw7psdmEnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMnLFxyXG4gICAgICAgIHMgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGhoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5IDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHl5IDogdHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBodTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBBcm1lbmlhbiBbaHktYW1dXHJcbi8vISBhdXRob3IgOiBBcm1lbmRhcmFieWFuIDogaHR0cHM6Ly9naXRodWIuY29tL2FybWVuZGFyYWJ5YW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBoeUFtID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaHktYW0nLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgZm9ybWF0OiAn1bDVuNaC1bbVvtWh1oDVq1/Wg9Wl1b/WgNW+1aHWgNWrX9W01aHWgNW/1atf1aHVutaA1avVrNWrX9W01aHVtdWr1b3Vq1/VsNW41oLVttWr1b3Vq1/VsNW41oLVrNWr1b3Vq1/WhdWj1bjVvdW/1bjVvdWrX9W91aXVutW/1aXVtNWi1aXWgNWrX9Ww1bjVr9W/1aXVtNWi1aXWgNWrX9W21bjVtdWl1bTVotWl1oDVq1/VpNWl1a/Vv9Wl1bTVotWl1oDVqycuc3BsaXQoJ18nKSxcclxuICAgICAgICBzdGFuZGFsb25lOiAn1bDVuNaC1bbVvtWh1oBf1oPVpdW/1oDVvtWh1oBf1bTVodaA1b9f1aHVutaA1avVrF/VtNWh1bXVq9W9X9Ww1bjWgtW21avVvV/VsNW41oLVrNWr1b1f1oXVo9W41b3Vv9W41b1f1b3VpdW61b/VpdW01aLVpdaAX9Ww1bjVr9W/1aXVtNWi1aXWgF/VttW41bXVpdW01aLVpdaAX9Wk1aXVr9W/1aXVtNWi1aXWgCcuc3BsaXQoJ18nKVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9Ww1bbVvl/Wg9W/1oBf1bTWgNW/X9Wh1brWgF/VtNW11b1f1bDVttW9X9Ww1azVvV/WhdWj1b1f1b3VutW/X9Ww1a/Vv1/VttW01aJf1aTVr9W/Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn1a/Vq9aA1aHVr9WrX9Wl1oDVr9W41oLVt9Wh1aLVqdWrX9Wl1oDVpdaE1bfVodWi1anVq1/VudW41oDVpdaE1bfVodWi1anVq1/VsNWr1bbVo9W31aHVotWp1atf1bjWgtaA1aLVodWpX9W31aHVotWh1aknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9Wv1oDVr1/VpdaA1a9f1aXWgNaEX9W51oDWhF/VsNW21aNf1bjWgtaA1aJf1bfVotWpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn1a/WgNWvX9Wl1oDVr1/VpdaA1oRf1bnWgNaEX9Ww1bbVo1/VuNaC1oDVol/Vt9Wi1aknLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZINWpLicsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZINWpLiwgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkg1akuLCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9Wh1bXVvdaF1oBdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9W+1aHVstWoXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1vVpdaA1aXVr10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGRkZCBb1oXWgNWoINWq1aHVtNWoXSBMVCc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1vVodW21oHVodWuXSBkZGRkIFvWhdaA1agg1arVodW01ahdIExUJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzINWw1aXVv9W4JyxcclxuICAgICAgICBwYXN0IDogJyVzINWh1bzVodW7JyxcclxuICAgICAgICBzIDogJ9W01asg1oTVodW21asg1b7VodW11oDVr9W11aHVticsXHJcbiAgICAgICAgbSA6ICfWgNW41brVpScsXHJcbiAgICAgICAgbW0gOiAnJWQg1oDVuNW61aUnLFxyXG4gICAgICAgIGggOiAn1arVodW0JyxcclxuICAgICAgICBoaCA6ICclZCDVqtWh1bQnLFxyXG4gICAgICAgIGQgOiAn1oXWgCcsXHJcbiAgICAgICAgZGQgOiAnJWQg1oXWgCcsXHJcbiAgICAgICAgTSA6ICfVodW01avVvScsXHJcbiAgICAgICAgTU0gOiAnJWQg1aHVtNWr1b0nLFxyXG4gICAgICAgIHkgOiAn1b/VodaA1asnLFxyXG4gICAgICAgIHl5IDogJyVkINW/1aHWgNWrJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/Vo9Wr1bfVpdaA1b7VoXzVodW81aHVvtW41b/VvtWhfNaB1aXWgNWl1a/VvtWhfNWl1oDVpdWv1bjVtdWh1bYvLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIC9eKNaB1aXWgNWl1a/VvtWhfNWl1oDVpdWv1bjVtdWh1bYpJC8udGVzdChpbnB1dCk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9Wj1avVt9Wl1oDVvtWhJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9Wh1bzVodW+1bjVv9W+1aEnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn1oHVpdaA1aXVr9W+1aEnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn1aXWgNWl1a/VuNW11aHVtic7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfXxcXGR7MSwyfS0o1avVtnzWgNWkKS8sXHJcbiAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgY2FzZSAnVyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERG8nOlxyXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdWr1bYnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct1oDVpCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaHlBbTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHktYW0uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaHktYW0uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBJbmRvbmVzaWFuIFtpZF1cclxuLy8hIGF1dGhvciA6IE1vaGFtbWFkIFNhdHJpbyBVdG9tbyA6IGh0dHBzOi8vZ2l0aHViLmNvbS90eW9rXHJcbi8vISByZWZlcmVuY2U6IGh0dHA6Ly9pZC53aWtpc291cmNlLm9yZy93aWtpL1BlZG9tYW5fVW11bV9FamFhbl9CYWhhc2FfSW5kb25lc2lhX3lhbmdfRGlzZW1wdXJuYWthblxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGlkID0gbW9tZW50LmRlZmluZUxvY2FsZSgnaWQnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYXJldF9BcHJpbF9NZWlfSnVuaV9KdWxpX0FndXN0dXNfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGVzZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKYW5fRmViX01hcl9BcHJfTWVpX0p1bl9KdWxfQWdzX1NlcF9Pa3RfTm92X0Rlcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ01pbmdndV9TZW5pbl9TZWxhc2FfUmFidV9LYW1pc19KdW1hdF9TYWJ0dScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnTWluX1Nlbl9TZWxfUmFiX0thbV9KdW1fU2FiJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnTWdfU25fU2xfUmJfS21fSm1fU2InLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISC5tbScsXHJcbiAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBbcHVrdWxdIEhILm1tJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC9wYWdpfHNpYW5nfHNvcmV8bWFsYW0vLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdwYWdpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc2lhbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc29yZScgfHwgbWVyaWRpZW0gPT09ICdtYWxhbScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BhZ2knO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3NpYW5nJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzb3JlJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ21hbGFtJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbSGFyaSBpbmkgcHVrdWxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tCZXNvayBwdWt1bF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbS2VtYXJpbiBwdWt1bF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xhbHUgcHVrdWxdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnZGFsYW0gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgeWFuZyBsYWx1JyxcclxuICAgICAgICBzIDogJ2JlYmVyYXBhIGRldGlrJyxcclxuICAgICAgICBtIDogJ3NlbWVuaXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1lbml0JyxcclxuICAgICAgICBoIDogJ3NlamFtJyxcclxuICAgICAgICBoaCA6ICclZCBqYW0nLFxyXG4gICAgICAgIGQgOiAnc2VoYXJpJyxcclxuICAgICAgICBkZCA6ICclZCBoYXJpJyxcclxuICAgICAgICBNIDogJ3NlYnVsYW4nLFxyXG4gICAgICAgIE1NIDogJyVkIGJ1bGFuJyxcclxuICAgICAgICB5IDogJ3NldGFodW4nLFxyXG4gICAgICAgIHl5IDogJyVkIHRhaHVuJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBpZDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvaWQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBJY2VsYW5kaWMgW2lzXVxyXG4vLyEgYXV0aG9yIDogSGlucmlrIMOWcm4gU2lndXLDsHNzb24gOiBodHRwczovL2dpdGh1Yi5jb20vaGlucmlrXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBwbHVyYWwobikge1xyXG4gICAgaWYgKG4gJSAxMDAgPT09IDExKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKG4gJSAxMCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdub2trcmFyIHNla8O6bmR1cicgOiAnbm9ra3J1bSBzZWvDum5kdW0nO1xyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtw61uw7p0YScgOiAnbcOtbsO6dHUnO1xyXG4gICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgaWYgKHBsdXJhbChudW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbcOtbsO6dHVyJyA6ICdtw61uw7p0dW0nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ23DrW7DunRhJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ23DrW7DunR1JztcclxuICAgICAgICBjYXNlICdoaCc6XHJcbiAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2tsdWtrdXN0dW5kaXInIDogJ2tsdWtrdXN0dW5kdW0nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2tsdWtrdXN0dW5kJztcclxuICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnZGFndXInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdkYWcnIDogJ2RlZ2knO1xyXG4gICAgICAgIGNhc2UgJ2RkJzpcclxuICAgICAgICAgICAgaWYgKHBsdXJhbChudW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZGFnYXInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChpc0Z1dHVyZSA/ICdkYWdhJyA6ICdkw7ZndW0nKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ2RhZ3VyJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGlzRnV0dXJlID8gJ2RhZycgOiAnZGVnaScpO1xyXG4gICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdtw6FudcOwdXInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdtw6FudcOwJyA6ICdtw6FudcOwaSc7XHJcbiAgICAgICAgY2FzZSAnTU0nOlxyXG4gICAgICAgICAgICBpZiAocGx1cmFsKG51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw6FudcOwaXInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChpc0Z1dHVyZSA/ICdtw6FudcOwaScgOiAnbcOhbnXDsHVtJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtw6FudcOwdXInO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaXNGdXR1cmUgPyAnbcOhbnXDsCcgOiAnbcOhbnXDsGknKTtcclxuICAgICAgICBjYXNlICd5JzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnw6FyJyA6ICfDoXJpJztcclxuICAgICAgICBjYXNlICd5eSc6XHJcbiAgICAgICAgICAgIGlmIChwbHVyYWwobnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ8OhcicgOiAnw6FydW0nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnw6FyJyA6ICfDoXJpJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBpcyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2lzJywge1xyXG4gICAgbW9udGhzIDogJ2phbsO6YXJfZmVicsO6YXJfbWFyc19hcHLDrWxfbWHDrV9qw7puw61fasO6bMOtX8OhZ8O6c3Rfc2VwdGVtYmVyX29rdMOzYmVyX27Ds3ZlbWJlcl9kZXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYcOtX2rDum5fasO6bF/DoWfDul9zZXBfb2t0X27Ds3ZfZGVzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnc3VubnVkYWd1cl9tw6FudWRhZ3VyX8O+cmnDsGp1ZGFndXJfbWnDsHZpa3VkYWd1cl9maW1tdHVkYWd1cl9mw7ZzdHVkYWd1cl9sYXVnYXJkYWd1cicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnc3VuX23DoW5fw75yaV9tacOwX2ZpbV9mw7ZzX2xhdScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1N1X03DoV/DnnJfTWlfRmlfRsO2X0xhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIFtrbC5dIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRC4gTU1NTSBZWVlZIFtrbC5dIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbw60gZGFnIGtsLl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW8OhIG1vcmd1biBrbC5dIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtrbC5dIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vDrSBnw6ZyIGtsLl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tzw63DsGFzdGFdIGRkZGQgW2tsLl0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdlZnRpciAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdmeXJpciAlcyBzw63DsGFuJyxcclxuICAgICAgICBzIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIG0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6ICdrbHVra3VzdHVuZCcsXHJcbiAgICAgICAgaGggOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIE1NIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeXkgOiB0cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGlzO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pcy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9pcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEl0YWxpYW4gW2l0XVxyXG4vLyEgYXV0aG9yIDogTG9yZW56byA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbGllbVxyXG4vLyEgYXV0aG9yOiBNYXR0aWEgTGFyZW50aXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub3N0YWxnaWF6XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgaXQgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdpdCcsIHtcclxuICAgIG1vbnRocyA6ICdnZW5uYWlvX2ZlYmJyYWlvX21hcnpvX2FwcmlsZV9tYWdnaW9fZ2l1Z25vX2x1Z2xpb19hZ29zdG9fc2V0dGVtYnJlX290dG9icmVfbm92ZW1icmVfZGljZW1icmUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdnZW5fZmViX21hcl9hcHJfbWFnX2dpdV9sdWdfYWdvX3NldF9vdHRfbm92X2RpYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ2RvbWVuaWNhX2x1bmVkw6xfbWFydGVkw6xfbWVyY29sZWTDrF9naW92ZWTDrF92ZW5lcmTDrF9zYWJhdG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2RvbV9sdW5fbWFyX21lcl9naW9fdmVuX3NhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ2RvX2x1X21hX21lX2dpX3ZlX3NhJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbT2dnaSBhbGxlXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tEb21hbmkgYWxsZV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbYWxsZV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbSWVyaSBhbGxlXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbGEgc2NvcnNhXSBkZGRkIFthbGxlXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2xvIHNjb3Jzb10gZGRkZCBbYWxsZV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKC9eWzAtOV0uKyQvKS50ZXN0KHMpID8gJ3RyYScgOiAnaW4nKSArICcgJyArIHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXN0IDogJyVzIGZhJyxcclxuICAgICAgICBzIDogJ2FsY3VuaSBzZWNvbmRpJyxcclxuICAgICAgICBtIDogJ3VuIG1pbnV0bycsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRpJyxcclxuICAgICAgICBoIDogJ3VuXFwnb3JhJyxcclxuICAgICAgICBoaCA6ICclZCBvcmUnLFxyXG4gICAgICAgIGQgOiAndW4gZ2lvcm5vJyxcclxuICAgICAgICBkZCA6ICclZCBnaW9ybmknLFxyXG4gICAgICAgIE0gOiAndW4gbWVzZScsXHJcbiAgICAgICAgTU0gOiAnJWQgbWVzaScsXHJcbiAgICAgICAgeSA6ICd1biBhbm5vJyxcclxuICAgICAgICB5eSA6ICclZCBhbm5pJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2UgOiAvXFxkezEsMn3Cui8sXHJcbiAgICBvcmRpbmFsOiAnJWTCuicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gaXQ7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2l0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogSmFwYW5lc2UgW2phXVxyXG4vLyEgYXV0aG9yIDogTEkgTG9uZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYXJ5b25cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBqYSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2phJywge1xyXG4gICAgbW9udGhzIDogJzHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfml6Xmm5zml6Vf5pyI5puc5pelX+eBq+abnOaXpV/msLTmm5zml6Vf5pyo5puc5pelX+mHkeabnOaXpV/lnJ/mm5zml6UnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+aXpV/mnIhf54GrX+awtF/mnKhf6YeRX+Wcnycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+aXpV/mnIhf54GrX+awtF/mnKhf6YeRX+Wcnycuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS9NTS9ERCcsXHJcbiAgICAgICAgTEwgOiAnWVlZWeW5tE3mnIhE5pelJyxcclxuICAgICAgICBMTEwgOiAnWVlZWeW5tE3mnIhE5pelIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ1lZWVnlubRN5pyIROaXpSBISDptbSBkZGRkJyxcclxuICAgICAgICBsIDogJ1lZWVkvTU0vREQnLFxyXG4gICAgICAgIGxsIDogJ1lZWVnlubRN5pyIROaXpScsXHJcbiAgICAgICAgbGxsIDogJ1lZWVnlubRN5pyIROaXpSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TeaciETml6UgSEg6bW0gZGRkZCdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv5Y2I5YmNfOWNiOW+jC9pLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gJ+WNiOW+jCc7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+WNiOWJjSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfljYjlvownO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vku4rml6VdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vmmI7ml6VdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdb5p2l6YCxXWRkZGQgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+aYqOaXpV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vliY3pgLFdZGRkZCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ95pelLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcclxuICAgICAgICBzd2l0Y2ggKHBlcmlvZCkge1xyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aXpSc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVz5b6MJyxcclxuICAgICAgICBwYXN0IDogJyVz5YmNJyxcclxuICAgICAgICBzIDogJ+aVsOenkicsXHJcbiAgICAgICAgbSA6ICcx5YiGJyxcclxuICAgICAgICBtbSA6ICclZOWIhicsXHJcbiAgICAgICAgaCA6ICcx5pmC6ZaTJyxcclxuICAgICAgICBoaCA6ICclZOaZgumWkycsXHJcbiAgICAgICAgZCA6ICcx5pelJyxcclxuICAgICAgICBkZCA6ICclZOaXpScsXHJcbiAgICAgICAgTSA6ICcx44O25pyIJyxcclxuICAgICAgICBNTSA6ICclZOODtuaciCcsXHJcbiAgICAgICAgeSA6ICcx5bm0JyxcclxuICAgICAgICB5eSA6ICclZOW5tCdcclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gamE7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2phLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2phLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogSmF2YW5lc2UgW2p2XVxyXG4vLyEgYXV0aG9yIDogUm9ueSBMYW50aXAgOiBodHRwczovL2dpdGh1Yi5jb20vbGFudGlwXHJcbi8vISByZWZlcmVuY2U6IGh0dHA6Ly9qdi53aWtpcGVkaWEub3JnL3dpa2kvQmFzYV9KYXdhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIganYgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdqdicsIHtcclxuICAgIG1vbnRocyA6ICdKYW51YXJpX0ZlYnJ1YXJpX01hcmV0X0FwcmlsX01laV9KdW5pX0p1bGlfQWd1c3R1c19TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3BlbWJlcl9EZXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZWJfTWFyX0Fwcl9NZWlfSnVuX0p1bF9BZ3NfU2VwX09rdF9Ob3BfRGVzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnTWluZ2d1X1NlbmVuX1NlbG9zb19SZWJ1X0tlbWlzX0plbXV3YWhfU2VwdHUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ01pbl9TZW5fU2VsX1JlYl9LZW1fSmVtX1NlcCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ01nX1NuX1NsX1JiX0ttX0ptX1NwJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEgubW0nLFxyXG4gICAgICAgIExUUyA6ICdISC5tbS5zcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvZW5qaW5nfHNpeWFuZ3xzb250ZW58bmRhbHUvLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdlbmppbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICdzaXlhbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAnc29udGVuJyB8fCBtZXJpZGllbSA9PT0gJ25kYWx1Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA8IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZW5qaW5nJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXJzIDwgMTUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzaXlhbmcnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3NvbnRlbic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICduZGFsdSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0RpbnRlbiBwdW5pa28gcHVrdWxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tNYmVuamFuZyBwdWt1bF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1a3VsXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbS2FsYSB3aW5naSBwdWt1bF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2tlcGVuZ2tlciBwdWt1bF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd3b250ZW4gaW5nICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGluZ2thbmcga2VwZW5na2VyJyxcclxuICAgICAgICBzIDogJ3Nhd2V0YXdpcyBkZXRpaycsXHJcbiAgICAgICAgbSA6ICdzZXR1bmdnYWwgbWVuaXQnLFxyXG4gICAgICAgIG1tIDogJyVkIG1lbml0JyxcclxuICAgICAgICBoIDogJ3NldHVuZ2dhbCBqYW0nLFxyXG4gICAgICAgIGhoIDogJyVkIGphbScsXHJcbiAgICAgICAgZCA6ICdzZWRpbnRlbicsXHJcbiAgICAgICAgZGQgOiAnJWQgZGludGVuJyxcclxuICAgICAgICBNIDogJ3Nld3VsYW4nLFxyXG4gICAgICAgIE1NIDogJyVkIHd1bGFuJyxcclxuICAgICAgICB5IDogJ3NldGF1bicsXHJcbiAgICAgICAgeXkgOiAnJWQgdGF1bidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4ganY7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2p2LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogR2VvcmdpYW4gW2thXVxyXG4vLyEgYXV0aG9yIDogSXJha2xpIEphbmlhc2h2aWxpIDogaHR0cHM6Ly9naXRodWIuY29tL2lyYWtsaS1qYW5pYXNodmlsaVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIGthID0gbW9tZW50LmRlZmluZUxvY2FsZSgna2EnLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ+GDmOGDkOGDnOGDleGDkOGDoOGDmF/hg5fhg5Thg5Hhg5Thg6Dhg5Xhg5Dhg5rhg5hf4YOb4YOQ4YOg4YOi4YOYX+GDkOGDnuGDoOGDmOGDmuGDmF/hg5vhg5Dhg5jhg6Hhg5hf4YOY4YOV4YOc4YOY4YOh4YOYX+GDmOGDleGDmuGDmOGDoeGDmF/hg5Dhg5Lhg5Xhg5jhg6Hhg6Lhg51f4YOh4YOU4YOl4YOi4YOU4YOb4YOR4YOU4YOg4YOYX+GDneGDpeGDouGDneGDm+GDkeGDlOGDoOGDmF/hg5zhg53hg5Thg5vhg5Hhg5Thg6Dhg5hf4YOT4YOU4YOZ4YOU4YOb4YOR4YOU4YOg4YOYJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIGZvcm1hdDogJ+GDmOGDkOGDnOGDleGDkOGDoOGDoV/hg5fhg5Thg5Hhg5Thg6Dhg5Xhg5Dhg5rhg6Ff4YOb4YOQ4YOg4YOi4YOhX+GDkOGDnuGDoOGDmOGDmuGDmOGDoV/hg5vhg5Dhg5jhg6Hhg6Ff4YOY4YOV4YOc4YOY4YOh4YOhX+GDmOGDleGDmuGDmOGDoeGDoV/hg5Dhg5Lhg5Xhg5jhg6Hhg6Lhg6Ff4YOh4YOU4YOl4YOi4YOU4YOb4YOR4YOU4YOg4YOhX+GDneGDpeGDouGDneGDm+GDkeGDlOGDoOGDoV/hg5zhg53hg5Thg5vhg5Hhg5Thg6Dhg6Ff4YOT4YOU4YOZ4YOU4YOb4YOR4YOU4YOg4YOhJy5zcGxpdCgnXycpXHJcbiAgICB9LFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4YOY4YOQ4YOcX+GDl+GDlOGDkV/hg5vhg5Dhg6Bf4YOQ4YOe4YOgX+GDm+GDkOGDmF/hg5jhg5Xhg5xf4YOY4YOV4YOaX+GDkOGDkuGDlV/hg6Hhg5Thg6Vf4YOd4YOl4YOiX+GDnOGDneGDlF/hg5Phg5Thg5knLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6IHtcclxuICAgICAgICBzdGFuZGFsb25lOiAn4YOZ4YOV4YOY4YOg4YOQX+GDneGDoOGDqOGDkOGDkeGDkOGDl+GDmF/hg6Hhg5Dhg5vhg6jhg5Dhg5Hhg5Dhg5fhg5hf4YOd4YOX4YOu4YOo4YOQ4YOR4YOQ4YOX4YOYX+GDruGDo+GDl+GDqOGDkOGDkeGDkOGDl+GDmF/hg57hg5Dhg6Dhg5Dhg6Hhg5nhg5Thg5Xhg5hf4YOo4YOQ4YOR4YOQ4YOX4YOYJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIGZvcm1hdDogJ+GDmeGDleGDmOGDoOGDkOGDoV/hg53hg6Dhg6jhg5Dhg5Hhg5Dhg5fhg6Ff4YOh4YOQ4YOb4YOo4YOQ4YOR4YOQ4YOX4YOhX+GDneGDl+GDruGDqOGDkOGDkeGDkOGDl+GDoV/hg67hg6Phg5fhg6jhg5Dhg5Hhg5Dhg5fhg6Ff4YOe4YOQ4YOg4YOQ4YOh4YOZ4YOU4YOV4YOhX+GDqOGDkOGDkeGDkOGDl+GDoScuc3BsaXQoJ18nKSxcclxuICAgICAgICBpc0Zvcm1hdDogLyjhg6zhg5jhg5zhg5B84YOo4YOU4YOb4YOT4YOU4YOSKS9cclxuICAgIH0sXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+GDmeGDleGDmF/hg53hg6Dhg6hf4YOh4YOQ4YObX+GDneGDl+GDrl/hg67hg6Phg5df4YOe4YOQ4YOgX+GDqOGDkOGDkScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+GDmeGDlV/hg53hg6Bf4YOh4YOQX+GDneGDl1/hg67hg6Nf4YOe4YOQX+GDqOGDkCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIGg6bW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4YOT4YOm4YOU4YOhXSBMVFst4YOW4YOUXScsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4YOu4YOV4YOQ4YOaXSBMVFst4YOW4YOUXScsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4YOS4YOj4YOo4YOY4YOcXSBMVFst4YOW4YOUXScsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW+GDqOGDlOGDm+GDk+GDlOGDkl0gZGRkZCBMVFst4YOW4YOUXScsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+GDrOGDmOGDnOGDkF0gZGRkZCBMVC3hg5bhg5QnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoLyjhg6zhg5Dhg5vhg5h84YOs4YOj4YOX4YOYfOGDoeGDkOGDkOGDl+GDmHzhg6zhg5Thg5rhg5gpLykudGVzdChzKSA/XHJcbiAgICAgICAgICAgICAgICBzLnJlcGxhY2UoL+GDmCQvLCAn4YOo4YOYJykgOlxyXG4gICAgICAgICAgICAgICAgcyArICfhg6jhg5gnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFzdCA6IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgIGlmICgoLyjhg6zhg5Dhg5vhg5h84YOs4YOj4YOX4YOYfOGDoeGDkOGDkOGDl+GDmHzhg5Phg6bhg5R84YOX4YOV4YOUKS8pLnRlc3QocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoLyjhg5h84YOUKSQvLCAn4YOY4YOhIOGDo+GDmeGDkOGDnCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoL+GDrOGDlOGDmuGDmC8pLnRlc3QocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL+GDrOGDlOGDmuGDmCQvLCAn4YOs4YOa4YOY4YOhIOGDo+GDmeGDkOGDnCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzIDogJ+GDoOGDkOGDm+GDk+GDlOGDnOGDmOGDm+GDlCDhg6zhg5Dhg5vhg5gnLFxyXG4gICAgICAgIG0gOiAn4YOs4YOj4YOX4YOYJyxcclxuICAgICAgICBtbSA6ICclZCDhg6zhg6Phg5fhg5gnLFxyXG4gICAgICAgIGggOiAn4YOh4YOQ4YOQ4YOX4YOYJyxcclxuICAgICAgICBoaCA6ICclZCDhg6Hhg5Dhg5Dhg5fhg5gnLFxyXG4gICAgICAgIGQgOiAn4YOT4YOm4YOUJyxcclxuICAgICAgICBkZCA6ICclZCDhg5Phg6bhg5QnLFxyXG4gICAgICAgIE0gOiAn4YOX4YOV4YOUJyxcclxuICAgICAgICBNTSA6ICclZCDhg5fhg5Xhg5QnLFxyXG4gICAgICAgIHkgOiAn4YOs4YOU4YOa4YOYJyxcclxuICAgICAgICB5eSA6ICclZCDhg6zhg5Thg5rhg5gnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogLzB8MS3hg5rhg5h84YOb4YOULVxcZHsxLDJ9fFxcZHsxLDJ9LeGDlC8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIGlmIChudW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3hg5rhg5gnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKG51bWJlciA8IDIwKSB8fCAobnVtYmVyIDw9IDEwMCAmJiAobnVtYmVyICUgMjAgPT09IDApKSB8fCAobnVtYmVyICUgMTAwID09PSAwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+GDm+GDlC0nICsgbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3hg5QnO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSxcclxuICAgICAgICBkb3kgOiA3XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGthO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rYS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rYS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEthemFraCBba2tdXHJcbi8vISBhdXRob3JzIDogTnVybGFuIFJha2hpbXpoYW5vdiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9udXJsYW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzdWZmaXhlcyA9IHtcclxuICAgIDA6ICct0YjRlicsXHJcbiAgICAxOiAnLdGI0ZYnLFxyXG4gICAgMjogJy3RiNGWJyxcclxuICAgIDM6ICct0YjRlicsXHJcbiAgICA0OiAnLdGI0ZYnLFxyXG4gICAgNTogJy3RiNGWJyxcclxuICAgIDY6ICct0YjRiycsXHJcbiAgICA3OiAnLdGI0ZYnLFxyXG4gICAgODogJy3RiNGWJyxcclxuICAgIDk6ICct0YjRiycsXHJcbiAgICAxMDogJy3RiNGLJyxcclxuICAgIDIwOiAnLdGI0YsnLFxyXG4gICAgMzA6ICct0YjRiycsXHJcbiAgICA0MDogJy3RiNGLJyxcclxuICAgIDUwOiAnLdGI0ZYnLFxyXG4gICAgNjA6ICct0YjRiycsXHJcbiAgICA3MDogJy3RiNGWJyxcclxuICAgIDgwOiAnLdGI0ZYnLFxyXG4gICAgOTA6ICct0YjRiycsXHJcbiAgICAxMDA6ICct0YjRlidcclxufTtcclxuXHJcbnZhciBrayA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2trJywge1xyXG4gICAgbW9udGhzIDogJ9Kb0LDSo9GC0LDRgF/QsNKb0L/QsNC9X9C90LDRg9GA0YvQt1/RgdOZ0YPRltGAX9C80LDQvNGL0YBf0LzQsNGD0YHRi9C8X9GI0ZbQu9C00LVf0YLQsNC80YvQt1/Sm9GL0YDQutKv0LnQtdC6X9Kb0LDQt9Cw0L1f0pvQsNGA0LDRiNCwX9C20LXQu9GC0L7Sm9GB0LDQvScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9Kb0LDSo1/QsNKb0L9f0L3QsNGDX9GB05nRg1/QvNCw0Lxf0LzQsNGDX9GI0ZbQu1/RgtCw0Lxf0pvRi9GAX9Kb0LDQt1/Sm9Cw0YBf0LbQtdC7Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn0LbQtdC60YHQtdC90LHRll/QtNKv0LnRgdC10L3QsdGWX9GB0LXQudGB0LXQvdCx0ZZf0YHTmdGA0YHQtdC90LHRll/QsdC10LnRgdC10L3QsdGWX9C20rHQvNCwX9GB0LXQvdCx0ZYnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9C20LXQul/QtNKv0Llf0YHQtdC5X9GB05nRgF/QsdC10Llf0LbSsdC8X9GB0LXQvScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9C20Lpf0LTQuV/RgdC5X9GB0YBf0LHQuV/QttC8X9GB0L0nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb0JHSr9Cz0ZbQvSDRgdCw0pPQsNGCXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb0JXRgNGC0LXSoyDRgdCw0pPQsNGCXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb0YHQsNKT0LDRgl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9Ca0LXRiNC1INGB0LDSk9Cw0YJdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb06jRgtC60LXQvSDQsNC/0YLQsNC90YvSo10gZGRkZCBb0YHQsNKT0LDRgl0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDRltGI0ZbQvdC00LUnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg0LHSsdGA0YvQvScsXHJcbiAgICAgICAgcyA6ICfQsdGW0YDQvdC10YjQtSDRgdC10LrRg9C90LQnLFxyXG4gICAgICAgIG0gOiAn0LHRltGAINC80LjQvdGD0YInLFxyXG4gICAgICAgIG1tIDogJyVkINC80LjQvdGD0YInLFxyXG4gICAgICAgIGggOiAn0LHRltGAINGB0LDSk9Cw0YInLFxyXG4gICAgICAgIGhoIDogJyVkINGB0LDSk9Cw0YInLFxyXG4gICAgICAgIGQgOiAn0LHRltGAINC60q/QvScsXHJcbiAgICAgICAgZGQgOiAnJWQg0LrSr9C9JyxcclxuICAgICAgICBNIDogJ9Cx0ZbRgCDQsNC5JyxcclxuICAgICAgICBNTSA6ICclZCDQsNC5JyxcclxuICAgICAgICB5IDogJ9Cx0ZbRgCDQttGL0LsnLFxyXG4gICAgICAgIHl5IDogJyVkINC20YvQuydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNGI0ZZ80YjRiykvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYSA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBiID0gbnVtYmVyID49IDEwMCA/IDEwMCA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArIChzdWZmaXhlc1tudW1iZXJdIHx8IHN1ZmZpeGVzW2FdIHx8IHN1ZmZpeGVzW2JdKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4ga2s7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2trLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2trLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ2FtYm9kaWFuIFtrbV1cclxuLy8hIGF1dGhvciA6IEtydXkgVmFubmEgOiBodHRwczovL2dpdGh1Yi5jb20va3J1eXZhbm5hXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIga20gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdrbScsIHtcclxuICAgIG1vbnRoczogJ+GemOGegOGemuGetl/hnoDhnrvhnpjhn5Lhnpfhn4hf4Z6Y4Z644Z6T4Z62X+GemOGfgeGen+Getl/hnqfhnp/hnpfhnrZf4Z6Y4Z634Z6Q4Z674Z6T4Z62X+GegOGegOGfkuGegOGeiuGetl/hnp/hnrjhnqDhnrZf4Z6A4Z6J4Z+S4Z6J4Z62X+Gej+Geu+Gem+Getl/hnpzhnrfhnoXhn5LhnobhnrfhnoDhnrZf4Z6S4Z+S4Z6T4Z68Jy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICfhnpjhnoDhnprhnrZf4Z6A4Z674Z6Y4Z+S4Z6X4Z+IX+GemOGeuOGek+Getl/hnpjhn4Hhnp/hnrZf4Z6n4Z6f4Z6X4Z62X+GemOGet+GekOGeu+Gek+Getl/hnoDhnoDhn5LhnoDhnorhnrZf4Z6f4Z644Z6g4Z62X+GegOGeieGfkuGeieGetl/hno/hnrvhnpvhnrZf4Z6c4Z634Z6F4Z+S4Z6G4Z634Z6A4Z62X+GekuGfkuGek+GevCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzOiAn4Z6i4Z624Z6R4Z634Z6P4Z+S4Z6ZX+GeheGfkOGek+GfkuGekV/hnqLhnoThn5LhnoLhnrbhnppf4Z6W4Z674Z6SX+GeluGfkuGemuGeoOGen+GfkuGelOGej+Get+GfjV/hnp/hnrvhnoDhn5Lhnppf4Z6f4Z+F4Z6a4Z+NJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ+GeouGetuGekeGet+Gej+GfkuGemV/hnoXhn5DhnpPhn5LhnpFf4Z6i4Z6E4Z+S4Z6C4Z624Z6aX+GeluGeu+Gekl/hnpbhn5LhnprhnqDhnp/hn5LhnpThno/hnrfhn41f4Z6f4Z674Z6A4Z+S4Z6aX+Gen+GfheGemuGfjScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluOiAn4Z6i4Z624Z6R4Z634Z6P4Z+S4Z6ZX+GeheGfkOGek+GfkuGekV/hnqLhnoThn5LhnoLhnrbhnppf4Z6W4Z674Z6SX+GeluGfkuGemuGeoOGen+GfkuGelOGej+Get+GfjV/hnp/hnrvhnoDhn5Lhnppf4Z6f4Z+F4Z6a4Z+NJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEw6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEw6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vhnpDhn5LhnoThn4PhnpPhn4Hhn4cg4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1vhnp/hn5LhnqLhn4LhnoAg4Z6Y4Z+J4Z+E4Z6EXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvhnpjhn4nhn4ThnoRdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW+GemOGfkuGen+Get+Gem+GemOGet+GeiSDhnpjhn4nhn4ThnoRdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW+Gen+GelOGfkuGej+GetuGeoOGfjeGemOGeu+Gek10gW+GemOGfieGfhOGehF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWU6IHtcclxuICAgICAgICBmdXR1cmU6ICclc+GekeGfgOGejycsXHJcbiAgICAgICAgcGFzdDogJyVz4Z6Y4Z674Z6TJyxcclxuICAgICAgICBzOiAn4Z6U4Z+J4Z674Z6T4Z+S4Z6Y4Z624Z6T4Z6c4Z634Z6T4Z624Z6R4Z64JyxcclxuICAgICAgICBtOiAn4Z6Y4Z694Z6Z4Z6T4Z624Z6R4Z64JyxcclxuICAgICAgICBtbTogJyVkIOGek+GetuGekeGeuCcsXHJcbiAgICAgICAgaDogJ+GemOGeveGemeGemOGfieGfhOGehCcsXHJcbiAgICAgICAgaGg6ICclZCDhnpjhn4nhn4ThnoQnLFxyXG4gICAgICAgIGQ6ICfhnpjhnr3hnpnhnpDhn5LhnoThn4MnLFxyXG4gICAgICAgIGRkOiAnJWQg4Z6Q4Z+S4Z6E4Z+DJyxcclxuICAgICAgICBNOiAn4Z6Y4Z694Z6Z4Z6B4Z+CJyxcclxuICAgICAgICBNTTogJyVkIOGegeGfgicsXHJcbiAgICAgICAgeTogJ+GemOGeveGemeGehuGfkuGek+GetuGfhicsXHJcbiAgICAgICAgeXk6ICclZCDhnobhn5LhnpPhnrbhn4YnXHJcbiAgICB9LFxyXG4gICAgd2Vlazoge1xyXG4gICAgICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95OiA0IC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4ga207XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ttLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2ttLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogS2FubmFkYSBba25dXHJcbi8vISBhdXRob3IgOiBSYWplZXYgTmFpayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWplZXZuYWlrdGVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgs6cnLFxyXG4gICAgJzInOiAn4LOoJyxcclxuICAgICczJzogJ+CzqScsXHJcbiAgICAnNCc6ICfgs6onLFxyXG4gICAgJzUnOiAn4LOrJyxcclxuICAgICc2JzogJ+CzrCcsXHJcbiAgICAnNyc6ICfgs60nLFxyXG4gICAgJzgnOiAn4LOuJyxcclxuICAgICc5JzogJ+CzrycsXHJcbiAgICAnMCc6ICfgs6YnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4LOnJzogJzEnLFxyXG4gICAgJ+CzqCc6ICcyJyxcclxuICAgICfgs6knOiAnMycsXHJcbiAgICAn4LOqJzogJzQnLFxyXG4gICAgJ+Czqyc6ICc1JyxcclxuICAgICfgs6wnOiAnNicsXHJcbiAgICAn4LOtJzogJzcnLFxyXG4gICAgJ+Czric6ICc4JyxcclxuICAgICfgs68nOiAnOScsXHJcbiAgICAn4LOmJzogJzAnXHJcbn07XHJcblxyXG52YXIga24gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdrbicsIHtcclxuICAgIG1vbnRocyA6ICfgspzgsqjgsrXgsrDgsr9f4LKr4LOG4LKs4LON4LKw4LK14LKw4LK/X+CyruCyvuCysOCzjeCymuCzjV/gso/gsqrgs43gsrDgsr/gsrLgs41f4LKu4LOG4LOVX+CynOCzguCyqOCzjV/gspzgs4HgsrLgs4bgs5Zf4LKG4LKX4LK44LON4LKf4LONX+CyuOCzhuCyquCzjeCyn+CzhuCyguCyrOCysOCzjV/gsoXgspXgs43gsp/gs4bgs4Lgs5XgsqzgsrDgs41f4LKo4LK14LOG4LKC4LKs4LKw4LONX+CyoeCyv+CyuOCzhuCyguCyrOCysOCzjScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+CynOCyqF/gsqvgs4bgsqzgs43gsrBf4LKu4LK+4LKw4LON4LKa4LONX+Cyj+CyquCzjeCysOCyv+CysuCzjV/gsq7gs4bgs5Vf4LKc4LOC4LKo4LONX+CynOCzgeCysuCzhuCzll/gsobgspfgsrjgs43gsp/gs41f4LK44LOG4LKq4LON4LKf4LOG4LKC4LKsX+CyheCyleCzjeCyn+CzhuCzguCzleCyrF/gsqjgsrXgs4bgsoLgsqxf4LKh4LK/4LK44LOG4LKC4LKsJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ+CyreCyvuCyqOCzgeCyteCyvuCysF/gsrjgs4bgs4Lgs5Xgsq7gsrXgsr7gsrBf4LKu4LKC4LKX4LKz4LK14LK+4LKwX+CyrOCzgeCyp+CyteCyvuCysF/gspfgs4HgsrDgs4HgsrXgsr7gsrBf4LK24LOB4LKV4LON4LKw4LK14LK+4LKwX+CytuCyqOCyv+CyteCyvuCysCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4LKt4LK+4LKo4LOBX+CyuOCzhuCzguCzleCyrl/gsq7gsoLgspfgsrNf4LKs4LOB4LKnX+Cyl+CzgeCysOCzgV/gsrbgs4HgspXgs43gsrBf4LK24LKo4LK/Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn4LKt4LK+X+CyuOCzhuCzguCzlV/gsq7gsoJf4LKs4LOBX+Cyl+CzgV/gsrbgs4Ff4LK2Jy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnQSBoOm1tJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+Cyh+CyguCypuCzgV0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+CyqOCyvuCys+Czhl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgsqjgsr/gsqjgs43gsqjgs4ZdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4LKV4LOG4LOC4LKo4LOG4LKvXSBkZGRkLCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIOCyqOCyguCypOCysCcsXHJcbiAgICAgICAgcGFzdCA6ICclcyDgsrngsr/gsoLgsqbgs4YnLFxyXG4gICAgICAgIHMgOiAn4LKV4LOG4LKy4LK14LOBIOCyleCzjeCyt+Cyo+Cyl+Cys+CzgScsXHJcbiAgICAgICAgbSA6ICfgspLgsoLgsqbgs4Eg4LKo4LK/4LKu4LK/4LK3JyxcclxuICAgICAgICBtbSA6ICclZCDgsqjgsr/gsq7gsr/gsrcnLFxyXG4gICAgICAgIGggOiAn4LKS4LKC4LKm4LOBIOCyl+CyguCyn+CzhicsXHJcbiAgICAgICAgaGggOiAnJWQg4LKX4LKC4LKf4LOGJyxcclxuICAgICAgICBkIDogJ+CykuCyguCypuCzgSDgsqbgsr/gsqgnLFxyXG4gICAgICAgIGRkIDogJyVkIOCypuCyv+CyqCcsXHJcbiAgICAgICAgTSA6ICfgspLgsoLgsqbgs4Eg4LKk4LK/4LKC4LKX4LKz4LOBJyxcclxuICAgICAgICBNTSA6ICclZCDgsqTgsr/gsoLgspfgsrPgs4EnLFxyXG4gICAgICAgIHkgOiAn4LKS4LKC4LKm4LOBIOCyteCysOCzjeCytycsXHJcbiAgICAgICAgeXkgOiAnJWQg4LK14LKw4LON4LK3J1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4LOn4LOo4LOp4LOq4LOr4LOs4LOt4LOu4LOv4LOmXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4LKw4LK+4LKk4LON4LKw4LK/fOCyrOCzhuCys+Cyv+Cyl+CzjeCyl+Czhnzgsq7gsqfgs43gsq/gsr7gsrngs43gsqh84LK44LKC4LKc4LOGLyxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAn4LKw4LK+4LKk4LON4LKw4LK/Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA8IDQgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgsqzgs4bgsrPgsr/gspfgs43gspfgs4YnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgsq7gsqfgs43gsq/gsr7gsrngs43gsqgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDEwID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4LK44LKC4LKc4LOGJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgsrDgsr7gsqTgs43gsrDgsr8nO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LKs4LOG4LKz4LK/4LKX4LON4LKX4LOGJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CyruCyp+CzjeCyr+CyvuCyueCzjeCyqCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgsrjgsoLgspzgs4YnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LKw4LK+4LKk4LON4LKw4LK/JztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KOCyqOCzhuCzlSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+CyqOCzhuCzlSc7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGtuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9rbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEtvcmVhbiBba29dXHJcbi8vISBhdXRob3IgOiBLeXVuZ3dvb2ssIFBhcmsgOiBodHRwczovL2dpdGh1Yi5jb20va3l1bmd3MDBrXHJcbi8vISBhdXRob3IgOiBKZWVleXVsIExlZSA8amVlZXl1bEBnbWFpbC5jb20+XHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIga28gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdrbycsIHtcclxuICAgIG1vbnRocyA6ICcx7JuUXzLsm5RfM+yblF807JuUXzXsm5RfNuyblF837JuUXzjsm5RfOeyblF8xMOyblF8xMeyblF8xMuyblCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJzHsm5RfMuyblF8z7JuUXzTsm5RfNeyblF827JuUXzfsm5RfOOyblF857JuUXzEw7JuUXzEx7JuUXzEy7JuUJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn7J287JqU7J28X+yblOyalOydvF/tmZTsmpTsnbxf7IiY7JqU7J28X+uqqeyalOydvF/quIjsmpTsnbxf7Yag7JqU7J28Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfsnbxf7JuUX+2ZlF/siJhf66qpX+q4iF/thqAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfsnbxf7JuUX+2ZlF/siJhf66qpX+q4iF/thqAnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdBIGg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdBIGg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS5NTS5ERCcsXHJcbiAgICAgICAgTEwgOiAnWVlZWeuFhCBNTU1NIETsnbwnLFxyXG4gICAgICAgIExMTCA6ICdZWVlZ64WEIE1NTU0gROydvCBBIGg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnWVlZWeuFhCBNTU1NIETsnbwgZGRkZCBBIGg6bW0nLFxyXG4gICAgICAgIGwgOiAnWVlZWS5NTS5ERCcsXHJcbiAgICAgICAgbGwgOiAnWVlZWeuFhCBNTU1NIETsnbwnLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZ64WEIE1NTU0gROydvCBBIGg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnWVlZWeuFhCBNTU1NIETsnbwgZGRkZCBBIGg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICfsmKTripggTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAn64K07J28IExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ+yWtOygnCBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAn7KeA64Kc7KO8IGRkZGQgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDtm4QnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg7KCEJyxcclxuICAgICAgICBzIDogJ+uqhyDstIgnLFxyXG4gICAgICAgIHNzIDogJyVk7LSIJyxcclxuICAgICAgICBtIDogJzHrtoQnLFxyXG4gICAgICAgIG1tIDogJyVk67aEJyxcclxuICAgICAgICBoIDogJ+2VnCDsi5zqsIQnLFxyXG4gICAgICAgIGhoIDogJyVk7Iuc6rCEJyxcclxuICAgICAgICBkIDogJ+2VmOujqCcsXHJcbiAgICAgICAgZGQgOiAnJWTsnbwnLFxyXG4gICAgICAgIE0gOiAn7ZWcIOuLrCcsXHJcbiAgICAgICAgTU0gOiAnJWTri6wnLFxyXG4gICAgICAgIHkgOiAn7J28IOuFhCcsXHJcbiAgICAgICAgeXkgOiAnJWTrhYQnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZSA6IC9cXGR7MSwyfSjsnbx87JuUfOyjvCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn7J28JztcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+yblCc7XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn7KO8JztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2UgOiAv7Jik7KCEfOyYpO2bhC8sXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuID09PSAn7Jik7ZuEJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzVXBwZXIpIHtcclxuICAgICAgICByZXR1cm4gaG91ciA8IDEyID8gJ+yYpOyghCcgOiAn7Jik7ZuEJztcclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4ga287XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tvLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2tvLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogS3lyZ3l6IFtreV1cclxuLy8hIGF1dGhvciA6IENoeW5neXogQXJ5c3RhbiB1dWx1IDogaHR0cHM6Ly9naXRodWIuY29tL2NoeW5neXpcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcblxyXG52YXIgc3VmZml4ZXMgPSB7XHJcbiAgICAwOiAnLdGH0q8nLFxyXG4gICAgMTogJy3Rh9C4JyxcclxuICAgIDI6ICct0YfQuCcsXHJcbiAgICAzOiAnLdGH0q8nLFxyXG4gICAgNDogJy3Rh9KvJyxcclxuICAgIDU6ICct0YfQuCcsXHJcbiAgICA2OiAnLdGH0YsnLFxyXG4gICAgNzogJy3Rh9C4JyxcclxuICAgIDg6ICct0YfQuCcsXHJcbiAgICA5OiAnLdGH0YMnLFxyXG4gICAgMTA6ICct0YfRgycsXHJcbiAgICAyMDogJy3Rh9GLJyxcclxuICAgIDMwOiAnLdGH0YMnLFxyXG4gICAgNDA6ICct0YfRiycsXHJcbiAgICA1MDogJy3Rh9KvJyxcclxuICAgIDYwOiAnLdGH0YsnLFxyXG4gICAgNzA6ICct0YfQuCcsXHJcbiAgICA4MDogJy3Rh9C4JyxcclxuICAgIDkwOiAnLdGH0YMnLFxyXG4gICAgMTAwOiAnLdGH0q8nXHJcbn07XHJcblxyXG52YXIga3kgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdreScsIHtcclxuICAgIG1vbnRocyA6ICfRj9C90LLQsNGA0Yxf0YTQtdCy0YDQsNC70Yxf0LzQsNGA0YJf0LDQv9GA0LXQu9GMX9C80LDQuV/QuNGO0L3RjF/QuNGO0LvRjF/QsNCy0LPRg9GB0YJf0YHQtdC90YLRj9Cx0YDRjF/QvtC60YLRj9Cx0YDRjF/QvdC+0Y/QsdGA0Yxf0LTQtdC60LDQsdGA0YwnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfRj9C90LJf0YTQtdCyX9C80LDRgNGCX9Cw0L/RgF/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCzX9GB0LXQvV/QvtC60YJf0L3QvtGPX9C00LXQuicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9CW0LXQutGI0LXQvNCx0Lhf0JTSr9C50YjTqdC80LHSr1/QqNC10LnRiNC10LzQsdC4X9Co0LDRgNGI0LXQvNCx0Lhf0JHQtdC50YjQtdC80LHQuF/QltGD0LzQsF/QmNGI0LXQvNCx0LgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9CW0LXQul/QlNKv0Llf0KjQtdC5X9Co0LDRgF/QkdC10Llf0JbRg9C8X9CY0YjQtScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9CW0Lpf0JTQuV/QqNC5X9Co0YBf0JHQuV/QltC8X9CY0YgnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb0JHSr9Cz0q/QvSDRgdCw0LDRgl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9Ct0YDRgtC10qMg0YHQsNCw0YJdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvRgdCw0LDRgl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9Ca0LXRh9C1INGB0LDQsNGCXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW9Oo0YLQutC10L0g0LDQv9GC0LDQvdGL0L1dIGRkZGQgW9C60q/QvdKvXSBb0YHQsNCw0YJdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg0LjRh9C40L3QtNC1JyxcclxuICAgICAgICBwYXN0IDogJyVzINC80YPRgNGD0L0nLFxyXG4gICAgICAgIHMgOiAn0LHQuNGA0L3QtdGH0LUg0YHQtdC60YPQvdC0JyxcclxuICAgICAgICBtIDogJ9Cx0LjRgCDQvNKv0L3TqdGCJyxcclxuICAgICAgICBtbSA6ICclZCDQvNKv0L3TqdGCJyxcclxuICAgICAgICBoIDogJ9Cx0LjRgCDRgdCw0LDRgicsXHJcbiAgICAgICAgaGggOiAnJWQg0YHQsNCw0YInLFxyXG4gICAgICAgIGQgOiAn0LHQuNGAINC60q/QvScsXHJcbiAgICAgICAgZGQgOiAnJWQg0LrSr9C9JyxcclxuICAgICAgICBNIDogJ9Cx0LjRgCDQsNC5JyxcclxuICAgICAgICBNTSA6ICclZCDQsNC5JyxcclxuICAgICAgICB5IDogJ9Cx0LjRgCDQttGL0LsnLFxyXG4gICAgICAgIHl5IDogJyVkINC20YvQuydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNGH0Lh80YfRi3zRh9KvfNGH0YMpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGEgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgYiA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAoc3VmZml4ZXNbbnVtYmVyXSB8fCBzdWZmaXhlc1thXSB8fCBzdWZmaXhlc1tiXSk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGt5O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9reS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9reS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEx1eGVtYm91cmdpc2ggW2xiXVxyXG4vLyEgYXV0aG9yIDogbXdlaW1lcnNraXJjaCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9td2VpbWVyc2tpcmNoXHJcbi8vISBhdXRob3IgOiBEYXZpZCBSYWlzb24gOiBodHRwczovL2dpdGh1Yi5jb20va3dpc2F0elxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ20nOiBbJ2VuZyBNaW51dHQnLCAnZW5nZXIgTWludXR0J10sXHJcbiAgICAgICAgJ2gnOiBbJ2VuZyBTdG9ubicsICdlbmdlciBTdG9ubiddLFxyXG4gICAgICAgICdkJzogWydlZW4gRGFnJywgJ2VuZ2VtIERhZyddLFxyXG4gICAgICAgICdNJzogWydlZSBNb3VudCcsICdlbmdlbSBNb3VudCddLFxyXG4gICAgICAgICd5JzogWydlZSBKb2VyJywgJ2VuZ2VtIEpvZXInXVxyXG4gICAgfTtcclxuICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXTtcclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzRnV0dXJlVGltZShzdHJpbmcpIHtcclxuICAgIHZhciBudW1iZXIgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKCcgJykpO1xyXG4gICAgaWYgKGVpZmVsZXJSZWdlbEFwcGxpZXNUb051bWJlcihudW1iZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuICdhICcgKyBzdHJpbmc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ2FuICcgKyBzdHJpbmc7XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc1Bhc3RUaW1lKHN0cmluZykge1xyXG4gICAgdmFyIG51bWJlciA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YoJyAnKSk7XHJcbiAgICBpZiAoZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcikpIHtcclxuICAgICAgICByZXR1cm4gJ3ZpcnUgJyArIHN0cmluZztcclxuICAgIH1cclxuICAgIHJldHVybiAndmlydW4gJyArIHN0cmluZztcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB3b3JkIGJlZm9yZSB0aGUgZ2l2ZW4gbnVtYmVyIGxvc2VzIHRoZSAnLW4nIGVuZGluZy5cclxuICogZS5nLiAnYW4gMTAgRGVlZycgYnV0ICdhIDUgRGVlZydcclxuICpcclxuICogQHBhcmFtIG51bWJlciB7aW50ZWdlcn1cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBlaWZlbGVyUmVnZWxBcHBsaWVzVG9OdW1iZXIobnVtYmVyKSB7XHJcbiAgICBudW1iZXIgPSBwYXJzZUludChudW1iZXIsIDEwKTtcclxuICAgIGlmIChpc05hTihudW1iZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG51bWJlciA8IDApIHtcclxuICAgICAgICAvLyBOZWdhdGl2ZSBOdW1iZXIgLS0+IGFsd2F5cyB0cnVlXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDEwKSB7XHJcbiAgICAgICAgLy8gT25seSAxIGRpZ2l0XHJcbiAgICAgICAgaWYgKDQgPD0gbnVtYmVyICYmIG51bWJlciA8PSA3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDEwMCkge1xyXG4gICAgICAgIC8vIDIgZGlnaXRzXHJcbiAgICAgICAgdmFyIGxhc3REaWdpdCA9IG51bWJlciAlIDEwLCBmaXJzdERpZ2l0ID0gbnVtYmVyIC8gMTA7XHJcbiAgICAgICAgaWYgKGxhc3REaWdpdCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKGZpcnN0RGlnaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKGxhc3REaWdpdCk7XHJcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDEwMDAwKSB7XHJcbiAgICAgICAgLy8gMyBvciA0IGRpZ2l0cyAtLT4gcmVjdXJzaXZlbHkgY2hlY2sgZmlyc3QgZGlnaXRcclxuICAgICAgICB3aGlsZSAobnVtYmVyID49IDEwKSB7XHJcbiAgICAgICAgICAgIG51bWJlciA9IG51bWJlciAvIDEwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEFueXRoaW5nIGxhcmdlciB0aGFuIDQgZGlnaXRzOiByZWN1cnNpdmVseSBjaGVjayBmaXJzdCBuLTMgZGlnaXRzXHJcbiAgICAgICAgbnVtYmVyID0gbnVtYmVyIC8gMTAwMDtcclxuICAgICAgICByZXR1cm4gZWlmZWxlclJlZ2VsQXBwbGllc1RvTnVtYmVyKG51bWJlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBsYiA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2xiJywge1xyXG4gICAgbW9udGhzOiAnSmFudWFyX0ZlYnJ1YXJfTcOkZXJ6X0FicsOrbGxfTWVlX0p1bmlfSnVsaV9BdWd1c3RfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGV6ZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ0phbi5fRmVici5fTXJ6Ll9BYnIuX01lZV9KdW4uX0p1bC5fQXVnLl9TZXB0Ll9Pa3QuX05vdi5fRGV6Licuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgd2Vla2RheXM6ICdTb25uZGVnX03DqWluZGVnX0TDq25zY2hkZWdfTcOrdHR3b2NoX0Rvbm5lc2NoZGVnX0ZyZWlkZWdfU2Ftc2NoZGVnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ1NvLl9Nw6kuX0TDqy5fTcOrLl9Eby5fRnIuX1NhLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluOiAnU29fTcOpX0TDq19Nw6tfRG9fRnJfU2EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0g6bW0gW0F1ZXJdJyxcclxuICAgICAgICBMVFM6ICdIOm1tOnNzIFtBdWVyXScsXHJcbiAgICAgICAgTDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEw6ICdELiBNTU1NIFlZWVkgSDptbSBbQXVlcl0nLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSBbQXVlcl0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXI6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0hhdXQgdW1dIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxyXG4gICAgICAgIG5leHREYXk6ICdbTXVlciB1bV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbdW1dIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW0fDq3NjaHRlciB1bV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERpZmZlcmVudCBkYXRlIHN0cmluZyBmb3IgJ0TDq25zY2hkZWcnIChUdWVzZGF5KSBhbmQgJ0Rvbm5lc2NoZGVnJyAoVGh1cnNkYXkpIGR1ZSB0byBwaG9ub2xvZ2ljYWwgcnVsZVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tMZXNjaHRlbl0gZGRkZCBbdW1dIExUJztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbTGVzY2h0ZV0gZGRkZCBbdW1dIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogcHJvY2Vzc0Z1dHVyZVRpbWUsXHJcbiAgICAgICAgcGFzdCA6IHByb2Nlc3NQYXN0VGltZSxcclxuICAgICAgICBzIDogJ2UgcHVlciBTZWtvbm5lbicsXHJcbiAgICAgICAgbSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbW0gOiAnJWQgTWludXR0ZW4nLFxyXG4gICAgICAgIGggOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGhoIDogJyVkIFN0b25uZW4nLFxyXG4gICAgICAgIGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGRkIDogJyVkIERlZWcnLFxyXG4gICAgICAgIE0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE1NIDogJyVkIE3DqWludCcsXHJcbiAgICAgICAgeSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgeXkgOiAnJWQgSm9lcidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbDogJyVkLicsXHJcbiAgICB3ZWVrOiB7XHJcbiAgICAgICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3k6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbGI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xiLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL2xiLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTGFvIFtsb11cclxuLy8hIGF1dGhvciA6IFJ5YW4gSGFydCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yeWFuaGFydDJcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBsbyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ2xvJywge1xyXG4gICAgbW9udGhzIDogJ+C6oeC6seC6h+C6geC6reC6mV/guoHgurjguqHgup7gurJf4Lqh4Lq14LqZ4LqyX+C7gOC6oeC6quC6sl/gup7gurbgupTguqrgurDgup7gurJf4Lqh4Lq04LqW4Lq44LqZ4LqyX+C6geC7jeC6peC6sOC6geC6u+C6lF/guqrgurTguofguqvgurJf4LqB4Lqx4LqZ4LqN4LqyX+C6leC6uOC6peC6sl/gup7gurDguojgurTguoFf4LqX4Lqx4LqZ4Lqn4LqyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4Lqh4Lqx4LqH4LqB4Lqt4LqZX+C6geC6uOC6oeC6nuC6sl/guqHgurXgupngurJf4LuA4Lqh4Lqq4LqyX+C6nuC6tuC6lOC6quC6sOC6nuC6sl/guqHgurTgupbgurjgupngurJf4LqB4LuN4Lql4Lqw4LqB4Lq74LqUX+C6quC6tOC6h+C6q+C6sl/guoHgurHgupnguo3gurJf4LqV4Lq44Lql4LqyX+C6nuC6sOC6iOC6tOC6gV/gupfgurHgupnguqfgurInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfguq3gurLgupfgurTgupRf4LqI4Lqx4LqZX+C6reC6seC6h+C6hOC6suC6mV/gup7gurjgupRf4Lqe4Lqw4Lqr4Lqx4LqUX+C6quC6uOC6gV/gu4DguqrgurvgurInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+C6l+C6tOC6lF/guojgurHguplf4Lqt4Lqx4LqH4LqE4Lqy4LqZX+C6nuC6uOC6lF/gup7gurDguqvgurHgupRf4Lqq4Lq44LqBX+C7gOC6quC6u+C6sicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+C6l1/guohf4Lqt4LqEX+C6nl/gup7guqtf4Lqq4LqBX+C6qicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAn4Lqn4Lqx4LqZZGRkZCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv4LqV4Lqt4LqZ4LuA4LqK4Lq74LuJ4LqyfOC6leC6reC6meC7geC6peC6hy8sXHJcbiAgICBpc1BNOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgPT09ICfgupXguq3gupngu4HguqXguocnO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgupXguq3gupngu4Dguorgurvgu4ngurInO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LqV4Lqt4LqZ4LuB4Lql4LqHJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4Lqh4Lq34LuJ4LqZ4Lq14LuJ4LuA4Lqn4Lql4LqyXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4Lqh4Lq34LuJ4Lqt4Lq34LuI4LqZ4LuA4Lqn4Lql4LqyXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW+C6p+C6seC6mV1kZGRkW+C7nOC7ieC6suC7gOC6p+C6peC6sl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+C6oeC6t+C7ieC6p+C6suC6meC6meC6teC7ieC7gOC6p+C6peC6sl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vguqfgurHgupldZGRkZFvgu4HguqXgu4nguqfgupngurXgu4ngu4DguqfguqXgurJdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn4Lqt4Lq14LqBICVzJyxcclxuICAgICAgICBwYXN0IDogJyVz4Lqc4LuI4Lqy4LqZ4Lqh4LqyJyxcclxuICAgICAgICBzIDogJ+C6muC7jeC7iOC7gOC6l+C6u+C7iOC6suC7g+C6lOC6p+C6tOC6meC6suC6l+C6tScsXHJcbiAgICAgICAgbSA6ICcxIOC6meC6suC6l+C6tScsXHJcbiAgICAgICAgbW0gOiAnJWQg4LqZ4Lqy4LqX4Lq1JyxcclxuICAgICAgICBoIDogJzEg4LqK4Lq74LuI4Lqn4LuC4Lqh4LqHJyxcclxuICAgICAgICBoaCA6ICclZCDguorgurvgu4jguqfgu4LguqHguocnLFxyXG4gICAgICAgIGQgOiAnMSDguqHgurfgu4knLFxyXG4gICAgICAgIGRkIDogJyVkIOC6oeC6t+C7iScsXHJcbiAgICAgICAgTSA6ICcxIOC7gOC6lOC6t+C6reC6mScsXHJcbiAgICAgICAgTU0gOiAnJWQg4LuA4LqU4Lq34Lqt4LqZJyxcclxuICAgICAgICB5IDogJzEg4Lqb4Lq1JyxcclxuICAgICAgICB5eSA6ICclZCDgupvgurUnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogLyjgupfgurXgu4gpXFxkezEsMn0vLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gJ+C6l+C6teC7iCcgKyBudW1iZXI7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGxvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sby5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sby5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IExpdGh1YW5pYW4gW2x0XVxyXG4vLyEgYXV0aG9yIDogTWluZGF1Z2FzIE1vesWrcmFzIDogaHR0cHM6Ly9naXRodWIuY29tL21tb3p1cmFzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdW5pdHMgPSB7XHJcbiAgICAnbScgOiAnbWludXTEl19taW51dMSXc19taW51dMSZJyxcclxuICAgICdtbSc6ICdtaW51dMSXc19taW51xI1pxbNfbWludXRlcycsXHJcbiAgICAnaCcgOiAndmFsYW5kYV92YWxhbmRvc192YWxhbmTEhScsXHJcbiAgICAnaGgnOiAndmFsYW5kb3NfdmFsYW5kxbNfdmFsYW5kYXMnLFxyXG4gICAgJ2QnIDogJ2RpZW5hX2RpZW5vc19kaWVuxIUnLFxyXG4gICAgJ2RkJzogJ2RpZW5vc19kaWVuxbNfZGllbmFzJyxcclxuICAgICdNJyA6ICdtxJdudW9fbcSXbmVzaW9fbcSXbmVzxK8nLFxyXG4gICAgJ01NJzogJ23El25lc2lhaV9txJduZXNpxbNfbcSXbmVzaXVzJyxcclxuICAgICd5JyA6ICdtZXRhaV9tZXTFs19tZXR1cycsXHJcbiAgICAneXknOiAnbWV0YWlfbWV0xbNfbWV0dXMnXHJcbn07XHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZVNlY29uZHMobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICBpZiAod2l0aG91dFN1ZmZpeCkge1xyXG4gICAgICAgIHJldHVybiAna2VsaW9zIHNla3VuZMSXcyc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBpc0Z1dHVyZSA/ICdrZWxpxbMgc2VrdW5kxb5pxbMnIDogJ2tlbGlhcyBzZWt1bmRlcyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNsYXRlU2luZ3VsYXIobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IGZvcm1zKGtleSlbMF0gOiAoaXNGdXR1cmUgPyBmb3JtcyhrZXkpWzFdIDogZm9ybXMoa2V5KVsyXSk7XHJcbn1cclxuZnVuY3Rpb24gc3BlY2lhbChudW1iZXIpIHtcclxuICAgIHJldHVybiBudW1iZXIgJSAxMCA9PT0gMCB8fCAobnVtYmVyID4gMTAgJiYgbnVtYmVyIDwgMjApO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1zKGtleSkge1xyXG4gICAgcmV0dXJuIHVuaXRzW2tleV0uc3BsaXQoJ18nKTtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXksIGlzRnV0dXJlKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVtYmVyICsgJyAnO1xyXG4gICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgKyB0cmFuc2xhdGVTaW5ndWxhcihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleVswXSwgaXNGdXR1cmUpO1xyXG4gICAgfSBlbHNlIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIChzcGVjaWFsKG51bWJlcikgPyBmb3JtcyhrZXkpWzFdIDogZm9ybXMoa2V5KVswXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgZm9ybXMoa2V5KVsxXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHNwZWNpYWwobnVtYmVyKSA/IGZvcm1zKGtleSlbMV0gOiBmb3JtcyhrZXkpWzJdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxudmFyIGx0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbHQnLCB7XHJcbiAgICBtb250aHMgOiB7XHJcbiAgICAgICAgZm9ybWF0OiAnc2F1c2lvX3Zhc2FyaW9fa292b19iYWxhbmTFvmlvX2dlZ3XFvsSXc19iaXLFvmVsaW9fbGllcG9zX3J1Z3BqxavEjWlvX3J1Z3PEl2pvX3NwYWxpb19sYXBrcmnEjWlvX2dydW9kxb5pbycuc3BsaXQoJ18nKSxcclxuICAgICAgICBzdGFuZGFsb25lOiAnc2F1c2lzX3Zhc2FyaXNfa292YXNfYmFsYW5kaXNfZ2VndcW+xJdfYmlyxb5lbGlzX2xpZXBhX3J1Z3Bqxat0aXNfcnVnc8SXamlzX3NwYWxpc19sYXBrcml0aXNfZ3J1b2Rpcycuc3BsaXQoJ18nKSxcclxuICAgICAgICBpc0Zvcm1hdDogL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT98TU1NTT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK0Rbb0RdPy9cclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6ICdzYXVfdmFzX2tvdl9iYWxfZ2VnX2Jpcl9saWVfcmdwX3Jnc19zcGFfbGFwX2dyZCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDoge1xyXG4gICAgICAgIGZvcm1hdDogJ3Nla21hZGllbsSvX3Bpcm1hZGllbsSvX2FudHJhZGllbsSvX3RyZcSNaWFkaWVuxK9fa2V0dmlydGFkaWVuxK9fcGVua3RhZGllbsSvX8WhZcWhdGFkaWVuxK8nLnNwbGl0KCdfJyksXHJcbiAgICAgICAgc3RhbmRhbG9uZTogJ3Nla21hZGllbmlzX3Bpcm1hZGllbmlzX2FudHJhZGllbmlzX3RyZcSNaWFkaWVuaXNfa2V0dmlydGFkaWVuaXNfcGVua3RhZGllbmlzX8WhZcWhdGFkaWVuaXMnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgaXNGb3JtYXQ6IC9kZGRkIEhIOm1tL1xyXG4gICAgfSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU2VrX1Bpcl9BbnRfVHJlX0tldF9QZW5fxaBlxaEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTX1BfQV9UX0tfUG5fxaAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdZWVlZLU1NLUREJyxcclxuICAgICAgICBMTCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0nLFxyXG4gICAgICAgIExMTCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0sIEhIOm1tIFt2YWwuXScsXHJcbiAgICAgICAgTExMTCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0sIGRkZGQsIEhIOm1tIFt2YWwuXScsXHJcbiAgICAgICAgbCA6ICdZWVlZLU1NLUREJyxcclxuICAgICAgICBsbCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0nLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0sIEhIOm1tIFt2YWwuXScsXHJcbiAgICAgICAgbGxsbCA6ICdZWVlZIFttLl0gTU1NTSBEIFtkLl0sIGRkZCwgSEg6bW0gW3ZhbC5dJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW8WgaWFuZGllbl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW1J5dG9qXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbVmFrYXJdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbUHJhxJdqdXPEr10gZGRkZCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3BvICVzJyxcclxuICAgICAgICBwYXN0IDogJ3ByaWXFoSAlcycsXHJcbiAgICAgICAgcyA6IHRyYW5zbGF0ZVNlY29uZHMsXHJcbiAgICAgICAgbSA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxyXG4gICAgICAgIG1tIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGggOiB0cmFuc2xhdGVTaW5ndWxhcixcclxuICAgICAgICBoaCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBkIDogdHJhbnNsYXRlU2luZ3VsYXIsXHJcbiAgICAgICAgZGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSA6IHRyYW5zbGF0ZVNpbmd1bGFyLFxyXG4gICAgICAgIE1NIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHkgOiB0cmFuc2xhdGVTaW5ndWxhcixcclxuICAgICAgICB5eSA6IHRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS1vamkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJy1vamknO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBsdDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbHQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBMYXR2aWFuIFtsdl1cclxuLy8hIGF1dGhvciA6IEtyaXN0YXBzIEthcmxzb25zIDogaHR0cHM6Ly9naXRodWIuY29tL3NrYWtyaVxyXG4vLyEgYXV0aG9yIDogSsSBbmlzIEVsbWVyaXMgOiBodHRwczovL2dpdGh1Yi5jb20vSmFuaXNFXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdW5pdHMgPSB7XHJcbiAgICAnbSc6ICdtaW7Fq3Rlc19taW7Fq3TEk21fbWluxat0ZV9taW7Fq3Rlcycuc3BsaXQoJ18nKSxcclxuICAgICdtbSc6ICdtaW7Fq3Rlc19taW7Fq3TEk21fbWluxat0ZV9taW7Fq3Rlcycuc3BsaXQoJ18nKSxcclxuICAgICdoJzogJ3N0dW5kYXNfc3R1bmTEgW1fc3R1bmRhX3N0dW5kYXMnLnNwbGl0KCdfJyksXHJcbiAgICAnaGgnOiAnc3R1bmRhc19zdHVuZMSBbV9zdHVuZGFfc3R1bmRhcycuc3BsaXQoJ18nKSxcclxuICAgICdkJzogJ2RpZW5hc19kaWVuxIFtX2RpZW5hX2RpZW5hcycuc3BsaXQoJ18nKSxcclxuICAgICdkZCc6ICdkaWVuYXNfZGllbsSBbV9kaWVuYV9kaWVuYXMnLnNwbGl0KCdfJyksXHJcbiAgICAnTSc6ICdtxJNuZcWhYV9txJNuZcWhaWVtX23Ek25lc2lzX23Ek25lxaFpJy5zcGxpdCgnXycpLFxyXG4gICAgJ01NJzogJ23Ek25lxaFhX23Ek25lxaFpZW1fbcSTbmVzaXNfbcSTbmXFoWknLnNwbGl0KCdfJyksXHJcbiAgICAneSc6ICdnYWRhX2dhZGllbV9nYWRzX2dhZGknLnNwbGl0KCdfJyksXHJcbiAgICAneXknOiAnZ2FkYV9nYWRpZW1fZ2Fkc19nYWRpJy5zcGxpdCgnXycpXHJcbn07XHJcbi8qKlxyXG4gKiBAcGFyYW0gd2l0aG91dFN1ZmZpeCBib29sZWFuIHRydWUgPSBhIGxlbmd0aCBvZiB0aW1lOyBmYWxzZSA9IGJlZm9yZS9hZnRlciBhIHBlcmlvZCBvZiB0aW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9ybWF0KGZvcm1zLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgpIHtcclxuICAgIGlmICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgLy8gRS5nLiBcIjIxIG1pbsWrdGVcIiwgXCIzIG1pbsWrdGVzXCIuXHJcbiAgICAgICAgcmV0dXJuIG51bWJlciAlIDEwID09PSAxICYmIG51bWJlciAlIDEwMCAhPT0gMTEgPyBmb3Jtc1syXSA6IGZvcm1zWzNdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBFLmcuIFwiMjEgbWluxat0ZXNcIiBhcyBpbiBcInDEk2MgMjEgbWluxat0ZXNcIi5cclxuICAgICAgICAvLyBFLmcuIFwiMyBtaW7Fq3TEk21cIiBhcyBpbiBcInDEk2MgMyBtaW7Fq3TEk21cIi5cclxuICAgICAgICByZXR1cm4gbnVtYmVyICUgMTAgPT09IDEgJiYgbnVtYmVyICUgMTAwICE9PSAxMSA/IGZvcm1zWzBdIDogZm9ybXNbMV07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgcmV0dXJuIG51bWJlciArICcgJyArIGZvcm1hdCh1bml0c1trZXldLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcihudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgcmV0dXJuIGZvcm1hdCh1bml0c1trZXldLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbGF0aXZlU2Vjb25kcyhudW1iZXIsIHdpdGhvdXRTdWZmaXgpIHtcclxuICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2Rhxb5hcyBzZWt1bmRlcycgOiAnZGHFvsSBbSBzZWt1bmTEk20nO1xyXG59XHJcblxyXG52YXIgbHYgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdsdicsIHtcclxuICAgIG1vbnRocyA6ICdqYW52xIFyaXNfZmVicnXEgXJpc19tYXJ0c19hcHLEq2xpc19tYWlqc19qxatuaWpzX2rFq2xpanNfYXVndXN0c19zZXB0ZW1icmlzX29rdG9icmlzX25vdmVtYnJpc19kZWNlbWJyaXMnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmViX21hcl9hcHJfbWFpX2rFq25fasWrbF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnc3bEk3RkaWVuYV9waXJtZGllbmFfb3RyZGllbmFfdHJlxaFkaWVuYV9jZXR1cnRkaWVuYV9waWVrdGRpZW5hX3Nlc3RkaWVuYScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnU3ZfUF9PX1RfQ19Qa19TJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnU3ZfUF9PX1RfQ19Qa19TJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWS4nLFxyXG4gICAgICAgIExMIDogJ1lZWVkuIFtnYWRhXSBELiBNTU1NJyxcclxuICAgICAgICBMTEwgOiAnWVlZWS4gW2dhZGFdIEQuIE1NTU0sIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ1lZWVkuIFtnYWRhXSBELiBNTU1NLCBkZGRkLCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vFoG9kaWVuIHB1bGtzdGVuXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbUsSrdCBwdWxrc3Rlbl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW3B1bGtzdGVuXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbVmFrYXIgcHVsa3N0ZW5dIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdbUGFnxIFqdcWhxIFdIGRkZGQgW3B1bGtzdGVuXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3DEk2MgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAncGlybXMgJXMnLFxyXG4gICAgICAgIHMgOiByZWxhdGl2ZVNlY29uZHMsXHJcbiAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcclxuICAgICAgICBtbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgaCA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcclxuICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgZCA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcclxuICAgICAgICBkZCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgTSA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcclxuICAgICAgICBNTSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgeSA6IHJlbGF0aXZlVGltZVdpdGhTaW5ndWxhcixcclxuICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIGx2O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9sdi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE1vbnRlbmVncmluIFttZV1cclxuLy8hIGF1dGhvciA6IE1pb2RyYWcgTmlrYcSNIDxtaW9kcmFnQHJlc3RhcnRpdC5tZT4gOiBodHRwczovL2dpdGh1Yi5jb20vbWlvZHJhZ25pa2FjXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdHJhbnNsYXRvciA9IHtcclxuICAgIHdvcmRzOiB7IC8vRGlmZmVyZW50IGdyYW1tYXRpY2FsIGNhc2VzXHJcbiAgICAgICAgbTogWydqZWRhbiBtaW51dCcsICdqZWRub2cgbWludXRhJ10sXHJcbiAgICAgICAgbW06IFsnbWludXQnLCAnbWludXRhJywgJ21pbnV0YSddLFxyXG4gICAgICAgIGg6IFsnamVkYW4gc2F0JywgJ2plZG5vZyBzYXRhJ10sXHJcbiAgICAgICAgaGg6IFsnc2F0JywgJ3NhdGEnLCAnc2F0aSddLFxyXG4gICAgICAgIGRkOiBbJ2RhbicsICdkYW5hJywgJ2RhbmEnXSxcclxuICAgICAgICBNTTogWydtamVzZWMnLCAnbWplc2VjYScsICdtamVzZWNpJ10sXHJcbiAgICAgICAgeXk6IFsnZ29kaW5hJywgJ2dvZGluZScsICdnb2RpbmEnXVxyXG4gICAgfSxcclxuICAgIGNvcnJlY3RHcmFtbWF0aWNhbENhc2U6IGZ1bmN0aW9uIChudW1iZXIsIHdvcmRLZXkpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyID09PSAxID8gd29yZEtleVswXSA6IChudW1iZXIgPj0gMiAmJiBudW1iZXIgPD0gNCA/IHdvcmRLZXlbMV0gOiB3b3JkS2V5WzJdKTtcclxuICAgIH0sXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgICAgIHZhciB3b3JkS2V5ID0gdHJhbnNsYXRvci53b3Jkc1trZXldO1xyXG4gICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gd29yZEtleVswXSA6IHdvcmRLZXlbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHRyYW5zbGF0b3IuY29ycmVjdEdyYW1tYXRpY2FsQ2FzZShudW1iZXIsIHdvcmRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBtZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21lJywge1xyXG4gICAgbW9udGhzOiAnamFudWFyX2ZlYnJ1YXJfbWFydF9hcHJpbF9tYWpfanVuX2p1bF9hdmd1c3Rfc2VwdGVtYmFyX29rdG9iYXJfbm92ZW1iYXJfZGVjZW1iYXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ2phbi5fZmViLl9tYXIuX2Fwci5fbWFqX2p1bl9qdWxfYXZnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5czogJ25lZGplbGphX3BvbmVkamVsamFrX3V0b3Jha19zcmlqZWRhX8SNZXR2cnRha19wZXRha19zdWJvdGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0OiAnbmVkLl9wb24uX3V0by5fc3JpLl/EjWV0Ll9wZXQuX3N1Yi4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ25lX3BvX3V0X3NyX8SNZV9wZV9zdScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdDoge1xyXG4gICAgICAgIExUOiAnSDptbScsXHJcbiAgICAgICAgTFRTIDogJ0g6bW06c3MnLFxyXG4gICAgICAgIEw6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRC4gTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEw6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhcjoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbZGFuYXMgdV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbc2p1dHJhIHVdIExUJyxcclxuXHJcbiAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGplbGp1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzcmlqZWR1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWUgdV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFdlZWtEYXlzID0gW1xyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbbmVkamVsamVdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcG9uZWRqZWxqa2FdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbdXRvcmthXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbc3JpamVkZV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFvEjWV0dnJ0a2FdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbG9nXSBbcGV0a2FdIFt1XSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW3Byb8WhbGVdIFtzdWJvdGVdIFt1XSBMVCdcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RXZWVrRGF5c1t0aGlzLmRheSgpXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCAgIDogJ3ByaWplICVzJyxcclxuICAgICAgICBzICAgICAgOiAnbmVrb2xpa28gc2VrdW5kaScsXHJcbiAgICAgICAgbSAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgaCAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgaGggICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgZCAgICAgIDogJ2RhbicsXHJcbiAgICAgICAgZGQgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgTSAgICAgIDogJ21qZXNlYycsXHJcbiAgICAgICAgTU0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgeSAgICAgIDogJ2dvZGludScsXHJcbiAgICAgICAgeXkgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG1lO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE1hb3JpIFttaV1cclxuLy8hIGF1dGhvciA6IEpvaG4gQ29ycmlnYW4gPHJvYmJpZWNsb3NldEBnbWFpbC5jb20+IDogaHR0cHM6Ly9naXRodWIuY29tL2pvaG5pZGVhbFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1pID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbWknLCB7XHJcbiAgICBtb250aHM6ICdLb2hpLXTEgXRlX0h1aS10YW5ndXJ1X1BvdXTFqy10ZS1yYW5naV9QYWVuZ2Etd2jEgXdoxIFfSGFyYXR1YV9QaXBpcmlfSMWNbmdvaW5nb2lfSGVyZS10dXJpLWvFjWvEgV9NYWh1cnVfV2hpcmluZ2EtxIEtbnVrdV9XaGlyaW5nYS3EgS1yYW5naV9IYWtpaGVhJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICdLb2hpX0h1aV9Qb3VfUGFlX0hhcmFfUGlwaV9IxY1uZ29pX0hlcmVfTWFodV9XaGktbnVfV2hpLXJhX0hha2knLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNSZWdleDogLyg/OlsnYS16XFx1MDEwMVxcdTAxNERcXHUwMTZCXStcXC0/KXsxLDN9L2ksXHJcbiAgICBtb250aHNTdHJpY3RSZWdleDogLyg/OlsnYS16XFx1MDEwMVxcdTAxNERcXHUwMTZCXStcXC0/KXsxLDN9L2ksXHJcbiAgICBtb250aHNTaG9ydFJlZ2V4OiAvKD86WydhLXpcXHUwMTAxXFx1MDE0RFxcdTAxNkJdK1xcLT8pezEsM30vaSxcclxuICAgIG1vbnRoc1Nob3J0U3RyaWN0UmVnZXg6IC8oPzpbJ2EtelxcdTAxMDFcXHUwMTREXFx1MDE2Ql0rXFwtPyl7MSwyfS9pLFxyXG4gICAgd2Vla2RheXM6ICdSxIF0YXB1X01hbmVfVMWrcmVpX1dlbmVyZWlfVMSBaXRlX1BhcmFpcmVfSMSBdGFyZWknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0OiAnVGFfTWFfVMWrX1dlX1TEgWlfUGFfSMSBJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW46ICdUYV9NYV9UxatfV2VfVMSBaV9QYV9IxIEnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdDoge1xyXG4gICAgICAgIExUOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUzogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgW2ldIEhIOm1tJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgRCBNTU1NIFlZWVkgW2ldIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tpIHRlaWUgbWFoYW5hLCBpXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1thcG9wbyBpXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtpXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tpbmFuYWhpIGldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ2RkZGQgW3doYWthbXV0dW5nYSBpXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZToge1xyXG4gICAgICAgIGZ1dHVyZTogJ2kgcm90byBpICVzJyxcclxuICAgICAgICBwYXN0OiAnJXMgaSBtdWEnLFxyXG4gICAgICAgIHM6ICd0ZSBoxJNrb25hIHJ1YXJ1YScsXHJcbiAgICAgICAgbTogJ2hlIG1lbmV0aScsXHJcbiAgICAgICAgbW06ICclZCBtZW5ldGknLFxyXG4gICAgICAgIGg6ICd0ZSBoYW9yYScsXHJcbiAgICAgICAgaGg6ICclZCBoYW9yYScsXHJcbiAgICAgICAgZDogJ2hlIHJhJyxcclxuICAgICAgICBkZDogJyVkIHJhJyxcclxuICAgICAgICBNOiAnaGUgbWFyYW1hJyxcclxuICAgICAgICBNTTogJyVkIG1hcmFtYScsXHJcbiAgICAgICAgeTogJ2hlIHRhdScsXHJcbiAgICAgICAgeXk6ICclZCB0YXUnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9wrovLFxyXG4gICAgb3JkaW5hbDogJyVkwronLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG1pO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9taS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9taS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE1hY2Vkb25pYW4gW21rXVxyXG4vLyEgYXV0aG9yIDogQm9yaXNsYXYgTWlja292IDogaHR0cHM6Ly9naXRodWIuY29tL0IwazBcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtayA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21rJywge1xyXG4gICAgbW9udGhzIDogJ9GY0LDQvdGD0LDRgNC4X9GE0LXQstGA0YPQsNGA0Lhf0LzQsNGA0YJf0LDQv9GA0LjQu1/QvNCw0Zhf0ZjRg9C90Lhf0ZjRg9C70Lhf0LDQstCz0YPRgdGCX9GB0LXQv9GC0LXQvNCy0YDQuF/QvtC60YLQvtC80LLRgNC4X9C90L7QtdC80LLRgNC4X9C00LXQutC10LzQstGA0LgnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfRmNCw0L1f0YTQtdCyX9C80LDRgF/QsNC/0YBf0LzQsNGYX9GY0YPQvV/RmNGD0Ltf0LDQstCzX9GB0LXQv1/QvtC60YJf0L3QvtC1X9C00LXQuicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9C90LXQtNC10LvQsF/Qv9C+0L3QtdC00LXQu9C90LjQul/QstGC0L7RgNC90LjQul/RgdGA0LXQtNCwX9GH0LXRgtCy0YDRgtC+0Lpf0L/QtdGC0L7Qul/RgdCw0LHQvtGC0LAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9C90LXQtF/Qv9C+0L1f0LLRgtC+X9GB0YDQtV/Rh9C10YJf0L/QtdGCX9GB0LDQsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ9C9ZV/Qv29f0LLRgl/RgdGAX9GH0LVf0L/QtV/RgWEnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW9CU0LXQvdC10YEg0LLQvl0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9Cj0YLRgNC1INCy0L5dIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdb0JLQvl0gZGRkZCBb0LLQvl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9CS0YfQtdGA0LAg0LLQvl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQmNC30LzQuNC90LDRgtCw0YLQsF0gZGRkZCBb0LLQvl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CY0LfQvNC40L3QsNGC0LjQvtGCXSBkZGRkIFvQstC+XSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfQv9C+0YHQu9C1ICVzJyxcclxuICAgICAgICBwYXN0IDogJ9C/0YDQtdC0ICVzJyxcclxuICAgICAgICBzIDogJ9C90LXQutC+0LvQutGDINGB0LXQutGD0L3QtNC4JyxcclxuICAgICAgICBtIDogJ9C80LjQvdGD0YLQsCcsXHJcbiAgICAgICAgbW0gOiAnJWQg0LzQuNC90YPRgtC4JyxcclxuICAgICAgICBoIDogJ9GH0LDRgScsXHJcbiAgICAgICAgaGggOiAnJWQg0YfQsNGB0LAnLFxyXG4gICAgICAgIGQgOiAn0LTQtdC9JyxcclxuICAgICAgICBkZCA6ICclZCDQtNC10L3QsCcsXHJcbiAgICAgICAgTSA6ICfQvNC10YHQtdGGJyxcclxuICAgICAgICBNTSA6ICclZCDQvNC10YHQtdGG0LgnLFxyXG4gICAgICAgIHkgOiAn0LPQvtC00LjQvdCwJyxcclxuICAgICAgICB5eSA6ICclZCDQs9C+0LTQuNC90LgnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9LSjQtdCyfNC10L180YLQuHzQstC4fNGA0Lh80LzQuCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgbGFzdERpZ2l0ID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgIGxhc3QyRGlnaXRzID0gbnVtYmVyICUgMTAwO1xyXG4gICAgICAgIGlmIChudW1iZXIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LXQsic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0MkRpZ2l0cyA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QtdC9JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3QyRGlnaXRzID4gMTAgJiYgbGFzdDJEaWdpdHMgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgtC4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QstC4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3RgNC4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNyB8fCBsYXN0RGlnaXQgPT09IDgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LzQuCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0YLQuCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBtaztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWsuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbWsuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNYWxheWFsYW0gW21sXVxyXG4vLyEgYXV0aG9yIDogRmxveWQgUGluayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG95ZHBpbmtcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtbCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ21sJywge1xyXG4gICAgbW9udGhzIDogJ+C0nOC0qOC1geC0teC0sOC0v1/gtKvgtYbgtKzgtY3gtLDgtYHgtLXgtLDgtL9f4LSu4LS+4LW84LSa4LWN4LSa4LWNX+C0j+C0quC1jeC0sOC0v+C1vV/gtK7gtYfgtK/gtY1f4LSc4LWC4LW6X+C0nOC1guC0suC1iF/gtJPgtJfgtLjgtY3gtLHgtY3gtLHgtY1f4LS44LWG4LSq4LWN4LSx4LWN4LSx4LSC4LSs4LW8X+C0kuC0leC1jeC0n+C1i+C0rOC1vF/gtKjgtLXgtILgtKzgtbxf4LSh4LS/4LS44LSC4LSs4LW8Jy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4LSc4LSo4LWBLl/gtKvgtYbgtKzgtY3gtLDgtYEuX+C0ruC0vuC1vC5f4LSP4LSq4LWN4LSw4LS/Ll/gtK7gtYfgtK/gtY1f4LSc4LWC4LW6X+C0nOC1guC0suC1iC5f4LST4LSXLl/gtLjgtYbgtKrgtY3gtLHgtY3gtLEuX+C0kuC0leC1jeC0n+C1iy5f4LSo4LS14LSCLl/gtKHgtL/gtLjgtIIuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICfgtJ7gtL7gtK/gtLHgtL7gtLTgtY3gtJpf4LSk4LS/4LSZ4LWN4LSV4LSz4LS+4LS04LWN4LSaX+C0muC1iuC0teC1jeC0teC0vuC0tOC1jeC0ml/gtKzgtYHgtKfgtKjgtL7gtLTgtY3gtJpf4LS14LWN4LSv4LS+4LS04LS+4LS04LWN4LSaX+C0teC1huC0s+C1jeC0s+C0v+C0r+C0vuC0tOC1jeC0ml/gtLbgtKjgtL/gtK/gtL7gtLTgtY3gtJonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+C0nuC0vuC0r+C1vF/gtKTgtL/gtJngtY3gtJXgtb5f4LSa4LWK4LS14LWN4LS1X+C0rOC1geC0p+C1u1/gtLXgtY3gtK/gtL7gtLTgtIJf4LS14LWG4LSz4LWN4LSz4LS/X+C0tuC0qOC0vycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+C0nuC0vl/gtKTgtL9f4LSa4LWKX+C0rOC1gV/gtLXgtY3gtK/gtL5f4LS14LWGX+C0ticuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbSAt4LSo4LWBJyxcclxuICAgICAgICBMVFMgOiAnQSBoOm1tOnNzIC3gtKjgtYEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tIC3gtKjgtYEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSAt4LSo4LWBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+C0h+C0qOC1jeC0qOC1jV0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+C0qOC0vuC0s+C1hl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQsIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgtIfgtKjgtY3gtKjgtLLgtYZdIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb4LSV4LS04LS/4LSe4LWN4LSeXSBkZGRkLCBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIOC0leC0tOC0v+C0nuC1jeC0nuC1jScsXHJcbiAgICAgICAgcGFzdCA6ICclcyDgtK7gtYHgtbvgtKrgtY0nLFxyXG4gICAgICAgIHMgOiAn4LSF4LW94LSqIOC0qOC0v+C0ruC0v+C0t+C0meC1jeC0meC1vicsXHJcbiAgICAgICAgbSA6ICfgtJLgtLDgtYEg4LSu4LS/4LSo4LS/4LSx4LWN4LSx4LWNJyxcclxuICAgICAgICBtbSA6ICclZCDgtK7gtL/gtKjgtL/gtLHgtY3gtLHgtY0nLFxyXG4gICAgICAgIGggOiAn4LSS4LSw4LWBIOC0ruC0o+C0v+C0leC1jeC0leC1guC1vCcsXHJcbiAgICAgICAgaGggOiAnJWQg4LSu4LSj4LS/4LSV4LWN4LSV4LWC4LW8JyxcclxuICAgICAgICBkIDogJ+C0kuC0sOC1gSDgtKbgtL/gtLXgtLjgtIInLFxyXG4gICAgICAgIGRkIDogJyVkIOC0puC0v+C0teC0uOC0gicsXHJcbiAgICAgICAgTSA6ICfgtJLgtLDgtYEg4LSu4LS+4LS44LSCJyxcclxuICAgICAgICBNTSA6ICclZCDgtK7gtL7gtLjgtIInLFxyXG4gICAgICAgIHkgOiAn4LSS4LSw4LWBIOC0teC1vOC0t+C0gicsXHJcbiAgICAgICAgeXkgOiAnJWQg4LS14LW84LS34LSCJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gtLDgtL7gtKTgtY3gtLDgtL984LSw4LS+4LS14LS/4LSy4LWGfOC0ieC0muC1jeC0miDgtJXgtLTgtL/gtJ7gtY3gtJ7gtY184LS14LWI4LSV4LWB4LSo4LWN4LSo4LWH4LSw4LSCfOC0sOC0vuC0pOC1jeC0sOC0vy9pLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKG1lcmlkaWVtID09PSAn4LSw4LS+4LSk4LWN4LSw4LS/JyAmJiBob3VyID49IDQpIHx8XHJcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+C0ieC0muC1jeC0miDgtJXgtLTgtL/gtJ7gtY3gtJ7gtY0nIHx8XHJcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9PT0gJ+C0teC1iOC0leC1geC0qOC1jeC0qOC1h+C0sOC0gicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LSw4LS+4LSk4LWN4LSw4LS/JztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C0sOC0vuC0teC0v+C0suC1hic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgtIngtJrgtY3gtJog4LSV4LS04LS/4LSe4LWN4LSe4LWNJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C0teC1iOC0leC1geC0qOC1jeC0qOC1h+C0sOC0gic7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgtLDgtL7gtKTgtY3gtLDgtL8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbWw7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21sLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21sLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTWFyYXRoaSBbbXJdXHJcbi8vISBhdXRob3IgOiBIYXJzaGFkIEthbGUgOiBodHRwczovL2dpdGh1Yi5jb20va2FsZWh2XHJcbi8vISBhdXRob3IgOiBWaXZlayBBdGhhbHllIDogaHR0cHM6Ly9naXRodWIuY29tL3ZuYXRoYWx5ZVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+ClpycsXHJcbiAgICAnMic6ICfgpagnLFxyXG4gICAgJzMnOiAn4KWpJyxcclxuICAgICc0JzogJ+ClqicsXHJcbiAgICAnNSc6ICfgpasnLFxyXG4gICAgJzYnOiAn4KWsJyxcclxuICAgICc3JzogJ+ClrScsXHJcbiAgICAnOCc6ICfgpa4nLFxyXG4gICAgJzknOiAn4KWvJyxcclxuICAgICcwJzogJ+ClpidcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfgpacnOiAnMScsXHJcbiAgICAn4KWoJzogJzInLFxyXG4gICAgJ+ClqSc6ICczJyxcclxuICAgICfgpaonOiAnNCcsXHJcbiAgICAn4KWrJzogJzUnLFxyXG4gICAgJ+ClrCc6ICc2JyxcclxuICAgICfgpa0nOiAnNycsXHJcbiAgICAn4KWuJzogJzgnLFxyXG4gICAgJ+Clryc6ICc5JyxcclxuICAgICfgpaYnOiAnMCdcclxufTtcclxuXHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZU1yKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSlcclxue1xyXG4gICAgdmFyIG91dHB1dCA9ICcnO1xyXG4gICAgaWYgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICBzd2l0Y2ggKHN0cmluZykge1xyXG4gICAgICAgICAgICBjYXNlICdzJzogb3V0cHV0ID0gJ+CkleCkvuCkueClgCDgpLjgpYfgpJXgpILgpKYnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbSc6IG91dHB1dCA9ICfgpI/gpJUg4KSu4KS/4KSo4KS/4KSfJzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21tJzogb3V0cHV0ID0gJyVkIOCkruCkv+CkqOCkv+Ckn+Clhyc7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdoJzogb3V0cHV0ID0gJ+Ckj+CklSDgpKTgpL7gpLgnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaGgnOiBvdXRwdXQgPSAnJWQg4KSk4KS+4KS4JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOiBvdXRwdXQgPSAn4KSP4KSVIOCkpuCkv+CkteCkuCc7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkZCc6IG91dHB1dCA9ICclZCDgpKbgpL/gpLXgpLgnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnTSc6IG91dHB1dCA9ICfgpI/gpJUg4KSu4KS54KS/4KSo4KS+JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ01NJzogb3V0cHV0ID0gJyVkIOCkruCkueCkv+CkqOClhyc7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd5Jzogb3V0cHV0ID0gJ+Ckj+CklSDgpLXgpLDgpY3gpLcnOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAneXknOiBvdXRwdXQgPSAnJWQg4KS14KSw4KWN4KS34KWHJzsgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3dpdGNoIChzdHJpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSAncyc6IG91dHB1dCA9ICfgpJXgpL7gpLngpYAg4KS44KWH4KSV4KSC4KSm4KS+4KSCJzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ20nOiBvdXRwdXQgPSAn4KSP4KSV4KS+IOCkruCkv+CkqOCkv+Ckn+Ckvic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtbSc6IG91dHB1dCA9ICclZCDgpK7gpL/gpKjgpL/gpJ/gpL7gpIInOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaCc6IG91dHB1dCA9ICfgpI/gpJXgpL4g4KSk4KS+4KS44KS+JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hoJzogb3V0cHV0ID0gJyVkIOCkpOCkvuCkuOCkvuCkgic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkJzogb3V0cHV0ID0gJ+Ckj+CkleCkviDgpKbgpL/gpLXgpLjgpL4nOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnZGQnOiBvdXRwdXQgPSAnJWQg4KSm4KS/4KS14KS44KS+4KSCJzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOiBvdXRwdXQgPSAn4KSP4KSV4KS+IOCkruCkueCkv+CkqOCljeCkr+Ckvic7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdNTSc6IG91dHB1dCA9ICclZCDgpK7gpLngpL/gpKjgpY3gpK/gpL7gpIInOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAneSc6IG91dHB1dCA9ICfgpI/gpJXgpL4g4KS14KSw4KWN4KS34KS+JzsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3l5Jzogb3V0cHV0ID0gJyVkIOCkteCksOCljeCkt+CkvuCkgic7IGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcclxufVxyXG5cclxudmFyIG1yID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXInLCB7XHJcbiAgICBtb250aHMgOiAn4KSc4KS+4KSo4KWH4KS14KS+4KSw4KWAX+Ckq+Clh+CkrOCljeCksOClgeCkteCkvuCksOClgF/gpK7gpL7gpLDgpY3gpJpf4KSP4KSq4KWN4KSw4KS/4KSyX+CkruClh1/gpJzgpYLgpKhf4KSc4KWB4KSy4KWIX+CkkeCkl+CkuOCljeCkn1/gpLjgpKrgpY3gpJ/gpYfgpILgpKzgpLBf4KSR4KSV4KWN4KSf4KWL4KSs4KSwX+CkqOCli+CkteCljeCkueClh+CkguCkrOCksF/gpKHgpL/gpLjgpYfgpILgpKzgpLAnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ+CknOCkvuCkqOClhy5f4KSr4KWH4KSs4KWN4KSw4KWBLl/gpK7gpL7gpLDgpY3gpJouX+Ckj+CkquCljeCksOCkvy5f4KSu4KWHLl/gpJzgpYLgpKguX+CknOClgeCksuCliC5f4KSR4KSXLl/gpLjgpKrgpY3gpJ/gpYfgpIIuX+CkkeCkleCljeCkn+Cliy5f4KSo4KWL4KS14KWN4KS54KWH4KSCLl/gpKHgpL/gpLjgpYfgpIIuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICfgpLDgpLXgpL/gpLXgpL7gpLBf4KS44KWL4KSu4KS14KS+4KSwX+CkruCkguCkl+Cks+CkteCkvuCksF/gpKzgpYHgpKfgpLXgpL7gpLBf4KSX4KWB4KSw4KWC4KS14KS+4KSwX+CktuClgeCkleCljeCksOCkteCkvuCksF/gpLbgpKjgpL/gpLXgpL7gpLAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+CksOCkteCkv1/gpLjgpYvgpK5f4KSu4KSC4KSX4KSzX+CkrOClgeCkp1/gpJfgpYHgpLDgpYJf4KS24KWB4KSV4KWN4KSwX+CktuCkqOCkvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+CksF/gpLjgpYtf4KSu4KSCX+CkrOClgV/gpJfgpYFf4KS24KWBX+Ckticuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbSDgpLXgpL7gpJzgpKTgpL4nLFxyXG4gICAgICAgIExUUyA6ICdBIGg6bW06c3Mg4KS14KS+4KSc4KSk4KS+JyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEEgaDptbSDgpLXgpL7gpJzgpKTgpL4nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSDgpLXgpL7gpJzgpKTgpL4nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb4KSG4KScXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdb4KSJ4KSm4KWN4KSv4KS+XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCwgTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+CkleCkvuCksl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW+CkruCkvuCkl+ClgOCksl0gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZTogJyVz4KSu4KSn4KWN4KSv4KWHJyxcclxuICAgICAgICBwYXN0OiAnJXPgpKrgpYLgpLDgpY3gpLXgpYAnLFxyXG4gICAgICAgIHM6IHJlbGF0aXZlVGltZU1yLFxyXG4gICAgICAgIG06IHJlbGF0aXZlVGltZU1yLFxyXG4gICAgICAgIG1tOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICBoOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICBoaDogcmVsYXRpdmVUaW1lTXIsXHJcbiAgICAgICAgZDogcmVsYXRpdmVUaW1lTXIsXHJcbiAgICAgICAgZGQ6IHJlbGF0aXZlVGltZU1yLFxyXG4gICAgICAgIE06IHJlbGF0aXZlVGltZU1yLFxyXG4gICAgICAgIE1NOiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICB5OiByZWxhdGl2ZVRpbWVNcixcclxuICAgICAgICB5eTogcmVsYXRpdmVUaW1lTXJcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Clp+ClqOClqeClquClq+ClrOClreClruClr+Clpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+CksOCkvuCkpOCljeCksOClgHzgpLjgpJXgpL7gpLPgpYB84KSm4KWB4KSq4KS+4KSw4KWAfOCkuOCkvuCkr+CkguCkleCkvuCks+ClgC8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CksOCkvuCkpOCljeCksOClgCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KS44KSV4KS+4KSz4KWAJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSm4KWB4KSq4KS+4KSw4KWAJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkuOCkvuCkr+CkguCkleCkvuCks+ClgCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW06IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpLDgpL7gpKTgpY3gpLDgpYAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KS44KSV4KS+4KSz4KWAJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CkpuClgeCkquCkvuCksOClgCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMjApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpLjgpL7gpK/gpILgpJXgpL7gpLPgpYAnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSk4KWN4KSw4KWAJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG1yO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9tci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE1hbGF5IFttcy1teV1cclxuLy8hIG5vdGUgOiBERVBSRUNBVEVELCB0aGUgY29ycmVjdCBvbmUgaXMgW21zXVxyXG4vLyEgYXV0aG9yIDogV2VsZGFuIEphbWlsaSA6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWxkYW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtc015ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXMtbXknLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYWNfQXByaWxfTWVpX0p1bl9KdWxhaV9PZ29zX1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0Rpc2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYWNfQXByX01laV9KdW5fSnVsX09nc19TZXBfT2t0X05vdl9EaXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdBaGFkX0lzbmluX1NlbGFzYV9SYWJ1X0toYW1pc19KdW1hYXRfU2FidHUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0FoZF9Jc25fU2VsX1JhYl9LaGFfSnVtX1NhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0FoX0lzX1NsX1JiX0ttX0ptX1NiJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEgubW0nLFxyXG4gICAgICAgIExUUyA6ICdISC5tbS5zcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvcGFnaXx0ZW5nYWhhcml8cGV0YW5nfG1hbGFtLyxcclxuICAgIG1lcmlkaWVtSG91cjogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdwYWdpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAndGVuZ2FoYXJpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3BldGFuZycgfHwgbWVyaWRpZW0gPT09ICdtYWxhbScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BhZ2knO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RlbmdhaGFyaSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncGV0YW5nJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ21hbGFtJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbSGFyaSBpbmkgcHVrdWxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tFc29rIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbcHVrdWxdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tLZWxtYXJpbiBwdWt1bF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xlcGFzIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhbGFtICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIHlhbmcgbGVwYXMnLFxyXG4gICAgICAgIHMgOiAnYmViZXJhcGEgc2FhdCcsXHJcbiAgICAgICAgbSA6ICdzZW1pbml0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW5pdCcsXHJcbiAgICAgICAgaCA6ICdzZWphbScsXHJcbiAgICAgICAgaGggOiAnJWQgamFtJyxcclxuICAgICAgICBkIDogJ3NlaGFyaScsXHJcbiAgICAgICAgZGQgOiAnJWQgaGFyaScsXHJcbiAgICAgICAgTSA6ICdzZWJ1bGFuJyxcclxuICAgICAgICBNTSA6ICclZCBidWxhbicsXHJcbiAgICAgICAgeSA6ICdzZXRhaHVuJyxcclxuICAgICAgICB5eSA6ICclZCB0YWh1bidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbXNNeTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXMtbXkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXMtbXkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBNYWxheSBbbXNdXHJcbi8vISBhdXRob3IgOiBXZWxkYW4gSmFtaWxpIDogaHR0cHM6Ly9naXRodWIuY29tL3dlbGRhblxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1zID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXMnLCB7XHJcbiAgICBtb250aHMgOiAnSmFudWFyaV9GZWJydWFyaV9NYWNfQXByaWxfTWVpX0p1bl9KdWxhaV9PZ29zX1NlcHRlbWJlcl9Pa3RvYmVyX05vdmVtYmVyX0Rpc2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYWNfQXByX01laV9KdW5fSnVsX09nc19TZXBfT2t0X05vdl9EaXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdBaGFkX0lzbmluX1NlbGFzYV9SYWJ1X0toYW1pc19KdW1hYXRfU2FidHUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0FoZF9Jc25fU2VsX1JhYl9LaGFfSnVtX1NhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0FoX0lzX1NsX1JiX0ttX0ptX1NiJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEgubW0nLFxyXG4gICAgICAgIExUUyA6ICdISC5tbS5zcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIFtwdWt1bF0gSEgubW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgW3B1a3VsXSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvcGFnaXx0ZW5nYWhhcml8cGV0YW5nfG1hbGFtLyxcclxuICAgIG1lcmlkaWVtSG91cjogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICdwYWdpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAndGVuZ2FoYXJpJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ3BldGFuZycgfHwgbWVyaWRpZW0gPT09ICdtYWxhbScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91cnMgPCAxMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3BhZ2knO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RlbmdhaGFyaSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncGV0YW5nJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ21hbGFtJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbSGFyaSBpbmkgcHVrdWxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tFc29rIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbcHVrdWxdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tLZWxtYXJpbiBwdWt1bF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ2RkZGQgW2xlcGFzIHB1a3VsXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2RhbGFtICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIHlhbmcgbGVwYXMnLFxyXG4gICAgICAgIHMgOiAnYmViZXJhcGEgc2FhdCcsXHJcbiAgICAgICAgbSA6ICdzZW1pbml0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW5pdCcsXHJcbiAgICAgICAgaCA6ICdzZWphbScsXHJcbiAgICAgICAgaGggOiAnJWQgamFtJyxcclxuICAgICAgICBkIDogJ3NlaGFyaScsXHJcbiAgICAgICAgZGQgOiAnJWQgaGFyaScsXHJcbiAgICAgICAgTSA6ICdzZWJ1bGFuJyxcclxuICAgICAgICBNTSA6ICclZCBidWxhbicsXHJcbiAgICAgICAgeSA6ICdzZXRhaHVuJyxcclxuICAgICAgICB5eSA6ICclZCB0YWh1bidcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbXM7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL21zLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQnVybWVzZSBbbXldXHJcbi8vISBhdXRob3IgOiBTcXVhciB0ZWFtLCBteXNxdWFyLmNvbVxyXG4vLyEgYXV0aG9yIDogRGF2aWQgUm9zc2VsbGF0IDogaHR0cHM6Ly9naXRodWIuY29tL2dob2xhZHJcclxuLy8hIGF1dGhvciA6IFRpbiBBdW5nIExpbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS90aGFueWF3emlubWluXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3ltYm9sTWFwID0ge1xyXG4gICAgJzEnOiAn4YGBJyxcclxuICAgICcyJzogJ+GBgicsXHJcbiAgICAnMyc6ICfhgYMnLFxyXG4gICAgJzQnOiAn4YGEJyxcclxuICAgICc1JzogJ+GBhScsXHJcbiAgICAnNic6ICfhgYYnLFxyXG4gICAgJzcnOiAn4YGHJyxcclxuICAgICc4JzogJ+GBiCcsXHJcbiAgICAnOSc6ICfhgYknLFxyXG4gICAgJzAnOiAn4YGAJ1xyXG59O1xyXG52YXIgbnVtYmVyTWFwID0ge1xyXG4gICAgJ+GBgSc6ICcxJyxcclxuICAgICfhgYInOiAnMicsXHJcbiAgICAn4YGDJzogJzMnLFxyXG4gICAgJ+GBhCc6ICc0JyxcclxuICAgICfhgYUnOiAnNScsXHJcbiAgICAn4YGGJzogJzYnLFxyXG4gICAgJ+GBhyc6ICc3JyxcclxuICAgICfhgYgnOiAnOCcsXHJcbiAgICAn4YGJJzogJzknLFxyXG4gICAgJ+GBgCc6ICcwJ1xyXG59O1xyXG5cclxudmFyIG15ID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbXknLCB7XHJcbiAgICBtb250aHM6ICfhgIfhgJThgLrhgJThgJ3hgKvhgJvhgK5f4YCW4YCx4YCW4YCx4YCs4YC64YCd4YCr4YCb4YCuX+GAmeGAkOGAul/hgKfhgJXhgLzhgK5f4YCZ4YCxX+GAh+GAveGAlOGAul/hgIfhgLDhgJzhgK3hgK/hgIThgLpf4YCe4YC84YCC4YCv4YCQ4YC6X+GAheGAgOGAuuGAkOGAhOGAuuGAmOGArF/hgKHhgLHhgKzhgIDhgLrhgJDhgK3hgK/hgJjhgKxf4YCU4YCt4YCv4YCd4YCE4YC64YCY4YCsX+GAkuGAruGAh+GAhOGAuuGAmOGArCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0OiAn4YCH4YCU4YC6X+GAluGAsV/hgJnhgJDhgLpf4YCV4YC84YCuX+GAmeGAsV/hgIfhgL3hgJThgLpf4YCc4YCt4YCv4YCE4YC6X+GAnuGAvF/hgIXhgIDhgLpf4YCh4YCx4YCs4YCA4YC6X+GAlOGAreGAr1/hgJLhgK4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5czogJ+GAkOGAlOGAhOGAuuGAueGAguGAlOGAveGAsV/hgJDhgJThgIThgLrhgLnhgJzhgKxf4YCh4YCE4YC64YC54YCC4YCrX+GAl+GAr+GAkuGAueGAk+GAn+GAsOGAuF/hgIDhgLzhgKzhgJ7hgJXhgJDhgLHhgLhf4YCe4YCx4YCs4YCA4YC84YCsX+GAheGAlOGAsScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICfhgJThgL3hgLFf4YCc4YCsX+GAguGAq1/hgJ/hgLDhgLhf4YCA4YC84YCsX+GAnuGAseGArF/hgJThgLEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ+GAlOGAveGAsV/hgJzhgKxf4YCC4YCrX+GAn+GAsOGAuF/hgIDhgLzhgKxf4YCe4YCx4YCsX+GAlOGAsScuc3BsaXQoJ18nKSxcclxuXHJcbiAgICBsb25nRGF0ZUZvcm1hdDoge1xyXG4gICAgICAgIExUOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUzogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEw6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEw6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1vhgJrhgJThgLEuXSBMVCBb4YCZ4YC+4YCsXScsXHJcbiAgICAgICAgbmV4dERheTogJ1vhgJnhgJThgIDhgLrhgJbhgLzhgJThgLpdIExUIFvhgJnhgL7hgKxdJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgTFQgW+GAmeGAvuGArF0nLFxyXG4gICAgICAgIGxhc3REYXk6ICdb4YCZ4YCU4YCxLuGAgF0gTFQgW+GAmeGAvuGArF0nLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW+GAleGAvOGAruGAuOGAgeGAsuGAt+GAnuGAseGArF0gZGRkZCBMVCBb4YCZ4YC+4YCsXScsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZToge1xyXG4gICAgICAgIGZ1dHVyZTogJ+GAnOGArOGAmeGAiuGAuuGAtyAlcyDhgJnhgL7hgKwnLFxyXG4gICAgICAgIHBhc3Q6ICfhgJzhgL3hgJThgLrhgIHhgLLhgLfhgJ7hgLHhgKwgJXMg4YCAJyxcclxuICAgICAgICBzOiAn4YCF4YCA4YC54YCA4YCU4YC6LuGAoeGAlOGAiuGAuuGAuOGAhOGAmuGAuicsXHJcbiAgICAgICAgbTogJ+GAkOGAheGAuuGAmeGAreGAlOGAheGAuicsXHJcbiAgICAgICAgbW06ICclZCDhgJnhgK3hgJThgIXhgLonLFxyXG4gICAgICAgIGg6ICfhgJDhgIXhgLrhgJThgKzhgJvhgK4nLFxyXG4gICAgICAgIGhoOiAnJWQg4YCU4YCs4YCb4YCuJyxcclxuICAgICAgICBkOiAn4YCQ4YCF4YC64YCb4YCA4YC6JyxcclxuICAgICAgICBkZDogJyVkIOGAm+GAgOGAuicsXHJcbiAgICAgICAgTTogJ+GAkOGAheGAuuGAnCcsXHJcbiAgICAgICAgTU06ICclZCDhgJwnLFxyXG4gICAgICAgIHk6ICfhgJDhgIXhgLrhgJThgL7hgIXhgLonLFxyXG4gICAgICAgIHl5OiAnJWQg4YCU4YC+4YCF4YC6J1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4YGB4YGC4YGD4YGE4YGF4YGG4YGH4YGI4YGJ4YGAXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICB3ZWVrOiB7XHJcbiAgICAgICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3k6IDQgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBteTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbXkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBOb3J3ZWdpYW4gQm9rbcOlbCBbbmJdXHJcbi8vISBhdXRob3JzIDogRXNwZW4gSG92bGFuZHNkYWwgOiBodHRwczovL2dpdGh1Yi5jb20vcmV4eGFyc1xyXG4vLyEgICAgICAgICAgIFNpZ3VyZCBHYXJ0bWFubiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaWd1cmRnYVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG5iID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbmInLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFyc19hcHJpbF9tYWlfanVuaV9qdWxpX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbi5fZmViLl9tYXJzX2FwcmlsX21haV9qdW5pX2p1bGlfYXVnLl9zZXAuX29rdC5fbm92Ll9kZXMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdzw7huZGFnX21hbmRhZ190aXJzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7hyZGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdzw7guX21hLl90aS5fb24uX3RvLl9mci5fbMO4Licuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3PDuF9tYV90aV9vbl90b19mcl9sw7gnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tpIGRhZyBrbC5dIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW2kgbW9yZ2VuIGtsLl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBba2wuXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tpIGfDpXIga2wuXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbZm9ycmlnZV0gZGRkZCBba2wuXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb20gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgc2lkZW4nLFxyXG4gICAgICAgIHMgOiAnbm9lbiBzZWt1bmRlcicsXHJcbiAgICAgICAgbSA6ICdldHQgbWludXR0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dHRlcicsXHJcbiAgICAgICAgaCA6ICdlbiB0aW1lJyxcclxuICAgICAgICBoaCA6ICclZCB0aW1lcicsXHJcbiAgICAgICAgZCA6ICdlbiBkYWcnLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2VyJyxcclxuICAgICAgICBNIDogJ2VuIG3DpW5lZCcsXHJcbiAgICAgICAgTU0gOiAnJWQgbcOlbmVkZXInLFxyXG4gICAgICAgIHkgOiAnZXR0IMOlcicsXHJcbiAgICAgICAgeXkgOiAnJWQgw6VyJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gbmI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL25iLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogTmVwYWxlc2UgW25lXVxyXG4vLyEgYXV0aG9yIDogc3V2YXNoIDogaHR0cHM6Ly9naXRodWIuY29tL3N1dmFzaFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+ClpycsXHJcbiAgICAnMic6ICfgpagnLFxyXG4gICAgJzMnOiAn4KWpJyxcclxuICAgICc0JzogJ+ClqicsXHJcbiAgICAnNSc6ICfgpasnLFxyXG4gICAgJzYnOiAn4KWsJyxcclxuICAgICc3JzogJ+ClrScsXHJcbiAgICAnOCc6ICfgpa4nLFxyXG4gICAgJzknOiAn4KWvJyxcclxuICAgICcwJzogJ+ClpidcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfgpacnOiAnMScsXHJcbiAgICAn4KWoJzogJzInLFxyXG4gICAgJ+ClqSc6ICczJyxcclxuICAgICfgpaonOiAnNCcsXHJcbiAgICAn4KWrJzogJzUnLFxyXG4gICAgJ+ClrCc6ICc2JyxcclxuICAgICfgpa0nOiAnNycsXHJcbiAgICAn4KWuJzogJzgnLFxyXG4gICAgJ+Clryc6ICc5JyxcclxuICAgICfgpaYnOiAnMCdcclxufTtcclxuXHJcbnZhciBuZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25lJywge1xyXG4gICAgbW9udGhzIDogJ+CknOCkqOCkteCksOClgF/gpKvgpYfgpKzgpY3gpLDgpYHgpLXgpLDgpYBf4KSu4KS+4KSw4KWN4KSaX+CkheCkquCljeCksOCkv+Cksl/gpK7gpIhf4KSc4KWB4KSoX+CknOClgeCksuCkvuCkiF/gpIXgpJfgpLfgpY3gpJ9f4KS44KWH4KSq4KWN4KSf4KWH4KSu4KWN4KSs4KSwX+CkheCkleCljeCkn+Cli+CkrOCksF/gpKjgpYvgpK3gpYfgpK7gpY3gpKzgpLBf4KSh4KS/4KS44KWH4KSu4KWN4KSs4KSwJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4KSc4KSoLl/gpKvgpYfgpKzgpY3gpLDgpYEuX+CkruCkvuCksOCljeCkml/gpIXgpKrgpY3gpLDgpL8uX+CkruCkiF/gpJzgpYHgpKhf4KSc4KWB4KSy4KS+4KSILl/gpIXgpJcuX+CkuOClh+CkquCljeCkny5f4KSF4KSV4KWN4KSf4KWLLl/gpKjgpYvgpK3gpYcuX+CkoeCkv+CkuOClhy4nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ+CkhuCkh+CkpOCkrOCkvuCksF/gpLjgpYvgpK7gpKzgpL7gpLBf4KSu4KSZ4KWN4KSX4KSy4KSs4KS+4KSwX+CkrOClgeCkp+CkrOCkvuCksF/gpKzgpL/gpLngpL/gpKzgpL7gpLBf4KS24KWB4KSV4KWN4KSw4KSs4KS+4KSwX+CktuCkqOCkv+CkrOCkvuCksCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4KSG4KSH4KSkLl/gpLjgpYvgpK4uX+CkruCkmeCljeCkl+Cksi5f4KSs4KWB4KSnLl/gpKzgpL/gpLngpL8uX+CktuClgeCkleCljeCksC5f4KS24KSo4KS/Licuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+Ckhi5f4KS44KWLLl/gpK7gpIIuX+CkrOClgS5f4KSs4KS/Ll/gpLbgpYEuX+Ckti4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnQeCkleCliyBoOm1tIOCkrOCknOClhycsXHJcbiAgICAgICAgTFRTIDogJ0HgpJXgpYsgaDptbTpzcyDgpKzgpJzgpYcnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQeCkleCliyBoOm1tIOCkrOCknOClhycsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQeCkleCliyBoOm1tIOCkrOCknOClhydcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Clp+ClqOClqeClquClq+ClrOClreClruClr+Clpl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+CksOCkvuCkpOCkv3zgpKzgpL/gpLngpL7gpKh84KSm4KS/4KSJ4KSB4KS44KWLfOCkuOCkvuCkgeCknS8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CksOCkvuCkpOCkvycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSs4KS/4KS54KS+4KSoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4KSm4KS/4KSJ4KSB4KS44KWLJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CkuOCkvuCkgeCknScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KSw4KS+4KSk4KS/JztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CkrOCkv+CkueCkvuCkqCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTYpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgpKbgpL/gpIngpIHgpLjgpYsnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4KS44KS+4KSB4KSdJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CksOCkvuCkpOCkvyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+CkhuCknF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+CkreCli+CksuCkv10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vgpIbgpIngpIHgpKbgpYtdIGRkZGRbLF0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+CkueCkv+CknOCli10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgpJfgpI/gpJXgpYtdIGRkZGRbLF0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclc+CkruCkvicsXHJcbiAgICAgICAgcGFzdCA6ICclcyDgpIXgpJfgpL7gpKHgpL8nLFxyXG4gICAgICAgIHMgOiAn4KSV4KWH4KS54KWAIOCkleCljeCkt+CkoycsXHJcbiAgICAgICAgbSA6ICfgpI/gpJUg4KSu4KS/4KSo4KWH4KSfJyxcclxuICAgICAgICBtbSA6ICclZCDgpK7gpL/gpKjgpYfgpJ8nLFxyXG4gICAgICAgIGggOiAn4KSP4KSVIOCkmOCko+CljeCkn+CkvicsXHJcbiAgICAgICAgaGggOiAnJWQg4KSY4KSj4KWN4KSf4KS+JyxcclxuICAgICAgICBkIDogJ+Ckj+CklSDgpKbgpL/gpKgnLFxyXG4gICAgICAgIGRkIDogJyVkIOCkpuCkv+CkqCcsXHJcbiAgICAgICAgTSA6ICfgpI/gpJUg4KSu4KS54KS/4KSo4KS+JyxcclxuICAgICAgICBNTSA6ICclZCDgpK7gpLngpL/gpKjgpL4nLFxyXG4gICAgICAgIHkgOiAn4KSP4KSVIOCkrOCksOCljeCktycsXHJcbiAgICAgICAgeXkgOiAnJWQg4KSs4KSw4KWN4KS3J1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBuZTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbmUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBEdXRjaCAoQmVsZ2l1bSkgW25sLWJlXVxyXG4vLyEgYXV0aG9yIDogSm9yaXMgUsO2bGluZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3Jpc3JvbGluZ1xyXG4vLyEgYXV0aG9yIDogSmFjb2IgTWlkZGFnIDogaHR0cHM6Ly9naXRodWIuY29tL21pZGRhZ2pcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHNTaG9ydFdpdGhEb3RzID0gJ2phbi5fZmViLl9tcnQuX2Fwci5fbWVpX2p1bi5fanVsLl9hdWcuX3NlcC5fb2t0Ll9ub3YuX2RlYy4nLnNwbGl0KCdfJyk7XHJcbnZhciBtb250aHNTaG9ydFdpdGhvdXREb3RzID0gJ2phbl9mZWJfbXJ0X2Fwcl9tZWlfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVjJy5zcGxpdCgnXycpO1xyXG5cclxudmFyIG1vbnRoc1BhcnNlID0gWy9eamFuL2ksIC9eZmViL2ksIC9ebWFhcnR8bXJ0Lj8kL2ksIC9eYXByL2ksIC9ebWVpJC9pLCAvXmp1bltpLl0/JC9pLCAvXmp1bFtpLl0/JC9pLCAvXmF1Zy9pLCAvXnNlcC9pLCAvXm9rdC9pLCAvXm5vdi9pLCAvXmRlYy9pXTtcclxudmFyIG1vbnRoc1JlZ2V4ID0gL14oamFudWFyaXxmZWJydWFyaXxtYWFydHxhcHJpbHxtZWl8YXByaWx8anVbbmxdaXxhdWd1c3R1c3xzZXB0ZW1iZXJ8b2t0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcnxqYW5cXC4/fGZlYlxcLj98bXJ0XFwuP3xhcHJcXC4/fGp1W25sXVxcLj98YXVnXFwuP3xzZXBcXC4/fG9rdFxcLj98bm92XFwuP3xkZWNcXC4/KS9pO1xyXG5cclxudmFyIG5sQmUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdubC1iZScsIHtcclxuICAgIG1vbnRocyA6ICdqYW51YXJpX2ZlYnJ1YXJpX21hYXJ0X2FwcmlsX21laV9qdW5pX2p1bGlfYXVndXN0dXNfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6IGZ1bmN0aW9uIChtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHM7XHJcbiAgICAgICAgfSBlbHNlIGlmICgvLU1NTS0vLnRlc3QoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRob3V0RG90c1ttLm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhEb3RzW20ubW9udGgoKV07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBtb250aHNSZWdleDogbW9udGhzUmVnZXgsXHJcbiAgICBtb250aHNTaG9ydFJlZ2V4OiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1N0cmljdFJlZ2V4OiAvXihqYW51YXJpfGZlYnJ1YXJpfG1hYXJ0fG1laXxqdVtubF1pfGFwcmlsfGF1Z3VzdHVzfHNlcHRlbWJlcnxva3RvYmVyfG5vdmVtYmVyfGRlY2VtYmVyKS9pLFxyXG4gICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleDogL14oamFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xtZWl8anVbbmxdXFwuP3xhdWdcXC4/fHNlcFxcLj98b2t0XFwuP3xub3ZcXC4/fGRlY1xcLj8pL2ksXHJcblxyXG4gICAgbW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIGxvbmdNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG4gICAgc2hvcnRNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG5cclxuICAgIHdlZWtkYXlzIDogJ3pvbmRhZ19tYWFuZGFnX2RpbnNkYWdfd29lbnNkYWdfZG9uZGVyZGFnX3ZyaWpkYWdfemF0ZXJkYWcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ3pvLl9tYS5fZGkuX3dvLl9kby5fdnIuX3phLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ3pvX21hX2RpX3dvX2RvX3ZyX3phJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbdmFuZGFhZyBvbV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbbW9yZ2VuIG9tXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtvbV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbZ2lzdGVyZW4gb21dIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1thZmdlbG9wZW5dIGRkZGQgW29tXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb3ZlciAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBnZWxlZGVuJyxcclxuICAgICAgICBzIDogJ2VlbiBwYWFyIHNlY29uZGVuJyxcclxuICAgICAgICBtIDogJ8Opw6luIG1pbnV1dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlbicsXHJcbiAgICAgICAgaCA6ICfDqcOpbiB1dXInLFxyXG4gICAgICAgIGhoIDogJyVkIHV1cicsXHJcbiAgICAgICAgZCA6ICfDqcOpbiBkYWcnLFxyXG4gICAgICAgIGRkIDogJyVkIGRhZ2VuJyxcclxuICAgICAgICBNIDogJ8Opw6luIG1hYW5kJyxcclxuICAgICAgICBNTSA6ICclZCBtYWFuZGVuJyxcclxuICAgICAgICB5IDogJ8Opw6luIGphYXInLFxyXG4gICAgICAgIHl5IDogJyVkIGphYXInXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHN0ZXxkZSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgKChudW1iZXIgPT09IDEgfHwgbnVtYmVyID09PSA4IHx8IG51bWJlciA+PSAyMCkgPyAnc3RlJyA6ICdkZScpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBubEJlO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC1iZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IER1dGNoIFtubF1cclxuLy8hIGF1dGhvciA6IEpvcmlzIFLDtmxpbmcgOiBodHRwczovL2dpdGh1Yi5jb20vam9yaXNyb2xpbmdcclxuLy8hIGF1dGhvciA6IEphY29iIE1pZGRhZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWRkYWdqXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzU2hvcnRXaXRoRG90cyA9ICdqYW4uX2ZlYi5fbXJ0Ll9hcHIuX21laV9qdW4uX2p1bC5fYXVnLl9zZXAuX29rdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU2hvcnRXaXRob3V0RG90cyA9ICdqYW5fZmViX21ydF9hcHJfbWVpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKTtcclxuXHJcbnZhciBtb250aHNQYXJzZSA9IFsvXmphbi9pLCAvXmZlYi9pLCAvXm1hYXJ0fG1ydC4/JC9pLCAvXmFwci9pLCAvXm1laSQvaSwgL15qdW5baS5dPyQvaSwgL15qdWxbaS5dPyQvaSwgL15hdWcvaSwgL15zZXAvaSwgL15va3QvaSwgL15ub3YvaSwgL15kZWMvaV07XHJcbnZhciBtb250aHNSZWdleCA9IC9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8YXByaWx8bWVpfGFwcmlsfGp1W25sXWl8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXJ8amFuXFwuP3xmZWJcXC4/fG1ydFxcLj98YXByXFwuP3xqdVtubF1cXC4/fGF1Z1xcLj98c2VwXFwuP3xva3RcXC4/fG5vdlxcLj98ZGVjXFwuPykvaTtcclxuXHJcbnZhciBubCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ25sJywge1xyXG4gICAgbW9udGhzIDogJ2phbnVhcmlfZmVicnVhcmlfbWFhcnRfYXByaWxfbWVpX2p1bmlfanVsaV9hdWd1c3R1c19zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0sIGZvcm1hdCkge1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9udGhzU2hvcnRXaXRoRG90cztcclxuICAgICAgICB9IGVsc2UgaWYgKC8tTU1NLS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTaG9ydFdpdGhvdXREb3RzW20ubW9udGgoKV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoc1Nob3J0V2l0aERvdHNbbS5tb250aCgpXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1vbnRoc1JlZ2V4OiBtb250aHNSZWdleCxcclxuICAgIG1vbnRoc1Nob3J0UmVnZXg6IG1vbnRoc1JlZ2V4LFxyXG4gICAgbW9udGhzU3RyaWN0UmVnZXg6IC9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8bWVpfGp1W25sXWl8YXByaWx8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2ksXHJcbiAgICBtb250aHNTaG9ydFN0cmljdFJlZ2V4OiAvXihqYW5cXC4/fGZlYlxcLj98bXJ0XFwuP3xhcHJcXC4/fG1laXxqdVtubF1cXC4/fGF1Z1xcLj98c2VwXFwuP3xva3RcXC4/fG5vdlxcLj98ZGVjXFwuPykvaSxcclxuXHJcbiAgICBtb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG4gICAgbG9uZ01vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXHJcbiAgICBzaG9ydE1vbnRoc1BhcnNlIDogbW9udGhzUGFyc2UsXHJcblxyXG4gICAgd2Vla2RheXMgOiAnem9uZGFnX21hYW5kYWdfZGluc2RhZ193b2Vuc2RhZ19kb25kZXJkYWdfdnJpamRhZ196YXRlcmRhZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnem8uX21hLl9kaS5fd28uX2RvLl92ci5femEuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnem9fbWFfZGlfd29fZG9fdnJfemEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC1NTS1ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1t2YW5kYWFnIG9tXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1ttb3JnZW4gb21dIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW29tXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tnaXN0ZXJlbiBvbV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW2FmZ2Vsb3Blbl0gZGRkZCBbb21dIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdvdmVyICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGdlbGVkZW4nLFxyXG4gICAgICAgIHMgOiAnZWVuIHBhYXIgc2Vjb25kZW4nLFxyXG4gICAgICAgIG0gOiAnw6nDqW4gbWludXV0JyxcclxuICAgICAgICBtbSA6ICclZCBtaW51dGVuJyxcclxuICAgICAgICBoIDogJ8Opw6luIHV1cicsXHJcbiAgICAgICAgaGggOiAnJWQgdXVyJyxcclxuICAgICAgICBkIDogJ8Opw6luIGRhZycsXHJcbiAgICAgICAgZGQgOiAnJWQgZGFnZW4nLFxyXG4gICAgICAgIE0gOiAnw6nDqW4gbWFhbmQnLFxyXG4gICAgICAgIE1NIDogJyVkIG1hYW5kZW4nLFxyXG4gICAgICAgIHkgOiAnw6nDqW4gamFhcicsXHJcbiAgICAgICAgeXkgOiAnJWQgamFhcidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3RlfGRlKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAoKG51bWJlciA9PT0gMSB8fCBudW1iZXIgPT09IDggfHwgbnVtYmVyID49IDIwKSA/ICdzdGUnIDogJ2RlJyk7XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIG5sO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ubC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IE55bm9yc2sgW25uXVxyXG4vLyEgYXV0aG9yIDogaHR0cHM6Ly9naXRodWIuY29tL21lY2h1d2luZFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG5uID0gbW9tZW50LmRlZmluZUxvY2FsZSgnbm4nLCB7XHJcbiAgICBtb250aHMgOiAnamFudWFyX2ZlYnJ1YXJfbWFyc19hcHJpbF9tYWlfanVuaV9qdWxpX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZXNlbWJlcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phbl9mZWJfbWFyX2Fwcl9tYWlfanVuX2p1bF9hdWdfc2VwX29rdF9ub3ZfZGVzJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnc3VuZGFnX23DpW5kYWdfdHlzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sYXVyZGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdzdW5fbcOlbl90eXNfb25zX3Rvcl9mcmVfbGF1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnc3VfbcOlX3R5X29uX3RvX2ZyX2zDuCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRC4gTU1NTSBZWVlZIFtrbC5dIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCBELiBNTU1NIFlZWVkgW2tsLl0gSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tJIGRhZyBrbG9ra2FdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW0kgbW9yZ29uIGtsb2trYV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBba2xva2thXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tJIGfDpXIga2xva2thXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdbRsO4cmVnw6VhbmRlXSBkZGRkIFtrbG9ra2FdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdvbSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBzaWRhbicsXHJcbiAgICAgICAgcyA6ICdub2tyZSBzZWt1bmQnLFxyXG4gICAgICAgIG0gOiAnZWl0IG1pbnV0dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXR0JyxcclxuICAgICAgICBoIDogJ2VpbiB0aW1lJyxcclxuICAgICAgICBoaCA6ICclZCB0aW1hcicsXHJcbiAgICAgICAgZCA6ICdlaW4gZGFnJyxcclxuICAgICAgICBkZCA6ICclZCBkYWdhcicsXHJcbiAgICAgICAgTSA6ICdlaW4gbcOlbmFkJyxcclxuICAgICAgICBNTSA6ICclZCBtw6VuYWRlcicsXHJcbiAgICAgICAgeSA6ICdlaXQgw6VyJyxcclxuICAgICAgICB5eSA6ICclZCDDpXInXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBubjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbm4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvbm4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBQdW5qYWJpIChJbmRpYSkgW3BhLWluXVxyXG4vLyEgYXV0aG9yIDogSGFycHJlZXQgU2luZ2ggOiBodHRwczovL2dpdGh1Yi5jb20vaGFycHJlZXRraGFsc2FndGJpdFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHN5bWJvbE1hcCA9IHtcclxuICAgICcxJzogJ+CppycsXHJcbiAgICAnMic6ICfgqagnLFxyXG4gICAgJzMnOiAn4KmpJyxcclxuICAgICc0JzogJ+CpqicsXHJcbiAgICAnNSc6ICfgqasnLFxyXG4gICAgJzYnOiAn4KmsJyxcclxuICAgICc3JzogJ+CprScsXHJcbiAgICAnOCc6ICfgqa4nLFxyXG4gICAgJzknOiAn4KmvJyxcclxuICAgICcwJzogJ+CppidcclxufTtcclxudmFyIG51bWJlck1hcCA9IHtcclxuICAgICfgqacnOiAnMScsXHJcbiAgICAn4KmoJzogJzInLFxyXG4gICAgJ+CpqSc6ICczJyxcclxuICAgICfgqaonOiAnNCcsXHJcbiAgICAn4KmrJzogJzUnLFxyXG4gICAgJ+CprCc6ICc2JyxcclxuICAgICfgqa0nOiAnNycsXHJcbiAgICAn4KmuJzogJzgnLFxyXG4gICAgJ+Cpryc6ICc5JyxcclxuICAgICfgqaYnOiAnMCdcclxufTtcclxuXHJcbnZhciBwYUluID0gbW9tZW50LmRlZmluZUxvY2FsZSgncGEtaW4nLCB7XHJcbiAgICAvLyBUaGVyZSBhcmUgbW9udGhzIG5hbWUgYXMgcGVyIE5hbmFrc2hhaGkgQ2FsZW5kZXIgYnV0IHRoZXkgYXJlIG5vdCB1c2VkIGFzIHJpZ2lkbHkgaW4gbW9kZXJuIFB1bmphYmkuXHJcbiAgICBtb250aHMgOiAn4Kic4Kio4Ki14Kiw4KmAX+Coq+CovOCosOCoteCosOCpgF/gqK7gqL7gqLDgqJpf4KiF4Kiq4KmN4Kiw4KmI4KiyX+CoruCoiF/gqJzgqYLgqKhf4Kic4KmB4Kiy4Ki+4KiIX+CoheCol+CouOCopF/gqLjgqKTgqbDgqKzgqLBf4KiF4KiV4Kik4KmC4Kis4KiwX+CoqOCoteCpsOCorOCosF/gqKbgqLjgqbDgqKzgqLAnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfgqJzgqKjgqLXgqLDgqYBf4Kir4Ki84Kiw4Ki14Kiw4KmAX+CoruCovuCosOComl/gqIXgqKrgqY3gqLDgqYjgqLJf4Kiu4KiIX+ConOCpguCoqF/gqJzgqYHgqLLgqL7gqIhf4KiF4KiX4Ki44KikX+CouOCopOCpsOCorOCosF/gqIXgqJXgqKTgqYLgqKzgqLBf4Kio4Ki14Kmw4Kis4KiwX+CopuCouOCpsOCorOCosCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ+CokOCopOCoteCovuCosF/gqLjgqYvgqK7gqLXgqL7gqLBf4Kiu4Kmw4KiX4Kiy4Ki14Ki+4KiwX+CorOCpgeCop+CoteCovuCosF/gqLXgqYDgqLDgqLXgqL7gqLBf4Ki44Ki84KmB4Kmx4KiV4Kiw4Ki14Ki+4KiwX+CouOCovOCoqOCpgOComuCosOCoteCovuCosCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4KiQ4KikX+CouOCpi+Corl/gqK7gqbDgqJfgqLJf4Kis4KmB4KinX+CoteCpgOCosF/gqLjgqLzgqYHgqJXgqLBf4Ki44Ki84Kio4KmAJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn4KiQ4KikX+CouOCpi+Corl/gqK7gqbDgqJfgqLJf4Kis4KmB4KinX+CoteCpgOCosF/gqLjgqLzgqYHgqJXgqLBf4Ki44Ki84Kio4KmAJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnQSBoOm1tIOCoteConOCphycsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcyDgqLXgqJzgqYcnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSwgQSBoOm1tIOCoteConOCphycsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSwgQSBoOm1tIOCoteConOCphydcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgqIXgqJxdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgqJXgqLJdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4KiV4KiyXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+CoquCov+Com+CosuCph10gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDgqLXgqL/gqbHgqJonLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4Kiq4Ki/4Kib4Kiy4KmHJyxcclxuICAgICAgICBzIDogJ+ColeCpgeConSDgqLjgqJXgqL/gqbDgqJ8nLFxyXG4gICAgICAgIG0gOiAn4KiH4KiVIOCoruCov+CpsOConycsXHJcbiAgICAgICAgbW0gOiAnJWQg4Kiu4Ki/4Kmw4KifJyxcclxuICAgICAgICBoIDogJ+Coh+CpseColSDgqJjgqbDgqJ/gqL4nLFxyXG4gICAgICAgIGhoIDogJyVkIOComOCpsOCon+CphycsXHJcbiAgICAgICAgZCA6ICfgqIfgqbHgqJUg4Kim4Ki/4KioJyxcclxuICAgICAgICBkZCA6ICclZCDgqKbgqL/gqKgnLFxyXG4gICAgICAgIE0gOiAn4KiH4Kmx4KiVIOCoruCoueCpgOCoqOCovicsXHJcbiAgICAgICAgTU0gOiAnJWQg4Kiu4Ki54KmA4Kio4KmHJyxcclxuICAgICAgICB5IDogJ+Coh+CpseColSDgqLjgqL7gqLInLFxyXG4gICAgICAgIHl5IDogJyVkIOCouOCovuCosidcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW+Cpp+CpqOCpqeCpquCpq+CprOCpreCpruCpr+Cppl0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJNYXBbbWF0Y2hdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIHBvc3Rmb3JtYXQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcZC9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbE1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gUHVuamFiaSBub3RhdGlvbiBmb3IgbWVyaWRpZW1zIGFyZSBxdWl0ZSBmdXp6eSBpbiBwcmFjdGljZS4gV2hpbGUgdGhlcmUgZXhpc3RzXHJcbiAgICAvLyBhIHJpZ2lkIG5vdGlvbiBvZiBhICdQYWhhcicgaXQgaXMgbm90IHVzZWQgYXMgcmlnaWRseSBpbiBtb2Rlcm4gUHVuamFiaS5cclxuICAgIG1lcmlkaWVtUGFyc2U6IC/gqLDgqL7gqKR84Ki44Ki14KmH4KiwfOCopuCpgeCoquCoueCov+CosHzgqLjgqLzgqL7gqK4vLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICfgqLDgqL7gqKQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyIDwgNCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CouOCoteCph+CosCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CopuCpgeCoquCoueCov+CosCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfgqLjgqLzgqL7gqK4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CosOCovuCopCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqLjgqLXgqYfgqLAnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4Kim4KmB4Kiq4Ki54Ki/4KiwJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CouOCovOCovuCoric7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgqLDgqL7gqKQnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gcGFJbjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGEtaW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGEtaW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBQb2xpc2ggW3BsXVxyXG4vLyEgYXV0aG9yIDogUmFmYWwgSGlyc3ogOiBodHRwczovL2dpdGh1Yi5jb20vZXZvTFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIG1vbnRoc05vbWluYXRpdmUgPSAnc3R5Y3plxYRfbHV0eV9tYXJ6ZWNfa3dpZWNpZcWEX21hal9jemVyd2llY19saXBpZWNfc2llcnBpZcWEX3dyemVzaWXFhF9wYcW6ZHppZXJuaWtfbGlzdG9wYWRfZ3J1ZHppZcWEJy5zcGxpdCgnXycpO1xyXG52YXIgbW9udGhzU3ViamVjdGl2ZSA9ICdzdHljem5pYV9sdXRlZ29fbWFyY2Ffa3dpZXRuaWFfbWFqYV9jemVyd2NhX2xpcGNhX3NpZXJwbmlhX3dyemXFm25pYV9wYcW6ZHppZXJuaWthX2xpc3RvcGFkYV9ncnVkbmlhJy5zcGxpdCgnXycpO1xyXG5mdW5jdGlvbiBwbHVyYWwobikge1xyXG4gICAgcmV0dXJuIChuICUgMTAgPCA1KSAmJiAobiAlIDEwID4gMSkgJiYgKCh+fihuIC8gMTApICUgMTApICE9PSAxKTtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2xhdGUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdtaW51dGEnIDogJ21pbnV0xJknO1xyXG4gICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdtaW51dHknIDogJ21pbnV0Jyk7XHJcbiAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ICA/ICdnb2R6aW5hJyAgOiAnZ29kemluxJknO1xyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdnb2R6aW55JyA6ICdnb2R6aW4nKTtcclxuICAgICAgICBjYXNlICdNTSc6XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbWllc2nEhWNlJyA6ICdtaWVzacSZY3knKTtcclxuICAgICAgICBjYXNlICd5eSc6XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbGF0YScgOiAnbGF0Jyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBwbCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3BsJywge1xyXG4gICAgbW9udGhzIDogZnVuY3Rpb24gKG1vbWVudFRvRm9ybWF0LCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW1vbWVudFRvRm9ybWF0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNOb21pbmF0aXZlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnJykge1xyXG4gICAgICAgICAgICAvLyBIYWNrOiBpZiBmb3JtYXQgZW1wdHkgd2Uga25vdyB0aGlzIGlzIHVzZWQgdG8gZ2VuZXJhdGVcclxuICAgICAgICAgICAgLy8gUmVnRXhwIGJ5IG1vbWVudC4gR2l2ZSB0aGVuIGJhY2sgYm90aCB2YWxpZCBmb3JtcyBvZiBtb250aHNcclxuICAgICAgICAgICAgLy8gaW4gUmVnRXhwIHJlYWR5IGZvcm1hdC5cclxuICAgICAgICAgICAgcmV0dXJuICcoJyArIG1vbnRoc1N1YmplY3RpdmVbbW9tZW50VG9Gb3JtYXQubW9udGgoKV0gKyAnfCcgKyBtb250aHNOb21pbmF0aXZlW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldICsgJyknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoL0QgTU1NTS8udGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNTdWJqZWN0aXZlW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb250aHNOb21pbmF0aXZlW21vbWVudFRvRm9ybWF0Lm1vbnRoKCldO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6ICdzdHlfbHV0X21hcl9rd2lfbWFqX2N6ZV9saXBfc2llX3dyel9wYcW6X2xpc19ncnUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICduaWVkemllbGFfcG9uaWVkemlhxYJla193dG9yZWtfxZtyb2RhX2N6d2FydGVrX3BpxIV0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICduZHpfcG9uX3d0X8Wbcl9jendfcHRfc29iJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnTmRfUG5fV3RfxZpyX0N6X1B0X1NvJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbRHppxZsgb10gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbSnV0cm8gb10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgbmllZHppZWzEmSBvXSBMVCc7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1dlIHd0b3JlayBvXSBMVCc7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgxZtyb2TEmSBvXSBMVCc7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgc29ib3TEmSBvXSBMVCc7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXXSBkZGRkIFtvXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXk6ICdbV2N6b3JhaiBvXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbVyB6ZXN6xYLEhSBuaWVkemllbMSZIG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tXIHplc3rFgsSFIMWbcm9kxJkgb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgemVzesWCxIUgc29ib3TEmSBvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW1cgemVzesWCeV0gZGRkZCBbb10gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICd6YSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyB0ZW11JyxcclxuICAgICAgICBzIDogJ2tpbGthIHNla3VuZCcsXHJcbiAgICAgICAgbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGhoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGQgOiAnMSBkemllxYQnLFxyXG4gICAgICAgIGRkIDogJyVkIGRuaScsXHJcbiAgICAgICAgTSA6ICdtaWVzacSFYycsXHJcbiAgICAgICAgTU0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeSA6ICdyb2snLFxyXG4gICAgICAgIHl5IDogdHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBwbDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcGwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBQb3J0dWd1ZXNlIChCcmF6aWwpIFtwdC1icl1cclxuLy8hIGF1dGhvciA6IENhaW8gUmliZWlybyBQZXJlaXJhIDogaHR0cHM6Ly9naXRodWIuY29tL2NhaW8tcmliZWlyby1wZXJlaXJhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgcHRCciA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3B0LWJyJywge1xyXG4gICAgbW9udGhzIDogJ2phbmVpcm9fZmV2ZXJlaXJvX21hcsOnb19hYnJpbF9tYWlvX2p1bmhvX2p1bGhvX2Fnb3N0b19zZXRlbWJyb19vdXR1YnJvX25vdmVtYnJvX2RlemVtYnJvJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2Zldl9tYXJfYWJyX21haV9qdW5fanVsX2Fnb19zZXRfb3V0X25vdl9kZXonLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdEb21pbmdvX1NlZ3VuZGEtZmVpcmFfVGVyw6dhLWZlaXJhX1F1YXJ0YS1mZWlyYV9RdWludGEtZmVpcmFfU2V4dGEtZmVpcmFfU8OhYmFkbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnRG9tX1NlZ19UZXJfUXVhX1F1aV9TZXhfU8OhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0RvXzLCql8zwqpfNMKqXzXCql82wqpfU8OhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBbZGVdIE1NTU0gW2RlXSBZWVlZIFvDoHNdIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBbw6BzXSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0hvamUgw6BzXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tBbWFuaMOjIMOgc10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbw6BzXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tPbnRlbSDDoHNdIExUJyxcclxuICAgICAgICBsYXN0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZGF5KCkgPT09IDAgfHwgdGhpcy5kYXkoKSA9PT0gNikgP1xyXG4gICAgICAgICAgICAgICAgJ1vDmmx0aW1vXSBkZGRkIFvDoHNdIExUJyA6IC8vIFNhdHVyZGF5ICsgU3VuZGF5XHJcbiAgICAgICAgICAgICAgICAnW8OabHRpbWFdIGRkZGQgW8Ogc10gTFQnOyAvLyBNb25kYXkgLSBGcmlkYXlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ2VtICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIGF0csOhcycsXHJcbiAgICAgICAgcyA6ICdwb3Vjb3Mgc2VndW5kb3MnLFxyXG4gICAgICAgIHNzIDogJyVkIHNlZ3VuZG9zJyxcclxuICAgICAgICBtIDogJ3VtIG1pbnV0bycsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRvcycsXHJcbiAgICAgICAgaCA6ICd1bWEgaG9yYScsXHJcbiAgICAgICAgaGggOiAnJWQgaG9yYXMnLFxyXG4gICAgICAgIGQgOiAndW0gZGlhJyxcclxuICAgICAgICBkZCA6ICclZCBkaWFzJyxcclxuICAgICAgICBNIDogJ3VtIG3DqnMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2VzJyxcclxuICAgICAgICB5IDogJ3VtIGFubycsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5vcydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn3Cui8sXHJcbiAgICBvcmRpbmFsIDogJyVkwronXHJcbn0pO1xyXG5cclxucmV0dXJuIHB0QnI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3B0LWJyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogUG9ydHVndWVzZSBbcHRdXHJcbi8vISBhdXRob3IgOiBKZWZmZXJzb24gOiBodHRwczovL2dpdGh1Yi5jb20vamFsZXg3OVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHB0ID0gbW9tZW50LmRlZmluZUxvY2FsZSgncHQnLCB7XHJcbiAgICBtb250aHMgOiAnamFuZWlyb19mZXZlcmVpcm9fbWFyw6dvX2FicmlsX21haW9fanVuaG9fanVsaG9fYWdvc3RvX3NldGVtYnJvX291dHVicm9fbm92ZW1icm9fZGV6ZW1icm8nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW5fZmV2X21hcl9hYnJfbWFpX2p1bl9qdWxfYWdvX3NldF9vdXRfbm92X2Rleicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ0RvbWluZ29fU2VndW5kYS1mZWlyYV9UZXLDp2EtZmVpcmFfUXVhcnRhLWZlaXJhX1F1aW50YS1mZWlyYV9TZXh0YS1mZWlyYV9Tw6FiYWRvJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdEb21fU2VnX1Rlcl9RdWFfUXVpX1NleF9Tw6FiJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnRG9fMsKqXzPCql80wqpfNcKqXzbCql9Tw6EnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIFtkZV0gTU1NTSBbZGVdIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbSG9qZSDDoHNdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW0FtYW5ow6Mgw6BzXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFvDoHNdIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW09udGVtIMOgc10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5kYXkoKSA9PT0gMCB8fCB0aGlzLmRheSgpID09PSA2KSA/XHJcbiAgICAgICAgICAgICAgICAnW8OabHRpbW9dIGRkZGQgW8Ogc10gTFQnIDogLy8gU2F0dXJkYXkgKyBTdW5kYXlcclxuICAgICAgICAgICAgICAgICdbw5psdGltYV0gZGRkZCBbw6BzXSBMVCc7IC8vIE1vbmRheSAtIEZyaWRheVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnZW0gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnaMOhICVzJyxcclxuICAgICAgICBzIDogJ3NlZ3VuZG9zJyxcclxuICAgICAgICBtIDogJ3VtIG1pbnV0bycsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRvcycsXHJcbiAgICAgICAgaCA6ICd1bWEgaG9yYScsXHJcbiAgICAgICAgaGggOiAnJWQgaG9yYXMnLFxyXG4gICAgICAgIGQgOiAndW0gZGlhJyxcclxuICAgICAgICBkZCA6ICclZCBkaWFzJyxcclxuICAgICAgICBNIDogJ3VtIG3DqnMnLFxyXG4gICAgICAgIE1NIDogJyVkIG1lc2VzJyxcclxuICAgICAgICB5IDogJ3VtIGFubycsXHJcbiAgICAgICAgeXkgOiAnJWQgYW5vcydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn3Cui8sXHJcbiAgICBvcmRpbmFsIDogJyVkwronLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHB0O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9wdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFJvbWFuaWFuIFtyb11cclxuLy8hIGF1dGhvciA6IFZsYWQgR3VyZGlnYSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9ndXJkaWdhXHJcbi8vISBhdXRob3IgOiBWYWxlbnRpbiBBZ2FjaGkgOiBodHRwczovL2dpdGh1Yi5jb20vYXZhbHlcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgICAgICdtbSc6ICdtaW51dGUnLFxyXG4gICAgICAgICAgICAnaGgnOiAnb3JlJyxcclxuICAgICAgICAgICAgJ2RkJzogJ3ppbGUnLFxyXG4gICAgICAgICAgICAnTU0nOiAnbHVuaScsXHJcbiAgICAgICAgICAgICd5eSc6ICdhbmknXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXBhcmF0b3IgPSAnICc7XHJcbiAgICBpZiAobnVtYmVyICUgMTAwID49IDIwIHx8IChudW1iZXIgPj0gMTAwICYmIG51bWJlciAlIDEwMCA9PT0gMCkpIHtcclxuICAgICAgICBzZXBhcmF0b3IgPSAnIGRlICc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtYmVyICsgc2VwYXJhdG9yICsgZm9ybWF0W2tleV07XHJcbn1cclxuXHJcbnZhciBybyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3JvJywge1xyXG4gICAgbW9udGhzIDogJ2lhbnVhcmllX2ZlYnJ1YXJpZV9tYXJ0aWVfYXByaWxpZV9tYWlfaXVuaWVfaXVsaWVfYXVndXN0X3NlcHRlbWJyaWVfb2N0b21icmllX25vaWVtYnJpZV9kZWNlbWJyaWUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdpYW4uX2ZlYnIuX21hcnQuX2Fwci5fbWFpX2l1bi5faXVsLl9hdWcuX3NlcHQuX29jdC5fbm92Ll9kZWMuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2R1bWluaWPEg19sdW5pX21hcsibaV9taWVyY3VyaV9qb2lfdmluZXJpX3PDom1ixIN0xIMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0R1bV9MdW5fTWFyX01pZV9Kb2lfVmluX1PDom0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdEdV9MdV9NYV9NaV9Kb19WaV9Tw6InLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW2F6aSBsYV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbbcOiaW5lIGxhXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFtsYV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbaWVyaSBsYV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrOiAnW2Zvc3RhXSBkZGRkIFtsYV0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3Blc3RlICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIMOubiB1cm3EgycsXHJcbiAgICAgICAgcyA6ICdjw6J0ZXZhIHNlY3VuZGUnLFxyXG4gICAgICAgIG0gOiAndW4gbWludXQnLFxyXG4gICAgICAgIG1tIDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbCxcclxuICAgICAgICBoIDogJ28gb3LEgycsXHJcbiAgICAgICAgaGggOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGQgOiAnbyB6aScsXHJcbiAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIE0gOiAnbyBsdW7EgycsXHJcbiAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIHkgOiAndW4gYW4nLFxyXG4gICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBybztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcm8uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvcm8uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBSdXNzaWFuIFtydV1cclxuLy8hIGF1dGhvciA6IFZpa3Rvcm1pbmF0b3IgOiBodHRwczovL2dpdGh1Yi5jb20vVmlrdG9ybWluYXRvclxyXG4vLyEgQXV0aG9yIDogTWVuZWxpb24gRWxlbnPDumxlIDogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcclxuLy8hIGF1dGhvciA6INCa0L7RgNC10L3QsdC10YDQsyDQnNCw0YDQuiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRwYWlyXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5mdW5jdGlvbiBwbHVyYWwod29yZCwgbnVtKSB7XHJcbiAgICB2YXIgZm9ybXMgPSB3b3JkLnNwbGl0KCdfJyk7XHJcbiAgICByZXR1cm4gbnVtICUgMTAgPT09IDEgJiYgbnVtICUgMTAwICE9PSAxMSA/IGZvcm1zWzBdIDogKG51bSAlIDEwID49IDIgJiYgbnVtICUgMTAgPD0gNCAmJiAobnVtICUgMTAwIDwgMTAgfHwgbnVtICUgMTAwID49IDIwKSA/IGZvcm1zWzFdIDogZm9ybXNbMl0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZVdpdGhQbHVyYWwobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ21tJzogd2l0aG91dFN1ZmZpeCA/ICfQvNC40L3Rg9GC0LBf0LzQuNC90YPRgtGLX9C80LjQvdGD0YInIDogJ9C80LjQvdGD0YLRg1/QvNC40L3Rg9GC0Ytf0LzQuNC90YPRgicsXHJcbiAgICAgICAgJ2hoJzogJ9GH0LDRgV/Rh9Cw0YHQsF/Rh9Cw0YHQvtCyJyxcclxuICAgICAgICAnZGQnOiAn0LTQtdC90Yxf0LTQvdGPX9C00L3QtdC5JyxcclxuICAgICAgICAnTU0nOiAn0LzQtdGB0Y/Rhl/QvNC10YHRj9GG0LBf0LzQtdGB0Y/RhtC10LInLFxyXG4gICAgICAgICd5eSc6ICfQs9C+0LRf0LPQvtC00LBf0LvQtdGCJ1xyXG4gICAgfTtcclxuICAgIGlmIChrZXkgPT09ICdtJykge1xyXG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9C80LjQvdGD0YLQsCcgOiAn0LzQuNC90YPRgtGDJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBwbHVyYWwoZm9ybWF0W2tleV0sICtudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcbnZhciBtb250aHNQYXJzZSA9IFsvXtGP0L3Qsi9pLCAvXtGE0LXQsi9pLCAvXtC80LDRgC9pLCAvXtCw0L/RgC9pLCAvXtC80LBb0LnRj10vaSwgL17QuNGO0L0vaSwgL17QuNGO0LsvaSwgL17QsNCy0LMvaSwgL17RgdC10L0vaSwgL17QvtC60YIvaSwgL17QvdC+0Y8vaSwgL17QtNC10LovaV07XHJcblxyXG4vLyBodHRwOi8vbmV3LmdyYW1vdGEucnUvc3ByYXZrYS9ydWxlcy8xMzktcHJvcCA6IMKnIDEwM1xyXG4vLyDQodC+0LrRgNCw0YnQtdC90LjRjyDQvNC10YHRj9GG0LXQsjogaHR0cDovL25ldy5ncmFtb3RhLnJ1L3NwcmF2a2EvYnVyby9zZWFyY2gtYW5zd2VyP3M9MjQyNjM3XHJcbi8vIENMRFIgZGF0YTogICAgICAgICAgaHR0cDovL3d3dy51bmljb2RlLm9yZy9jbGRyL2NoYXJ0cy8yOC9zdW1tYXJ5L3J1Lmh0bWwjMTc1M1xyXG52YXIgcnUgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdydScsIHtcclxuICAgIG1vbnRocyA6IHtcclxuICAgICAgICBmb3JtYXQ6ICfRj9C90LLQsNGA0Y9f0YTQtdCy0YDQsNC70Y9f0LzQsNGA0YLQsF/QsNC/0YDQtdC70Y9f0LzQsNGPX9C40Y7QvdGPX9C40Y7Qu9GPX9Cw0LLQs9GD0YHRgtCwX9GB0LXQvdGC0Y/QsdGA0Y9f0L7QutGC0Y/QsdGA0Y9f0L3QvtGP0LHRgNGPX9C00LXQutCw0LHRgNGPJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHN0YW5kYWxvbmU6ICfRj9C90LLQsNGA0Yxf0YTQtdCy0YDQsNC70Yxf0LzQsNGA0YJf0LDQv9GA0LXQu9GMX9C80LDQuV/QuNGO0L3RjF/QuNGO0LvRjF/QsNCy0LPRg9GB0YJf0YHQtdC90YLRj9Cx0YDRjF/QvtC60YLRj9Cx0YDRjF/QvdC+0Y/QsdGA0Yxf0LTQtdC60LDQsdGA0YwnLnNwbGl0KCdfJylcclxuICAgIH0sXHJcbiAgICBtb250aHNTaG9ydCA6IHtcclxuICAgICAgICAvLyDQv9C+IENMRFIg0LjQvNC10L3QvdC+IFwi0LjRjtC7LlwiINC4IFwi0LjRjtC9LlwiLCDQvdC+INC60LDQutC+0Lkg0YHQvNGL0YHQuyDQvNC10L3Rj9GC0Ywg0LHRg9C60LLRgyDQvdCwINGC0L7Rh9C60YMgP1xyXG4gICAgICAgIGZvcm1hdDogJ9GP0L3Qsi5f0YTQtdCy0YAuX9C80LDRgC5f0LDQv9GALl/QvNCw0Y9f0LjRjtC90Y9f0LjRjtC70Y9f0LDQstCzLl/RgdC10L3Rgi5f0L7QutGCLl/QvdC+0Y/QsS5f0LTQtdC6Licuc3BsaXQoJ18nKSxcclxuICAgICAgICBzdGFuZGFsb25lOiAn0Y/QvdCyLl/RhNC10LLRgC5f0LzQsNGA0YJf0LDQv9GALl/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCzLl/RgdC10L3Rgi5f0L7QutGCLl/QvdC+0Y/QsS5f0LTQtdC6Licuc3BsaXQoJ18nKVxyXG4gICAgfSxcclxuICAgIHdlZWtkYXlzIDoge1xyXG4gICAgICAgIHN0YW5kYWxvbmU6ICfQstC+0YHQutGA0LXRgdC10L3RjNC1X9C/0L7QvdC10LTQtdC70YzQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTQsF/Rh9C10YLQstC10YDQs1/Qv9GP0YLQvdC40YbQsF/RgdGD0LHQsdC+0YLQsCcuc3BsaXQoJ18nKSxcclxuICAgICAgICBmb3JtYXQ6ICfQstC+0YHQutGA0LXRgdC10L3RjNC1X9C/0L7QvdC10LTQtdC70YzQvdC40Lpf0LLRgtC+0YDQvdC40Lpf0YHRgNC10LTRg1/Rh9C10YLQstC10YDQs1/Qv9GP0YLQvdC40YbRg1/RgdGD0LHQsdC+0YLRgycuc3BsaXQoJ18nKSxcclxuICAgICAgICBpc0Zvcm1hdDogL1xcWyA/W9CS0LJdID8oPzrQv9GA0L7RiNC70YPRjnzRgdC70LXQtNGD0Y7RidGD0Y580Y3RgtGDKT8gP1xcXSA/ZGRkZC9cclxuICAgIH0sXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9Cy0YFf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQstGBX9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2UgOiBtb250aHNQYXJzZSxcclxuICAgIGxvbmdNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG4gICAgc2hvcnRNb250aHNQYXJzZSA6IG1vbnRoc1BhcnNlLFxyXG5cclxuICAgIC8vINC/0L7Qu9C90YvQtSDQvdCw0LfQstCw0L3QuNGPINGBINC/0LDQtNC10LbQsNC80LgsINC/0L4g0YLRgNC4INCx0YPQutCy0YssINC00LvRjyDQvdC10LrQvtGC0L7RgNGL0YUsINC/0L4gNCDQsdGD0LrQstGLLCDRgdC+0LrRgNCw0YnQtdC90LjRjyDRgSDRgtC+0YfQutC+0Lkg0Lgg0LHQtdC3INGC0L7Rh9C60LhcclxuICAgIG1vbnRoc1JlZ2V4OiAvXijRj9C90LLQsNGAW9GM0Y9dfNGP0L3QslxcLj980YTQtdCy0YDQsNC7W9GM0Y9dfNGE0LXQstGAP1xcLj980LzQsNGA0YLQsD980LzQsNGAXFwuP3zQsNC/0YDQtdC7W9GM0Y9dfNCw0L/RgFxcLj980LzQsFvQudGPXXzQuNGO0L1b0YzRj1180LjRjtC9XFwuP3zQuNGO0Ltb0YzRj1180LjRjtC7XFwuP3zQsNCy0LPRg9GB0YLQsD980LDQstCzXFwuP3zRgdC10L3RgtGP0LHRgFvRjNGPXXzRgdC10L3Rgj9cXC4/fNC+0LrRgtGP0LHRgFvRjNGPXXzQvtC60YJcXC4/fNC90L7Rj9Cx0YBb0YzRj1180L3QvtGP0LE/XFwuP3zQtNC10LrQsNCx0YBb0YzRj1180LTQtdC6XFwuPykvaSxcclxuXHJcbiAgICAvLyDQutC+0L/QuNGPINC/0YDQtdC00YvQtNGD0YnQtdCz0L5cclxuICAgIG1vbnRoc1Nob3J0UmVnZXg6IC9eKNGP0L3QstCw0YBb0YzRj1180Y/QvdCyXFwuP3zRhNC10LLRgNCw0Ltb0YzRj1180YTQtdCy0YA/XFwuP3zQvNCw0YDRgtCwP3zQvNCw0YBcXC4/fNCw0L/RgNC10Ltb0YzRj1180LDQv9GAXFwuP3zQvNCwW9C50Y9dfNC40Y7QvVvRjNGPXXzQuNGO0L1cXC4/fNC40Y7Qu1vRjNGPXXzQuNGO0LtcXC4/fNCw0LLQs9GD0YHRgtCwP3zQsNCy0LNcXC4/fNGB0LXQvdGC0Y/QsdGAW9GM0Y9dfNGB0LXQvdGCP1xcLj980L7QutGC0Y/QsdGAW9GM0Y9dfNC+0LrRglxcLj980L3QvtGP0LHRgFvRjNGPXXzQvdC+0Y/QsT9cXC4/fNC00LXQutCw0LHRgFvRjNGPXXzQtNC10LpcXC4/KS9pLFxyXG5cclxuICAgIC8vINC/0L7Qu9C90YvQtSDQvdCw0LfQstCw0L3QuNGPINGBINC/0LDQtNC10LbQsNC80LhcclxuICAgIG1vbnRoc1N0cmljdFJlZ2V4OiAvXijRj9C90LLQsNGAW9GP0YxdfNGE0LXQstGA0LDQu1vRj9GMXXzQvNCw0YDRgtCwP3zQsNC/0YDQtdC7W9GP0YxdfNC80LBb0Y/QuV180LjRjtC9W9GP0YxdfNC40Y7Qu1vRj9GMXXzQsNCy0LPRg9GB0YLQsD980YHQtdC90YLRj9Cx0YBb0Y/RjF180L7QutGC0Y/QsdGAW9GP0YxdfNC90L7Rj9Cx0YBb0Y/RjF180LTQtdC60LDQsdGAW9GP0YxdKS9pLFxyXG5cclxuICAgIC8vINCS0YvRgNCw0LbQtdC90LjQtSwg0LrQvtGC0L7RgNC+0LUg0YHQvtC+0YLQstC10YHRgtCy0YPQtdGCINGC0L7Qu9GM0LrQviDRgdC+0LrRgNCw0YnRkdC90L3Ri9C8INGE0L7RgNC80LDQvFxyXG4gICAgbW9udGhzU2hvcnRTdHJpY3RSZWdleDogL14o0Y/QvdCyXFwufNGE0LXQstGAP1xcLnzQvNCw0YBb0YIuXXzQsNC/0YBcXC580LzQsFvRj9C5XXzQuNGO0L1b0YzRjy5dfNC40Y7Qu1vRjNGPLl180LDQstCzXFwufNGB0LXQvdGCP1xcLnzQvtC60YJcXC580L3QvtGP0LE/XFwufNC00LXQulxcLikvaSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVkg0LMuJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkg0LMuLCBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSDQsy4sIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb0KHQtdCz0L7QtNC90Y8g0LJdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9CX0LDQstGC0YDQsCDQsl0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdb0JLRh9C10YDQsCDQsl0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiBmdW5jdGlvbiAobm93KSB7XHJcbiAgICAgICAgICAgIGlmIChub3cud2VlaygpICE9PSB0aGlzLndlZWsoKSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDRgdC70LXQtNGD0Y7RidC10LVdIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINGB0LvQtdC00YPRjtGJ0LjQuV0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0YHQu9C10LTRg9GO0YnRg9GOXSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGF5KCkgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQktC+XSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkl0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICAgICAgaWYgKG5vdy53ZWVrKCkgIT09IHRoaXMud2VlaygpKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSINC/0YDQvtGI0LvQvtC1XSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vQkiDQv9GA0L7RiNC70YvQuV0gZGRkZCBb0LJdIExUJztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0JIg0L/RgNC+0YjQu9GD0Y5dIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXkoKSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CS0L5dIGRkZGQgW9CyXSBMVCc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW9CSXSBkZGRkIFvQsl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfRh9C10YDQtdC3ICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzINC90LDQt9Cw0LQnLFxyXG4gICAgICAgIHMgOiAn0L3QtdGB0LrQvtC70YzQutC+INGB0LXQutGD0L3QtCcsXHJcbiAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGggOiAn0YfQsNGBJyxcclxuICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgZCA6ICfQtNC10L3RjCcsXHJcbiAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIE0gOiAn0LzQtdGB0Y/RhicsXHJcbiAgICAgICAgTU0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIHkgOiAn0LPQvtC0JyxcclxuICAgICAgICB5eSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWxcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0Lh80YPRgtGA0LB80LTQvdGPfNCy0LXRh9C10YDQsC9pLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAvXijQtNC90Y980LLQtdGH0LXRgNCwKSQvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9C4JztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9GD0YLRgNCwJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9C00L3Rjyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfQstC10YfQtdGA0LAnO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0tKNC5fNCz0L580Y8pLyxcclxuICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgICAgICBjYXNlICdkJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnLdC5JztcclxuICAgICAgICAgICAgY2FzZSAnRCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3Qs9C+JztcclxuICAgICAgICAgICAgY2FzZSAndyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0Y8nO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHJ1O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ydS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9ydS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFNpbmRoaSBbc2RdXHJcbi8vISBhdXRob3IgOiBOYXJhaW4gU2FnYXIgOiBodHRwczovL2dpdGh1Yi5jb20vbmFyYWluc2FnYXJcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHMgPSBbXHJcbiAgICAn2KzZhtmI2LHZiicsXHJcbiAgICAn2YHZitio2LHZiNix2YonLFxyXG4gICAgJ9mF2KfYsdqGJyxcclxuICAgICfYp9m+2LHZitmEJyxcclxuICAgICfZhdim2YonLFxyXG4gICAgJ9is2YjZhicsXHJcbiAgICAn2KzZiNmE2KfYodmQJyxcclxuICAgICfYotqv2LPZvScsXHJcbiAgICAn2LPZitm+2b3Zhdio2LEnLFxyXG4gICAgJ9ii2qrZvdmI2KjYsScsXHJcbiAgICAn2YbZiNmF2KjYsScsXHJcbiAgICAn2orYs9mF2KjYsSdcclxuXTtcclxudmFyIGRheXMgPSBbXHJcbiAgICAn2KLahtixJyxcclxuICAgICfYs9mI2YXYsScsXHJcbiAgICAn2Kfasdin2LHZiCcsXHJcbiAgICAn2KfYsdio2LknLFxyXG4gICAgJ9iu2YXZitizJyxcclxuICAgICfYrNmF2LknLFxyXG4gICAgJ9qH2Ybah9ixJ1xyXG5dO1xyXG5cclxudmFyIHNkID0gbW9tZW50LmRlZmluZUxvY2FsZSgnc2QnLCB7XHJcbiAgICBtb250aHMgOiBtb250aHMsXHJcbiAgICBtb250aHNTaG9ydCA6IG1vbnRocyxcclxuICAgIHdlZWtkYXlzIDogZGF5cyxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiBkYXlzLFxyXG4gICAgd2Vla2RheXNNaW4gOiBkYXlzLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGTYjCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv2LXYqNitfNi02KfZhS8sXHJcbiAgICBpc1BNIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICfYtNin2YUnID09PSBpbnB1dDtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn2LXYqNitJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICfYtNin2YUnO1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW9in2oRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vYs9qA2Kfau9mKXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb2Kfas9mK2YYg2YfZgdiq2Yog2KrZil0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9qq2KfZhNmH2YddIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdb2q/Ystix2YrZhCDZh9mB2KrZil0gZGRkZCBb2KrZil0gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDZvtmI2KEnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg2KfasycsXHJcbiAgICAgICAgcyA6ICfahtmG2K8g2LPZitqq2YbaiicsXHJcbiAgICAgICAgbSA6ICfZh9qqINmF2YbZvScsXHJcbiAgICAgICAgbW0gOiAnJWQg2YXZhtm9JyxcclxuICAgICAgICBoIDogJ9mH2qog2qrZhNin2qonLFxyXG4gICAgICAgIGhoIDogJyVkINqq2YTYp9qqJyxcclxuICAgICAgICBkIDogJ9mH2qog2o/ZitmG2YfZhicsXHJcbiAgICAgICAgZGQgOiAnJWQg2o/ZitmG2YfZhicsXHJcbiAgICAgICAgTSA6ICfZh9qqINmF2YfZitmG2YgnLFxyXG4gICAgICAgIE1NIDogJyVkINmF2YfZitmG2KcnLFxyXG4gICAgICAgIHkgOiAn2YfaqiDYs9in2YQnLFxyXG4gICAgICAgIHl5IDogJyVkINiz2KfZhCdcclxuICAgIH0sXHJcbiAgICBwcmVwYXJzZTogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgv2IwvZywgJywnKTtcclxuICAgIH0sXHJcbiAgICBwb3N0Zm9ybWF0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8sL2csICfYjCcpO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzZDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2QuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2QuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBOb3J0aGVybiBTYW1pIFtzZV1cclxuLy8hIGF1dGhvcnMgOiBCw6VyZCBSb2xzdGFkIEhlbnJpa3NlbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJhbWVsbFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuXHJcbnZhciBzZSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NlJywge1xyXG4gICAgbW9udGhzIDogJ2/EkcSRYWphZ2Vtw6FubnVfZ3VvdnZhbcOhbm51X25qdWvEjWFtw6FubnVfY3VvxYtvbcOhbm51X21pZXNzZW3DoW5udV9nZWFzc2Vtw6FubnVfc3VvaWRuZW3DoW5udV9ib3JnZW3DoW5udV/EjWFrxI1hbcOhbm51X2dvbGdnb3Rtw6FubnVfc2vDoWJtYW3DoW5udV9qdW92bGFtw6FubnUnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdvxJHEkWpfZ3Vvdl9uanVrX2N1b19taWVzX2dlYXNfc3VvaV9ib3JnX8SNYWvEjV9nb2xnX3Nrw6FiX2p1b3YnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdzb3RuYWJlYWl2aV92dW9zc8OhcmdhX21hxYvFi2Viw6FyZ2FfZ2Fza2F2YWhra3VfZHVvcmFzdGF0X2JlYXJqYWRhdF9sw6F2dmFyZGF0Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdzb3RuX3Z1b3NfbWHFi19nYXNrX2R1b3JfYmVhcl9sw6F2Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnc192X21fZ19kX2JfTCcuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnTU1NTSBELiBbYi5dIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdNTU1NIEQuIFtiLl0gWVlZWSBbdGkuXSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQuIFtiLl0gWVlZWSBbdGkuXSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW290bmUgdGldIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW2lodHRpbiB0aV0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBbdGldIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW2lrdGUgdGldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1tvdmRkaXRdIGRkZGQgW3RpXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMgZ2Vhxb5lcycsXHJcbiAgICAgICAgcGFzdCA6ICdtYcWLaXQgJXMnLFxyXG4gICAgICAgIHMgOiAnbW9hZGRlIHNla3VuZGRhdCcsXHJcbiAgICAgICAgbSA6ICdva3RhIG1pbnVodGEnLFxyXG4gICAgICAgIG1tIDogJyVkIG1pbnVodGF0JyxcclxuICAgICAgICBoIDogJ29rdGEgZGlpbW11JyxcclxuICAgICAgICBoaCA6ICclZCBkaWltbXV0JyxcclxuICAgICAgICBkIDogJ29rdGEgYmVhaXZpJyxcclxuICAgICAgICBkZCA6ICclZCBiZWFpdnZpdCcsXHJcbiAgICAgICAgTSA6ICdva3RhIG3DoW5udScsXHJcbiAgICAgICAgTU0gOiAnJWQgbcOhbnV0JyxcclxuICAgICAgICB5IDogJ29rdGEgamFoa2knLFxyXG4gICAgICAgIHl5IDogJyVkIGphZ2l0J1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc2U7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogU2luaGFsZXNlIFtzaV1cclxuLy8hIGF1dGhvciA6IFNhbXBhdGggU2l0aW5hbWFsdXdhIDogaHR0cHM6Ly9naXRodWIuY29tL3NhbXBhdGhzcmlzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG4vKmpzaGludCAtVzEwMCovXHJcbnZhciBzaSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NpJywge1xyXG4gICAgbW9udGhzIDogJ+C2ouC2seC3gOC3j+C2u+C3kl/gtrTgt5ngtrbgtrvgt4Dgt4/gtrvgt5Jf4La44LeP4La74LeK4Lat4LeUX+C2heC2tOC3iuKAjeC2u+C3muC2veC3il/gtrjgt5Dgtrrgt5Jf4Lai4LeW4Lax4LeSX+C2ouC3luC2veC3kl/gtoXgtpzgt53gt4Pgt4rgtq3gt5Rf4LeD4LeQ4La04LeK4Lat4LeQ4La44LeK4La24La74LeKX+C2lOC2muC3iuC2reC3neC2tuC2u+C3il/gtrHgt5zgt4Dgt5Dgtrjgt4rgtrbgtrvgt4pf4Lav4LeZ4LeD4LeQ4La44LeK4La24La74LeKJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAn4Lai4LaxX+C2tOC3meC2tl/gtrjgt4/gtrvgt4pf4LaF4La04LeKX+C2uOC3kOC2uuC3kl/gtqLgt5bgtrHgt5Jf4Lai4LeW4La94LeSX+C2heC2nOC3nV/gt4Pgt5DgtrTgt4pf4LaU4Laa4LeKX+C2seC3nOC3gOC3kF/gtq/gt5ngt4Pgt5AnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfgtongtrvgt5Lgtq/gt49f4LeD4Laz4LeU4Lav4LePX+C2heC2n+C3hOC2u+C3lOC3gOC3j+C2r+C3j1/gtrbgtq/gt4/gtq/gt49f4La24LeK4oCN4La74LeE4LeD4LeK4La04Lat4LeS4Lax4LeK4Lav4LePX+C3g+C3kuC2muC3lOC2u+C3j+C2r+C3j1/gt4Pgt5ngtrHgt4Pgt5Tgtrvgt4/gtq/gt48nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+C2ieC2u+C3kl/gt4PgtrPgt5Rf4LaF4LafX+C2tuC2r+C3j1/gtrbgt4rigI3gtrvgt4Rf4LeD4LeS4Laa4LeUX+C3g+C3meC2sScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+C2iV/gt4Nf4LaFX+C2tl/gtrbgt4rigI3gtrtf4LeD4LeSX+C3g+C3mScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdhIGg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdhIGg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS9NTS9ERCcsXHJcbiAgICAgICAgTEwgOiAnWVlZWSBNTU1NIEQnLFxyXG4gICAgICAgIExMTCA6ICdZWVlZIE1NTU0gRCwgYSBoOm1tJyxcclxuICAgICAgICBMTExMIDogJ1lZWVkgTU1NTSBEIFvgt4Dgt5DgtrHgt5JdIGRkZGQsIGEgaDptbTpzcydcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgtoXgtq9dIExUW+C2p10nLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+C3hOC3meC2p10gTFRb4LanXScsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBMVFvgtqddJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vgtorgtrrgt5pdIExUW+C2p10nLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vgtrTgt4Pgt5Tgtpzgt5LgtrpdIGRkZGQgTFRb4LanXScsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVz4Laa4LeS4Lax4LeKJyxcclxuICAgICAgICBwYXN0IDogJyVz4Laa4LanIOC2tOC3meC2uycsXHJcbiAgICAgICAgcyA6ICfgtq3gtq3gt4rgtrTgtrsg4Laa4LeS4LeE4LeS4La04La6JyxcclxuICAgICAgICBtIDogJ+C2uOC3kuC2seC3kuC2reC3iuC2reC3lOC3gCcsXHJcbiAgICAgICAgbW0gOiAn4La44LeS4Lax4LeS4Lat4LeK4Lat4LeUICVkJyxcclxuICAgICAgICBoIDogJ+C2tOC3kOC2uicsXHJcbiAgICAgICAgaGggOiAn4La04LeQ4La6ICVkJyxcclxuICAgICAgICBkIDogJ+C2r+C3kuC2seC2uicsXHJcbiAgICAgICAgZGQgOiAn4Lav4LeS4LaxICVkJyxcclxuICAgICAgICBNIDogJ+C2uOC3j+C3g+C2uicsXHJcbiAgICAgICAgTU0gOiAn4La44LeP4LeDICVkJyxcclxuICAgICAgICB5IDogJ+C3gOC3g+C2uycsXHJcbiAgICAgICAgeXkgOiAn4LeA4LeD4La7ICVkJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSDgt4Dgt5DgtrHgt5IvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgJyDgt4Dgt5DgtrHgt5InO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2UgOiAv4La04LeZ4La7IOC3gOC2u+C3lHzgtrTgt4Pgt4og4LeA4La74LeUfOC2tOC3mS7gt4B84La0LuC3gC4vLFxyXG4gICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gJ+C2tC7gt4AuJyB8fCBpbnB1dCA9PT0gJ+C2tOC3g+C3iiDgt4Dgtrvgt5QnO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAn4La0LuC3gC4nIDogJ+C2tOC3g+C3iiDgt4Dgtrvgt5QnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ+C2tOC3mS7gt4AuJyA6ICfgtrTgt5ngtrsg4LeA4La74LeUJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHNpO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zaS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zaS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFNsb3ZhayBbc2tdXHJcbi8vISBhdXRob3IgOiBNYXJ0aW4gTWlua2EgOiBodHRwczovL2dpdGh1Yi5jb20vazJzXHJcbi8vISBiYXNlZCBvbiB3b3JrIG9mIHBldHJiZWxhIDogaHR0cHM6Ly9naXRodWIuY29tL3BldHJiZWxhXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbW9udGhzID0gJ2phbnXDoXJfZmVicnXDoXJfbWFyZWNfYXByw61sX23DoWpfasO6bl9qw7psX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0w7NiZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyk7XHJcbnZhciBtb250aHNTaG9ydCA9ICdqYW5fZmViX21hcl9hcHJfbcOhal9qw7puX2rDumxfYXVnX3NlcF9va3Rfbm92X2RlYycuc3BsaXQoJ18nKTtcclxuZnVuY3Rpb24gcGx1cmFsKG4pIHtcclxuICAgIHJldHVybiAobiA+IDEpICYmIChuIDwgNSk7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNsYXRlKG51bWJlciwgd2l0aG91dFN1ZmZpeCwga2V5LCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG51bWJlciArICcgJztcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgY2FzZSAncyc6ICAvLyBhIGZldyBzZWNvbmRzIC8gaW4gYSBmZXcgc2Vjb25kcyAvIGEgZmV3IHNlY29uZHMgYWdvXHJcbiAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAncMOhciBzZWvDum5kJyA6ICdww6FyIHNla3VuZGFtaSc7XHJcbiAgICAgICAgY2FzZSAnbSc6ICAvLyBhIG1pbnV0ZSAvIGluIGEgbWludXRlIC8gYSBtaW51dGUgYWdvXHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ21pbsO6dGEnIDogKGlzRnV0dXJlID8gJ21pbsO6dHUnIDogJ21pbsO6dG91Jyk7XHJcbiAgICAgICAgY2FzZSAnbW0nOiAvLyA5IG1pbnV0ZXMgLyBpbiA5IG1pbnV0ZXMgLyA5IG1pbnV0ZXMgYWdvXHJcbiAgICAgICAgICAgIGlmICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHBsdXJhbChudW1iZXIpID8gJ21pbsO6dHknIDogJ21pbsO6dCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdtaW7DunRhbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2gnOiAgLy8gYW4gaG91ciAvIGluIGFuIGhvdXIgLyBhbiBob3VyIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/ICdob2RpbmEnIDogKGlzRnV0dXJlID8gJ2hvZGludScgOiAnaG9kaW5vdScpO1xyXG4gICAgICAgIGNhc2UgJ2hoJzogLy8gOSBob3VycyAvIGluIDkgaG91cnMgLyA5IGhvdXJzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdob2RpbnknIDogJ2hvZMOtbicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdob2RpbmFtaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZCc6ICAvLyBhIGRheSAvIGluIGEgZGF5IC8gYSBkYXkgYWdvXHJcbiAgICAgICAgICAgIHJldHVybiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkgPyAnZGXFiCcgOiAnZMWIb20nO1xyXG4gICAgICAgIGNhc2UgJ2RkJzogLy8gOSBkYXlzIC8gaW4gOSBkYXlzIC8gOSBkYXlzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdkbmknIDogJ2Ruw60nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnZMWIYW1pJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdNJzogIC8vIGEgbW9udGggLyBpbiBhIG1vbnRoIC8gYSBtb250aCBhZ29cclxuICAgICAgICAgICAgcmV0dXJuICh3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlKSA/ICdtZXNpYWMnIDogJ21lc2lhY29tJztcclxuICAgICAgICBjYXNlICdNTSc6IC8vIDkgbW9udGhzIC8gaW4gOSBtb250aHMgLyA5IG1vbnRocyBhZ29cclxuICAgICAgICAgICAgaWYgKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAocGx1cmFsKG51bWJlcikgPyAnbWVzaWFjZScgOiAnbWVzaWFjb3YnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnbWVzaWFjbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3knOiAgLy8gYSB5ZWFyIC8gaW4gYSB5ZWFyIC8gYSB5ZWFyIGFnb1xyXG4gICAgICAgICAgICByZXR1cm4gKHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUpID8gJ3JvaycgOiAncm9rb20nO1xyXG4gICAgICAgIGNhc2UgJ3l5JzogLy8gOSB5ZWFycyAvIGluIDkgeWVhcnMgLyA5IHllYXJzIGFnb1xyXG4gICAgICAgICAgICBpZiAod2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIChwbHVyYWwobnVtYmVyKSA/ICdyb2t5JyA6ICdyb2tvdicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdyb2ttaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBzayA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NrJywge1xyXG4gICAgbW9udGhzIDogbW9udGhzLFxyXG4gICAgbW9udGhzU2hvcnQgOiBtb250aHNTaG9ydCxcclxuICAgIHdlZWtkYXlzIDogJ25lZGXEvmFfcG9uZGVsb2tfdXRvcm9rX3N0cmVkYV/FoXR2cnRva19waWF0b2tfc29ib3RhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICduZV9wb191dF9zdF/FoXRfcGlfc28nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICduZV9wb191dF9zdF/FoXRfcGlfc28nLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tkbmVzIG9dIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW3phanRyYSBvXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBuZWRlxL51IG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBkZGRkIFtvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBzdHJlZHUgb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZvIMWhdHZydG9rIG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2IHBpYXRvayBvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdiBzb2JvdHUgb10gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5OiAnW3bEjWVyYSBvXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDuiBuZWRlxL51IG9dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO9XSBkZGRkIFtvXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbbWludWzDuiBzdHJlZHUgb10gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW21pbnVsw71dIGRkZGQgW29dIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1ttaW51bMO6IHNvYm90dSBvXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcclxuICAgICAgICBwYXN0IDogJ3ByZWQgJXMnLFxyXG4gICAgICAgIHMgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBtbSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGhoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgZGQgOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNTSA6IHRyYW5zbGF0ZSxcclxuICAgICAgICB5IDogdHJhbnNsYXRlLFxyXG4gICAgICAgIHl5IDogdHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzaztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2suanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc2suanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTbG92ZW5pYW4gW3NsXVxyXG4vLyEgYXV0aG9yIDogUm9iZXJ0IFNlZG92xaFlayA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zZWRvdnNla1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciByZXN1bHQgPSBudW1iZXIgKyAnICc7XHJcbiAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICduZWthaiBzZWt1bmQnIDogJ25la2FqIHNla3VuZGFtaSc7XHJcbiAgICAgICAgY2FzZSAnbSc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2VuYSBtaW51dGEnIDogJ2VubyBtaW51dG8nO1xyXG4gICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggPyAnbWludXRhJyA6ICdtaW51dG8nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWludXRpJyA6ICdtaW51dGFtYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbWludXRlJyA6ICdtaW51dGFtaSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtaW51dCcgOiAnbWludXRhbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnaCc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ2VuYSB1cmEnIDogJ2VubyB1cm8nO1xyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggPyAndXJhJyA6ICd1cm8nO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAndXJpJyA6ICd1cmFtYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAndXJlJyA6ICd1cmFtaSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICd1cicgOiAndXJhbWknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2VuIGRhbicgOiAnZW5pbSBkbmVtJztcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2RhbicgOiAnZG5lbSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdkbmknIDogJ2RuZXZvbWEnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnZG5pJyA6ICdkbmV2aSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgcmV0dXJuIHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnZW4gbWVzZWMnIDogJ2VuaW0gbWVzZWNlbSc7XHJcbiAgICAgICAgY2FzZSAnTU0nOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlYycgOiAnbWVzZWNlbSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlY2EnIDogJ21lc2VjZW1hJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPCA1KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlY2UnIDogJ21lc2VjaSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdtZXNlY2V2JyA6ICdtZXNlY2knO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgY2FzZSAneSc6XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2VubyBsZXRvJyA6ICdlbmltIGxldG9tJztcclxuICAgICAgICBjYXNlICd5eSc6XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2xldG8nIDogJ2xldG9tJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB3aXRob3V0U3VmZml4IHx8IGlzRnV0dXJlID8gJ2xldGknIDogJ2xldG9tYSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgNSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHdpdGhvdXRTdWZmaXggfHwgaXNGdXR1cmUgPyAnbGV0YScgOiAnbGV0aSc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd2l0aG91dFN1ZmZpeCB8fCBpc0Z1dHVyZSA/ICdsZXQnIDogJ2xldGknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBzbCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NsJywge1xyXG4gICAgbW9udGhzIDogJ2phbnVhcl9mZWJydWFyX21hcmVjX2FwcmlsX21hal9qdW5pal9qdWxpal9hdmd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdqYW4uX2ZlYi5fbWFyLl9hcHIuX21hai5fanVuLl9qdWwuX2F2Zy5fc2VwLl9va3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICduZWRlbGphX3BvbmVkZWxqZWtfdG9yZWtfc3JlZGFfxI1ldHJ0ZWtfcGV0ZWtfc29ib3RhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICduZWQuX3Bvbi5fdG9yLl9zcmUuX8SNZXQuX3BldC5fc29iLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ25lX3BvX3RvX3NyX8SNZV9wZV9zbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdELiBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBELiBNTU1NIFlZWVkgSDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5ICA6ICdbZGFuZXMgb2JdIExUJyxcclxuICAgICAgICBuZXh0RGF5ICA6ICdbanV0cmkgb2JdIExUJyxcclxuXHJcbiAgICAgICAgbmV4dFdlZWsgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZdIFtuZWRlbGpvXSBbb2JdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1t2XSBbc3JlZG9dIFtvYl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZdIFtzb2JvdG9dIFtvYl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ZdIGRkZGQgW29iXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgIDogJ1t2xI1lcmFqIG9iXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ByZWrFoW5qb10gW25lZGVsam9dIFtvYl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ByZWrFoW5qb10gW3NyZWRvXSBbb2JdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1twcmVqxaFuam9dIFtzb2JvdG9dIFtvYl0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3ByZWrFoW5qaV0gZGRkZCBbb2JdIExUJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ8SNZXogJXMnLFxyXG4gICAgICAgIHBhc3QgICA6ICdwcmVkICVzJyxcclxuICAgICAgICBzICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG0gICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgbW0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIGhoICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZCAgICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBkZCAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE0gICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgTU0gICAgIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5ICAgICAgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIHl5ICAgICA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHNsO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEFsYmFuaWFuIFtzcV1cclxuLy8hIGF1dGhvciA6IEZsYWvDq3JpbSBJc21hbmkgOiBodHRwczovL2dpdGh1Yi5jb20vZmxha2VyaW1pXHJcbi8vISBhdXRob3IgOiBNZW5lbGlvbiBFbGVuc8O6bGUgOiBodHRwczovL2dpdGh1Yi5jb20vT2lyZVxyXG4vLyEgYXV0aG9yIDogT2VyZCBDdWthbGxhIDogaHR0cHM6Ly9naXRodWIuY29tL29lcmRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzcSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3NxJywge1xyXG4gICAgbW9udGhzIDogJ0phbmFyX1Noa3VydF9NYXJzX1ByaWxsX01hal9RZXJzaG9yX0tvcnJpa19HdXNodF9TaHRhdG9yX1RldG9yX07Dq250b3JfRGhqZXRvcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9TaGtfTWFyX1ByaV9NYWpfUWVyX0tvcl9HdXNfU2h0X1RldF9Ow6tuX0Roaicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ0UgRGllbF9FIEjDq27Dq19FIE1hcnTDq19FIE3Dq3JrdXLDq19FIEVuanRlX0UgUHJlbXRlX0UgU2h0dW7Dqycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnRGllX0jDq25fTWFyX03Dq3JfRW5qX1ByZV9TaHQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdEX0hfTWFfTcOrX0VfUF9TaCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvUER8TUQvLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LmNoYXJBdCgwKSA9PT0gJ00nO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGhvdXJzIDwgMTIgPyAnUEQnIDogJ01EJztcclxuICAgIH0sXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbU290IG7Dq10gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW05lc8OrciBuw6tdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFtuw6tdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tEamUgbsOrXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbZSBrYWx1YXIgbsOrXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ27DqyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyBtw6sgcGFyw6snLFxyXG4gICAgICAgIHMgOiAnZGlzYSBzZWtvbmRhJyxcclxuICAgICAgICBtIDogJ25qw6sgbWludXTDqycsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRhJyxcclxuICAgICAgICBoIDogJ25qw6sgb3LDqycsXHJcbiAgICAgICAgaGggOiAnJWQgb3LDqycsXHJcbiAgICAgICAgZCA6ICduasOrIGRpdMOrJyxcclxuICAgICAgICBkZCA6ICclZCBkaXTDqycsXHJcbiAgICAgICAgTSA6ICduasOrIG11YWonLFxyXG4gICAgICAgIE1NIDogJyVkIG11YWonLFxyXG4gICAgICAgIHkgOiAnbmrDqyB2aXQnLFxyXG4gICAgICAgIHl5IDogJyVkIHZpdGUnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzcTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3EuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3EuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTZXJiaWFuIEN5cmlsbGljIFtzci1jeXJsXVxyXG4vLyEgYXV0aG9yIDogTWlsYW4gSmFuYcSNa292acSHPG1pbGFuamFuYWNrb3ZpY0BnbWFpbC5jb20+IDogaHR0cHM6Ly9naXRodWIuY29tL21pbGFuLWpcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0cmFuc2xhdG9yID0ge1xyXG4gICAgd29yZHM6IHsgLy9EaWZmZXJlbnQgZ3JhbW1hdGljYWwgY2FzZXNcclxuICAgICAgICBtOiBbJ9GY0LXQtNCw0L0g0LzQuNC90YPRgicsICfRmNC10LTQvdC1INC80LjQvdGD0YLQtSddLFxyXG4gICAgICAgIG1tOiBbJ9C80LjQvdGD0YInLCAn0LzQuNC90YPRgtC1JywgJ9C80LjQvdGD0YLQsCddLFxyXG4gICAgICAgIGg6IFsn0ZjQtdC00LDQvSDRgdCw0YInLCAn0ZjQtdC00L3QvtCzINGB0LDRgtCwJ10sXHJcbiAgICAgICAgaGg6IFsn0YHQsNGCJywgJ9GB0LDRgtCwJywgJ9GB0LDRgtC4J10sXHJcbiAgICAgICAgZGQ6IFsn0LTQsNC9JywgJ9C00LDQvdCwJywgJ9C00LDQvdCwJ10sXHJcbiAgICAgICAgTU06IFsn0LzQtdGB0LXRhicsICfQvNC10YHQtdGG0LAnLCAn0LzQtdGB0LXRhtC4J10sXHJcbiAgICAgICAgeXk6IFsn0LPQvtC00LjQvdCwJywgJ9Cz0L7QtNC40L3QtScsICfQs9C+0LTQuNC90LAnXVxyXG4gICAgfSxcclxuICAgIGNvcnJlY3RHcmFtbWF0aWNhbENhc2U6IGZ1bmN0aW9uIChudW1iZXIsIHdvcmRLZXkpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyID09PSAxID8gd29yZEtleVswXSA6IChudW1iZXIgPj0gMiAmJiBudW1iZXIgPD0gNCA/IHdvcmRLZXlbMV0gOiB3b3JkS2V5WzJdKTtcclxuICAgIH0sXHJcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgICAgIHZhciB3b3JkS2V5ID0gdHJhbnNsYXRvci53b3Jkc1trZXldO1xyXG4gICAgICAgIGlmIChrZXkubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gd29yZEtleVswXSA6IHdvcmRLZXlbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICcgJyArIHRyYW5zbGF0b3IuY29ycmVjdEdyYW1tYXRpY2FsQ2FzZShudW1iZXIsIHdvcmRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbnZhciBzckN5cmwgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzci1jeXJsJywge1xyXG4gICAgbW9udGhzOiAn0ZjQsNC90YPQsNGAX9GE0LXQsdGA0YPQsNGAX9C80LDRgNGCX9Cw0L/RgNC40Ltf0LzQsNGYX9GY0YPQvV/RmNGD0Ltf0LDQstCz0YPRgdGCX9GB0LXQv9GC0LXQvNCx0LDRgF/QvtC60YLQvtCx0LDRgF/QvdC+0LLQtdC80LHQsNGAX9C00LXRhtC10LzQsdCw0YAnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydDogJ9GY0LDQvS5f0YTQtdCxLl/QvNCw0YAuX9Cw0L/RgC5f0LzQsNGYX9GY0YPQvV/RmNGD0Ltf0LDQstCzLl/RgdC10L8uX9C+0LrRgi5f0L3QvtCyLl/QtNC10YYuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzOiAn0L3QtdC00LXRmdCwX9C/0L7QvdC10LTQtdGZ0LDQul/Rg9GC0L7RgNCw0Lpf0YHRgNC10LTQsF/Rh9C10YLQstGA0YLQsNC6X9C/0LXRgtCw0Lpf0YHRg9Cx0L7RgtCwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydDogJ9C90LXQtC5f0L/QvtC9Ll/Rg9GC0L4uX9GB0YDQtS5f0YfQtdGCLl/Qv9C10YIuX9GB0YPQsS4nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbjogJ9C90LVf0L/Qvl/Rg9GCX9GB0YBf0YfQtV/Qv9C1X9GB0YMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1BhcnNlRXhhY3QgOiB0cnVlLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IHtcclxuICAgICAgICBMVDogJ0g6bW0nLFxyXG4gICAgICAgIExUUyA6ICdIOm1tOnNzJyxcclxuICAgICAgICBMOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEw6ICdELiBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTDogJ0QuIE1NTU0gWVlZWSBIOm1tJyxcclxuICAgICAgICBMTExMOiAnZGRkZCwgRC4gTU1NTSBZWVlZIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXI6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW9C00LDQvdCw0YEg0YNdIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW9GB0YPRgtGA0LAg0YNdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZGF5KCkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vRg10gW9C90LXQtNC10ZnRg10gW9GDXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIFvRgdGA0LXQtNGDXSBb0YNdIExUJztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1vRg10gW9GB0YPQsdC+0YLRg10gW9GDXSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdb0YNdIGRkZGQgW9GDXSBMVCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhc3REYXkgIDogJ1vRmNGD0YfQtSDRg10gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFdlZWtEYXlzID0gW1xyXG4gICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70LVdIFvQvdC10LTQtdGZ0LVdIFvRg10gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1vQv9GA0L7RiNC70L7Qs10gW9C/0L7QvdC10LTQtdGZ0LrQsF0gW9GDXSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQvtCzXSBb0YPRgtC+0YDQutCwXSBb0YNdIExUJyxcclxuICAgICAgICAgICAgICAgICdb0L/RgNC+0YjQu9C1XSBb0YHRgNC10LTQtV0gW9GDXSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQvtCzXSBb0YfQtdGC0LLRgNGC0LrQsF0gW9GDXSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQvtCzXSBb0L/QtdGC0LrQsF0gW9GDXSBMVCcsXHJcbiAgICAgICAgICAgICAgICAnW9C/0YDQvtGI0LvQtV0gW9GB0YPQsdC+0YLQtV0gW9GDXSBMVCdcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RXZWVrRGF5c1t0aGlzLmRheSgpXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfQt9CwICVzJyxcclxuICAgICAgICBwYXN0ICAgOiAn0L/RgNC1ICVzJyxcclxuICAgICAgICBzICAgICAgOiAn0L3QtdC60L7Qu9C40LrQviDRgdC10LrRg9C90LTQuCcsXHJcbiAgICAgICAgbSAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgaCAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgaGggICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgZCAgICAgIDogJ9C00LDQvScsXHJcbiAgICAgICAgZGQgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgTSAgICAgIDogJ9C80LXRgdC10YYnLFxyXG4gICAgICAgIE1NICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlLFxyXG4gICAgICAgIHkgICAgICA6ICfQs9C+0LTQuNC90YMnLFxyXG4gICAgICAgIHl5ICAgICA6IHRyYW5zbGF0b3IudHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzckN5cmw7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLWN5cmwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3ItY3lybC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFNlcmJpYW4gW3NyXVxyXG4vLyEgYXV0aG9yIDogTWlsYW4gSmFuYcSNa292acSHPG1pbGFuamFuYWNrb3ZpY0BnbWFpbC5jb20+IDogaHR0cHM6Ly9naXRodWIuY29tL21pbGFuLWpcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0cmFuc2xhdG9yID0ge1xyXG4gICAgd29yZHM6IHsgLy9EaWZmZXJlbnQgZ3JhbW1hdGljYWwgY2FzZXNcclxuICAgICAgICBtOiBbJ2plZGFuIG1pbnV0JywgJ2plZG5lIG1pbnV0ZSddLFxyXG4gICAgICAgIG1tOiBbJ21pbnV0JywgJ21pbnV0ZScsICdtaW51dGEnXSxcclxuICAgICAgICBoOiBbJ2plZGFuIHNhdCcsICdqZWRub2cgc2F0YSddLFxyXG4gICAgICAgIGhoOiBbJ3NhdCcsICdzYXRhJywgJ3NhdGknXSxcclxuICAgICAgICBkZDogWydkYW4nLCAnZGFuYScsICdkYW5hJ10sXHJcbiAgICAgICAgTU06IFsnbWVzZWMnLCAnbWVzZWNhJywgJ21lc2VjaSddLFxyXG4gICAgICAgIHl5OiBbJ2dvZGluYScsICdnb2RpbmUnLCAnZ29kaW5hJ11cclxuICAgIH0sXHJcbiAgICBjb3JyZWN0R3JhbW1hdGljYWxDYXNlOiBmdW5jdGlvbiAobnVtYmVyLCB3b3JkS2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciA9PT0gMSA/IHdvcmRLZXlbMF0gOiAobnVtYmVyID49IDIgJiYgbnVtYmVyIDw9IDQgPyB3b3JkS2V5WzFdIDogd29yZEtleVsyXSk7XHJcbiAgICB9LFxyXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBrZXkpIHtcclxuICAgICAgICB2YXIgd29yZEtleSA9IHRyYW5zbGF0b3Iud29yZHNba2V5XTtcclxuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2l0aG91dFN1ZmZpeCA/IHdvcmRLZXlbMF0gOiB3b3JkS2V5WzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyB0cmFuc2xhdG9yLmNvcnJlY3RHcmFtbWF0aWNhbENhc2UobnVtYmVyLCB3b3JkS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG52YXIgc3IgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzcicsIHtcclxuICAgIG1vbnRoczogJ2phbnVhcl9mZWJydWFyX21hcnRfYXByaWxfbWFqX2p1bl9qdWxfYXZndXN0X3NlcHRlbWJhcl9va3RvYmFyX25vdmVtYmFyX2RlY2VtYmFyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQ6ICdqYW4uX2ZlYi5fbWFyLl9hcHIuX21hal9qdW5fanVsX2F2Zy5fc2VwLl9va3QuX25vdi5fZGVjLicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1BhcnNlRXhhY3Q6IHRydWUsXHJcbiAgICB3ZWVrZGF5czogJ25lZGVsamFfcG9uZWRlbGpha191dG9yYWtfc3JlZGFfxI1ldHZydGFrX3BldGFrX3N1Ym90YScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQ6ICduZWQuX3Bvbi5fdXRvLl9zcmUuX8SNZXQuX3BldC5fc3ViLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluOiAnbmVfcG9fdXRfc3JfxI1lX3BlX3N1Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0OiB7XHJcbiAgICAgICAgTFQ6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMOiAnRC4gTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEw6ICdELiBNTU1NIFlZWVkgSDptbScsXHJcbiAgICAgICAgTExMTDogJ2RkZGQsIEQuIE1NTU0gWVlZWSBIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tkYW5hcyB1XSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1tzdXRyYSB1XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW25lZGVsanVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gW3NyZWR1XSBbdV0gTFQnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW3VdIFtzdWJvdHVdIFt1XSBMVCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbdV0gZGRkZCBbdV0gTFQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXN0RGF5ICA6ICdbanXEjWUgdV0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFdlZWtEYXlzID0gW1xyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxlXSBbbmVkZWxqZV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFtwb25lZGVsamthXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW3V0b3JrYV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW3NyZWRlXSBbdV0gTFQnLFxyXG4gICAgICAgICAgICAgICAgJ1twcm/FoWxvZ10gW8SNZXR2cnRrYV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsb2ddIFtwZXRrYV0gW3VdIExUJyxcclxuICAgICAgICAgICAgICAgICdbcHJvxaFsZV0gW3N1Ym90ZV0gW3VdIExUJ1xyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByZXR1cm4gbGFzdFdlZWtEYXlzW3RoaXMuZGF5KCldO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3phICVzJyxcclxuICAgICAgICBwYXN0ICAgOiAncHJlICVzJyxcclxuICAgICAgICBzICAgICAgOiAnbmVrb2xpa28gc2VrdW5kaScsXHJcbiAgICAgICAgbSAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgbW0gICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgaCAgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgaGggICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgZCAgICAgIDogJ2RhbicsXHJcbiAgICAgICAgZGQgICAgIDogdHJhbnNsYXRvci50cmFuc2xhdGUsXHJcbiAgICAgICAgTSAgICAgIDogJ21lc2VjJyxcclxuICAgICAgICBNTSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZSxcclxuICAgICAgICB5ICAgICAgOiAnZ29kaW51JyxcclxuICAgICAgICB5eSAgICAgOiB0cmFuc2xhdG9yLnRyYW5zbGF0ZVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfVxcLi8sXHJcbiAgICBvcmRpbmFsIDogJyVkLicsXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gc3I7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3NyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogc2lTd2F0aSBbc3NdXHJcbi8vISBhdXRob3IgOiBOaWNvbGFpIERhdmllczxtYWlsQG5pY29sYWkuaW8+IDogaHR0cHM6Ly9naXRodWIuY29tL25pY29sYWlkYXZpZXNcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcblxyXG52YXIgc3MgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzcycsIHtcclxuICAgIG1vbnRocyA6IFwiQmhpbWJpZHZ3YW5lX0luZGxvdmFuYV9JbmRsb3YnbGVua2h1bHVfTWFiYXNhX0lua2h3ZWtod2V0aV9JbmhsYWJhX0tob2x3YW5lX0luZ2NpX0lueW9uaV9JbXBoYWxhX0x3ZXRpX0luZ29uZ29uaVwiLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdCaGlfSW5hX0ludV9NYWJfSW5rX0luaF9LaG9fSWdjX0lueV9JbXBfTHdlX0lnbycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ0xpc29udGZvX1Vtc29tYnVsdWtvX0xlc2liaWxpX0xlc2l0c2F0ZnVfTGVzaW5lX0xlc2lobGFudV9VbWdjaWJlbG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0xpc19VbWJfTHNiX0xlc19Mc2lfTHNoX1VtZycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0xpX1VzX0xiX0x0X0xzX0xoX1VnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIGg6bW0gQScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBoOm1tIEEnXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbTmFtdWhsYSBuZ2FdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tLdXNhc2EgbmdhXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbbmdhXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbSXRvbG8gbmdhXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnZGRkZCBbbGVsaXBoZWxpbGVdIFtuZ2FdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnbmdhICVzJyxcclxuICAgICAgICBwYXN0IDogJ3dlbnRla2EgbmdhICVzJyxcclxuICAgICAgICBzIDogJ2VtaXp1endhbmEgbG9tY2FuZScsXHJcbiAgICAgICAgbSA6ICd1bXp1enUnLFxyXG4gICAgICAgIG1tIDogJyVkIGVtaXp1enUnLFxyXG4gICAgICAgIGggOiAnbGlob3JhJyxcclxuICAgICAgICBoaCA6ICclZCBlbWFob3JhJyxcclxuICAgICAgICBkIDogJ2xpbGFuZ2EnLFxyXG4gICAgICAgIGRkIDogJyVkIGVtYWxhbmdhJyxcclxuICAgICAgICBNIDogJ2lueWFuZ2EnLFxyXG4gICAgICAgIE1NIDogJyVkIHRpbnlhbmdhJyxcclxuICAgICAgICB5IDogJ3Vtbnlha2EnLFxyXG4gICAgICAgIHl5IDogJyVkIGltaW55YWthJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC9la3VzZW5pfGVtaW5pfGVudHNhbWJhbWF8ZWJ1c3VrdS8sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA8IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZWt1c2VuaSc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IDE1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZW1pbmknO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91cnMgPCAxOSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VudHNhbWJhbWEnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZWJ1c3VrdSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtSG91ciA6IGZ1bmN0aW9uIChob3VyLCBtZXJpZGllbSkge1xyXG4gICAgICAgIGlmIChob3VyID09PSAxMikge1xyXG4gICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1lcmlkaWVtID09PSAnZWt1c2VuaScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ2VtaW5pJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMSA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ2VudHNhbWJhbWEnIHx8IG1lcmlkaWVtID09PSAnZWJ1c3VrdScpIHtcclxuICAgICAgICAgICAgaWYgKGhvdXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS8sXHJcbiAgICBvcmRpbmFsIDogJyVkJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzcztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3MuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3MuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTd2VkaXNoIFtzdl1cclxuLy8hIGF1dGhvciA6IEplbnMgQWxtIDogaHR0cHM6Ly9naXRodWIuY29tL3VsbXVzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3YgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCdzdicsIHtcclxuICAgIG1vbnRocyA6ICdqYW51YXJpX2ZlYnJ1YXJpX21hcnNfYXByaWxfbWFqX2p1bmlfanVsaV9hdWd1c3RpX3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdzw7ZuZGFnX23DpW5kYWdfdGlzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7ZyZGFnJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdzw7ZuX23DpW5fdGlzX29uc190b3JfZnJlX2zDtnInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdzw7ZfbcOlX3RpX29uX3RvX2ZyX2zDticuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWS1NTS1ERCcsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBba2wuXSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIFtrbC5dIEhIOm1tJyxcclxuICAgICAgICBsbGwgOiAnRCBNTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdkZGQgRCBNTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnW0lkYWddIExUJyxcclxuICAgICAgICBuZXh0RGF5OiAnW0ltb3Jnb25dIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW0lnw6VyXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWs6ICdbUMOlXSBkZGRkIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ1tJXSBkZGRkW3NdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdvbSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICdmw7ZyICVzIHNlZGFuJyxcclxuICAgICAgICBzIDogJ27DpWdyYSBzZWt1bmRlcicsXHJcbiAgICAgICAgbSA6ICdlbiBtaW51dCcsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcicsXHJcbiAgICAgICAgaCA6ICdlbiB0aW1tZScsXHJcbiAgICAgICAgaGggOiAnJWQgdGltbWFyJyxcclxuICAgICAgICBkIDogJ2VuIGRhZycsXHJcbiAgICAgICAgZGQgOiAnJWQgZGFnYXInLFxyXG4gICAgICAgIE0gOiAnZW4gbcOlbmFkJyxcclxuICAgICAgICBNTSA6ICclZCBtw6VuYWRlcicsXHJcbiAgICAgICAgeSA6ICdldHQgw6VyJyxcclxuICAgICAgICB5eSA6ICclZCDDpXInXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGV8YSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAofn4obnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICdlJyA6XHJcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdhJyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICdhJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdlJyA6ICdlJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiBzdjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3YuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvc3YuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBTd2FoaWxpIFtzd11cclxuLy8hIGF1dGhvciA6IEZhaGFkIEthc3NpbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWRzZWxcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzdyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3N3Jywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcmlfRmVicnVhcmlfTWFjaGlfQXByaWxpX01laV9KdW5pX0p1bGFpX0Fnb3N0aV9TZXB0ZW1iYV9Pa3RvYmFfTm92ZW1iYV9EZXNlbWJhJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYWNfQXByX01laV9KdW5fSnVsX0Fnb19TZXBfT2t0X05vdl9EZXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdKdW1hcGlsaV9KdW1hdGF0dV9KdW1hbm5lX0p1bWF0YW5vX0FsaGFtaXNpX0lqdW1hYV9KdW1hbW9zaScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnSnBsX0p0YXRfSm5uZV9KdGFuX0FsaF9Jam1fSm1vcycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0oyX0ozX0o0X0o1X0FsX0lqX0oxJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQuTU0uWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBEIE1NTU0gWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tsZW8gc2FhXSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdba2VzaG8gc2FhXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW3dpa2kgaWpheW9dIGRkZGQgW3NhYXRdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tqYW5hXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW3dpa2kgaWxpeW9waXRhXSBkZGRkIFtzYWF0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIGJhYWRheWUnLFxyXG4gICAgICAgIHBhc3QgOiAndG9rZWEgJXMnLFxyXG4gICAgICAgIHMgOiAnaGl2aSBwdW5kZScsXHJcbiAgICAgICAgbSA6ICdkYWtpa2EgbW9qYScsXHJcbiAgICAgICAgbW0gOiAnZGFraWthICVkJyxcclxuICAgICAgICBoIDogJ3NhYSBsaW1vamEnLFxyXG4gICAgICAgIGhoIDogJ21hc2FhICVkJyxcclxuICAgICAgICBkIDogJ3Npa3UgbW9qYScsXHJcbiAgICAgICAgZGQgOiAnbWFzaWt1ICVkJyxcclxuICAgICAgICBNIDogJ213ZXppIG1tb2phJyxcclxuICAgICAgICBNTSA6ICdtaWV6aSAlZCcsXHJcbiAgICAgICAgeSA6ICdtd2FrYSBtbW9qYScsXHJcbiAgICAgICAgeXkgOiAnbWlha2EgJWQnXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA3ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHN3O1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9zdy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFRhbWlsIFt0YV1cclxuLy8hIGF1dGhvciA6IEFyanVua3VtYXIgS3Jpc2huYW1vb3J0aHkgOiBodHRwczovL2dpdGh1Yi5jb20vdGsxMjA0MDRcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBzeW1ib2xNYXAgPSB7XHJcbiAgICAnMSc6ICfgr6cnLFxyXG4gICAgJzInOiAn4K+oJyxcclxuICAgICczJzogJ+CvqScsXHJcbiAgICAnNCc6ICfgr6onLFxyXG4gICAgJzUnOiAn4K+rJyxcclxuICAgICc2JzogJ+CvrCcsXHJcbiAgICAnNyc6ICfgr60nLFxyXG4gICAgJzgnOiAn4K+uJyxcclxuICAgICc5JzogJ+CvrycsXHJcbiAgICAnMCc6ICfgr6YnXHJcbn07XHJcbnZhciBudW1iZXJNYXAgPSB7XHJcbiAgICAn4K+nJzogJzEnLFxyXG4gICAgJ+CvqCc6ICcyJyxcclxuICAgICfgr6knOiAnMycsXHJcbiAgICAn4K+qJzogJzQnLFxyXG4gICAgJ+Cvqyc6ICc1JyxcclxuICAgICfgr6wnOiAnNicsXHJcbiAgICAn4K+tJzogJzcnLFxyXG4gICAgJ+Cvric6ICc4JyxcclxuICAgICfgr68nOiAnOScsXHJcbiAgICAn4K+mJzogJzAnXHJcbn07XHJcblxyXG52YXIgdGEgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0YScsIHtcclxuICAgIG1vbnRocyA6ICfgrpzgrqngrrXgrrDgrr9f4K6q4K6/4K6q4K+N4K6w4K614K6w4K6/X+CuruCuvuCusOCvjeCumuCvjV/gro/grqrgr43grrDgrrLgr41f4K6u4K+HX+CunOCvguCuqeCvjV/grpzgr4LgrrLgr4hf4K6G4K6V4K644K+N4K6f4K+NX+CumuCvhuCuquCvjeCun+CvhuCuruCvjeCuquCusOCvjV/groXgrpXgr43grp/gr4fgrr7grqrgrrDgr41f4K6o4K614K6u4K+N4K6q4K6w4K+NX+Cun+Cuv+CumuCuruCvjeCuquCusOCvjScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+CunOCuqeCuteCusOCuv1/grqrgrr/grqrgr43grrDgrrXgrrDgrr9f4K6u4K6+4K6w4K+N4K6a4K+NX+Cuj+CuquCvjeCusOCusuCvjV/grq7gr4df4K6c4K+C4K6p4K+NX+CunOCvguCusuCviF/grobgrpXgrrjgr43grp/gr41f4K6a4K+G4K6q4K+N4K6f4K+G4K6u4K+N4K6q4K6w4K+NX+CuheCuleCvjeCun+Cvh+CuvuCuquCusOCvjV/grqjgrrXgrq7gr43grqrgrrDgr41f4K6f4K6/4K6a4K6u4K+N4K6q4K6w4K+NJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn4K6e4K6+4K6v4K6/4K6x4K+N4K6x4K+B4K6V4K+N4K6V4K6/4K604K6u4K+IX+CupOCuv+CumeCvjeCuleCun+CvjeCuleCuv+CutOCuruCviF/grprgr4bgrrXgr43grrXgrr7grq/gr43grpXgrr/grrTgrq7gr4hf4K6q4K+B4K6k4K6p4K+N4K6V4K6/4K604K6u4K+IX+CuteCuv+Cur+CuvuCutOCuleCvjeCuleCuv+CutOCuruCviF/grrXgr4bgrrPgr43grrPgrr/grpXgr43grpXgrr/grrTgrq7gr4hf4K6a4K6p4K6/4K6V4K+N4K6V4K6/4K604K6u4K+IJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfgrp7grr7grq/grr/grrHgr4Ff4K6k4K6/4K6Z4K+N4K6V4K6z4K+NX+CumuCvhuCuteCvjeCuteCuvuCur+CvjV/grqrgr4HgrqTgrqngr41f4K614K6/4K6v4K6+4K604K6p4K+NX+CuteCvhuCus+CvjeCus+Cuv1/grprgrqngrr8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfgrp7grr5f4K6k4K6/X+CumuCvhl/grqrgr4Ff4K614K6/X+CuteCvhl/grponLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVksIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZLCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgrofgrqngr43grrHgr4FdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgrqjgrr7grrPgr4hdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4K6o4K+H4K6x4K+N4K6x4K+BXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+CuleCun+CuqOCvjeCupCDgrrXgrr7grrDgrq7gr41dIGRkZGQsIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMg4K6H4K6y4K+NJyxcclxuICAgICAgICBwYXN0IDogJyVzIOCuruCvgeCuqeCvjScsXHJcbiAgICAgICAgcyA6ICfgrpLgrrDgr4Eg4K6a4K6/4K6yIOCuteCuv+CuqOCuvuCun+Cuv+CuleCus+CvjScsXHJcbiAgICAgICAgbSA6ICfgrpLgrrDgr4Eg4K6o4K6/4K6u4K6/4K6f4K6u4K+NJyxcclxuICAgICAgICBtbSA6ICclZCDgrqjgrr/grq7grr/grp/grpngr43grpXgrrPgr40nLFxyXG4gICAgICAgIGggOiAn4K6S4K6w4K+BIOCuruCuo+CuvyDgrqjgr4fgrrDgrq7gr40nLFxyXG4gICAgICAgIGhoIDogJyVkIOCuruCuo+CuvyDgrqjgr4fgrrDgrq7gr40nLFxyXG4gICAgICAgIGQgOiAn4K6S4K6w4K+BIOCuqOCuvuCus+CvjScsXHJcbiAgICAgICAgZGQgOiAnJWQg4K6o4K6+4K6f4K+N4K6V4K6z4K+NJyxcclxuICAgICAgICBNIDogJ+CukuCusOCvgSDgrq7grr7grqTgrq7gr40nLFxyXG4gICAgICAgIE1NIDogJyVkIOCuruCuvuCupOCumeCvjeCuleCus+CvjScsXHJcbiAgICAgICAgeSA6ICfgrpLgrrDgr4Eg4K614K6w4K+B4K6f4K6u4K+NJyxcclxuICAgICAgICB5eSA6ICclZCDgrobgrqPgr43grp/gr4HgrpXgrrPgr40nXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ94K614K6k4K+BLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlciArICfgrrXgrqTgr4EnO1xyXG4gICAgfSxcclxuICAgIHByZXBhcnNlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9b4K+n4K+o4K+p4K+q4K+r4K+s4K+t4K+u4K+v4K+mXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck1hcFttYXRjaF07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxkL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sTWFwW21hdGNoXTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICAvLyByZWZlciBodHRwOi8vdGEud2lraXBlZGlhLm9yZy9zLzFlcjFcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/grq/grr7grq7grq7gr4184K614K+I4K6V4K6x4K+IfOCuleCuvuCusuCviHzgrqjgrqPgr43grqrgrpXgrrLgr4184K6O4K6x4K+N4K6q4K6+4K6f4K+BfOCuruCuvuCusuCviC8sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcg4K6v4K6+4K6u4K6u4K+NJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCA2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnIOCuteCviOCuleCuseCviCc7ICAvLyDgrrXgr4jgrpXgrrHgr4hcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyDgrpXgrr7grrLgr4gnOyAvLyDgrpXgrr7grrLgr4hcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyDgrqjgrqPgr43grqrgrpXgrrLgr40nOyAvLyDgrqjgrqPgr43grqrgrpXgrrLgr41cclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyDgro7grrHgr43grqrgrr7grp/gr4EnOyAvLyDgro7grrHgr43grqrgrr7grp/gr4FcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAyMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJyDgrq7grr7grrLgr4gnOyAvLyDgrq7grr7grrLgr4hcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyDgrq/grr7grq7grq7gr40nO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+Cur+CuvuCuruCuruCvjScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCAyID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4K614K+I4K6V4K6x4K+IJyB8fCBtZXJpZGllbSA9PT0gJ+CuleCuvuCusuCviCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CuqOCuo+CvjeCuquCuleCusuCvjScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTAgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyICsgMTI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0YTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGEuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUZWx1Z3UgW3RlXVxyXG4vLyEgYXV0aG9yIDogS3Jpc2huYSBDaGFpdGFueWEgVGhvdGEgOiBodHRwczovL2dpdGh1Yi5jb20va2N0aG90YVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHRlID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGUnLCB7XHJcbiAgICBtb250aHMgOiAn4LCc4LCo4LC14LCw4LC/X+Cwq+Cwv+CwrOCxjeCwsOCwteCwsOCwv1/gsK7gsL7gsLDgsY3gsJrgsL9f4LCP4LCq4LGN4LCw4LC/4LCy4LGNX+CwruCxh1/gsJzgsYLgsKjgsY1f4LCc4LGC4LCy4LGG4LGWX+CwhuCwl+CwuOCxjeCwn+CxgV/gsLjgsYbgsKrgsY3gsJ/gsYbgsILgsKzgsLDgsY1f4LCF4LCV4LGN4LCf4LGL4LCs4LCw4LGNX+CwqOCwteCwguCwrOCwsOCxjV/gsKHgsL/gsLjgsYbgsILgsKzgsLDgsY0nLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfgsJzgsKguX+Cwq+Cwv+CwrOCxjeCwsC5f4LCu4LC+4LCw4LGN4LCa4LC/X+Cwj+CwquCxjeCwsOCwvy5f4LCu4LGHX+CwnOCxguCwqOCxjV/gsJzgsYLgsLLgsYbgsZZf4LCG4LCXLl/gsLjgsYbgsKrgsY0uX+CwheCwleCxjeCwn+Cxiy5f4LCo4LC1Ll/gsKHgsL/gsLjgsYYuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICfgsIbgsKbgsL/gsLXgsL7gsLDgsIJf4LC44LGL4LCu4LC14LC+4LCw4LCCX+CwruCwguCwl+Cws+CwteCwvuCwsOCwgl/gsKzgsYHgsKfgsLXgsL7gsLDgsIJf4LCX4LGB4LCw4LGB4LC14LC+4LCw4LCCX+CwtuCxgeCwleCxjeCwsOCwteCwvuCwsOCwgl/gsLbgsKjgsL/gsLXgsL7gsLDgsIInLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+CwhuCwpuCwv1/gsLjgsYvgsK5f4LCu4LCC4LCX4LCzX+CwrOCxgeCwp1/gsJfgsYHgsLDgsYFf4LC24LGB4LCV4LGN4LCwX+CwtuCwqOCwvycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+Cwhl/gsLjgsYtf4LCu4LCCX+CwrOCxgV/gsJfgsYFf4LC24LGBX+Cwticuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0EgaDptbScsXHJcbiAgICAgICAgTFRTIDogJ0EgaDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZLCBBIGg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVksIEEgaDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vgsKjgsYfgsKHgsYFdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vgsLDgsYfgsKrgsYFdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkLCBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4LCo4LC/4LCo4LGN4LCoXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+Cwl+CwpF0gZGRkZCwgTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICclcyDgsLLgsYsnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMg4LCV4LGN4LCw4LC/4LCk4LCCJyxcclxuICAgICAgICBzIDogJ+CwleCxiuCwqOCxjeCwqOCwvyDgsJXgsY3gsLfgsKPgsL7gsLLgsYEnLFxyXG4gICAgICAgIG0gOiAn4LCS4LCVIOCwqOCwv+CwruCwv+Cwt+CwgicsXHJcbiAgICAgICAgbW0gOiAnJWQg4LCo4LC/4LCu4LC/4LC34LC+4LCy4LGBJyxcclxuICAgICAgICBoIDogJ+CwkuCwlSDgsJfgsILgsJ8nLFxyXG4gICAgICAgIGhoIDogJyVkIOCwl+CwguCwn+CwsuCxgScsXHJcbiAgICAgICAgZCA6ICfgsJLgsJUg4LCw4LGL4LCc4LGBJyxcclxuICAgICAgICBkZCA6ICclZCDgsLDgsYvgsJzgsYHgsLLgsYEnLFxyXG4gICAgICAgIE0gOiAn4LCS4LCVIOCwqOCxhuCwsicsXHJcbiAgICAgICAgTU0gOiAnJWQg4LCo4LGG4LCy4LCy4LGBJyxcclxuICAgICAgICB5IDogJ+CwkuCwlSDgsLjgsILgsLXgsKTgsY3gsLjgsLDgsIInLFxyXG4gICAgICAgIHl5IDogJyVkIOCwuOCwguCwteCwpOCxjeCwuOCwsOCwvuCwsuCxgSdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL1xcZHsxLDJ94LC1LyxcclxuICAgIG9yZGluYWwgOiAnJWTgsLUnLFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+CwsOCwvuCwpOCxjeCwsOCwv3zgsIngsKbgsK/gsIJ84LCu4LCn4LGN4LCv4LC+4LC54LGN4LCo4LCCfOCwuOCwvuCwr+CwguCwpOCxjeCwsOCwgi8sXHJcbiAgICBtZXJpZGllbUhvdXIgOiBmdW5jdGlvbiAoaG91ciwgbWVyaWRpZW0pIHtcclxuICAgICAgICBpZiAoaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJpZGllbSA9PT0gJ+CwsOCwvuCwpOCxjeCwsOCwvycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPCA0ID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4LCJ4LCm4LCv4LCCJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcclxuICAgICAgICB9IGVsc2UgaWYgKG1lcmlkaWVtID09PSAn4LCu4LCn4LGN4LCv4LC+4LC54LGN4LCo4LCCJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciA+PSAxMCA/IGhvdXIgOiBob3VyICsgMTI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+CwuOCwvuCwr+CwguCwpOCxjeCwsOCwgicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPCA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LCw4LC+4LCk4LGN4LCw4LC/JztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CwieCwpuCwr+Cwgic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChob3VyIDwgMTcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfgsK7gsKfgsY3gsK/gsL7gsLngsY3gsKjgsIInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDIwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LC44LC+4LCv4LCC4LCk4LGN4LCw4LCCJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+CwsOCwvuCwpOCxjeCwsOCwvyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0ZTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUZXR1biBEaWxpIChFYXN0IFRpbW9yKSBbdGV0XVxyXG4vLyEgYXV0aG9yIDogSm9zaHVhIEJyb29rcyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NoYnJvb2tzXHJcbi8vISBhdXRob3IgOiBPbm9yaW8gRGUgSi4gQWZvbnNvIDogaHR0cHM6Ly9naXRodWIuY29tL21hcm9ib1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHRldCA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3RldCcsIHtcclxuICAgIG1vbnRocyA6ICdKYW5laXJ1X0ZldmVyZWlydV9NYXJzdV9BYnJpbF9NYWl1X0p1bml1X0p1bGl1X0F1Z3VzdHVfU2V0ZW1icnVfT3V0dWJydV9Ob3ZlbWJydV9EZXplbWJydScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZXZfTWFyX0Ficl9NYWlfSnVuX0p1bF9BdWdfU2V0X091dF9Ob3ZfRGV6Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnRG9taW5ndV9TZWd1bmRhX1RlcnNhX0t1YXJ0YV9LaW50YV9TZXh0YV9TYWJhZHUnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0RvbV9TZWdfVGVyc19LdWFfS2ludF9TZXh0X1NhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0RvX1NlZ19UZV9LdV9LaV9TZXhfU2EnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1tPaGluIGloYV0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbQWJhbiBpaGFdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2loYV0gTFQnLFxyXG4gICAgICAgIGxhc3REYXk6ICdbSG9yaXNlaWsgaWhhXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFtzZW1hbmEga290dWtdIFtpaGFdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdpaGEgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgbGl1YmEnLFxyXG4gICAgICAgIHMgOiAnbWludXR1IGJhbHVuJyxcclxuICAgICAgICBtIDogJ21pbnV0dSBpZGEnLFxyXG4gICAgICAgIG1tIDogJ21pbnV0dXMgJWQnLFxyXG4gICAgICAgIGggOiAnaG9yYXMgaWRhJyxcclxuICAgICAgICBoaCA6ICdob3JhcyAlZCcsXHJcbiAgICAgICAgZCA6ICdsb3JvbiBpZGEnLFxyXG4gICAgICAgIGRkIDogJ2xvcm9uICVkJyxcclxuICAgICAgICBNIDogJ2Z1bGFuIGlkYScsXHJcbiAgICAgICAgTU0gOiAnZnVsYW4gJWQnLFxyXG4gICAgICAgIHkgOiAndGluYW4gaWRhJyxcclxuICAgICAgICB5eSA6ICd0aW5hbiAlZCdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0oc3R8bmR8cmR8dGgpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0ZXQ7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RldC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90ZXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUaGFpIFt0aF1cclxuLy8hIGF1dGhvciA6IEtyaWRzYWRhIFRoYW5hYnVscG9uZyA6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaXJuXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdGggPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0aCcsIHtcclxuICAgIG1vbnRocyA6ICfguKHguIHguKPguLLguITguKFf4LiB4Li44Lih4Lig4Liy4Lie4Lix4LiZ4LiY4LmMX+C4oeC4teC4meC4suC4hOC4oV/guYDguKHguKnguLLguKLguJlf4Lie4Lik4Lip4Lig4Liy4LiE4LihX+C4oeC4tOC4luC4uOC4meC4suC4ouC4mV/guIHguKPguIHguI7guLLguITguKFf4Liq4Li04LiH4Lir4Liy4LiE4LihX+C4geC4seC4meC4ouC4suC4ouC4mV/guJXguLjguKXguLLguITguKFf4Lie4Lik4Lio4LiI4Li04LiB4Liy4Lii4LiZX+C4mOC4seC4meC4p+C4suC4hOC4oScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+C4oS7guIQuX+C4gS7guJ4uX+C4oeC4tS7guIQuX+C5gOC4oS7guKIuX+C4ni7guIQuX+C4oeC4tC7guKIuX+C4gS7guIQuX+C4qi7guIQuX+C4gS7guKIuX+C4lS7guIQuX+C4ni7guKIuX+C4mC7guIQuJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ+C4reC4suC4l+C4tOC4leC4ouC5jF/guIjguLHguJnguJfguKPguYxf4Lit4Lix4LiH4LiE4Liy4LijX+C4nuC4uOC4mF/guJ7guKTguKvguLHguKrguJrguJTguLVf4Lio4Li44LiB4Lij4LmMX+C5gOC4quC4suC4o+C5jCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn4Lit4Liy4LiX4Li04LiV4Lii4LmMX+C4iOC4seC4meC4l+C4o+C5jF/guK3guLHguIfguITguLLguKNf4Lie4Li44LiYX+C4nuC4pOC4q+C4seC4ql/guKjguLjguIHguKPguYxf4LmA4Liq4Liy4Lij4LmMJy5zcGxpdCgnXycpLCAvLyB5ZXMsIHRocmVlIGNoYXJhY3RlcnMgZGlmZmVyZW5jZVxyXG4gICAgd2Vla2RheXNNaW4gOiAn4Lit4LiyLl/guIguX+C4rS5f4LieLl/guJ7guKQuX+C4qC5f4LiqLicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIOC5gOC4p+C4peC4siBIOm1tJyxcclxuICAgICAgICBMTExMIDogJ+C4p+C4seC4mWRkZGTguJfguLXguYggRCBNTU1NIFlZWVkg4LmA4Lin4Lil4LiyIEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+C4geC5iOC4reC4meC5gOC4l+C4teC5iOC4ouC4h3zguKvguKXguLHguIfguYDguJfguLXguYjguKLguIcvLFxyXG4gICAgaXNQTTogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSAn4Lir4Lil4Lix4LiH4LmA4LiX4Li14LmI4Lii4LiHJztcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICBpZiAoaG91ciA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn4LiB4LmI4Lit4LiZ4LmA4LiX4Li14LmI4Lii4LiHJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+C4q+C4peC4seC4h+C5gOC4l+C4teC5iOC4ouC4hyc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW+C4p+C4seC4meC4meC4teC5iSDguYDguKfguKXguLJdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vguJ7guKPguLjguYjguIfguJnguLXguYkg4LmA4Lin4Lil4LiyXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZFvguKvguJnguYnguLIg4LmA4Lin4Lil4LiyXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdb4LmA4Lih4Li34LmI4Lit4Lin4Liy4LiZ4LiZ4Li14LmJIOC5gOC4p+C4peC4sl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vguKfguLHguJldZGRkZFvguJfguLXguYjguYHguKXguYnguKcg4LmA4Lin4Lil4LiyXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ+C4reC4teC4gSAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclc+C4l+C4teC5iOC5geC4peC5ieC4pycsXHJcbiAgICAgICAgcyA6ICfguYTguKHguYjguIHguLXguYjguKfguLTguJnguLLguJfguLUnLFxyXG4gICAgICAgIG0gOiAnMSDguJnguLLguJfguLUnLFxyXG4gICAgICAgIG1tIDogJyVkIOC4meC4suC4l+C4tScsXHJcbiAgICAgICAgaCA6ICcxIOC4iuC4seC5iOC4p+C5guC4oeC4hycsXHJcbiAgICAgICAgaGggOiAnJWQg4LiK4Lix4LmI4Lin4LmC4Lih4LiHJyxcclxuICAgICAgICBkIDogJzEg4Lin4Lix4LiZJyxcclxuICAgICAgICBkZCA6ICclZCDguKfguLHguJknLFxyXG4gICAgICAgIE0gOiAnMSDguYDguJTguLfguK3guJknLFxyXG4gICAgICAgIE1NIDogJyVkIOC5gOC4lOC4t+C4reC4mScsXHJcbiAgICAgICAgeSA6ICcxIOC4m+C4tScsXHJcbiAgICAgICAgeXkgOiAnJWQg4Lib4Li1J1xyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0aDtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGguanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUYWdhbG9nIChQaGlsaXBwaW5lcykgW3RsLXBoXVxyXG4vLyEgYXV0aG9yIDogRGFuIEhhZ21hbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9oYWdtYW5kYW5cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB0bFBoID0gbW9tZW50LmRlZmluZUxvY2FsZSgndGwtcGgnLCB7XHJcbiAgICBtb250aHMgOiAnRW5lcm9fUGVicmVyb19NYXJzb19BYnJpbF9NYXlvX0h1bnlvX0h1bHlvX0Fnb3N0b19TZXR5ZW1icmVfT2t0dWJyZV9Ob2J5ZW1icmVfRGlzeWVtYnJlJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnRW5lX1BlYl9NYXJfQWJyX01heV9IdW5fSHVsX0Fnb19TZXRfT2t0X05vYl9EaXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdMaW5nZ29fTHVuZXNfTWFydGVzX01peWVya3VsZXNfSHV3ZWJlc19CaXllcm5lc19TYWJhZG8nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0xpbl9MdW5fTWFyX01peV9IdXdfQml5X1NhYicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0xpX0x1X01hX01pX0h1X0JpX1NhYicuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnTU0vRC9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdNTU1NIEQsIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdNTU1NIEQsIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBERCwgWVlZWSBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5OiAnTFQgW25nYXlvbmcgYXJhd10nLFxyXG4gICAgICAgIG5leHREYXk6ICdbQnVrYXMgbmddIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ0xUIFtzYSBzdXN1bm9kIG5hXSBkZGRkJyxcclxuICAgICAgICBsYXN0RGF5OiAnTFQgW2thaGFwb25dJyxcclxuICAgICAgICBsYXN0V2VlazogJ0xUIFtub29uZyBuYWthcmFhbmddIGRkZGQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ3NhIGxvb2IgbmcgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgYW5nIG5ha2FsaXBhcycsXHJcbiAgICAgICAgcyA6ICdpbGFuZyBzZWd1bmRvJyxcclxuICAgICAgICBtIDogJ2lzYW5nIG1pbnV0bycsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludXRvJyxcclxuICAgICAgICBoIDogJ2lzYW5nIG9yYXMnLFxyXG4gICAgICAgIGhoIDogJyVkIG9yYXMnLFxyXG4gICAgICAgIGQgOiAnaXNhbmcgYXJhdycsXHJcbiAgICAgICAgZGQgOiAnJWQgYXJhdycsXHJcbiAgICAgICAgTSA6ICdpc2FuZyBidXdhbicsXHJcbiAgICAgICAgTU0gOiAnJWQgYnV3YW4nLFxyXG4gICAgICAgIHkgOiAnaXNhbmcgdGFvbicsXHJcbiAgICAgICAgeXkgOiAnJWQgdGFvbidcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0vLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0bFBoO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bC1waC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bC1waC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IEtsaW5nb24gW3RsaF1cclxuLy8hIGF1dGhvciA6IERvbWluaWthIEtydWsgOiBodHRwczovL2dpdGh1Yi5jb20vYW1hcmFudGhyb3NlXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgbnVtYmVyc05vdW5zID0gJ3BhZ2hfd2HigJlfY2hh4oCZX3dlal9sb1NfdmFnaF9qYXZfU29jaF9jaG9yZ2hfSHV0Jy5zcGxpdCgnXycpO1xyXG5cclxuZnVuY3Rpb24gdHJhbnNsYXRlRnV0dXJlKG91dHB1dCkge1xyXG4gICAgdmFyIHRpbWUgPSBvdXRwdXQ7XHJcbiAgICB0aW1lID0gKG91dHB1dC5pbmRleE9mKCdqYWonKSAhPT0gLTEpID9cclxuICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ2xlUycgOlxyXG4gICAgKG91dHB1dC5pbmRleE9mKCdqYXInKSAhPT0gLTEpID9cclxuICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ3dhUScgOlxyXG4gICAgKG91dHB1dC5pbmRleE9mKCdESVMnKSAhPT0gLTEpID9cclxuICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ25lbScgOlxyXG4gICAgdGltZSArICcgcElxJztcclxuICAgIHJldHVybiB0aW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2xhdGVQYXN0KG91dHB1dCkge1xyXG4gICAgdmFyIHRpbWUgPSBvdXRwdXQ7XHJcbiAgICB0aW1lID0gKG91dHB1dC5pbmRleE9mKCdqYWonKSAhPT0gLTEpID9cclxuICAgIHRpbWUuc2xpY2UoMCwgLTMpICsgJ0h14oCZJyA6XHJcbiAgICAob3V0cHV0LmluZGV4T2YoJ2phcicpICE9PSAtMSkgP1xyXG4gICAgdGltZS5zbGljZSgwLCAtMykgKyAnd2VuJyA6XHJcbiAgICAob3V0cHV0LmluZGV4T2YoJ0RJUycpICE9PSAtMSkgP1xyXG4gICAgdGltZS5zbGljZSgwLCAtMykgKyAnYmVuJyA6XHJcbiAgICB0aW1lICsgJyByZXQnO1xyXG4gICAgcmV0dXJuIHRpbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zbGF0ZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcclxuICAgIHZhciBudW1iZXJOb3VuID0gbnVtYmVyQXNOb3VuKG51bWJlcik7XHJcbiAgICBzd2l0Y2ggKHN0cmluZykge1xyXG4gICAgICAgIGNhc2UgJ21tJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIHR1cCc7XHJcbiAgICAgICAgY2FzZSAnaGgnOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTm91biArICcgcmVwJztcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJOb3VuICsgJyBqYWonO1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlck5vdW4gKyAnIGphcic7XHJcbiAgICAgICAgY2FzZSAneXknOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyTm91biArICcgRElTJztcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbnVtYmVyQXNOb3VuKG51bWJlcikge1xyXG4gICAgdmFyIGh1bmRyZWQgPSBNYXRoLmZsb29yKChudW1iZXIgJSAxMDAwKSAvIDEwMCksXHJcbiAgICB0ZW4gPSBNYXRoLmZsb29yKChudW1iZXIgJSAxMDApIC8gMTApLFxyXG4gICAgb25lID0gbnVtYmVyICUgMTAsXHJcbiAgICB3b3JkID0gJyc7XHJcbiAgICBpZiAoaHVuZHJlZCA+IDApIHtcclxuICAgICAgICB3b3JkICs9IG51bWJlcnNOb3Vuc1todW5kcmVkXSArICd2YXRsaCc7XHJcbiAgICB9XHJcbiAgICBpZiAodGVuID4gMCkge1xyXG4gICAgICAgIHdvcmQgKz0gKCh3b3JkICE9PSAnJykgPyAnICcgOiAnJykgKyBudW1iZXJzTm91bnNbdGVuXSArICdtYUgnO1xyXG4gICAgfVxyXG4gICAgaWYgKG9uZSA+IDApIHtcclxuICAgICAgICB3b3JkICs9ICgod29yZCAhPT0gJycpID8gJyAnIDogJycpICsgbnVtYmVyc05vdW5zW29uZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKHdvcmQgPT09ICcnKSA/ICdwYWdoJyA6IHdvcmQ7XHJcbn1cclxuXHJcbnZhciB0bGggPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0bGgnLCB7XHJcbiAgICBtb250aHMgOiAndGVyYeKAmSBqYXIgd2HigJlfdGVyYeKAmSBqYXIgY2hh4oCZX3RlcmHigJkgamFyIHdlal90ZXJh4oCZIGphciBsb1NfdGVyYeKAmSBqYXIgdmFnaF90ZXJh4oCZIGphciBqYXZfdGVyYeKAmSBqYXIgU29jaF90ZXJh4oCZIGphciBjaG9yZ2hfdGVyYeKAmSBqYXIgSHV0X3RlcmHigJkgamFyIHdh4oCZbWFIX3RlcmHigJkgamFyIHdh4oCZbWFIIHdh4oCZX3RlcmHigJkgamFyIHdh4oCZbWFIIGNoYeKAmScuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ2phciB3YeKAmV9qYXIgY2hh4oCZX2phciB3ZWpfamFyIGxvU19qYXIgdmFnaF9qYXIgamF2X2phciBTb2NoX2phciBjaG9yZ2hfamFyIEh1dF9qYXIgd2HigJltYUhfamFyIHdh4oCZbWFIIHdh4oCZX2phciB3YeKAmW1hSCBjaGHigJknLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2xvam1JdGphal9EYVNqYWpfcG92amFqX2doSXRsaGphal9sb2doamFqX2J1cWphal9naEluamFqJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdsb2ptSXRqYWpfRGFTamFqX3Bvdmphal9naEl0bGhqYWpfbG9naGphal9idXFqYWpfZ2hJbmphaicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ2xvam1JdGphal9EYVNqYWpfcG92amFqX2doSXRsaGphal9sb2doamFqX2J1cWphal9naEluamFqJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbRGFIamFqXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1t3YeKAmWxlU10gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnTExMJyxcclxuICAgICAgICBsYXN0RGF5OiAnW3dh4oCZSHXigJldIExUJyxcclxuICAgICAgICBsYXN0V2VlazogJ0xMTCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiB0cmFuc2xhdGVGdXR1cmUsXHJcbiAgICAgICAgcGFzdCA6IHRyYW5zbGF0ZVBhc3QsXHJcbiAgICAgICAgcyA6ICdwdVMgbHVwJyxcclxuICAgICAgICBtIDogJ3dh4oCZIHR1cCcsXHJcbiAgICAgICAgbW0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgaCA6ICd3YeKAmSByZXAnLFxyXG4gICAgICAgIGhoIDogdHJhbnNsYXRlLFxyXG4gICAgICAgIGQgOiAnd2HigJkgamFqJyxcclxuICAgICAgICBkZCA6IHRyYW5zbGF0ZSxcclxuICAgICAgICBNIDogJ3dh4oCZIGphcicsXHJcbiAgICAgICAgTU0gOiB0cmFuc2xhdGUsXHJcbiAgICAgICAgeSA6ICd3YeKAmSBESVMnLFxyXG4gICAgICAgIHl5IDogdHJhbnNsYXRlXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9XFwuLyxcclxuICAgIG9yZGluYWwgOiAnJWQuJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0bGg7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3RsaC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90bGguanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUdXJraXNoIFt0cl1cclxuLy8hIGF1dGhvcnMgOiBFcmhhbiBHdW5kb2dhbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9lcmhhbmd1bmRvZ2FuLFxyXG4vLyEgICAgICAgICAgIEJ1cmFrIFlpxJ9pdCBLYXlhOiBodHRwczovL2dpdGh1Yi5jb20vQllLXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgc3VmZml4ZXMgPSB7XHJcbiAgICAxOiAnXFwnaW5jaScsXHJcbiAgICA1OiAnXFwnaW5jaScsXHJcbiAgICA4OiAnXFwnaW5jaScsXHJcbiAgICA3MDogJ1xcJ2luY2knLFxyXG4gICAgODA6ICdcXCdpbmNpJyxcclxuICAgIDI6ICdcXCduY2knLFxyXG4gICAgNzogJ1xcJ25jaScsXHJcbiAgICAyMDogJ1xcJ25jaScsXHJcbiAgICA1MDogJ1xcJ25jaScsXHJcbiAgICAzOiAnXFwnw7xuY8O8JyxcclxuICAgIDQ6ICdcXCfDvG5jw7wnLFxyXG4gICAgMTAwOiAnXFwnw7xuY8O8JyxcclxuICAgIDY6ICdcXCduY8SxJyxcclxuICAgIDk6ICdcXCd1bmN1JyxcclxuICAgIDEwOiAnXFwndW5jdScsXHJcbiAgICAzMDogJ1xcJ3VuY3UnLFxyXG4gICAgNjA6ICdcXCfEsW5jxLEnLFxyXG4gICAgOTA6ICdcXCfEsW5jxLEnXHJcbn07XHJcblxyXG52YXIgdHIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0cicsIHtcclxuICAgIG1vbnRocyA6ICdPY2FrX8WedWJhdF9NYXJ0X05pc2FuX01hecSxc19IYXppcmFuX1RlbW11el9BxJ91c3Rvc19FeWzDvGxfRWtpbV9LYXPEsW1fQXJhbMSxaycuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ09jYV/FnnViX01hcl9OaXNfTWF5X0hhel9UZW1fQcSfdV9FeWxfRWtpX0thc19BcmEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdQYXphcl9QYXphcnRlc2lfU2FsxLFfw4dhcsWfYW1iYV9QZXLFn2VtYmVfQ3VtYV9DdW1hcnRlc2knLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ1Bhel9QdHNfU2FsX8OHYXJfUGVyX0N1bV9DdHMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdQel9QdF9TYV/Dh2FfUGVfQ3VfQ3QnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbYnVnw7xuIHNhYXRdIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1t5YXLEsW4gc2FhdF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1tnZWxlY2VrXSBkZGRkIFtzYWF0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbZMO8bl0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tnZcOnZW5dIGRkZGQgW3NhYXRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXMgc29ucmEnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMgw7ZuY2UnLFxyXG4gICAgICAgIHMgOiAnYmlya2HDpyBzYW5peWUnLFxyXG4gICAgICAgIG0gOiAnYmlyIGRha2lrYScsXHJcbiAgICAgICAgbW0gOiAnJWQgZGFraWthJyxcclxuICAgICAgICBoIDogJ2JpciBzYWF0JyxcclxuICAgICAgICBoaCA6ICclZCBzYWF0JyxcclxuICAgICAgICBkIDogJ2JpciBnw7xuJyxcclxuICAgICAgICBkZCA6ICclZCBnw7xuJyxcclxuICAgICAgICBNIDogJ2JpciBheScsXHJcbiAgICAgICAgTU0gOiAnJWQgYXknLFxyXG4gICAgICAgIHkgOiAnYmlyIHnEsWwnLFxyXG4gICAgICAgIHl5IDogJyVkIHnEsWwnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9JyhpbmNpfG5jaXzDvG5jw7x8bmPEsXx1bmN1fMSxbmPEsSkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICBpZiAobnVtYmVyID09PSAwKSB7ICAvLyBzcGVjaWFsIGNhc2UgZm9yIHplcm9cclxuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICdcXCfEsW5jxLEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYSA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBiID0gbnVtYmVyICUgMTAwIC0gYSxcclxuICAgICAgICAgICAgYyA9IG51bWJlciA+PSAxMDAgPyAxMDAgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAoc3VmZml4ZXNbYV0gfHwgc3VmZml4ZXNbYl0gfHwgc3VmZml4ZXNbY10pO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0cjtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBUYWxvc3NhbiBbdHpsXVxyXG4vLyEgYXV0aG9yIDogUm9iaW4gdmFuIGRlciBWbGlldCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9yb2JpbjB2YW4wZGVyMHZcclxuLy8hIGF1dGhvciA6IEl1c3TDrCBDYW51blxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxuLy8gQWZ0ZXIgdGhlIHllYXIgdGhlcmUgc2hvdWxkIGJlIGEgc2xhc2ggYW5kIHRoZSBhbW91bnQgb2YgeWVhcnMgc2luY2UgRGVjZW1iZXIgMjYsIDE5NzkgaW4gUm9tYW4gbnVtZXJhbHMuXHJcbi8vIFRoaXMgaXMgY3VycmVudGx5IHRvbyBkaWZmaWN1bHQgKG1heWJlIGV2ZW4gaW1wb3NzaWJsZSkgdG8gYWRkLlxyXG52YXIgdHpsID0gbW9tZW50LmRlZmluZUxvY2FsZSgndHpsJywge1xyXG4gICAgbW9udGhzIDogJ0phbnVhcl9GZXZyYWdsaF9NYXLDp19BdnLDr3VfTWFpX0fDvG5fSnVsaWFfR3VzY2h0X1NldGVtdmFyX0xpc3RvcMOkdHNfTm9lbXZhcl9aZWNlbXZhcicuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ0phbl9GZXZfTWFyX0F2cl9NYWlfR8O8bl9KdWxfR3VzX1NldF9MaXNfTm9lX1plYycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ1PDumxhZGlfTMO6bmXDp2lfTWFpdHppX03DoXJjdXJpX1how7phZGlfVmnDqW5lcsOnaV9Tw6F0dXJpJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTw7psX0zDum5fTWFpX03DoXJfWGjDul9WacOpX1PDoXQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdTw7pfTMO6X01hX03DoV9YaF9WaV9Tw6EnLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISC5tbScsXHJcbiAgICAgICAgTFRTIDogJ0hILm1tLnNzJyxcclxuICAgICAgICBMIDogJ0RELk1NLllZWVknLFxyXG4gICAgICAgIExMIDogJ0QuIE1NTU0gW2RhbGxhc10gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QuIE1NTU0gW2RhbGxhc10gWVlZWSBISC5tbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkLCBbbGldIEQuIE1NTU0gW2RhbGxhc10gWVlZWSBISC5tbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvZFxcJ298ZFxcJ2EvaSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJ2RcXCdvJyA9PT0gaW5wdXQudG9Mb3dlckNhc2UoKTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2RcXCdvJyA6ICdEXFwnTyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnZFxcJ2EnIDogJ0RcXCdBJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdbb3hoaSDDoF0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW2RlbcOgIMOgXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbw6BdIExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1tpZWlyaSDDoF0gTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1tzw7xyIGVsXSBkZGRkIFtsYXN0ZXUgw6BdIExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnb3NwcmVpICVzJyxcclxuICAgICAgICBwYXN0IDogJ2phJXMnLFxyXG4gICAgICAgIHMgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIG1tIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICBoaCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZCA6IHByb2Nlc3NSZWxhdGl2ZVRpbWUsXHJcbiAgICAgICAgZGQgOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE0gOiBwcm9jZXNzUmVsYXRpdmVUaW1lLFxyXG4gICAgICAgIE1NIDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5IDogcHJvY2Vzc1JlbGF0aXZlVGltZSxcclxuICAgICAgICB5eSA6IHByb2Nlc3NSZWxhdGl2ZVRpbWVcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn1cXC4vLFxyXG4gICAgb3JkaW5hbCA6ICclZC4nLFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSwgaXNGdXR1cmUpIHtcclxuICAgIHZhciBmb3JtYXQgPSB7XHJcbiAgICAgICAgJ3MnOiBbJ3ZpZW5zYXMgc2VjdW5kcycsICdcXCdpZW5zYXMgc2VjdW5kcyddLFxyXG4gICAgICAgICdtJzogWydcXCduIG3DrXV0JywgJ1xcJ2llbnMgbcOtdXQnXSxcclxuICAgICAgICAnbW0nOiBbbnVtYmVyICsgJyBtw611dHMnLCAnJyArIG51bWJlciArICcgbcOtdXRzJ10sXHJcbiAgICAgICAgJ2gnOiBbJ1xcJ24gw75vcmEnLCAnXFwnaWVuc2Egw75vcmEnXSxcclxuICAgICAgICAnaGgnOiBbbnVtYmVyICsgJyDDvm9yYXMnLCAnJyArIG51bWJlciArICcgw75vcmFzJ10sXHJcbiAgICAgICAgJ2QnOiBbJ1xcJ24geml1YScsICdcXCdpZW5zYSB6aXVhJ10sXHJcbiAgICAgICAgJ2RkJzogW251bWJlciArICcgeml1YXMnLCAnJyArIG51bWJlciArICcgeml1YXMnXSxcclxuICAgICAgICAnTSc6IFsnXFwnbiBtZXMnLCAnXFwnaWVucyBtZXMnXSxcclxuICAgICAgICAnTU0nOiBbbnVtYmVyICsgJyBtZXNlbicsICcnICsgbnVtYmVyICsgJyBtZXNlbiddLFxyXG4gICAgICAgICd5JzogWydcXCduIGFyJywgJ1xcJ2llbnMgYXInXSxcclxuICAgICAgICAneXknOiBbbnVtYmVyICsgJyBhcnMnLCAnJyArIG51bWJlciArICcgYXJzJ11cclxuICAgIH07XHJcbiAgICByZXR1cm4gaXNGdXR1cmUgPyBmb3JtYXRba2V5XVswXSA6ICh3aXRob3V0U3VmZml4ID8gZm9ybWF0W2tleV1bMF0gOiBmb3JtYXRba2V5XVsxXSk7XHJcbn1cclxuXHJcbnJldHVybiB0emw7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90emwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBDZW50cmFsIEF0bGFzIFRhbWF6aWdodCBMYXRpbiBbdHptLWxhdG5dXHJcbi8vISBhdXRob3IgOiBBYmRlbCBTYWlkIDogaHR0cHM6Ly9naXRodWIuY29tL2FiZGVsc2FpZFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHR6bUxhdG4gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd0em0tbGF0bicsIHtcclxuICAgIG1vbnRocyA6ICdpbm5heXJfYnLLpGF5csukX21hcsukc8ukX2licmlyX21heXl3X3l3bnl3X3l3bHl3el/Jo3fFoXRfxaF3dGFuYmlyX2t0y6R3YnLLpF9ud3dhbmJpcl9kd2puYmlyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnaW5uYXlyX2Jyy6RheXLLpF9tYXLLpHPLpF9pYnJpcl9tYXl5d195d255d195d2x5d3pfyaN3xaF0X8Whd3RhbmJpcl9rdMukd2Jyy6Rfbnd3YW5iaXJfZHdqbmJpcicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ2FzYW1hc19heW5hc19hc2luYXNfYWtyYXNfYWt3YXNfYXNpbXdhc19hc2nhuI15YXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ2FzYW1hc19heW5hc19hc2luYXNfYWtyYXNfYWt3YXNfYXNpbXdhc19hc2nhuI15YXMnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdhc2FtYXNfYXluYXNfYXNpbmFzX2FrcmFzX2Frd2FzX2FzaW13YXNfYXNp4biNeWFzJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogJ1thc2RraCBnXSBMVCcsXHJcbiAgICAgICAgbmV4dERheTogJ1thc2thIGddIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2ddIExUJyxcclxuICAgICAgICBsYXN0RGF5OiAnW2Fzc2FudCBnXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFtnXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnZGFka2ggcyB5YW4gJXMnLFxyXG4gICAgICAgIHBhc3QgOiAneWFuICVzJyxcclxuICAgICAgICBzIDogJ2ltaWsnLFxyXG4gICAgICAgIG0gOiAnbWludeG4jScsXHJcbiAgICAgICAgbW0gOiAnJWQgbWludeG4jScsXHJcbiAgICAgICAgaCA6ICdzYcmbYScsXHJcbiAgICAgICAgaGggOiAnJWQgdGFzc2HJm2luJyxcclxuICAgICAgICBkIDogJ2FzcycsXHJcbiAgICAgICAgZGQgOiAnJWQgb3NzYW4nLFxyXG4gICAgICAgIE0gOiAnYXlvd3InLFxyXG4gICAgICAgIE1NIDogJyVkIGl5eWlybicsXHJcbiAgICAgICAgeSA6ICdhc2dhcycsXHJcbiAgICAgICAgeXkgOiAnJWQgaXNnYXNuJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiAxMiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB0em1MYXRuO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0tbGF0bi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS90em0tbGF0bi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IENlbnRyYWwgQXRsYXMgVGFtYXppZ2h0IFt0em1dXHJcbi8vISBhdXRob3IgOiBBYmRlbCBTYWlkIDogaHR0cHM6Ly9naXRodWIuY29tL2FiZGVsc2FpZFxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHR6bSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3R6bScsIHtcclxuICAgIG1vbnRocyA6ICfitYnitY/itY/itLDitaLitZRf4rSx4rWV4rSw4rWi4rWVX+K1juK0sOK1leK1ml/itYnitLHitZTitYnitZRf4rWO4rSw4rWi4rWi4rWTX+K1ouK1k+K1j+K1ouK1k1/itaLitZPitY3itaLitZPitaNf4rWW4rWT4rWb4rWcX+K1m+K1k+K1nOK0sOK1j+K0seK1ieK1lF/itL3itZ/itZPitLHitZVf4rWP4rWT4rWh4rSw4rWP4rSx4rWJ4rWUX+K0t+K1k+K1iuK1j+K0seK1ieK1lCcuc3BsaXQoJ18nKSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ+K1ieK1j+K1j+K0sOK1ouK1lF/itLHitZXitLDitaLitZVf4rWO4rSw4rWV4rWaX+K1ieK0seK1lOK1ieK1lF/itY7itLDitaLitaLitZNf4rWi4rWT4rWP4rWi4rWTX+K1ouK1k+K1jeK1ouK1k+K1o1/itZbitZPitZvitZxf4rWb4rWT4rWc4rSw4rWP4rSx4rWJ4rWUX+K0veK1n+K1k+K0seK1lV/itY/itZPitaHitLDitY/itLHitYnitZRf4rS34rWT4rWK4rWP4rSx4rWJ4rWUJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAn4rSw4rWZ4rSw4rWO4rSw4rWZX+K0sOK1ouK1j+K0sOK1mV/itLDitZnitYnitY/itLDitZlf4rSw4rS94rWU4rSw4rWZX+K0sOK0veK1oeK0sOK1mV/itLDitZnitYnitY7itaHitLDitZlf4rSw4rWZ4rWJ4rS54rWi4rSw4rWZJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfitLDitZnitLDitY7itLDitZlf4rSw4rWi4rWP4rSw4rWZX+K0sOK1meK1ieK1j+K0sOK1mV/itLDitL3itZTitLDitZlf4rSw4rS94rWh4rSw4rWZX+K0sOK1meK1ieK1juK1oeK0sOK1mV/itLDitZnitYnitLnitaLitLDitZknLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfitLDitZnitLDitY7itLDitZlf4rSw4rWi4rWP4rSw4rWZX+K0sOK1meK1ieK1j+K0sOK1mV/itLDitL3itZTitLDitZlf4rSw4rS94rWh4rSw4rWZX+K0sOK1meK1ieK1juK1oeK0sOK1mV/itLDitZnitYnitLnitaLitLDitZknLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdkZGRkIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdb4rSw4rWZ4rS34rWFIOK0tF0gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdb4rSw4rWZ4rS94rSwIOK0tF0gTFQnLFxyXG4gICAgICAgIG5leHRXZWVrOiAnZGRkZCBb4rS0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1vitLDitZritLDitY/itZwg4rS0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFvitLRdIExUJyxcclxuICAgICAgICBzYW1lRWxzZTogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICfitLfitLDitLfitYUg4rWZIOK1ouK0sOK1jyAlcycsXHJcbiAgICAgICAgcGFzdCA6ICfitaLitLDitY8gJXMnLFxyXG4gICAgICAgIHMgOiAn4rWJ4rWO4rWJ4rS9JyxcclxuICAgICAgICBtIDogJ+K1juK1ieK1j+K1k+K0uicsXHJcbiAgICAgICAgbW0gOiAnJWQg4rWO4rWJ4rWP4rWT4rS6JyxcclxuICAgICAgICBoIDogJ+K1meK0sOK1hOK0sCcsXHJcbiAgICAgICAgaGggOiAnJWQg4rWc4rSw4rWZ4rWZ4rSw4rWE4rWJ4rWPJyxcclxuICAgICAgICBkIDogJ+K0sOK1meK1mScsXHJcbiAgICAgICAgZGQgOiAnJWQgb+K1meK1meK0sOK1jycsXHJcbiAgICAgICAgTSA6ICfitLDitaJv4rWT4rWUJyxcclxuICAgICAgICBNTSA6ICclZCDitYnitaLitaLitYnitZTitY8nLFxyXG4gICAgICAgIHkgOiAn4rSw4rWZ4rSz4rSw4rWZJyxcclxuICAgICAgICB5eSA6ICclZCDitYnitZnitLPitLDitZnitY8nXHJcbiAgICB9LFxyXG4gICAgd2VlayA6IHtcclxuICAgICAgICBkb3cgOiA2LCAvLyBTYXR1cmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDEyICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHR6bTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdHptLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3R6bS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFVrcmFpbmlhbiBbdWtdXHJcbi8vISBhdXRob3IgOiB6ZW1sYW5pbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS96ZW1sYW5pblxyXG4vLyEgQXV0aG9yIDogTWVuZWxpb24gRWxlbnPDumxlIDogaHR0cHM6Ly9naXRodWIuY29tL09pcmVcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHBsdXJhbCh3b3JkLCBudW0pIHtcclxuICAgIHZhciBmb3JtcyA9IHdvcmQuc3BsaXQoJ18nKTtcclxuICAgIHJldHVybiBudW0gJSAxMCA9PT0gMSAmJiBudW0gJSAxMDAgIT09IDExID8gZm9ybXNbMF0gOiAobnVtICUgMTAgPj0gMiAmJiBudW0gJSAxMCA8PSA0ICYmIChudW0gJSAxMDAgPCAxMCB8fCBudW0gJSAxMDAgPj0gMjApID8gZm9ybXNbMV0gOiBmb3Jtc1syXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lV2l0aFBsdXJhbChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGtleSkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHtcclxuICAgICAgICAnbW0nOiB3aXRob3V0U3VmZml4ID8gJ9GF0LLQuNC70LjQvdCwX9GF0LLQuNC70LjQvdC4X9GF0LLQuNC70LjQvScgOiAn0YXQstC40LvQuNC90YNf0YXQstC40LvQuNC90Lhf0YXQstC40LvQuNC9JyxcclxuICAgICAgICAnaGgnOiB3aXRob3V0U3VmZml4ID8gJ9Cz0L7QtNC40L3QsF/Qs9C+0LTQuNC90Lhf0LPQvtC00LjQvScgOiAn0LPQvtC00LjQvdGDX9Cz0L7QtNC40L3QuF/Qs9C+0LTQuNC9JyxcclxuICAgICAgICAnZGQnOiAn0LTQtdC90Yxf0LTQvdGWX9C00L3RltCyJyxcclxuICAgICAgICAnTU0nOiAn0LzRltGB0Y/RhtGMX9C80ZbRgdGP0YbRll/QvNGW0YHRj9GG0ZbQsicsXHJcbiAgICAgICAgJ3l5JzogJ9GA0ZbQul/RgNC+0LrQuF/RgNC+0LrRltCyJ1xyXG4gICAgfTtcclxuICAgIGlmIChrZXkgPT09ICdtJykge1xyXG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9GF0LLQuNC70LjQvdCwJyA6ICfRhdCy0LjQu9C40L3Rgyc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdoJykge1xyXG4gICAgICAgIHJldHVybiB3aXRob3V0U3VmZml4ID8gJ9Cz0L7QtNC40L3QsCcgOiAn0LPQvtC00LjQvdGDJztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyAnICcgKyBwbHVyYWwoZm9ybWF0W2tleV0sICtudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHdlZWtkYXlzQ2FzZVJlcGxhY2UobSwgZm9ybWF0KSB7XHJcbiAgICB2YXIgd2Vla2RheXMgPSB7XHJcbiAgICAgICAgJ25vbWluYXRpdmUnOiAn0L3QtdC00ZbQu9GPX9C/0L7QvdC10LTRltC70L7Qul/QstGW0LLRgtC+0YDQvtC6X9GB0LXRgNC10LTQsF/Rh9C10YLQstC10YBf0L/igJnRj9GC0L3QuNGG0Y9f0YHRg9Cx0L7RgtCwJy5zcGxpdCgnXycpLFxyXG4gICAgICAgICdhY2N1c2F0aXZlJzogJ9C90LXQtNGW0LvRjl/Qv9C+0L3QtdC00ZbQu9C+0Lpf0LLRltCy0YLQvtGA0L7Qul/RgdC10YDQtdC00YNf0YfQtdGC0LLQtdGAX9C/4oCZ0Y/RgtC90LjRhtGOX9GB0YPQsdC+0YLRgycuc3BsaXQoJ18nKSxcclxuICAgICAgICAnZ2VuaXRpdmUnOiAn0L3QtdC00ZbQu9GWX9C/0L7QvdC10LTRltC70LrQsF/QstGW0LLRgtC+0YDQutCwX9GB0LXRgNC10LTQuF/Rh9C10YLQstC10YDQs9CwX9C/4oCZ0Y/RgtC90LjRhtGWX9GB0YPQsdC+0YLQuCcuc3BsaXQoJ18nKVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoIW0pIHtcclxuICAgICAgICByZXR1cm4gd2Vla2RheXNbJ25vbWluYXRpdmUnXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbm91bkNhc2UgPSAoLyhcXFtb0JLQstCj0YNdXFxdKSA/ZGRkZC8pLnRlc3QoZm9ybWF0KSA/XHJcbiAgICAgICAgJ2FjY3VzYXRpdmUnIDpcclxuICAgICAgICAoKC9cXFs/KD860LzQuNC90YPQu9C+0Zd80L3QsNGB0YLRg9C/0L3QvtGXKT8gP1xcXSA/ZGRkZC8pLnRlc3QoZm9ybWF0KSA/XHJcbiAgICAgICAgICAgICdnZW5pdGl2ZScgOlxyXG4gICAgICAgICAgICAnbm9taW5hdGl2ZScpO1xyXG4gICAgcmV0dXJuIHdlZWtkYXlzW25vdW5DYXNlXVttLmRheSgpXTtcclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzSG91cnNGdW5jdGlvbihzdHIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ciArICfQvicgKyAodGhpcy5ob3VycygpID09PSAxMSA/ICfQsScgOiAnJykgKyAnXSBMVCc7XHJcbiAgICB9O1xyXG59XHJcblxyXG52YXIgdWsgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd1aycsIHtcclxuICAgIG1vbnRocyA6IHtcclxuICAgICAgICAnZm9ybWF0JzogJ9GB0ZbRh9C90Y9f0LvRjtGC0L7Qs9C+X9Cx0LXRgNC10LfQvdGPX9C60LLRltGC0L3Rj1/RgtGA0LDQstC90Y9f0YfQtdGA0LLQvdGPX9C70LjQv9C90Y9f0YHQtdGA0L/QvdGPX9Cy0LXRgNC10YHQvdGPX9C20L7QstGC0L3Rj1/Qu9C40YHRgtC+0L/QsNC00LBf0LPRgNGD0LTQvdGPJy5zcGxpdCgnXycpLFxyXG4gICAgICAgICdzdGFuZGFsb25lJzogJ9GB0ZbRh9C10L3RjF/Qu9GO0YLQuNC5X9Cx0LXRgNC10LfQtdC90Yxf0LrQstGW0YLQtdC90Yxf0YLRgNCw0LLQtdC90Yxf0YfQtdGA0LLQtdC90Yxf0LvQuNC/0LXQvdGMX9GB0LXRgNC/0LXQvdGMX9Cy0LXRgNC10YHQtdC90Yxf0LbQvtCy0YLQtdC90Yxf0LvQuNGB0YLQvtC/0LDQtF/Qs9GA0YPQtNC10L3RjCcuc3BsaXQoJ18nKVxyXG4gICAgfSxcclxuICAgIG1vbnRoc1Nob3J0IDogJ9GB0ZbRh1/Qu9GO0YJf0LHQtdGAX9C60LLRltGCX9GC0YDQsNCyX9GH0LXRgNCyX9C70LjQv1/RgdC10YDQv1/QstC10YBf0LbQvtCy0YJf0LvQuNGB0YJf0LPRgNGD0LQnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6IHdlZWtkYXlzQ2FzZVJlcGxhY2UsXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ9C90LRf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQvdC0X9C/0L1f0LLRgl/RgdGAX9GH0YJf0L/Rgl/RgdCxJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC5NTS5ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWSDRgC4nLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSDRgC4sIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZINGALiwgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheTogcHJvY2Vzc0hvdXJzRnVuY3Rpb24oJ1vQodGM0L7Qs9C+0LTQvdGWICcpLFxyXG4gICAgICAgIG5leHREYXk6IHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JfQsNCy0YLRgNCwICcpLFxyXG4gICAgICAgIGxhc3REYXk6IHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JLRh9C+0YDQsCAnKSxcclxuICAgICAgICBuZXh0V2VlazogcHJvY2Vzc0hvdXJzRnVuY3Rpb24oJ1vQo10gZGRkZCBbJyksXHJcbiAgICAgICAgbGFzdFdlZWs6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmRheSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JzQuNC90YPQu9C+0ZddIGRkZGQgWycpLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NIb3Vyc0Z1bmN0aW9uKCdb0JzQuNC90YPQu9C+0LPQvl0gZGRkZCBbJykuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZUVsc2U6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn0LfQsCAlcycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDRgtC+0LzRgycsXHJcbiAgICAgICAgcyA6ICfQtNC10LrRltC70YzQutCwINGB0LXQutGD0L3QtCcsXHJcbiAgICAgICAgbSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgbW0gOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIGggOiAn0LPQvtC00LjQvdGDJyxcclxuICAgICAgICBoaCA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgZCA6ICfQtNC10L3RjCcsXHJcbiAgICAgICAgZGQgOiByZWxhdGl2ZVRpbWVXaXRoUGx1cmFsLFxyXG4gICAgICAgIE0gOiAn0LzRltGB0Y/RhtGMJyxcclxuICAgICAgICBNTSA6IHJlbGF0aXZlVGltZVdpdGhQbHVyYWwsXHJcbiAgICAgICAgeSA6ICfRgNGW0LonLFxyXG4gICAgICAgIHl5IDogcmVsYXRpdmVUaW1lV2l0aFBsdXJhbFxyXG4gICAgfSxcclxuICAgIC8vIE0uIEUuOiB0aG9zZSB0d28gYXJlIHZpcnR1YWxseSB1bnVzZWQgYnV0IGEgdXNlciBtaWdodCB3YW50IHRvIGltcGxlbWVudCB0aGVtIGZvciBoaXMvaGVyIHdlYnNpdGUgZm9yIHNvbWUgcmVhc29uXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv0L3QvtGH0ZZ80YDQsNC90LrRg3zQtNC90Y980LLQtdGH0L7RgNCwLyxcclxuICAgIGlzUE06IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAvXijQtNC90Y980LLQtdGH0L7RgNCwKSQvLnRlc3QoaW5wdXQpO1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9C90L7Rh9GWJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9GA0LDQvdC60YMnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA8IDE3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn0LTQvdGPJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ9Cy0LXRh9C+0YDQsCc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfS0o0Ll80LPQvikvLFxyXG4gICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICBjYXNlICd3JzpcclxuICAgICAgICAgICAgY2FzZSAnVyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJy3QuSc7XHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICct0LPQvic7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdWs7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VrLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VrLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVXJkdSBbdXJdXHJcbi8vISBhdXRob3IgOiBTYXdvb2QgQWxhbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9pYm5lc2F5ZWVkXHJcbi8vISBhdXRob3IgOiBaYWNrIDogaHR0cHM6Ly9naXRodWIuY29tL1phY2tWaXNpb25cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciBtb250aHMgPSBbXHJcbiAgICAn2KzZhtmI2LHbjCcsXHJcbiAgICAn2YHYsdmI2LHbjCcsXHJcbiAgICAn2YXYp9ix2oYnLFxyXG4gICAgJ9in2b7YsduM2YQnLFxyXG4gICAgJ9mF2KbbjCcsXHJcbiAgICAn2KzZiNmGJyxcclxuICAgICfYrNmI2YTYp9im24wnLFxyXG4gICAgJ9in2q/Ys9iqJyxcclxuICAgICfYs9iq2YXYqNixJyxcclxuICAgICfYp9qp2KrZiNio2LEnLFxyXG4gICAgJ9mG2YjZhdio2LEnLFxyXG4gICAgJ9iv2LPZhdio2LEnXHJcbl07XHJcbnZhciBkYXlzID0gW1xyXG4gICAgJ9in2KrZiNin2LEnLFxyXG4gICAgJ9m+24zYsScsXHJcbiAgICAn2YXZhtqv2YQnLFxyXG4gICAgJ9io2K/avicsXHJcbiAgICAn2KzZhdi52LHYp9iqJyxcclxuICAgICfYrNmF2LnbgScsXHJcbiAgICAn24HZgdiq24EnXHJcbl07XHJcblxyXG52YXIgdXIgPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd1cicsIHtcclxuICAgIG1vbnRocyA6IG1vbnRocyxcclxuICAgIG1vbnRoc1Nob3J0IDogbW9udGhzLFxyXG4gICAgd2Vla2RheXMgOiBkYXlzLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6IGRheXMsXHJcbiAgICB3ZWVrZGF5c01pbiA6IGRheXMsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcclxuICAgICAgICBMIDogJ0REL01NL1lZWVknLFxyXG4gICAgICAgIExMIDogJ0QgTU1NTSBZWVlZJyxcclxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZNiMIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtUGFyc2U6IC/Ytdio2K182LTYp9mFLyxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJ9i02KfZhScgPT09IGlucHV0O1xyXG4gICAgfSxcclxuICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXIsIG1pbnV0ZSwgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VyIDwgMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICfYtdio2K0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ9i02KfZhSc7XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb2KLYrCDYqNmI2YLYql0gTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW9qp2YQg2KjZiNmC2KpdIExUJyxcclxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFvYqNmI2YLYql0gTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9qv2LDYtNiq24Eg2LHZiNiyINio2YjZgtiqXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW9qv2LDYtNiq24FdIGRkZGQgW9io2YjZgtiqXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzINio2LnYrycsXHJcbiAgICAgICAgcGFzdCA6ICclcyDZgtio2YQnLFxyXG4gICAgICAgIHMgOiAn2obZhtivINiz24zaqdmG2ognLFxyXG4gICAgICAgIG0gOiAn2KfbjNqpINmF2YbZuScsXHJcbiAgICAgICAgbW0gOiAnJWQg2YXZhtm5JyxcclxuICAgICAgICBoIDogJ9in24zaqSDar9q+2YbZuduBJyxcclxuICAgICAgICBoaCA6ICclZCDar9q+2YbZuduSJyxcclxuICAgICAgICBkIDogJ9in24zaqSDYr9mGJyxcclxuICAgICAgICBkZCA6ICclZCDYr9mGJyxcclxuICAgICAgICBNIDogJ9in24zaqSDZhdin24EnLFxyXG4gICAgICAgIE1NIDogJyVkINmF2KfbgScsXHJcbiAgICAgICAgeSA6ICfYp9uM2qkg2LPYp9mEJyxcclxuICAgICAgICB5eSA6ICclZCDYs9in2YQnXHJcbiAgICB9LFxyXG4gICAgcHJlcGFyc2U6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL9iML2csICcsJyk7XHJcbiAgICB9LFxyXG4gICAgcG9zdGZvcm1hdDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLC9nLCAn2IwnKTtcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDQgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdXI7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVXpiZWsgTGF0aW4gW3V6LWxhdG5dXHJcbi8vISBhdXRob3IgOiBSYXN1bGJlayBNaXJ6YXlldiA6IGdpdGh1Yi5jb20vUmFzdWxiZWVla1xyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHV6TGF0biA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3V6LWxhdG4nLCB7XHJcbiAgICBtb250aHMgOiAnWWFudmFyX0ZldnJhbF9NYXJ0X0FwcmVsX01heV9JeXVuX0l5dWxfQXZndXN0X1NlbnRhYnJfT2t0YWJyX05veWFicl9EZWthYnInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdZYW5fRmV2X01hcl9BcHJfTWF5X0l5dW5fSXl1bF9BdmdfU2VuX09rdF9Ob3lfRGVrJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXMgOiAnWWFrc2hhbmJhX0R1c2hhbmJhX1Nlc2hhbmJhX0Nob3JzaGFuYmFfUGF5c2hhbmJhX0p1bWFfU2hhbmJhJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdZYWtfRHVzaF9TZXNoX0Nob3JfUGF5X0p1bV9TaGFuJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAnWWFfRHVfU2VfQ2hvX1BhX0p1X1NoYScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBISDptbScsXHJcbiAgICAgICAgTExMTCA6ICdEIE1NTU0gWVlZWSwgZGRkZCBISDptbSdcclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1tCdWd1biBzb2F0XSBMVCBbZGFdJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1tFcnRhZ2FdIExUIFtkYV0nLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2t1bmkgc29hdF0gTFQgW2RhXScsXHJcbiAgICAgICAgbGFzdERheSA6ICdbS2VjaGEgc29hdF0gTFQgW2RhXScsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW09cXCd0Z2FuXSBkZGRkIFtrdW5pIHNvYXRdIExUIFtkYV0nLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgcmVsYXRpdmVUaW1lIDoge1xyXG4gICAgICAgIGZ1dHVyZSA6ICdZYXFpbiAlcyBpY2hpZGEnLFxyXG4gICAgICAgIHBhc3QgOiAnQmlyIG5lY2hhICVzIG9sZGluJyxcclxuICAgICAgICBzIDogJ3Nvbml5YScsXHJcbiAgICAgICAgbSA6ICdiaXIgZGFxaXFhJyxcclxuICAgICAgICBtbSA6ICclZCBkYXFpcWEnLFxyXG4gICAgICAgIGggOiAnYmlyIHNvYXQnLFxyXG4gICAgICAgIGhoIDogJyVkIHNvYXQnLFxyXG4gICAgICAgIGQgOiAnYmlyIGt1bicsXHJcbiAgICAgICAgZGQgOiAnJWQga3VuJyxcclxuICAgICAgICBNIDogJ2JpciBveScsXHJcbiAgICAgICAgTU0gOiAnJWQgb3knLFxyXG4gICAgICAgIHkgOiAnYmlyIHlpbCcsXHJcbiAgICAgICAgeXkgOiAnJWQgeWlsJ1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNyAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB1ekxhdG47XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LWxhdG4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdXotbGF0bi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFV6YmVrIFt1el1cclxuLy8hIGF1dGhvciA6IFNhcmRvciBNdW1pbm92IDogaHR0cHM6Ly9naXRodWIuY29tL211bWlub2ZmXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgdXogPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd1eicsIHtcclxuICAgIG1vbnRocyA6ICfRj9C90LLQsNGAX9GE0LXQstGA0LDQu1/QvNCw0YDRgl/QsNC/0YDQtdC7X9C80LDQuV/QuNGO0L1f0LjRjtC7X9Cw0LLQs9GD0YHRgl/RgdC10L3RgtGP0LHRgF/QvtC60YLRj9Cx0YBf0L3QvtGP0LHRgF/QtNC10LrQsNCx0YAnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICfRj9C90LJf0YTQtdCyX9C80LDRgF/QsNC/0YBf0LzQsNC5X9C40Y7QvV/QuNGO0Ltf0LDQstCzX9GB0LXQvV/QvtC60YJf0L3QvtGPX9C00LXQuicuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ9Cv0LrRiNCw0L3QsdCwX9CU0YPRiNCw0L3QsdCwX9Ch0LXRiNCw0L3QsdCwX9Cn0L7RgNGI0LDQvdCx0LBf0J/QsNC50YjQsNC90LHQsF/QltGD0LzQsF/QqNCw0L3QsdCwJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICfQr9C60Yhf0JTRg9GIX9Ch0LXRiF/Qp9C+0YBf0J/QsNC5X9CW0YPQvF/QqNCw0L0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICfQr9C6X9CU0YNf0KHQtV/Qp9C+X9Cf0LBf0JbRg1/QqNCwJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ0QgTU1NTSBZWVlZLCBkZGRkIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW9CR0YPQs9GD0L0g0YHQvtCw0YJdIExUIFvQtNCwXScsXHJcbiAgICAgICAgbmV4dERheSA6ICdb0K3RgNGC0LDQs9CwXSBMVCBb0LTQsF0nLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW9C60YPQvdC4INGB0L7QsNGCXSBMVCBb0LTQsF0nLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW9Ca0LXRh9CwINGB0L7QsNGCXSBMVCBb0LTQsF0nLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vQo9GC0LPQsNC9XSBkZGRkIFvQutGD0L3QuCDRgdC+0LDRgl0gTFQgW9C00LBdJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAn0K/QutC40L0gJXMg0LjRh9C40LTQsCcsXHJcbiAgICAgICAgcGFzdCA6ICfQkdC40YAg0L3QtdGH0LAgJXMg0L7Qu9C00LjQvScsXHJcbiAgICAgICAgcyA6ICfRhNGD0YDRgdCw0YInLFxyXG4gICAgICAgIG0gOiAn0LHQuNGAINC00LDQutC40LrQsCcsXHJcbiAgICAgICAgbW0gOiAnJWQg0LTQsNC60LjQutCwJyxcclxuICAgICAgICBoIDogJ9Cx0LjRgCDRgdC+0LDRgicsXHJcbiAgICAgICAgaGggOiAnJWQg0YHQvtCw0YInLFxyXG4gICAgICAgIGQgOiAn0LHQuNGAINC60YPQvScsXHJcbiAgICAgICAgZGQgOiAnJWQg0LrRg9C9JyxcclxuICAgICAgICBNIDogJ9Cx0LjRgCDQvtC5JyxcclxuICAgICAgICBNTSA6ICclZCDQvtC5JyxcclxuICAgICAgICB5IDogJ9Cx0LjRgCDQudC40LsnLFxyXG4gICAgICAgIHl5IDogJyVkINC50LjQuydcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgIGRveSA6IDcgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gdXo7XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3V6LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogVmlldG5hbWVzZSBbdmldXHJcbi8vISBhdXRob3IgOiBCYW5nIE5ndXllbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYW5nbmtcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB2aSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3ZpJywge1xyXG4gICAgbW9udGhzIDogJ3Row6FuZyAxX3Row6FuZyAyX3Row6FuZyAzX3Row6FuZyA0X3Row6FuZyA1X3Row6FuZyA2X3Row6FuZyA3X3Row6FuZyA4X3Row6FuZyA5X3Row6FuZyAxMF90aMOhbmcgMTFfdGjDoW5nIDEyJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnVGgwMV9UaDAyX1RoMDNfVGgwNF9UaDA1X1RoMDZfVGgwN19UaDA4X1RoMDlfVGgxMF9UaDExX1RoMTInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcclxuICAgIHdlZWtkYXlzIDogJ2No4bunIG5o4bqtdF90aOG7qSBoYWlfdGjhu6kgYmFfdGjhu6kgdMawX3Ro4bupIG7Eg21fdGjhu6kgc8OhdV90aOG7qSBi4bqjeScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAnQ05fVDJfVDNfVDRfVDVfVDZfVDcnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c01pbiA6ICdDTl9UMl9UM19UNF9UNV9UNl9UNycuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBtZXJpZGllbVBhcnNlOiAvc2F8Y2gvaSxcclxuICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gL15jaCQvaS50ZXN0KGlucHV0KTtcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xyXG4gICAgICAgIGlmIChob3VycyA8IDEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3NhJyA6ICdTQSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnY2gnIDogJ0NIJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gW27Eg21dIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gW27Eg21dIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFtuxINtXSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBsIDogJ0REL00vWVlZWScsXHJcbiAgICAgICAgbGwgOiAnRCBNTU0gWVlZWScsXHJcbiAgICAgICAgbGxsIDogJ0QgTU1NIFlZWVkgSEg6bW0nLFxyXG4gICAgICAgIGxsbGwgOiAnZGRkLCBEIE1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXk6ICdbSMO0bSBuYXkgbMO6Y10gTFQnLFxyXG4gICAgICAgIG5leHREYXk6ICdbTmfDoHkgbWFpIGzDumNdIExUJyxcclxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW3R14bqnbiB04bubaSBsw7pjXSBMVCcsXHJcbiAgICAgICAgbGFzdERheTogJ1tIw7RtIHF1YSBsw7pjXSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWs6ICdkZGRkIFt0deG6p24gcuG7k2kgbMO6Y10gTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJyVzIHThu5tpJyxcclxuICAgICAgICBwYXN0IDogJyVzIHRyxrDhu5tjJyxcclxuICAgICAgICBzIDogJ3bDoGkgZ2nDonknLFxyXG4gICAgICAgIG0gOiAnbeG7mXQgcGjDunQnLFxyXG4gICAgICAgIG1tIDogJyVkIHBow7p0JyxcclxuICAgICAgICBoIDogJ23hu5l0IGdp4budJyxcclxuICAgICAgICBoaCA6ICclZCBnaeG7nScsXHJcbiAgICAgICAgZCA6ICdt4buZdCBuZ8OgeScsXHJcbiAgICAgICAgZGQgOiAnJWQgbmfDoHknLFxyXG4gICAgICAgIE0gOiAnbeG7mXQgdGjDoW5nJyxcclxuICAgICAgICBNTSA6ICclZCB0aMOhbmcnLFxyXG4gICAgICAgIHkgOiAnbeG7mXQgbsSDbScsXHJcbiAgICAgICAgeXkgOiAnJWQgbsSDbSdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0vLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB2aTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvdmkuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBQc2V1ZG8gW3gtcHNldWRvXVxyXG4vLyEgYXV0aG9yIDogQW5kcmV3IEhvb2QgOiBodHRwczovL2dpdGh1Yi5jb20vYW5kcmV3aG9vZDEyNVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHhQc2V1ZG8gPSBtb21lbnQuZGVmaW5lTG9jYWxlKCd4LXBzZXVkbycsIHtcclxuICAgIG1vbnRocyA6ICdKfsOhw7HDusOhfnLDvV9GfsOpYnLDun7DoXLDvV9+TcOhcmN+aF/DgXB+csOtbF9+TcOhw71ffkrDusOxw6l+X0rDumx+w71fw4HDun5nw7pzdH5fU8OpcH50w6ltYn7DqXJfw5N+Y3TDs2J+w6lyX8ORfsOzdsOpbX5iw6lyX35Ew6ljw6l+bWLDqXInLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdKfsOhw7FffkbDqWJffk3DoXJffsOBcHJffk3DocO9X35Kw7rDsV9+SsO6bF9+w4HDumdfflPDqXBffsOTY3RffsORw7N2X35Ew6ljJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICB3ZWVrZGF5cyA6ICdTfsO6w7Fkw6F+w71fTcOzfsOxZMOhw71+X1TDusOpfnNkw6HDvX5fV8OpZH7DscOpc2R+w6HDvV9UfmjDunJzfmTDocO9X35GcsOtZH7DocO9X1N+w6F0w7pyfmTDocO9Jy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNTaG9ydCA6ICdTfsO6w7Fffk3Ds8OxX35Uw7rDqV9+V8OpZF9+VGjDul9+RnLDrV9+U8OhdCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ1N+w7pfTcOzfl9Uw7pfflfDqV9UfmhfRnJ+X1PDoScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdISDptbScsXHJcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcclxuICAgICAgICBMTCA6ICdEIE1NTU0gWVlZWScsXHJcbiAgICAgICAgTExMIDogJ0QgTU1NTSBZWVlZIEhIOm1tJyxcclxuICAgICAgICBMTExMIDogJ2RkZGQsIEQgTU1NTSBZWVlZIEhIOm1tJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW1R+w7Nkw6F+w70gw6F0XSBMVCcsXHJcbiAgICAgICAgbmV4dERheSA6ICdbVH7Ds23Ds35ycsOzfncgw6F0XSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbw6F0XSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbw51+w6lzdH7DqXJkw6F+w70gw6F0XSBMVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW0x+w6FzdF0gZGRkZCBbw6F0XSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ8OtfsOxICVzJyxcclxuICAgICAgICBwYXN0IDogJyVzIMOhfmfDsycsXHJcbiAgICAgICAgcyA6ICfDoSB+ZsOpdyB+c8OpY8OzfsOxZHMnLFxyXG4gICAgICAgIG0gOiAnw6Egfm3DrcOxfsO6dMOpJyxcclxuICAgICAgICBtbSA6ICclZCBtfsOtw7HDun50w6lzJyxcclxuICAgICAgICBoIDogJ8OhfsOxIGjDs37DunInLFxyXG4gICAgICAgIGhoIDogJyVkIGh+w7PDunJzJyxcclxuICAgICAgICBkIDogJ8OhIH5kw6HDvScsXHJcbiAgICAgICAgZGQgOiAnJWQgZH7DocO9cycsXHJcbiAgICAgICAgTSA6ICfDoSB+bcOzw7F+dGgnLFxyXG4gICAgICAgIE1NIDogJyVkIG1+w7PDsXR+aHMnLFxyXG4gICAgICAgIHkgOiAnw6EgfsO9w6nDoXInLFxyXG4gICAgICAgIHl5IDogJyVkIMO9fsOpw6FycydcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcclxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcclxuICAgICAgICAgICAgb3V0cHV0ID0gKH5+KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcclxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcclxuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxyXG4gICAgfVxyXG59KTtcclxuXHJcbnJldHVybiB4UHNldWRvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS94LXBzZXVkby5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS94LXBzZXVkby5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IFlvcnViYSBOaWdlcmlhIFt5b11cclxuLy8hIGF1dGhvciA6IEF0b2xhZ2JlIEFiaXNveWUgOiBodHRwczovL2dpdGh1Yi5jb20vYW5kZWxhLWJhdG9sYWdiZVxyXG5cclxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XHJcbiAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJy4uL21vbWVudCddLCBmYWN0b3J5KSA6XHJcbiAgIGZhY3RvcnkoZ2xvYmFsLm1vbWVudClcclxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG5cclxudmFyIHlvID0gbW9tZW50LmRlZmluZUxvY2FsZSgneW8nLCB7XHJcbiAgICBtb250aHMgOiAnU+G6ucyBcuG6ucyBX0XMgHJlzIBsZcyAX+G6uHLhurnMgG5hzIBfScyAZ2JlzIFfRcyAYmliaV9PzIBrdcyAZHVfQWfhurltb19PzIBndcyBbl9Pd2V3ZV/hu4zMgHdhzIByYcyAX0JlzIFsdcyBX+G7jMyAcOG6ucyAzIAnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICdT4bq5zIFyX0XMgHJsX+G6uHJuX0nMgGdiX0XMgGJpX0/MgGt1zIBfQWfhurlfT8yAZ3XMgV9Pd2Vf4buMzIB3YcyAX0JlzIFsX+G7jMyAcOG6ucyAzIAnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICdBzIBpzIBrdcyBX0FqZcyBX0nMgHPhurnMgWd1bl/hu4xq4buNzIFydcyBX+G7jGrhu43MgWLhu41f4bq4dGnMgF9BzIBiYcyBbeG6ucyBdGEnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ0HMgGnMgGtfQWplzIFfScyAc+G6ucyBX+G7jGpyX+G7jGpiX+G6uHRpzIBfQcyAYmHMgScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ0HMgGnMgF9Bal9JzIBzX+G7jHJf4buMYl/hurh0X0HMgGInLnNwbGl0KCdfJyksXHJcbiAgICBsb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICBMVCA6ICdoOm1tIEEnLFxyXG4gICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxyXG4gICAgICAgIEwgOiAnREQvTU0vWVlZWScsXHJcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxyXG4gICAgICAgIExMTCA6ICdEIE1NTU0gWVlZWSBoOm1tIEEnLFxyXG4gICAgICAgIExMTEwgOiAnZGRkZCwgRCBNTU1NIFlZWVkgaDptbSBBJ1xyXG4gICAgfSxcclxuICAgIGNhbGVuZGFyIDoge1xyXG4gICAgICAgIHNhbWVEYXkgOiAnW0/MgG5pzIAgbmldIExUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vhu4zMgGxhIG5pXSBMVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBb4buMc+G6ucyAIHRvzIFuXFwnYuG7jV0gW25pXSBMVCcsXHJcbiAgICAgICAgbGFzdERheSA6ICdbQcyAbmEgbmldIExUJyxcclxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFvhu4xz4bq5zIAgdG/MgWzhu43MgV0gW25pXSBMVCcsXHJcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcclxuICAgIH0sXHJcbiAgICByZWxhdGl2ZVRpbWUgOiB7XHJcbiAgICAgICAgZnV0dXJlIDogJ25pzIEgJXMnLFxyXG4gICAgICAgIHBhc3QgOiAnJXMga+G7jWphzIEnLFxyXG4gICAgICAgIHMgOiAnacyAc+G6uWp1zIEgYWF5YcyBIGRpZScsXHJcbiAgICAgICAgbSA6ICdpzIBz4bq5anXMgSBrYW4nLFxyXG4gICAgICAgIG1tIDogJ2nMgHPhurlqdcyBICVkJyxcclxuICAgICAgICBoIDogJ3dhzIFrYXRpIGthbicsXHJcbiAgICAgICAgaGggOiAnd2HMgWthdGkgJWQnLFxyXG4gICAgICAgIGQgOiAn4buNauG7jcyBIGthbicsXHJcbiAgICAgICAgZGQgOiAn4buNauG7jcyBICVkJyxcclxuICAgICAgICBNIDogJ29zdcyAIGthbicsXHJcbiAgICAgICAgTU0gOiAnb3N1zIAgJWQnLFxyXG4gICAgICAgIHkgOiAn4buNZHXMgW4ga2FuJyxcclxuICAgICAgICB5eSA6ICfhu41kdcyBbiAlZCdcclxuICAgIH0sXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIDogL+G7jWrhu43MgVxcc1xcZHsxLDJ9LyxcclxuICAgIG9yZGluYWwgOiAn4buNauG7jcyBICVkJyxcclxuICAgIHdlZWsgOiB7XHJcbiAgICAgICAgZG93IDogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICAgICAgZG95IDogNCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHlvO1xyXG5cclxufSkpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS95by5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS95by5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vISBtb21lbnQuanMgbG9jYWxlIGNvbmZpZ3VyYXRpb25cclxuLy8hIGxvY2FsZSA6IENoaW5lc2UgKENoaW5hKSBbemgtY25dXHJcbi8vISBhdXRob3IgOiBzdXVwaWMgOiBodHRwczovL2dpdGh1Yi5jb20vc3V1cGljXHJcbi8vISBhdXRob3IgOiBaZW5vIFplbmcgOiBodHRwczovL2dpdGh1Yi5jb20vemVub3plbmdcclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nID8gZmFjdG9yeShyZXF1aXJlKCcuLi9tb21lbnQnKSkgOlxyXG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxyXG4gICBmYWN0b3J5KGdsb2JhbC5tb21lbnQpXHJcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbnZhciB6aENuID0gbW9tZW50LmRlZmluZUxvY2FsZSgnemgtY24nLCB7XHJcbiAgICBtb250aHMgOiAn5LiA5pyIX+S6jOaciF/kuInmnIhf5Zub5pyIX+S6lOaciF/lha3mnIhf5LiD5pyIX+WFq+aciF/kuZ3mnIhf5Y2B5pyIX+WNgeS4gOaciF/ljYHkuozmnIgnLnNwbGl0KCdfJyksXHJcbiAgICBtb250aHNTaG9ydCA6ICcx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciCcuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzIDogJ+aYn+acn+aXpV/mmJ/mnJ/kuIBf5pif5pyf5LqMX+aYn+acn+S4iV/mmJ/mnJ/lm5tf5pif5pyf5LqUX+aYn+acn+WFrScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzU2hvcnQgOiAn5ZGo5pelX+WRqOS4gF/lkajkuoxf5ZGo5LiJX+WRqOWbm1/lkajkupRf5ZGo5YWtJy5zcGxpdCgnXycpLFxyXG4gICAgd2Vla2RheXNNaW4gOiAn5pelX+S4gF/kuoxf5LiJX+Wbm1/kupRf5YWtJy5zcGxpdCgnXycpLFxyXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XHJcbiAgICAgICAgTFQgOiAnSEg6bW0nLFxyXG4gICAgICAgIExUUyA6ICdISDptbTpzcycsXHJcbiAgICAgICAgTCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgTEwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIExMTCA6ICdZWVlZ5bm0TU1NROaXpUFo54K5bW3liIYnLFxyXG4gICAgICAgIExMTEwgOiAnWVlZWeW5tE1NTUTml6VkZGRkQWjngrltbeWIhicsXHJcbiAgICAgICAgbCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgbGwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIGxsbCA6ICdZWVlZ5bm0TU1NROaXpSBISDptbScsXHJcbiAgICAgICAgbGxsbCA6ICdZWVlZ5bm0TU1NROaXpWRkZGQgSEg6bW0nXHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW1QYXJzZTogL+WHjOaZqHzml6nkuIp85LiK5Y2IfOS4reWNiHzkuIvljYh85pma5LiKLyxcclxuICAgIG1lcmlkaWVtSG91cjogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICflh4zmmagnIHx8IG1lcmlkaWVtID09PSAn5pep5LiKJyB8fFxyXG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPT09ICfkuIrljYgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfkuIvljYgnIHx8IG1lcmlkaWVtID09PSAn5pma5LiKJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vICfkuK3ljYgnXHJcbiAgICAgICAgICAgIHJldHVybiBob3VyID49IDExID8gaG91ciA6IGhvdXIgKyAxMjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91ciwgbWludXRlLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgdmFyIGhtID0gaG91ciAqIDEwMCArIG1pbnV0ZTtcclxuICAgICAgICBpZiAoaG0gPCA2MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICflh4zmmagnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCA5MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfml6nkuIonO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMTMwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5LiK5Y2IJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTIzMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+S4reWNiCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDE4MDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfkuIvljYgnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5pma5LiKJztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FsZW5kYXIgOiB7XHJcbiAgICAgICAgc2FtZURheSA6ICdb5LuK5aSpXUxUJyxcclxuICAgICAgICBuZXh0RGF5IDogJ1vmmI7lpKldTFQnLFxyXG4gICAgICAgIG5leHRXZWVrIDogJ1vkuItdZGRkZExUJyxcclxuICAgICAgICBsYXN0RGF5IDogJ1vmmKjlpKldTFQnLFxyXG4gICAgICAgIGxhc3RXZWVrIDogJ1vkuIpdZGRkZExUJyxcclxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgfSxcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSjml6V85pyIfOWRqCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIsIHBlcmlvZCkge1xyXG4gICAgICAgIHN3aXRjaCAocGVyaW9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgY2FzZSAnREREJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5pelJztcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aciCc7XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAn5ZGoJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXPlhoUnLFxyXG4gICAgICAgIHBhc3QgOiAnJXPliY0nLFxyXG4gICAgICAgIHMgOiAn5Yeg56eSJyxcclxuICAgICAgICBtIDogJzEg5YiG6ZKfJyxcclxuICAgICAgICBtbSA6ICclZCDliIbpkp8nLFxyXG4gICAgICAgIGggOiAnMSDlsI/ml7YnLFxyXG4gICAgICAgIGhoIDogJyVkIOWwj+aXticsXHJcbiAgICAgICAgZCA6ICcxIOWkqScsXHJcbiAgICAgICAgZGQgOiAnJWQg5aSpJyxcclxuICAgICAgICBNIDogJzEg5Liq5pyIJyxcclxuICAgICAgICBNTSA6ICclZCDkuKrmnIgnLFxyXG4gICAgICAgIHkgOiAnMSDlubQnLFxyXG4gICAgICAgIHl5IDogJyVkIOW5tCdcclxuICAgIH0sXHJcbiAgICB3ZWVrIDoge1xyXG4gICAgICAgIC8vIEdCL1QgNzQwOC0xOTk044CK5pWw5o2u5YWD5ZKM5Lqk5o2i5qC85byPwrfkv6Hmga/kuqTmjaLCt+aXpeacn+WSjOaXtumXtOihqOekuuazleOAi+S4jklTTyA4NjAxOjE5ODjnrYnmlYhcclxuICAgICAgICBkb3cgOiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cclxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICB9XHJcbn0pO1xyXG5cclxucmV0dXJuIHpoQ247XHJcblxyXG59KSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWNuLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9tb21lbnQvbG9jYWxlL3poLWNuLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8hIG1vbWVudC5qcyBsb2NhbGUgY29uZmlndXJhdGlvblxyXG4vLyEgbG9jYWxlIDogQ2hpbmVzZSAoSG9uZyBLb25nKSBbemgtaGtdXHJcbi8vISBhdXRob3IgOiBCZW4gOiBodHRwczovL2dpdGh1Yi5jb20vYmVuLWxpblxyXG4vLyEgYXV0aG9yIDogQ2hyaXMgTGFtIDogaHR0cHM6Ly9naXRodWIuY29tL2hlaGFjaHJpc1xyXG4vLyEgYXV0aG9yIDogS29uc3RhbnRpbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9za2ZkXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgemhIayA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3poLWhrJywge1xyXG4gICAgbW9udGhzIDogJ+S4gOaciF/kuozmnIhf5LiJ5pyIX+Wbm+aciF/kupTmnIhf5YWt5pyIX+S4g+aciF/lhavmnIhf5Lmd5pyIX+WNgeaciF/ljYHkuIDmnIhf5Y2B5LqM5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+mAseaXpV/pgLHkuIBf6YCx5LqMX+mAseS4iV/pgLHlm5tf6YCx5LqUX+mAseWFrScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+aXpV/kuIBf5LqMX+S4iV/lm5tf5LqUX+WFrScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIExMIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBMTEwgOiAnWVlZWeW5tE1NTUTml6UgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnWVlZWeW5tE1NTUTml6VkZGRkIEhIOm1tJyxcclxuICAgICAgICBsIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBsbCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgbGxsIDogJ1lZWVnlubRNTU1E5pelIEhIOm1tJyxcclxuICAgICAgICBsbGxsIDogJ1lZWVnlubRNTU1E5pelZGRkZCBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv5YeM5pmofOaXqeS4inzkuIrljYh85Lit5Y2IfOS4i+WNiHzmmZrkuIovLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICflh4zmmagnIHx8IG1lcmlkaWVtID09PSAn5pep5LiKJyB8fCBtZXJpZGllbSA9PT0gJ+S4iuWNiCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+S4reWNiCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfkuIvljYgnIHx8IG1lcmlkaWVtID09PSAn5pma5LiKJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICB2YXIgaG0gPSBob3VyICogMTAwICsgbWludXRlO1xyXG4gICAgICAgIGlmIChobSA8IDYwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+WHjOaZqCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDkwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+aXqeS4iic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDExMzApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfkuIrljYgnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMjMwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5Lit5Y2IJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTgwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+S4i+WNiCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfmmZrkuIonO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vku4rlpKldTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+aYjuWkqV1MVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW+S4i11kZGRkTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+aYqOWkqV1MVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+S4il1kZGRkTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KOaXpXzmnIh86YCxKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnZCcgOlxyXG4gICAgICAgICAgICBjYXNlICdEJyA6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCcgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfml6UnO1xyXG4gICAgICAgICAgICBjYXNlICdNJyA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aciCc7XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnIDpcclxuICAgICAgICAgICAgY2FzZSAnVycgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfpgLEnO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXPlhacnLFxyXG4gICAgICAgIHBhc3QgOiAnJXPliY0nLFxyXG4gICAgICAgIHMgOiAn5bm+56eSJyxcclxuICAgICAgICBtIDogJzEg5YiG6ZCYJyxcclxuICAgICAgICBtbSA6ICclZCDliIbpkJgnLFxyXG4gICAgICAgIGggOiAnMSDlsI/mmYInLFxyXG4gICAgICAgIGhoIDogJyVkIOWwj+aZgicsXHJcbiAgICAgICAgZCA6ICcxIOWkqScsXHJcbiAgICAgICAgZGQgOiAnJWQg5aSpJyxcclxuICAgICAgICBNIDogJzEg5YCL5pyIJyxcclxuICAgICAgICBNTSA6ICclZCDlgIvmnIgnLFxyXG4gICAgICAgIHkgOiAnMSDlubQnLFxyXG4gICAgICAgIHl5IDogJyVkIOW5tCdcclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gemhIaztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtaGsuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vISBsb2NhbGUgOiBDaGluZXNlIChUYWl3YW4pIFt6aC10d11cclxuLy8hIGF1dGhvciA6IEJlbiA6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZW4tbGluXHJcbi8vISBhdXRob3IgOiBDaHJpcyBMYW0gOiBodHRwczovL2dpdGh1Yi5jb20vaGVoYWNocmlzXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXHJcbiAgICAgICAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhY3RvcnkocmVxdWlyZSgnLi4vbW9tZW50JykpIDpcclxuICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnLi4vbW9tZW50J10sIGZhY3RvcnkpIDpcclxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxyXG59KHRoaXMsIChmdW5jdGlvbiAobW9tZW50KSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcblxyXG52YXIgemhUdyA9IG1vbWVudC5kZWZpbmVMb2NhbGUoJ3poLXR3Jywge1xyXG4gICAgbW9udGhzIDogJ+S4gOaciF/kuozmnIhf5LiJ5pyIX+Wbm+aciF/kupTmnIhf5YWt5pyIX+S4g+aciF/lhavmnIhf5Lmd5pyIX+WNgeaciF/ljYHkuIDmnIhf5Y2B5LqM5pyIJy5zcGxpdCgnXycpLFxyXG4gICAgbW9udGhzU2hvcnQgOiAnMeaciF8y5pyIXzPmnIhfNOaciF815pyIXzbmnIhfN+aciF845pyIXznmnIhfMTDmnIhfMTHmnIhfMTLmnIgnLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5cyA6ICfmmJ/mnJ/ml6Vf5pif5pyf5LiAX+aYn+acn+S6jF/mmJ/mnJ/kuIlf5pif5pyf5ZubX+aYn+acn+S6lF/mmJ/mnJ/lha0nLnNwbGl0KCdfJyksXHJcbiAgICB3ZWVrZGF5c1Nob3J0IDogJ+mAseaXpV/pgLHkuIBf6YCx5LqMX+mAseS4iV/pgLHlm5tf6YCx5LqUX+mAseWFrScuc3BsaXQoJ18nKSxcclxuICAgIHdlZWtkYXlzTWluIDogJ+aXpV/kuIBf5LqMX+S4iV/lm5tf5LqUX+WFrScuc3BsaXQoJ18nKSxcclxuICAgIGxvbmdEYXRlRm9ybWF0IDoge1xyXG4gICAgICAgIExUIDogJ0hIOm1tJyxcclxuICAgICAgICBMVFMgOiAnSEg6bW06c3MnLFxyXG4gICAgICAgIEwgOiAnWVlZWeW5tE1NTUTml6UnLFxyXG4gICAgICAgIExMIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBMTEwgOiAnWVlZWeW5tE1NTUTml6UgSEg6bW0nLFxyXG4gICAgICAgIExMTEwgOiAnWVlZWeW5tE1NTUTml6VkZGRkIEhIOm1tJyxcclxuICAgICAgICBsIDogJ1lZWVnlubRNTU1E5pelJyxcclxuICAgICAgICBsbCA6ICdZWVlZ5bm0TU1NROaXpScsXHJcbiAgICAgICAgbGxsIDogJ1lZWVnlubRNTU1E5pelIEhIOm1tJyxcclxuICAgICAgICBsbGxsIDogJ1lZWVnlubRNTU1E5pelZGRkZCBISDptbSdcclxuICAgIH0sXHJcbiAgICBtZXJpZGllbVBhcnNlOiAv5YeM5pmofOaXqeS4inzkuIrljYh85Lit5Y2IfOS4i+WNiHzmmZrkuIovLFxyXG4gICAgbWVyaWRpZW1Ib3VyIDogZnVuY3Rpb24gKGhvdXIsIG1lcmlkaWVtKSB7XHJcbiAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XHJcbiAgICAgICAgICAgIGhvdXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVyaWRpZW0gPT09ICflh4zmmagnIHx8IG1lcmlkaWVtID09PSAn5pep5LiKJyB8fCBtZXJpZGllbSA9PT0gJ+S4iuWNiCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXJpZGllbSA9PT0gJ+S4reWNiCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhvdXIgPj0gMTEgPyBob3VyIDogaG91ciArIDEyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWVyaWRpZW0gPT09ICfkuIvljYgnIHx8IG1lcmlkaWVtID09PSAn5pma5LiKJykge1xyXG4gICAgICAgICAgICByZXR1cm4gaG91ciArIDEyO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtZXJpZGllbSA6IGZ1bmN0aW9uIChob3VyLCBtaW51dGUsIGlzTG93ZXIpIHtcclxuICAgICAgICB2YXIgaG0gPSBob3VyICogMTAwICsgbWludXRlO1xyXG4gICAgICAgIGlmIChobSA8IDYwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+WHjOaZqCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDkwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+aXqeS4iic7XHJcbiAgICAgICAgfSBlbHNlIGlmIChobSA8IDExMzApIHtcclxuICAgICAgICAgICAgcmV0dXJuICfkuIrljYgnO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaG0gPCAxMjMwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAn5Lit5Y2IJztcclxuICAgICAgICB9IGVsc2UgaWYgKGhtIDwgMTgwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ+S4i+WNiCc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICfmmZrkuIonO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjYWxlbmRhciA6IHtcclxuICAgICAgICBzYW1lRGF5IDogJ1vku4rlpKldTFQnLFxyXG4gICAgICAgIG5leHREYXkgOiAnW+aYjuWkqV1MVCcsXHJcbiAgICAgICAgbmV4dFdlZWsgOiAnW+S4i11kZGRkTFQnLFxyXG4gICAgICAgIGxhc3REYXkgOiAnW+aYqOWkqV1MVCcsXHJcbiAgICAgICAgbGFzdFdlZWsgOiAnW+S4il1kZGRkTFQnLFxyXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXHJcbiAgICB9LFxyXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KOaXpXzmnIh86YCxKS8sXHJcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlciwgcGVyaW9kKSB7XHJcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcclxuICAgICAgICAgICAgY2FzZSAnZCcgOlxyXG4gICAgICAgICAgICBjYXNlICdEJyA6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RERCcgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfml6UnO1xyXG4gICAgICAgICAgICBjYXNlICdNJyA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgJ+aciCc7XHJcbiAgICAgICAgICAgIGNhc2UgJ3cnIDpcclxuICAgICAgICAgICAgY2FzZSAnVycgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlciArICfpgLEnO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICBmdXR1cmUgOiAnJXPlhacnLFxyXG4gICAgICAgIHBhc3QgOiAnJXPliY0nLFxyXG4gICAgICAgIHMgOiAn5bm+56eSJyxcclxuICAgICAgICBtIDogJzEg5YiG6ZCYJyxcclxuICAgICAgICBtbSA6ICclZCDliIbpkJgnLFxyXG4gICAgICAgIGggOiAnMSDlsI/mmYInLFxyXG4gICAgICAgIGhoIDogJyVkIOWwj+aZgicsXHJcbiAgICAgICAgZCA6ICcxIOWkqScsXHJcbiAgICAgICAgZGQgOiAnJWQg5aSpJyxcclxuICAgICAgICBNIDogJzEg5YCL5pyIJyxcclxuICAgICAgICBNTSA6ICclZCDlgIvmnIgnLFxyXG4gICAgICAgIHkgOiAnMSDlubQnLFxyXG4gICAgICAgIHl5IDogJyVkIOW5tCdcclxuICAgIH1cclxufSk7XHJcblxyXG5yZXR1cm4gemhUdztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtdHcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGUvemgtdHcuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyEgbW9tZW50LmpzXHJcbi8vISB2ZXJzaW9uIDogMi4xOS4yXHJcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXHJcbi8vISBsaWNlbnNlIDogTUlUXHJcbi8vISBtb21lbnRqcy5jb21cclxuXHJcbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxyXG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcclxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaG9va0NhbGxiYWNrO1xyXG5cclxuZnVuY3Rpb24gaG9va3MgKCkge1xyXG4gICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG4vLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxyXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cclxuZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xyXG4gICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcclxuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XHJcbiAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcclxuICAgIC8vIGlucHV0ICE9IG51bGxcclxuICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xyXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciBrO1xyXG4gICAgICAgIGZvciAoayBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxufVxyXG5cclxuZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcclxuICAgIHZhciByZXMgPSBbXSwgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcclxuICAgIGZvciAodmFyIGkgaW4gYikge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XHJcbiAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xyXG4gICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcclxuICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcclxuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcclxuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXHJcbiAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXHJcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXHJcbiAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcclxuICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcclxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxyXG4gICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxyXG4gICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxyXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxyXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxyXG4gICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXHJcbiAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XHJcbiAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xyXG4gICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG0uX3BmO1xyXG59XHJcblxyXG52YXIgc29tZTtcclxuaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XHJcbiAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XHJcbn0gZWxzZSB7XHJcbiAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xyXG4gICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xyXG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZChtKSB7XHJcbiAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xyXG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXHJcbiAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxyXG4gICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcclxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxyXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcclxuICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxyXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXHJcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXHJcbiAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcclxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcclxuXHJcbiAgICAgICAgaWYgKG0uX3N0cmljdCkge1xyXG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxyXG4gICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcclxuICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbS5faXNWYWxpZDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcclxuICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XHJcbiAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xyXG4gICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtO1xyXG59XHJcblxyXG4vLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXHJcbi8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXHJcbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xyXG5cclxuZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xyXG4gICAgdmFyIGksIHByb3AsIHZhbDtcclxuXHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcclxuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xyXG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcclxuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XHJcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XHJcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xyXG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xyXG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XHJcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcclxuICAgIH1cclxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XHJcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XHJcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XHJcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRvO1xyXG59XHJcblxyXG52YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG5cclxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcclxuZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xyXG4gICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xyXG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XHJcbiAgICB9XHJcbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XHJcbiAgICAvLyBvYmplY3RzLlxyXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XHJcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xyXG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcclxuICAgIGlmIChudW1iZXIgPCAwKSB7XHJcbiAgICAgICAgLy8gLTAgLT4gMFxyXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XHJcbiAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxyXG4gICAgICAgIHZhbHVlID0gMDtcclxuXHJcbiAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xyXG4gICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXHJcbmZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XHJcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXHJcbiAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcclxuICAgICAgICBkaWZmcyA9IDAsXHJcbiAgICAgICAgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XHJcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcclxuICAgICAgICAgICAgZGlmZnMrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3YXJuKG1zZykge1xyXG4gICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcclxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XHJcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGFyZztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xyXG4gICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9LCBmbik7XHJcbn1cclxuXHJcbnZhciBkZXByZWNhdGlvbnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcclxuICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcclxuICAgICAgICB3YXJuKG1zZyk7XHJcbiAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cclxuaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XHJcbmhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXQgKGNvbmZpZykge1xyXG4gICAgdmFyIHByb3AsIGk7XHJcbiAgICBmb3IgKGkgaW4gY29uZmlnKSB7XHJcbiAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xyXG4gICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XHJcbiAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cclxuICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXHJcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcclxuICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XHJcbiAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xyXG4gICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXHJcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcclxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xyXG4gICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xyXG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGtleXM7XHJcblxyXG5pZiAoT2JqZWN0LmtleXMpIHtcclxuICAgIGtleXMgPSBPYmplY3Qua2V5cztcclxufSBlbHNlIHtcclxuICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XHJcbiAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxyXG4gICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcclxuICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXHJcbiAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcclxuICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxyXG4gICAgc2FtZUVsc2UgOiAnTCdcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XHJcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XHJcbiAgICBMVFMgIDogJ2g6bW06c3MgQScsXHJcbiAgICBMVCAgIDogJ2g6bW0gQScsXHJcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxyXG4gICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxyXG4gICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcclxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcclxufTtcclxuXHJcbmZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcclxuICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxyXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xyXG5cclxuICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcclxuXHJcbmZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcclxufVxyXG5cclxudmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcclxudmFyIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcclxuXHJcbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcclxuICAgIGZ1dHVyZSA6ICdpbiAlcycsXHJcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcclxuICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxyXG4gICAgc3MgOiAnJWQgc2Vjb25kcycsXHJcbiAgICBtICA6ICdhIG1pbnV0ZScsXHJcbiAgICBtbSA6ICclZCBtaW51dGVzJyxcclxuICAgIGggIDogJ2FuIGhvdXInLFxyXG4gICAgaGggOiAnJWQgaG91cnMnLFxyXG4gICAgZCAgOiAnYSBkYXknLFxyXG4gICAgZGQgOiAnJWQgZGF5cycsXHJcbiAgICBNICA6ICdhIG1vbnRoJyxcclxuICAgIE1NIDogJyVkIG1vbnRocycsXHJcbiAgICB5ICA6ICdhIHllYXInLFxyXG4gICAgeXkgOiAnJWQgeWVhcnMnXHJcbn07XHJcblxyXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xyXG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xyXG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cclxuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XHJcbiAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xyXG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xyXG59XHJcblxyXG52YXIgYWxpYXNlcyA9IHt9O1xyXG5cclxuZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcclxuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xyXG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxyXG4gICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxyXG4gICAgICAgIHByb3A7XHJcblxyXG4gICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XHJcbn1cclxuXHJcbnZhciBwcmlvcml0aWVzID0ge307XHJcblxyXG5mdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcclxuICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xyXG4gICAgdmFyIHVuaXRzID0gW107XHJcbiAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XHJcbiAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcclxuICAgIH1cclxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB1bml0cztcclxufVxyXG5cclxuZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xyXG4gICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcclxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXHJcbiAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xyXG4gICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xyXG4gICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xyXG59XHJcblxyXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XHJcblxyXG52YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcclxuXHJcbnZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcclxuXHJcbnZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xyXG5cclxuLy8gdG9rZW46ICAgICdNJ1xyXG4vLyBwYWRkZWQ6ICAgWydNTScsIDJdXHJcbi8vIG9yZGluYWw6ICAnTW8nXHJcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxyXG5mdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcclxuICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhZGRlZCkge1xyXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKG9yZGluYWwpIHtcclxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xyXG4gICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcclxuICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xyXG5cclxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxyXG5mdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XHJcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xyXG4gICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcclxuXHJcbiAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xyXG4gICAgdmFyIGkgPSA1O1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xyXG4gICAgfVxyXG5cclxuICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xyXG4gICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xyXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIGkgLT0gMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZm9ybWF0O1xyXG59XHJcblxyXG52YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxyXG52YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XHJcbnZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcclxudmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcclxudmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxyXG52YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XHJcbnZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XHJcbnZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxyXG52YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XHJcbnZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XHJcbnZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcclxuXHJcbnZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcclxudmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxyXG5cclxudmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcclxudmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcclxuXHJcbnZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXHJcblxyXG4vLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cclxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xyXG52YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XHJcblxyXG5cclxudmFyIHJlZ2V4ZXMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcclxuICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xyXG4gICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xyXG4gICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XHJcbn1cclxuXHJcbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcclxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xyXG4gICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xyXG4gICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcclxuICAgIH0pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xyXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcbn1cclxuXHJcbnZhciB0b2tlbnMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcclxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xyXG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcclxuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcclxuICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XHJcbiAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcclxuICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcclxuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgWUVBUiA9IDA7XHJcbnZhciBNT05USCA9IDE7XHJcbnZhciBEQVRFID0gMjtcclxudmFyIEhPVVIgPSAzO1xyXG52YXIgTUlOVVRFID0gNDtcclxudmFyIFNFQ09ORCA9IDU7XHJcbnZhciBNSUxMSVNFQ09ORCA9IDY7XHJcbnZhciBXRUVLID0gNztcclxudmFyIFdFRUtEQVkgPSA4O1xyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xyXG4gICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcclxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcclxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XHJcblxyXG4vLyBQUklPUklUSUVTXHJcblxyXG5hZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcclxuXHJcbi8vIFBBUlNJTkdcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcclxuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5hZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcclxuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xyXG5cclxuYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcclxuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcclxuICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xyXG59KTtcclxuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XHJcbn0pO1xyXG5cclxuLy8gSEVMUEVSU1xyXG5cclxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XHJcbiAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XHJcbiAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XHJcbn1cclxuXHJcbi8vIEhPT0tTXHJcblxyXG5ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcclxufTtcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbnZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcclxuXHJcbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xyXG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcclxuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xyXG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xyXG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xyXG4gICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgIGlmICh1bml0ID09PSAnRnVsbFllYXInICYmIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiYgbW9tLm1vbnRoKCkgPT09IDEgJiYgbW9tLmRhdGUoKSA9PT0gMjkpIHtcclxuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxuZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcclxuICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XHJcbiAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtb2QobiwgeCkge1xyXG4gICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xyXG59XHJcblxyXG52YXIgaW5kZXhPZjtcclxuXHJcbmlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xyXG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xyXG59IGVsc2Uge1xyXG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgLy8gSSBrbm93XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XHJcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xyXG4gICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcclxuICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcclxufVxyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcclxufSk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcclxuXHJcbi8vIFBSSU9SSVRZXHJcblxyXG5hZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xyXG59KTtcclxuYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcclxufSk7XHJcblxyXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xyXG59KTtcclxuXHJcbmFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XHJcbiAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcclxuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxyXG4gICAgaWYgKG1vbnRoICE9IG51bGwpIHtcclxuICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gTE9DQUxFU1xyXG5cclxudmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XHJcbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XHJcbmZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XHJcbiAgICBpZiAoIW0pIHtcclxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzIDpcclxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxyXG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xyXG59XHJcblxyXG52YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xyXG5mdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XHJcbiAgICBpZiAoIW0pIHtcclxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcclxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxyXG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xyXG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XHJcblxyXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcclxuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XHJcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcclxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcclxuICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxyXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcclxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcclxuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xyXG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxyXG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG5mdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xyXG4gICAgdmFyIGRheU9mTW9udGg7XHJcblxyXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgLy8gTm8gb3BcclxuICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XHJcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xyXG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcclxuICAgIHJldHVybiBtb207XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XHJcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XHJcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcclxuZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcclxuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcclxuZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XHJcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1N0cmljdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cclxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcclxuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcclxuICAgICAgICBpLCBtb207XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxyXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xyXG4gICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XHJcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcclxuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xyXG4gICAgfVxyXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxyXG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxyXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xyXG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XHJcbiAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XHJcbiAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcclxuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxyXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxyXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XHJcblxyXG4gICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XHJcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xyXG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xyXG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcclxuXHJcbiAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XHJcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xyXG4gICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0ZTtcclxufVxyXG5cclxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcclxuZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XHJcbiAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXHJcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcclxuICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXHJcbiAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xyXG5cclxuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xyXG59XHJcblxyXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxyXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcclxuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcclxuICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcclxuICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxyXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcclxuXHJcbiAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcclxuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XHJcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcclxuICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xyXG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcclxuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXNZZWFyID0geWVhcjtcclxuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB5ZWFyOiByZXNZZWFyLFxyXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcclxuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcclxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxyXG4gICAgICAgIHJlc1dlZWssIHJlc1llYXI7XHJcblxyXG4gICAgaWYgKHdlZWsgPCAxKSB7XHJcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xyXG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xyXG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XHJcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XHJcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcclxuICAgICAgICByZXNXZWVrID0gd2VlaztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdlZWs6IHJlc1dlZWssXHJcbiAgICAgICAgeWVhcjogcmVzWWVhclxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcclxuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcclxuICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xyXG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XHJcbn1cclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xyXG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XHJcbmFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XHJcblxyXG4vLyBQUklPUklUSUVTXHJcblxyXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcclxuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5cclxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XHJcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XHJcbn0pO1xyXG5cclxuLy8gSEVMUEVSU1xyXG5cclxuLy8gTE9DQUxFU1xyXG5cclxuZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XHJcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcclxufVxyXG5cclxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xyXG4gICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXHJcbiAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcclxuICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcclxufVxyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcclxuICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcclxuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcclxuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xyXG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xyXG59KTtcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xyXG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XHJcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XHJcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XHJcblxyXG4vLyBQUklPUklUWVxyXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcclxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xyXG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XHJcbn0pO1xyXG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XHJcbn0pO1xyXG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcclxufSk7XHJcblxyXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xyXG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXHJcbiAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XHJcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcclxuICAgIH1cclxufSk7XHJcblxyXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XHJcbn0pO1xyXG5cclxuLy8gSEVMUEVSU1xyXG5cclxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcclxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcclxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcclxuICAgIH1cclxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XHJcbn1cclxuXHJcbi8vIExPQ0FMRVNcclxuXHJcbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XHJcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcclxuICAgIGlmICghbSkge1xyXG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcclxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbJ3N0YW5kYWxvbmUnXTtcclxuICAgIH1cclxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c1t0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5kYXkoKV07XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XHJcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcclxuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcclxufVxyXG5cclxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcclxuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcclxuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xyXG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcclxuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcclxuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdHJpY3QpIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcclxuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XHJcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcclxuXHJcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xyXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XHJcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcblxyXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcclxuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xyXG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XHJcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XHJcbiAgICB9XHJcbiAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcclxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkYXk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XHJcbiAgICB9XHJcbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xyXG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcclxuICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXHJcbiAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXHJcblxyXG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcclxuZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcclxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcclxuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XHJcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcclxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcclxuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcclxuZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcclxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcclxuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcclxuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xyXG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcclxuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXHJcbiAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxyXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcclxuICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcclxuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XHJcbiAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xyXG4gICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xyXG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcclxuICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xyXG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XHJcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xyXG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xyXG4gICAgfVxyXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XHJcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXHJcbiAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xyXG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XHJcbiAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XHJcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xyXG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xyXG4gICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XHJcblxyXG4gICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xyXG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XHJcbn1cclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmZ1bmN0aW9uIGhGb3JtYXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xyXG59XHJcblxyXG5hZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcclxuYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xyXG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcclxuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xyXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xyXG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5tZXJpZGllbSgnYScsIHRydWUpO1xyXG5tZXJpZGllbSgnQScsIGZhbHNlKTtcclxuXHJcbi8vIEFMSUFTRVNcclxuXHJcbmFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XHJcblxyXG4vLyBQUklPUklUWVxyXG5hZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5mdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xyXG59XHJcblxyXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xyXG5hZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xyXG5hZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignaycsICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5cclxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcclxuYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xyXG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xyXG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XHJcblxyXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcclxuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcclxuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XHJcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xyXG4gICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XHJcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcclxuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XHJcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XHJcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XHJcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XHJcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcclxuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xyXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XHJcbn0pO1xyXG5hZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xyXG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XHJcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xyXG59KTtcclxuYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcclxuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcclxuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcclxuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xyXG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XHJcbn0pO1xyXG5cclxuLy8gTE9DQUxFU1xyXG5cclxuZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcclxuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcclxuICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxyXG4gICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XHJcbn1cclxuXHJcbnZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xyXG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcclxuICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbi8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxyXG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXHJcbi8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xyXG4vLyB0aGlzIHJ1bGUuXHJcbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcclxuXHJcbi8vIG1vbnRoc1xyXG4vLyB3ZWVrXHJcbi8vIHdlZWtkYXlzXHJcbi8vIG1lcmlkaWVtXHJcbnZhciBiYXNlQ29uZmlnID0ge1xyXG4gICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcclxuICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXHJcbiAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxyXG4gICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXHJcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcclxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcclxuXHJcbiAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXHJcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxyXG5cclxuICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxyXG5cclxuICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXHJcbiAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxyXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXHJcblxyXG4gICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2VcclxufTtcclxuXHJcbi8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcclxudmFyIGxvY2FsZXMgPSB7fTtcclxudmFyIGxvY2FsZUZhbWlsaWVzID0ge307XHJcbnZhciBnbG9iYWxMb2NhbGU7XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XHJcbn1cclxuXHJcbi8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxyXG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxyXG4vLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XHJcbmZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xyXG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xyXG5cclxuICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XHJcbiAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcclxuICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XHJcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xyXG4gICAgICAgIHdoaWxlIChqID4gMCkge1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XHJcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgai0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XHJcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcclxuICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXHJcbiAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxyXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XHJcbiAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XHJcbiAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XHJcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxufVxyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXHJcbi8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXHJcbi8vIGxvY2FsZSBrZXkuXHJcbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcclxuICAgIHZhciBkYXRhO1xyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XHJcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XHJcbiAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XHJcbiAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xyXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xyXG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xyXG5cclxuICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cclxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cclxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcclxuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcclxuICAgICAgICAvLyBNRVJHRVxyXG4gICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XHJcbiAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xyXG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcclxuICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcclxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xyXG5cclxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcclxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXHJcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxufVxyXG5cclxuLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxyXG5mdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xyXG4gICAgdmFyIGxvY2FsZTtcclxuXHJcbiAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XHJcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNBcnJheShrZXkpKSB7XHJcbiAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxyXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcclxuICAgICAgICBpZiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleSA9IFtrZXldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XHJcbiAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xyXG4gICAgdmFyIG92ZXJmbG93O1xyXG4gICAgdmFyIGEgPSBtLl9hO1xyXG5cclxuICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcclxuICAgICAgICBvdmVyZmxvdyA9XHJcbiAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcclxuICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XHJcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XHJcbiAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XHJcbiAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XHJcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcclxuICAgICAgICAgICAgLTE7XHJcblxyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xyXG4gICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xyXG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbTtcclxufVxyXG5cclxuLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxyXG5mdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XHJcbiAgICBpZiAoYSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcbiAgICBpZiAoYiAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYztcclxufVxyXG5cclxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcclxuICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XHJcbiAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XHJcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcclxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XHJcbn1cclxuXHJcbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxyXG4vLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xyXG4vLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cclxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XHJcbiAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcclxuXHJcbiAgICBpZiAoY29uZmlnLl9kKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xyXG5cclxuICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcclxuICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XHJcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXHJcbiAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xyXG4gICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xyXG4gICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XHJcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXHJcbiAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XHJcbiAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcclxuICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xyXG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXHJcbiAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcclxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXHJcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcclxuICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xyXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcclxuICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxyXG4gICAgLy8gd2l0aCBwYXJzZVpvbmUuXHJcbiAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xyXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xyXG4gICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBjb25maWcuX2QuZ2V0RGF5KCkpIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XHJcbiAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XHJcblxyXG4gICAgdyA9IGNvbmZpZy5fdztcclxuICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcclxuICAgICAgICBkb3cgPSAxO1xyXG4gICAgICAgIGRveSA9IDQ7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxyXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcclxuICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxyXG4gICAgICAgIC8vIGNyZWF0ZSBub3cpLlxyXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xyXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xyXG4gICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xyXG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xyXG4gICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xyXG4gICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcclxuXHJcbiAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcclxuXHJcbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxyXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XHJcblxyXG4gICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcclxuICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcclxuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcclxuICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcclxuICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xyXG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xyXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcclxuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xyXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcclxuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBpc28gODYwMSByZWdleFxyXG4vLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcclxudmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XHJcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcclxuXHJcbnZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xyXG5cclxudmFyIGlzb0RhdGVzID0gW1xyXG4gICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXHJcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcclxuICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxyXG4gICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxyXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXHJcbiAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcclxuICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxyXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcclxuICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcclxuICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXHJcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxyXG4gICAgWydZWVlZREREJywgL1xcZHs3fS9dXHJcbl07XHJcblxyXG4vLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXHJcbnZhciBpc29UaW1lcyA9IFtcclxuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcclxuICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXHJcbiAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXHJcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcclxuICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxyXG4gICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxyXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXHJcbiAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXHJcbiAgICBbJ0hIJywgL1xcZFxcZC9dXHJcbl07XHJcblxyXG52YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcclxuXHJcbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XHJcbiAgICB2YXIgaSwgbCxcclxuICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXHJcbiAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcclxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xyXG5cclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xyXG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xyXG4gICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcclxuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXHJcbnZhciByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLztcclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXHJcbiAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXHJcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxyXG4gICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxyXG4gICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcclxuICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxyXG4gICAgXTtcclxuXHJcbiAgICBpZiAoc2Vjb25kU3RyKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcclxuICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xyXG4gICAgaWYgKHllYXIgPD0gNDkpIHtcclxuICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XHJcbiAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XHJcbiAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHllYXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcclxuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXHJcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnRyaW0oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcclxuICAgIGlmICh3ZWVrZGF5U3RyKSB7XHJcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxyXG4gICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxyXG4gICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XHJcbiAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xyXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG52YXIgb2JzT2Zmc2V0cyA9IHtcclxuICAgIFVUOiAwLFxyXG4gICAgR01UOiAwLFxyXG4gICAgRURUOiAtNCAqIDYwLFxyXG4gICAgRVNUOiAtNSAqIDYwLFxyXG4gICAgQ0RUOiAtNSAqIDYwLFxyXG4gICAgQ1NUOiAtNiAqIDYwLFxyXG4gICAgTURUOiAtNiAqIDYwLFxyXG4gICAgTVNUOiAtNyAqIDYwLFxyXG4gICAgUERUOiAtNyAqIDYwLFxyXG4gICAgUFNUOiAtOCAqIDYwXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XHJcbiAgICBpZiAob2JzT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcclxuICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcclxuICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XHJcbiAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xyXG4gICAgICAgIHJldHVybiBoICogNjAgKyBtO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xyXG4gICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcclxuICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XHJcbiAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xyXG5cclxuICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XHJcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcclxuXHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xyXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xyXG4gICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xyXG5cclxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XHJcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XHJcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xyXG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xyXG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXHJcbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xyXG59XHJcblxyXG5ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcclxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXHJcbiAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcclxuICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcclxuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcclxuICAgIGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xyXG4gICAgfVxyXG4pO1xyXG5cclxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxyXG5ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cclxuaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcclxuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcclxuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXHJcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xyXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xyXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uZmlnLl9hID0gW107XHJcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XHJcblxyXG4gICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcclxuICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcclxuICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcclxuICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxyXG4gICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xyXG5cclxuICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XHJcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcclxuICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XHJcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XHJcbiAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XHJcbiAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXHJcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXHJcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcclxuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxyXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxyXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcclxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XHJcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XHJcbiAgICAvLyBoYW5kbGUgbWVyaWRpZW1cclxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcclxuXHJcbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcclxuICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xyXG4gICAgdmFyIGlzUG07XHJcblxyXG4gICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcclxuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgcmV0dXJuIGhvdXI7XHJcbiAgICB9XHJcbiAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xyXG4gICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gRmFsbGJhY2tcclxuICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xyXG4gICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xyXG4gICAgICAgICAgICBob3VyICs9IDEyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcclxuICAgICAgICAgICAgaG91ciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3VyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cclxuICAgICAgICByZXR1cm4gaG91cjtcclxuICAgIH1cclxufVxyXG5cclxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcclxuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xyXG4gICAgdmFyIHRlbXBDb25maWcsXHJcbiAgICAgICAgYmVzdE1vbWVudCxcclxuXHJcbiAgICAgICAgc2NvcmVUb0JlYXQsXHJcbiAgICAgICAgaSxcclxuICAgICAgICBjdXJyZW50U2NvcmU7XHJcblxyXG4gICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcclxuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcclxuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcclxuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcclxuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xyXG5cclxuICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxyXG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcclxuXHJcbiAgICAgICAgLy9vciB0b2tlbnNcclxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcclxuXHJcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xyXG5cclxuICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xyXG4gICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcclxuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XHJcbiAgICBpZiAoY29uZmlnLl9kKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcclxuICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XHJcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xyXG4gICAgaWYgKHJlcy5fbmV4dERheSkge1xyXG4gICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxyXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcclxuICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XHJcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXHJcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xyXG5cclxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XHJcblxyXG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcclxuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xyXG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcclxuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcclxuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XHJcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xyXG4gICAgfSAgZWxzZSB7XHJcbiAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcclxuICAgICAgICBjb25maWcuX2QgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb25maWc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcclxuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcclxuICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcclxuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XHJcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcclxuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xyXG4gICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcclxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XHJcbiAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcclxuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xyXG4gICAgdmFyIGMgPSB7fTtcclxuXHJcbiAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XHJcbiAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxyXG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xyXG4gICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcclxuICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XHJcbiAgICBjLl9sID0gbG9jYWxlO1xyXG4gICAgYy5faSA9IGlucHV0O1xyXG4gICAgYy5fZiA9IGZvcm1hdDtcclxuICAgIGMuX3N0cmljdCA9IHN0cmljdDtcclxuXHJcbiAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xyXG59XHJcblxyXG52YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxyXG4gICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcclxuICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuKTtcclxuXHJcbnZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXHJcbiAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxyXG4gICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pO1xyXG5cclxuLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcclxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxyXG4vL1xyXG4vLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXHJcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXHJcbmZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xyXG4gICAgdmFyIHJlcywgaTtcclxuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XHJcbiAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XHJcbiAgICB9XHJcbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XHJcbiAgICB9XHJcbiAgICByZXMgPSBtb21lbnRzWzBdO1xyXG4gICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcclxuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xyXG5mdW5jdGlvbiBtaW4gKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XHJcblxyXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWF4ICgpIHtcclxuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcclxufVxyXG5cclxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xyXG59O1xyXG5cclxudmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XHJcblxyXG5mdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIG0pIHtcclxuICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XHJcbiAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XHJcbiAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcclxufVxyXG5cclxuZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxyXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcclxuICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXHJcbiAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXHJcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxyXG4gICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXHJcbiAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxyXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXHJcbiAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcclxuICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcclxuXHJcbiAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XHJcblxyXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcclxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xyXG4gICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXHJcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxyXG4gICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxyXG4gICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXHJcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XHJcbiAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xyXG4gICAgICAgIHdlZWtzICogNztcclxuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXHJcbiAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxyXG4gICAgLy8gaXQgc2VwYXJhdGVseS5cclxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xyXG4gICAgICAgIHF1YXJ0ZXJzICogMyArXHJcbiAgICAgICAgeWVhcnMgKiAxMjtcclxuXHJcbiAgICB0aGlzLl9kYXRhID0ge307XHJcblxyXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XHJcblxyXG4gICAgdGhpcy5fYnViYmxlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XHJcbiAgICBpZiAobnVtYmVyIDwgMCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5mdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcclxuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XHJcbiAgICAgICAgdmFyIHNpZ24gPSAnKyc7XHJcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcclxuICAgICAgICAgICAgc2lnbiA9ICctJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5vZmZzZXQoJ1onLCAnOicpO1xyXG5vZmZzZXQoJ1paJywgJycpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcclxuYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcclxuYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XHJcbiAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xyXG59KTtcclxuXHJcbi8vIEhFTFBFUlNcclxuXHJcbi8vIHRpbWV6b25lIGNodW5rZXJcclxuLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXHJcbi8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxyXG52YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XHJcblxyXG5mdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xyXG4gICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcclxuXHJcbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xyXG4gICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xyXG4gICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xyXG5cclxuICAgIHJldHVybiBtaW51dGVzID09PSAwID9cclxuICAgICAgMCA6XHJcbiAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XHJcbn1cclxuXHJcbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXHJcbmZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcclxuICAgIHZhciByZXMsIGRpZmY7XHJcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XHJcbiAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcclxuICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xyXG4gICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cclxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XHJcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xyXG4gICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxyXG4gICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xyXG59XHJcblxyXG4vLyBIT09LU1xyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxyXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cclxuaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG4vLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcclxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cclxuLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxyXG4vLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXHJcbi8vXHJcbi8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxyXG4vLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcclxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxyXG4vLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcclxuLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cclxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcclxuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcclxuICAgICAgICBsb2NhbEFkanVzdDtcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xyXG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xyXG4gICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcclxuICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcclxuICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcclxuICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcclxuICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcclxuICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XHJcblxyXG4gICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxyXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcclxuICAgICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjID0ge307XHJcblxyXG4gICAgY29weUNvbmZpZyhjLCB0aGlzKTtcclxuICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xyXG5cclxuICAgIGlmIChjLl9hKSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcclxuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxyXG4gICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0xvY2FsICgpIHtcclxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1V0YyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcclxufVxyXG5cclxuLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XHJcbnZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xyXG5cclxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcclxuLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxyXG4vLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XHJcbnZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xyXG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXHJcbiAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcclxuICAgICAgICBtYXRjaCA9IG51bGwsXHJcbiAgICAgICAgc2lnbixcclxuICAgICAgICByZXQsXHJcbiAgICAgICAgZGlmZlJlcztcclxuXHJcbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcclxuICAgICAgICBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxyXG4gICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxyXG4gICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcclxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xyXG4gICAgICAgIGR1cmF0aW9uID0ge1xyXG4gICAgICAgICAgICB5ICA6IDAsXHJcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcclxuICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxyXG4gICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXHJcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcclxuICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxyXG4gICAgICAgIH07XHJcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XHJcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogKG1hdGNoWzFdID09PSAnKycpID8gMSA6IDE7XHJcbiAgICAgICAgZHVyYXRpb24gPSB7XHJcbiAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXHJcbiAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXHJcbiAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXHJcbiAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXHJcbiAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXHJcbiAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXHJcbiAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgIGR1cmF0aW9uID0ge307XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xyXG4gICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcclxuXHJcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcclxuICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xyXG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcclxuICAgIH1cclxuXHJcbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xyXG5cclxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XHJcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xyXG5jcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xyXG5cclxuZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xyXG4gICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cclxuICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxyXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxyXG4gICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XHJcbiAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XHJcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcclxuICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xyXG5cclxuICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcclxuICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XHJcbiAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XHJcbiAgICAgICAgLS1yZXMubW9udGhzO1xyXG4gICAgfVxyXG5cclxuICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcclxuICAgIHZhciByZXM7XHJcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XHJcbiAgICB9XHJcblxyXG4gICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xyXG4gICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XHJcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xyXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcclxuICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxyXG5mdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcclxuICAgICAgICB2YXIgZHVyLCB0bXA7XHJcbiAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XHJcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcclxuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xyXG4gICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xyXG4gICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xyXG4gICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcclxuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xyXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXHJcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcclxuICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcclxuXHJcbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAvLyBObyBvcFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XHJcblxyXG4gICAgaWYgKG1vbnRocykge1xyXG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF5cykge1xyXG4gICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcclxuICAgIH1cclxuICAgIGlmIChtaWxsaXNlY29uZHMpIHtcclxuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHVwZGF0ZU9mZnNldCkge1xyXG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xyXG52YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XHJcblxyXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XHJcbiAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xyXG4gICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxyXG4gICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcclxuICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxyXG4gICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XHJcbiAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcclxuICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xyXG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cclxuICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxyXG4gICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcclxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcclxuICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XHJcblxyXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lICgpIHtcclxuICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcclxuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XHJcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xyXG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcclxuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XHJcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xyXG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcclxuICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcclxuICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXHJcbiAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xyXG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcclxuICAgICAgICBpbnB1dE1zO1xyXG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcclxuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xyXG4gICAgdmFyIHRoYXQsXHJcbiAgICAgICAgem9uZURlbHRhLFxyXG4gICAgICAgIGRlbHRhLCBvdXRwdXQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcblxyXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XHJcblxyXG4gICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcblxyXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcclxuXHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuXHJcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XHJcbiAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcclxuICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXHJcbiAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxyXG4gICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXHJcbiAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxyXG4gICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcclxuICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xyXG4gICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcclxuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcclxuICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxyXG4gICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcclxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XHJcblxyXG4gICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XHJcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XHJcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcclxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xyXG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXHJcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cclxuICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xyXG59XHJcblxyXG5ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcclxuaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcclxuXHJcbmZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9JU09TdHJpbmcoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcclxuICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcclxuICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxyXG4gKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXHJcbiAqXHJcbiAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnNwZWN0ICgpIHtcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xyXG4gICAgfVxyXG4gICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcclxuICAgIHZhciB6b25lID0gJyc7XHJcbiAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XHJcbiAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XHJcbiAgICAgICAgem9uZSA9ICdaJztcclxuICAgIH1cclxuICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xyXG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xyXG4gICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XHJcbiAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcclxuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xyXG4gICAgfVxyXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XHJcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcclxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcclxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XHJcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcclxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcclxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XHJcbiAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcclxufVxyXG5cclxuLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xyXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cclxuZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcclxuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xyXG5cclxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcclxuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcclxuICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXHJcbiAgICBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcblxyXG5mdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcclxuICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cclxuICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcclxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxyXG4gICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xyXG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgY2FzZSAnd2Vlayc6XHJcbiAgICAgICAgY2FzZSAnaXNvV2Vlayc6XHJcbiAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICBjYXNlICdkYXRlJzpcclxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcclxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgIGNhc2UgJ2hvdXInOlxyXG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdtaW51dGUnOlxyXG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdzZWNvbmQnOlxyXG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcclxuICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XHJcbiAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xyXG4gICAgfVxyXG4gICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcclxuICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxyXG4gICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcclxuICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cclxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XHJcbiAgICAgICAgdW5pdHMgPSAnZGF5JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB2YWx1ZU9mICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bml4ICgpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvRGF0ZSAoKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b0FycmF5ICgpIHtcclxuICAgIHZhciBtID0gdGhpcztcclxuICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0b09iamVjdCAoKSB7XHJcbiAgICB2YXIgbSA9IHRoaXM7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcclxuICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcclxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcclxuICAgICAgICBob3VyczogbS5ob3VycygpLFxyXG4gICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxyXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxyXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9KU09OICgpIHtcclxuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcclxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XHJcbiAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcclxuICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XHJcbiAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxyXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcclxuICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcclxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXHJcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xyXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xyXG59XHJcblxyXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xyXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xyXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xyXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xyXG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XHJcblxyXG4vLyBQUklPUklUWVxyXG5cclxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xyXG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XHJcblxyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xyXG5hZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5hZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XHJcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcclxuYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xyXG5hZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XHJcblxyXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcclxuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcclxufSk7XHJcblxyXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xyXG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XHJcbn0pO1xyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxuZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XHJcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxyXG4gICAgICAgICAgICBpbnB1dCxcclxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXHJcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxyXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcclxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcclxuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcclxuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xyXG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xyXG4gICAgdmFyIHdlZWtzVGFyZ2V0O1xyXG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xyXG4gICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcclxuICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XHJcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxyXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xyXG5cclxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xyXG4gICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xyXG4gICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuXHJcbmFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XHJcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xyXG59KTtcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XHJcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XHJcbn1cclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcclxuXHJcbi8vIFBSSU9ST0lUWVxyXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcclxuXHJcbi8vIFBBUlNJTkdcclxuXHJcbmFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcclxuYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcclxuICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cclxuICAgIHJldHVybiBpc1N0cmljdCA/XHJcbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcclxuICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcclxufSk7XHJcblxyXG5hZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcclxuYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XHJcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcclxufSk7XHJcblxyXG4vLyBNT01FTlRTXHJcblxyXG52YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcclxuXHJcbi8vIFBSSU9SSVRZXHJcbmFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcclxuYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XHJcbmFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xyXG59KTtcclxuXHJcbi8vIEhFTFBFUlNcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcclxuICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XHJcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XHJcbn1cclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XHJcblxyXG4vLyBBTElBU0VTXHJcblxyXG5hZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XHJcblxyXG4vLyBQUklPUklUWVxyXG5cclxuYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XHJcbmFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xyXG5hZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xyXG5cclxuLy8gTU9NRU5UU1xyXG5cclxudmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XHJcblxyXG4vLyBGT1JNQVRUSU5HXHJcblxyXG5hZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuXHJcbmFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xyXG5cclxuLy8gUEFSU0lOR1xyXG5cclxuYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xyXG5hZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcclxuYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbnZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcclxufSk7XHJcblxyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XHJcbn0pO1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XHJcbn0pO1xyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XHJcbn0pO1xyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcclxufSk7XHJcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XHJcbn0pO1xyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XHJcbn0pO1xyXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcclxufSk7XHJcblxyXG5cclxuLy8gQUxJQVNFU1xyXG5cclxuYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xyXG5cclxuLy8gUFJJT1JJVFlcclxuXHJcbmFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xyXG5hZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xyXG5hZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xyXG5cclxudmFyIHRva2VuO1xyXG5mb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XHJcbiAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcclxuICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XHJcbn1cclxuXHJcbmZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcclxuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xyXG59XHJcbi8vIE1PTUVOVFNcclxuXHJcbnZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcclxuXHJcbi8vIEZPUk1BVFRJTkdcclxuXHJcbmFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xyXG5hZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcclxuXHJcbi8vIE1PTUVOVFNcclxuXHJcbmZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcclxufVxyXG5cclxudmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcclxuXHJcbnByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xyXG5wcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XHJcbnByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XHJcbnByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcclxucHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcclxucHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XHJcbnByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcclxucHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xyXG5wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xyXG5wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xyXG5wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcclxucHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XHJcbnByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcclxucHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcclxucHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XHJcbnByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xyXG5wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XHJcbnByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XHJcbnByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xyXG5wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XHJcbnByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xyXG5wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XHJcbnByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xyXG5wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcclxucHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XHJcbnByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xyXG5wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XHJcbnByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XHJcbnByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcclxucHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcclxucHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XHJcbnByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XHJcbnByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcclxucHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XHJcbnByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XHJcbnByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcclxucHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xyXG5wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcclxuXHJcbi8vIFllYXJcclxucHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XHJcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xyXG5cclxuLy8gV2VlayBZZWFyXHJcbnByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XHJcbnByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XHJcblxyXG4vLyBRdWFydGVyXHJcbnByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XHJcblxyXG4vLyBNb250aFxyXG5wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xyXG5wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xyXG5cclxuLy8gV2Vla1xyXG5wcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XHJcbnByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcclxucHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcclxucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcclxuXHJcbi8vIERheVxyXG5wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcclxucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XHJcbnByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XHJcbnByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XHJcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XHJcblxyXG4vLyBIb3VyXHJcbnByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XHJcblxyXG4vLyBNaW51dGVcclxucHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcclxuXHJcbi8vIFNlY29uZFxyXG5wcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xyXG5cclxuLy8gTWlsbGlzZWNvbmRcclxucHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcclxuXHJcbi8vIE9mZnNldFxyXG5wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcclxucHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcclxucHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xyXG5wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xyXG5wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xyXG5wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xyXG5wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XHJcbnByb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XHJcbnByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XHJcbnByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XHJcblxyXG4vLyBUaW1lem9uZVxyXG5wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xyXG5wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xyXG5cclxuLy8gRGVwcmVjYXRpb25zXHJcbnByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcclxucHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XHJcbnByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xyXG5wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XHJcbnByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVVbml4IChpbnB1dCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcclxuICAgIHJldHVybiBzdHJpbmc7XHJcbn1cclxuXHJcbnZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcclxuXHJcbnByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XHJcbnByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XHJcbnByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XHJcbnByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcclxucHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XHJcbnByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xyXG5wcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcclxucHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xyXG5wcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcclxuXHJcbi8vIE1vbnRoXHJcbnByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xyXG5wcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xyXG5wcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xyXG5wcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XHJcbnByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xyXG5cclxuLy8gV2Vla1xyXG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xyXG5wcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XHJcbnByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcclxuXHJcbi8vIERheSBvZiBXZWVrXHJcbnByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XHJcbnByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XHJcbnByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcclxucHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xyXG5cclxucHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XHJcbnByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XHJcbnByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xyXG5cclxuLy8gSG91cnNcclxucHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcclxucHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xyXG5cclxuZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcclxuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcclxuICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XHJcbiAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xyXG4gICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcclxuICAgICAgICBpbmRleCA9IGZvcm1hdDtcclxuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xyXG5cclxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBvdXQgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59XHJcblxyXG4vLyAoKVxyXG4vLyAoNSlcclxuLy8gKGZtdCwgNSlcclxuLy8gKGZtdClcclxuLy8gKHRydWUpXHJcbi8vICh0cnVlLCA1KVxyXG4vLyAodHJ1ZSwgZm10LCA1KVxyXG4vLyAodHJ1ZSwgZm10KVxyXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XHJcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xyXG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xyXG4gICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xyXG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcclxuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcclxuICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xyXG5cclxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBvdXQgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcclxuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcclxufVxyXG5cclxuZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcclxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxyXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcclxuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxyXG4gICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcclxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XHJcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xyXG5ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XHJcbmhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcclxuXHJcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XHJcblxyXG5mdW5jdGlvbiBhYnMgKCkge1xyXG4gICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcclxuXHJcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XHJcbiAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xyXG4gICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xyXG5cclxuICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xyXG4gICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xyXG4gICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xyXG4gICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcclxuICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xyXG4gICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XHJcbiAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xyXG5cclxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcclxuICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XHJcbiAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XHJcblxyXG4gICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcclxufVxyXG5cclxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxyXG5mdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xyXG59XHJcblxyXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxyXG5mdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcclxuICAgIGlmIChudW1iZXIgPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBidWJibGUgKCkge1xyXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcclxuICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xyXG4gICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcclxuICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xyXG4gICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XHJcblxyXG4gICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxyXG4gICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XHJcbiAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxyXG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcclxuICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XHJcbiAgICAgICAgZGF5cyA9IDA7XHJcbiAgICAgICAgbW9udGhzID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXHJcbiAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXHJcbiAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XHJcblxyXG4gICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcclxuICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xyXG5cclxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcclxuICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xyXG5cclxuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcclxuICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcclxuXHJcbiAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xyXG5cclxuICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcclxuICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcclxuICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcclxuICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcclxuXHJcbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXHJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcclxuICAgIG1vbnRocyAlPSAxMjtcclxuXHJcbiAgICBkYXRhLmRheXMgICA9IGRheXM7XHJcbiAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcclxuICAgIGRhdGEueWVhcnMgID0geWVhcnM7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xyXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxyXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXHJcbiAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XHJcbiAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcclxuICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcyAodW5pdHMpIHtcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgfVxyXG4gICAgdmFyIGRheXM7XHJcbiAgICB2YXIgbW9udGhzO1xyXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcclxuXHJcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuXHJcbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xyXG4gICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xyXG4gICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcclxuICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxyXG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XHJcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xyXG4gICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcclxuICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcclxuICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xyXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcclxuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xyXG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcclxuICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xyXG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XHJcbmZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH1cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcclxuICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xyXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xyXG4gICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcclxuICAgICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xyXG4gICAgfTtcclxufVxyXG5cclxudmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xyXG52YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcclxudmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XHJcbnZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xyXG52YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcclxudmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XHJcbnZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xyXG52YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcclxuXHJcbmZ1bmN0aW9uIGNsb25lJDEgKCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcclxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XHJcbiAgICB9O1xyXG59XHJcblxyXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XHJcbnZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XHJcbnZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XHJcbnZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xyXG52YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xyXG52YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XHJcbnZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xyXG5cclxuZnVuY3Rpb24gd2Vla3MgKCkge1xyXG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XHJcbn1cclxuXHJcbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XHJcbnZhciB0aHJlc2hvbGRzID0ge1xyXG4gICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xyXG4gICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXHJcbiAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXHJcbiAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XHJcbiAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxyXG4gICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXHJcbn07XHJcblxyXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxyXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XHJcbiAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XHJcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcclxuICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xyXG4gICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XHJcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcclxuICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xyXG4gICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XHJcblxyXG4gICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XHJcbiAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcclxuICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxyXG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XHJcbiAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcclxuICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxyXG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcclxuICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxyXG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XHJcbiAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcclxuXHJcbiAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcclxuICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xyXG4gICAgYVs0XSA9IGxvY2FsZTtcclxuICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcclxufVxyXG5cclxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xyXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xyXG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiByb3VuZDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xyXG5mdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcclxuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcclxuICAgIH1cclxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xyXG4gICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XHJcbiAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xyXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcclxuICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcclxuXHJcbiAgICBpZiAod2l0aFN1ZmZpeCkge1xyXG4gICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xyXG59XHJcblxyXG52YXIgYWJzJDEgPSBNYXRoLmFicztcclxuXHJcbmZ1bmN0aW9uIHNpZ24oeCkge1xyXG4gICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XHJcbiAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxyXG4gICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xyXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxyXG4gICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xyXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcclxuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxyXG4gICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcclxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xyXG4gICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xyXG4gICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XHJcbiAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xyXG5cclxuICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxyXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xyXG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xyXG4gICAgc2Vjb25kcyAlPSA2MDtcclxuICAgIG1pbnV0ZXMgJT0gNjA7XHJcblxyXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxyXG4gICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xyXG4gICAgbW9udGhzICU9IDEyO1xyXG5cclxuXHJcbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xyXG4gICAgdmFyIFkgPSB5ZWFycztcclxuICAgIHZhciBNID0gbW9udGhzO1xyXG4gICAgdmFyIEQgPSBkYXlzO1xyXG4gICAgdmFyIGggPSBob3VycztcclxuICAgIHZhciBtID0gbWludXRlcztcclxuICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XHJcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xyXG5cclxuICAgIGlmICghdG90YWwpIHtcclxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXHJcbiAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxyXG4gICAgICAgIHJldHVybiAnUDBEJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XHJcbiAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xyXG4gICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcclxuICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xyXG5cclxuICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xyXG4gICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXHJcbiAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcclxuICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXHJcbiAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xyXG4gICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xyXG4gICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xyXG4gICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XHJcbn1cclxuXHJcbnZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xyXG5cclxucHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcclxucHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcclxucHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xyXG5wcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcclxucHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xyXG5wcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XHJcbnByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XHJcbnByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XHJcbnByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xyXG5wcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xyXG5wcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcclxucHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xyXG5wcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcclxucHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcclxucHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcclxucHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XHJcbnByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcclxucHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcclxucHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XHJcbnByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xyXG5wcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XHJcbnByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xyXG5wcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XHJcbnByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XHJcbnByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcclxucHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xyXG5wcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcclxucHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XHJcbnByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xyXG5wcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xyXG5wcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcclxuXHJcbi8vIERlcHJlY2F0aW9uc1xyXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xyXG5wcm90byQyLmxhbmcgPSBsYW5nO1xyXG5cclxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xyXG5cclxuLy8gRk9STUFUVElOR1xyXG5cclxuYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xyXG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XHJcblxyXG4vLyBQQVJTSU5HXHJcblxyXG5hZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xyXG5hZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xyXG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XHJcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcclxufSk7XHJcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcclxuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XHJcbn0pO1xyXG5cclxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xyXG5cclxuXHJcbmhvb2tzLnZlcnNpb24gPSAnMi4xOS4yJztcclxuXHJcbnNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XHJcblxyXG5ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcclxuaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xyXG5ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XHJcbmhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcclxuaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xyXG5ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xyXG5ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xyXG5ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XHJcbmhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcclxuaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcclxuaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XHJcbmhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xyXG5ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XHJcbmhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcclxuaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xyXG5ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xyXG5ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XHJcbmhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcclxuaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xyXG5ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XHJcbmhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xyXG5ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcclxuaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XHJcbmhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xyXG5ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XHJcbmhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xyXG5ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcclxuXHJcbnJldHVybiBob29rcztcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9